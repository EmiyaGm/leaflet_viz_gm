webpackJsonp([0,1],[
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; //矢量画图工具

	//import Deck, {PolygonLayer} from 'deck.gl';


	var _util = __webpack_require__(2);

	var _util2 = _interopRequireDefault(_util);

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	var _leafletMinimap = __webpack_require__(4);

	var _leafletMinimap2 = _interopRequireDefault(_leafletMinimap);

	var _location = __webpack_require__(5);

	var _providers = __webpack_require__(6);

	var _providers2 = _interopRequireDefault(_providers);

	__webpack_require__(7);

	__webpack_require__(8);

	__webpack_require__(9);

	__webpack_require__(10);

	__webpack_require__(11);

	__webpack_require__(12);

	__webpack_require__(13);

	__webpack_require__(14);

	__webpack_require__(15);

	__webpack_require__(16);

	__webpack_require__(17);

	__webpack_require__(18);

	__webpack_require__(19);

	__webpack_require__(21);

	__webpack_require__(22);

	__webpack_require__(23);

	__webpack_require__(24);

	__webpack_require__(25);

	var _core = __webpack_require__(27);

	__webpack_require__(410);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	window.mauna_map = {
	    init: function init(data, callBack) {
	        var host = window.location.host;
	        host = 'api' + host.substring(host.indexOf('.'), host.length);
	        var map_container = (0, _jquery2.default)('#' + data.map_container);
	        var id = data.map_container;
	        var map = basemap(id);
	        var tools = data.tools;
	        var tools_group_template = '<div class="switch_group" data-state="0"><i class="map-icon map-menu"></i></div>';
	        var button_group_template = '<div class="button_group"><ul id="tools"></ul></div>';
	        var navigation = data.navigation || null;
	        if (tools) {
	            init_tools();
	        }
	        var top_menu_template = '';
	        var frequently_used_city = void 0;
	        if (navigation != null) {
	            var top_menu_template_first = '<div class="top_menu select" style="position: absolute">\
	                                    <div class="navigation_title form-group has-feedback">\
	                                        <span class="select-arrow" style="top:14px;right:5px"></span>\
	                                        <input type="text" class="form-control" id="navigation_input" readonly style="background: #fff;padding:0;padding-left:5px;padding-right:5px;height:30px; line-height: 30px; min-width: 70px;">\
	                                    </div>\
	                                    <div class="search_place form-group">\
	                                    </div>\
	                                </div>\
	                                <div class="navigation_modal card-div-border">\
	                                    <div class="table-toolbar" style="margin: 8px 0 0 8px;padding-left: 0px">\
	                                    <form class="form-inline">\
	                                    <div class="display_search">\
	                                    <div name="type" value="city" class="btn-group">';

	            var top_menu_template_second = '';
	            var top_menu_template_third = '</div><div class="pull-right"></div>\
	                                    </div>\
	                                    </form>\
	                                    </div>\
	                                    <div class="navigation_totle">';
	            var top_menu_template_forth = '';
	            for (var i = 0; i < navigation.length; i++) {
	                if (navigation[i].value == 'city') {
	                    frequently_used_city = navigation[i].frequently_used_city;
	                    if (i == 0) {
	                        top_menu_template_second = top_menu_template_second + '<button class="btn btn-sm btn-primary navigation" type="button" value="' + navigation[i].value + '">' + navigation[i].name + '</button>';
	                        top_menu_template_forth = top_menu_template_forth + '<div class="navigation_' + navigation[i].value + '"><div style="margin-left: 14px;margin-top: 16px;padding: 0;color: #666;">常用城市</div><ul class="frequently_used_city" ></ul></div>';
	                    } else {
	                        top_menu_template_second = top_menu_template_second + '<button class="btn btn-sm btn-white navigation" type="button" value="' + navigation[i].value + '">' + navigation[i].name + '</button>';
	                        top_menu_template_forth = top_menu_template_forth + '<div class="navigation_' + navigation[i].value + '" style="display: none;"></div>';
	                    }
	                } else {
	                    if (i == 0) {
	                        top_menu_template_second = top_menu_template_second + '<button class="btn btn-sm btn-primary navigation" type="button" value="' + navigation[i].value + '">' + navigation[i].name + '</button>';
	                        top_menu_template_forth = top_menu_template_forth + '<div class="navigation_' + navigation[i].value + '"></div>';
	                    } else {
	                        top_menu_template_second = top_menu_template_second + '<button class="btn btn-sm btn-white navigation" type="button" value="' + navigation[i].value + '">' + navigation[i].name + '</button>';
	                        top_menu_template_forth = top_menu_template_forth + '<div class="navigation_' + navigation[i].value + '" style="display: none;"></div>';
	                    }
	                }
	            }
	            top_menu_template = top_menu_template + top_menu_template_first + top_menu_template_second + top_menu_template_third + top_menu_template_forth + '</div></div>';
	        }

	        map_container.append('<div id="center-point" style="position: absolute;bottom: 0;z-index: 1000;background:rgba(255, 255, 255, 0.5);color: #333;font-size: 12px"></div>');
	        init_top_menu(frequently_used_city);
	        init_cross();

	        var location = '';
	        var url = 'https://restapi.amap.com/v3/geocode/regeo?output=json&location=' + map.getCenter().lng + ',' + map.getCenter().lat + '&key=3ee09e2462ad937d972b825e3624a89a&radius=1000&extensions=all';
	        _jquery2.default.ajax({
	            url: url,
	            success: function success(data) {
	                var dataJson = data.regeocode;
	                var zoom = map.getZoom();
	                var center = '';
	                if (dataJson.addressComponent.country.length > 0) {
	                    if (dataJson.addressComponent.province.length > 0) {
	                        if (zoom == 4) {
	                            center = '中国';
	                            (0, _jquery2.default)('#center-point').css('left', 'calc(50% - 14px)');
	                        } else if (zoom == 5 || zoom == 6) {
	                            center = dataJson.addressComponent['province'];
	                            (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                        } else if (zoom >= 7 && zoom <= 10) {
	                            center = dataJson.addressComponent['province'] + dataJson.addressComponent['city'];
	                            (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                        } else if (zoom >= 11 && zoom <= 13) {
	                            center = dataJson.addressComponent['province'] + dataJson.addressComponent['city'] + dataJson.addressComponent['district'];
	                            (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                        } else if (zoom >= 14 && zoom <= 18) {
	                            center = dataJson.formatted_address;
	                            (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                        }
	                    } else if (dataJson.addressComponent.seaArea) {
	                        center = dataJson.addressComponent.seaArea;
	                        (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                    }
	                } else {
	                    center = '中国以外地区';
	                    (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                }
	                location = dataJson.addressComponent['district'];
	                (0, _jquery2.default)('#navigation_input').val(location);
	                (0, _jquery2.default)('#center-point').html(center);
	            }
	        });
	        map.on('moveend', function () {
	            var url = 'https://restapi.amap.com/v3/geocode/regeo?output=json&location=' + map.getCenter().lng + ',' + map.getCenter().lat + '&key=3ee09e2462ad937d972b825e3624a89a&radius=1000&extensions=all';
	            _jquery2.default.ajax({
	                url: url,
	                success: function success(data) {
	                    var dataJson = data.regeocode;
	                    var zoom = map.getZoom();
	                    var center = '';
	                    if (dataJson.addressComponent.country.length > 0) {
	                        if (dataJson.addressComponent.province.length > 0) {
	                            if (zoom == 4) {
	                                center = '中国';
	                                (0, _jquery2.default)('#center-point').css('left', 'calc(50% - 14px)');
	                            } else if (zoom == 5 || zoom == 6) {
	                                center = dataJson.addressComponent['province'];
	                                (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                            } else if (zoom >= 7 && zoom <= 10) {
	                                center = dataJson.addressComponent['province'] + dataJson.addressComponent['city'];
	                                (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                            } else if (zoom >= 11 && zoom <= 13) {
	                                center = dataJson.addressComponent['province'] + dataJson.addressComponent['city'] + dataJson.addressComponent['district'];
	                                (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                            } else if (zoom >= 14 && zoom <= 18) {
	                                center = dataJson.formatted_address;
	                                (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                            }
	                        } else if (dataJson.addressComponent.seaArea) {
	                            center = dataJson.addressComponent.seaArea;
	                            (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                        }
	                    } else {
	                        center = '中国以外地区';
	                        (0, _jquery2.default)('#center-point').css('left', 'calc(50% - ' + center.length * 12 / 2 + 'px)');
	                    }
	                    location = dataJson.addressComponent['district'];
	                    (0, _jquery2.default)('#navigation_input').val(location);
	                    (0, _jquery2.default)('#center-point').html(center);
	                }
	            });
	        });
	        function init_tools() {
	            init_tools_group();
	        }

	        function init_top_menu(frequently_used_city) {
	            map_container.append(top_menu_template);
	            (0, _jquery2.default)('.top_menu').on('click', function (e) {
	                e.stopPropagation();
	            });
	            (0, _jquery2.default)('.navigation_title').on('click', function (e) {
	                if ((0, _jquery2.default)('.navigation_title').hasClass('open')) {
	                    (0, _jquery2.default)('.navigation_title').removeClass('open');
	                } else {
	                    (0, _jquery2.default)('.navigation_title').addClass('open');
	                }
	                if (!(0, _jquery2.default)('.navigation_modal').attr('style')) {
	                    (0, _jquery2.default)('.navigation_modal').attr('style', 'display:block');
	                } else if ((0, _jquery2.default)('.navigation_modal').attr('style') == 'display:none') {
	                    (0, _jquery2.default)('.navigation_modal').attr('style', 'display:block');
	                } else {
	                    (0, _jquery2.default)('.navigation_modal').attr('style', 'display:none');
	                }
	                e.stopPropagation();
	            });
	            (0, _jquery2.default)('.top_menu').on('dblclick', function (e) {
	                e.stopPropagation();
	            });
	            var li = '';
	            if (frequently_used_city) {
	                for (var _i = 0; _i < frequently_used_city.length; _i++) {
	                    li = li + '<li data-zoom="' + frequently_used_city[_i].zoom + '" data-center="' + frequently_used_city[_i].center[0] + ',' + frequently_used_city[_i].center[1] + '">' + frequently_used_city[_i].name + '</li>';
	                }
	                (0, _jquery2.default)('ul.frequently_used_city').append(li);
	                (0, _jquery2.default)('ul.frequently_used_city > li').on('click', function (e) {
	                    var zoom = (0, _jquery2.default)(this).attr('data-zoom');
	                    var latlng = (0, _jquery2.default)(this).attr('data-center').split(',');
	                    map.setView(latlng, zoom);
	                    e.stopPropagation();
	                });
	            }
	            (0, _jquery2.default)('button.navigation').on('click', function (e) {
	                (0, _jquery2.default)('button.navigation').each(function (i, e) {
	                    (0, _jquery2.default)(e).removeClass('btn-primary');
	                    (0, _jquery2.default)(e).addClass('btn-white');
	                });
	                (0, _jquery2.default)(this).removeClass('btn-white');
	                (0, _jquery2.default)(this).addClass('btn-primary');
	                var value = (0, _jquery2.default)(this).val();
	                (0, _jquery2.default)('.navigation_totle>div').hide();
	                (0, _jquery2.default)('.navigation_' + value).show();
	                e.stopPropagation();
	            });

	            (0, _jquery2.default)('ul.frequently_used_city').after('<div style="margin-left: 14px;margin-top: 16px;padding: 0;color: #666;">选择城市</div>' + '<div style="margin-left: 14px; margin-top:8px; margin-right: 14px;">' + '<div data-id="province" class="select" value="" style="width: calc(32.6%);"></div>' + '<div data-id="city" class="select" value="" style="width: calc(32.6%);"></div>' + '<div data-id="district" class="select" value="" style="width: calc(32.6%);"></div>' + '</div>');
	        }

	        function init_tools_group() {
	            map_container.append(tools_group_template);
	            map_container.append(button_group_template);
	        }
	        (0, _jquery2.default)('.switch_group').on('click', function (e) {
	            if ((0, _jquery2.default)('.switch_group').attr('data-state') == 0) {
	                (0, _jquery2.default)('.button_group').show();
	                (0, _jquery2.default)('.switch_group').attr('data-state', 1);
	                (0, _jquery2.default)('.switch_group i').addClass('font-active');
	            } else {
	                (0, _jquery2.default)('.button_group').hide();
	                (0, _jquery2.default)('.switch_group').attr('data-state', 0);
	                (0, _jquery2.default)('.switch_group i').removeClass('font-active');
	                //重置所有状态
	                // close_evey_window();
	            }
	            e.stopPropagation();
	        });

	        (0, _jquery2.default)(".switch_group").dblclick(function (e) {
	            e.stopPropagation();
	        });

	        (0, _jquery2.default)(".button_group").dblclick(function (e) {
	            e.stopPropagation();
	        });

	        (0, _jquery2.default)('.button_group').on('click', function (e) {
	            e.stopPropagation();
	        });

	        (0, _jquery2.default)('.navigation_modal').on('click', function (e) {
	            e.stopPropagation();
	        });

	        (0, _jquery2.default)('.navigation_modal').on('dblclick', function (e) {
	            e.stopPropagation();
	        });

	        (0, _jquery2.default)('.navigation_modal').on('mousewheel', function (e) {
	            e.stopPropagation();
	        });

	        function init_cross() {
	            map_container.append('<img src="../dist/images/cross_blue.svg" style="width: 14px;position: absolute;top: calc(50% - 7px);left: calc(50% - 7px);z-index: 1000"/>');
	        }

	        function basemap(map_container) {
	            var corner1 = L.latLng(85, 170),
	                corner2 = L.latLng(-85, -170),
	                maxbound = L.latLngBounds(corner1, corner2);
	            var map = L.map(map_container, {
	                crs: L.CRS.EPSG3857, //默认墨卡托投影 ESPG：3857
	                attributionControl: false,
	                zoomsliderControl: true,
	                zoomControl: false,
	                maxZoom: 18,
	                minZoom: 4,
	                maxBounds: maxbound
	            }).setView([30, 104], 5);
	            var osm = L.tileLayer.chinaProvider('GaoDe.Normal.Map', {
	                updateInterval: 0,
	                keepBuffer: 0,
	                className: 'basemap'
	            });
	            /*
	             let token = 'pk.eyJ1IjoiZW1peWFnbSIsImEiOiJjajdsazVkdWsxMG12MzJvNnF4dWE4dzdkIn0.95qn2oWmFfBAZsHMzO42vQ';
	             let gl = L.mapboxGL({
	             accessToken: token,
	             style: {
	             "version": 8,
	             //      style: 'mapbox://styles/mapbox/basic-v9',
	             //      "sprite": "mapbox://sprites/mapbox/streets-v8",
	             "sources": {
	             "gaode-tiles": {
	             "type": "raster",
	             'tiles': [
	             "http://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}"
	             ],
	             'tileSize': 256
	             }
	             },
	             "layers": [{
	             "id": "simple-tiles",
	             "type": "raster",
	             "source": "gaode-tiles",
	             "minzoom": 0,
	             "maxzoom": 22
	             }]
	             },
	             center: [30, 104],
	             zoom: 5
	             }).addTo(map);
	             */
	            osm.addTo(map);

	            var scale = L.control.scale({
	                imperial: false
	            });
	            scale.addTo(map); //比例尺


	            var osm2 = new L.tileLayer.chinaProvider('Google.Normal.Map', {});
	            new _leafletMinimap2.default(osm2, {
	                width: 180,
	                height: 180,
	                minimized: true,
	                closeCallback: data.minimap_closecallback
	            }).addTo(map); //小地图

	            if ((0, _jquery2.default)('.leaflet-control-minimap').length > 0 && (0, _jquery2.default)('.leaflet-control-zoomslider').length > 0) {
	                var minimap = (0, _jquery2.default)('.leaflet-control-minimap');
	                (0, _jquery2.default)('.leaflet-control-minimap').remove();
	                (0, _jquery2.default)('.leaflet-control-zoomslider').after(minimap);
	            }
	            (0, _jquery2.default)('.leaflet-control-zoomslider-province').hide();
	            (0, _jquery2.default)('.leaflet-control-zoomslider-city').hide();
	            (0, _jquery2.default)('.leaflet-control-zoomslider-street').hide();
	            (0, _jquery2.default)('.leaflet-control-zoomslider').mouseover(function () {
	                (0, _jquery2.default)('.leaflet-control-zoomslider-province').show();
	                (0, _jquery2.default)('.leaflet-control-zoomslider-city').show();
	                (0, _jquery2.default)('.leaflet-control-zoomslider-street').show();
	            });
	            (0, _jquery2.default)('.leaflet-control-zoomslider').mouseout(function () {
	                (0, _jquery2.default)('.leaflet-control-zoomslider-province').hide();
	                (0, _jquery2.default)('.leaflet-control-zoomslider-city').hide();
	                (0, _jquery2.default)('.leaflet-control-zoomslider-street').hide();
	            });

	            /**
	             let myIcon = L.icon({
	                className: 'my-cross-icon',
	                iconUrl: 'common/mauna/js/mauna.leaflet/dist/images/cross_blue.png',
	                iconSize: [18, 18],
	            });
	             let crossMarker = L.marker(map.getCenter(), {
	                icon: myIcon,
	                zIndexOffset: 30000,
	            }).addTo(map);
	                   map.on('move',function () {
	                crossMarker.setLatLng(map.getCenter());
	            });
	               map.on('zoom',function () {
	                crossMarker.setLatLng(map.getCenter());
	            });
	                   let osmGeocoder = new L.Control.OSMGeocoder({
	                collapsed: false,
	                position: 'topright',
	                text: 'Search',
	            });
	             osmGeocoder.addTo(map);//搜索框
	                   let attribution = L.control.attribution();
	             attribution.addTo(map);
	             let location = '';
	             let url = 'http://api.vehicle-dev-nj.mokua.com:5107/vehicle/regeo?lng='+map.getCenter().lng+'&lat='+map.getCenter().lat;
	             $.ajax({
	                url: url,
	                success: function(data){
	                    let dataJson = eval('(' + data + ')');
	                    location = dataJson.addressComponent['district'];
	                    attribution.setPrefix(location);
	                }
	            });
	             map.on('moveend',function () {
	                let url = 'http://api.vehicle-dev-nj.mokua.com:5107/vehicle/regeo?lng='+map.getCenter().lng+'&lat='+map.getCenter().lat;
	                $.ajax({
	                    url: url,
	                    success: function(data){
	                        let dataJson = eval('(' + data + ')');
	                        location = dataJson.addressComponent['district'];
	                        attribution.setPrefix(location);
	                    }
	                });
	            });
	             map.on('zoomend',function () {
	                let url = 'http://api.vehicle-dev-nj.mokua.com:5107/vehicle/regeo?lng='+map.getCenter().lng+'&lat='+map.getCenter().lat;
	                $.ajax({
	                    url: url,
	                    success: function(data){
	                        let dataJson = eval('(' + data + ')');
	                        location = dataJson.addressComponent['district'];
	                        attribution.setPrefix(location);
	                    }
	                });
	            });
	                 let iconLayersControl = new iconLayers({
	                maxLayersInRow:4
	            });
	             let layers = [];
	             layers.push({
	                id:1,
	                title:'高德地图',
	                icon:'../dist/images/高德地图.jpg',
	                layer: L.tileLayer.chinaProvider('GaoDe.Normal.Map',{
	                    maxZoom: 18
	                })
	            });
	               layers.push({
	                id:2,
	                title:'高德卫星',
	                icon:'../dist/images/高德卫星.jpg',
	                layer:L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{
	                    maxZoom: 18
	                  })
	            });
	               layers.push({
	                id:3,
	                title:'谷歌地图',
	                icon:'../dist/images/谷歌地图.jpg',
	                layer:L.tileLayer.chinaProvider('Google.Normal.Map',{
	                    maxZoom: 18
	                  })
	            });
	               layers.push({
	                id:4,
	                title:'谷歌卫星',
	                icon:'../dist/images/谷歌卫星.jpg',
	                layer:L.tileLayer.chinaProvider('Google.Satellite.Map',{
	                    maxZoom: 18
	                  })
	            });
	               for (let providerId in providers) {
	                layers.push(providers[providerId]);
	            }
	             iconLayersControl.setLayers(layers);
	             iconLayersControl.addTo(map);
	             iconLayersControl.on('activelayerchange', function(e) {
	                console.log('1111111111111111');
	            });
	             **/

	            //let drawnItems = editableLayers.addTo(map);

	            map.on('click', function () {
	                if ((0, _jquery2.default)('.top_menu').hasClass('open')) {
	                    (0, _jquery2.default)('.top_menu').removeClass('open');
	                }
	                if ((0, _jquery2.default)('.navigation_modal').attr('style') == undefined) {} else if ((0, _jquery2.default)('.navigation_modal').attr('style') == 'display:none') {} else {
	                    (0, _jquery2.default)('.navigation_modal').attr('style', 'display:none');
	                }
	                if ((0, _jquery2.default)('#tools > li > .map-icon.font-active').parent().attr('data-picture') == 1) {
	                    (0, _jquery2.default)('#tools > li > .map-icon.font-active').parent().attr('data-picture', 0);
	                    (0, _jquery2.default)('#tools > li > .map-icon.font-active').next().attr('style', 'display:none');
	                    (0, _jquery2.default)('#tools > li > .map-icon.font-active').removeClass('font-active');
	                }
	            });
	            return map;
	        }

	        if (callBack) {
	            callBack();
	        }
	        map.map_source = 'gaode';
	        map.road = false;
	        return map;
	    },
	    addMarker: function addMarker(latlng, map, options, imgUrl, callBack) {
	        if (imgUrl) {
	            L.Icon.Glyph.MDI = L.Icon.Glyph.extend({
	                options: {
	                    prefix: 'mdi',
	                    iconUrl: imgUrl.url,
	                    iconSize: [imgUrl.width, imgUrl.height],
	                    bgSize: {
	                        x: imgUrl.bgwidth,
	                        y: imgUrl.bgheight
	                    }
	                }
	            });
	            // Factory
	            L.icon.glyph.mdi = function (options) {
	                return new L.Icon.Glyph.MDI(options);
	            };

	            if (options) {
	                options.icon = L.icon.glyph.mdi({ glyph: 'package' });
	                options.riseOnHover = true;
	            } else {
	                options = {
	                    icon: L.icon.glyph.mdi({ glyph: 'package' }),
	                    riseOnHover: true
	                };
	            }

	            var marker = L.marker(latlng, options);

	            var layer = marker.addTo(map);
	            if (callBack) {
	                callBack();
	            }
	            return layer;
	        } else {
	            var _marker = L.marker(latlng);
	            var _layer = _marker.addTo(map);
	            if (callBack) {
	                callBack();
	            }
	            return _layer;
	        }
	    },
	    setView: function setView(latlng, map, zoom, callBack) {
	        map.setView(latlng, zoom);
	        if (callBack) {
	            callBack();
	        }
	        return map;
	    },
	    removeMarker: function removeMarker(layer, callBack) {
	        layer.remove();
	        if (callBack) {
	            callBack();
	        }
	        return this;
	    },
	    draw: function draw(map, first, second, speed, imgUrl, options, callBack) {
	        if (imgUrl) {
	            L.Icon.Glyph.MDI = L.Icon.Glyph.extend({
	                options: {
	                    prefix: 'mdi',
	                    iconUrl: imgUrl.url,
	                    iconSize: [imgUrl.width, imgUrl.height],
	                    bgSize: {
	                        x: imgUrl.bgwidth,
	                        y: imgUrl.bgheight
	                    }
	                }
	            });
	            // Factory
	            L.icon.glyph.mdi = function (options) {
	                return new L.Icon.Glyph.MDI(options);
	            };

	            if (options) {
	                options.icon = L.icon.glyph.mdi({ glyph: 'package' });
	                options.riseOnHover = true;
	            } else {
	                options = {
	                    icon: L.icon.glyph.mdi({ glyph: 'package' }),
	                    riseOnHover: true
	                };
	            }
	        }
	        var marker = L.Marker.movingMarker([first, second], [speed], options).addTo(map);
	        if (callBack) {
	            callBack();
	        }
	        return marker;
	    },
	    drawLines: function drawLines(map, latlngs, speed, imgUrl, options, callBack) {
	        if (imgUrl) {
	            L.Icon.Glyph.MDI = L.Icon.Glyph.extend({
	                options: {
	                    prefix: 'mdi',
	                    iconUrl: imgUrl.url,
	                    iconSize: [imgUrl.width, imgUrl.height],
	                    bgSize: {
	                        x: imgUrl.bgwidth,
	                        y: imgUrl.bgheight
	                    }
	                }
	            });
	            // Factory
	            L.icon.glyph.mdi = function (options) {
	                return new L.Icon.Glyph.MDI(options);
	            };

	            if (options) {
	                options.icon = L.icon.glyph.mdi({ glyph: 'package' });
	                options.riseOnHover = true;
	            } else {
	                options = {
	                    icon: L.icon.glyph.mdi({ glyph: 'package' }),
	                    riseOnHover: true
	                };
	            }
	        }
	        var marker = L.Marker.movingMarker(latlngs, speed, options).addTo(map);

	        if (callBack) {
	            callBack();
	        }
	        return marker;
	    },
	    polyLine: function polyLine(map, latlngs, options, fitbound, callBack) {
	        var polyline = L.polyline(latlngs, options).addTo(map);
	        if (fitbound) {
	            map.fitBounds(polyline.getBounds());
	        }
	        if (callBack) {
	            callBack();
	        }
	        return polyline;
	    },
	    contorl: function contorl(map, marker, command, lineoptions, callBack) {
	        switch (command) {
	            case 'start':
	                marker.start();break;
	            case 'pause':
	                marker.pause();break;
	            case 'stop':
	                marker.stop();break;
	            case 'resume':
	                marker.resume();break;
	        }
	        var snakeLine = void 0;

	        if (lineoptions) {
	            snakeLine = L.polyline([], lineoptions).addTo(map);
	        } else {
	            snakeLine = L.polyline([]).addTo(map);
	        }
	        var decorator = L.polylineDecorator(snakeLine, {
	            patterns: [{ offset: 25, repeat: 100, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { fillOpacity: 1, weight: 0 } }) }]
	        }).addTo(map);
	        marker.on('move', updateSnakeLine);

	        function updateSnakeLine(e) {
	            var ll = e.target.getLatLng();
	            snakeLine.addLatLng(ll);
	            if (!map.getBounds().contains(ll)) {
	                map.panTo(ll);
	            }
	        }
	        if (callBack) {
	            callBack();
	        }
	        return snakeLine;
	    },
	    control2: function control2(map, marker, lineoptions, callBack) {
	        var snakeLine = void 0;

	        if (lineoptions) {
	            snakeLine = L.polyline([], lineoptions).addTo(map);
	        } else {
	            snakeLine = L.polyline([]).addTo(map);
	        }
	        var decorator = L.polylineDecorator(snakeLine, {
	            patterns: [{ offset: 25, repeat: 100, symbol: L.Symbol.arrowHead({ pixelSize: 15, pathOptions: { fillOpacity: 1, weight: 0 } }) }]
	        }).addTo(map);
	        marker.on('move', updateSnakeLine);

	        function updateSnakeLine(e) {
	            var ll = e.target.getLatLng();
	            snakeLine.addLatLng(ll);
	        }
	        if (callBack) {
	            callBack();
	        }
	        return snakeLine;
	    },
	    d3draw: function d3draw(map, callBack) {
	        map = new L.Map("map", { center: [37.8, -96.9], zoom: 4 }).addLayer(new L.TileLayer("http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"));
	        var svg = d3.select(map.getPanes().overlayPane).append("svg"),
	            g = svg.append("g").attr("class", "leaflet-zoom-hide");
	        d3.json("us-states.json", function (error, collection) {
	            if (error) throw error;
	            var transform = d3.geo.transform({ point: projectPoint }),
	                path = d3.geo.path().projection(transform);
	            function projectPoint(x, y) {
	                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
	                this.stream.point(point.x, point.y);
	            }
	            var feature = g.selectAll("path").data(collection.features).enter().append("path");
	            feature.attr("d", path);
	            // code here
	        });
	        if (callBack) {
	            callBack();
	        }
	    },
	    addToolbar: function addToolbar(map, className, template, clickFunc1, clickFunc2, callBack) {
	        var button_group = (0, _jquery2.default)('#tools');
	        button_group.append(template);
	        button_group.find('.' + className).click(function (e) {
	            change_icon(className);
	            if ((0, _jquery2.default)('.' + className).attr('data-picture') == 1) {
	                (0, _jquery2.default)('.' + className + ' > div').show();
	                if (clickFunc1) {
	                    clickFunc1(e);
	                }
	            } else {
	                (0, _jquery2.default)('.' + className + ' > div').hide();
	                if (clickFunc2) {
	                    clickFunc2(e);
	                }
	            }
	            map.on('click', function () {
	                if ((0, _jquery2.default)('.top_menu').hasClass('open')) {
	                    (0, _jquery2.default)('.top_menu').removeClass('open');
	                }
	                if ((0, _jquery2.default)('.navigation_modal').attr('style') == undefined) {} else if ((0, _jquery2.default)('.navigation_modal').attr('style') == 'display:none') {} else {
	                    (0, _jquery2.default)('.navigation_modal').attr('style', 'display:none');
	                }
	                if ((0, _jquery2.default)('#tools > li > .map-icon.font-active').parent().attr('data-picture') == 1) {
	                    (0, _jquery2.default)('#tools > li > .map-icon.font-active').parent().attr('data-picture', 0);
	                    (0, _jquery2.default)('#tools > li > .map-icon.font-active').next().attr('style', 'display:none');
	                    (0, _jquery2.default)('#tools > li > .map-icon.font-active').removeClass('font-active');
	                }
	            });
	            e.stopPropagation();
	        });
	        (0, _jquery2.default)(document).on("keyup", function (event) {
	            if ((0, _jquery2.default)('.' + className).attr('data-picture') == 1) {
	                if (event.keyCode == 27) {
	                    change_icon(className);
	                    (0, _jquery2.default)('.' + className + ' > div').hide();
	                    if (clickFunc2) {
	                        clickFunc2(event);
	                    }
	                }
	            }
	        });
	        button_group.find('.' + className).dblclick(function (e) {
	            e.stopPropagation();
	        });
	        if (callBack) {
	            callBack();
	        }
	        button_group.find('.' + className).mousewheel(function (e) {
	            e.stopPropagation();
	        });

	        function change_icon(cls) {
	            (0, _jquery2.default)('#tools>li>i').removeClass('font-active');
	            (0, _jquery2.default)('#tools>li>div').attr('style', 'display:none');

	            if ((0, _jquery2.default)('.' + cls).attr('data-picture') == 0) {
	                //$(`.${cls}`).children().attr('src',`/common/mauna/images/${cls}_active.png`);
	                (0, _jquery2.default)('.' + cls).find('>i').addClass('font-active');
	                (0, _jquery2.default)('#tools>li').attr('data-picture', 0);
	                (0, _jquery2.default)('.' + cls).attr('data-picture', 1);
	            } else {
	                (0, _jquery2.default)('.' + cls).find('i').removeClass('font-active');
	                (0, _jquery2.default)('.' + cls).attr('data-picture', 0);
	                // close_evey_window();
	            }
	        }

	        return this;
	    },
	    hideComponent: function hideComponent(map, component, callBack) {
	        switch (component) {
	            case 'centerpoint':
	                (0, _jquery2.default)('#' + map._container.id).find('#center-point').hide();break;
	            case 'zoomslider':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-zoomslider').hide();break;
	            case 'lineaermeasurement':
	                break;
	            case 'search':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-geocoder').hide();break;
	            case 'scale':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-scale').hide();break;
	            case 'minimap':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-minimap').hide();break;
	            case 'searchplace':
	                (0, _jquery2.default)('#' + map._container.id).find('.search_place').hide();break;
	        }
	        if (callBack) {
	            callBack();
	        }
	        return this;
	    },
	    showComponent: function showComponent(map, component, callBack) {
	        switch (component) {
	            case 'centerpoint':
	                (0, _jquery2.default)('#' + map._container.id).find('#center-point').show();break;
	            case 'zoomslider':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-zoomslider').show();break;
	            case 'lineaermeasurement':
	                break;
	            case 'search':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-geocoder').show();break;
	            case 'scale':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-scale').show();break;
	            case 'minimap':
	                (0, _jquery2.default)('#' + map._container.id).find('.leaflet-control-minimap').show();break;
	            case 'searchplace':
	                (0, _jquery2.default)('#' + map._container.id).find('.search_place').show();break;
	        }
	        if (callBack) {
	            callBack();
	        }
	        return this;
	    },
	    getNavigation: function getNavigation(index, callBack) {
	        if (callBack) {
	            callBack();
	        }
	        return (0, _jquery2.default)('.navigation_totle > div')[index - 1];
	    },
	    myIcon: function myIcon(map, latlng, options, markeropt) {
	        var myIcon = L.divIcon(options);
	        if (markeropt) {
	            markeropt.icon = myIcon;
	            markeropt.riseOnHover = true;
	        } else {
	            markeropt = {
	                icon: myIcon,
	                riseOnHover: true
	            };
	        }
	        return L.marker(latlng, markeropt).addTo(map);
	    },
	    myMarker: function myMarker(latlng, options, markeropt) {
	        var myIcon = L.divIcon(options);
	        if (markeropt) {
	            markeropt.icon = myIcon;
	        } else {
	            markeropt = {
	                icon: myIcon
	            };
	        }
	        return L.marker(latlng, markeropt);
	    },
	    icon: function icon(map, latlng, options, markeropt) {
	        var icon = L.icon(options);
	        if (markeropt) {
	            markeropt.icon = icon;
	            markeropt.riseOnHover = true;
	        } else {
	            markeropt = {
	                icon: icon,
	                riseOnHover: true
	            };
	        }
	        return L.marker(latlng, markeropt).addTo(map);
	    },
	    location: function location(latlng, callBack) {
	        latlng = L.latLng(latlng);
	        var address = new _location.Location().init('高德地图', latlng);
	        if (callBack) {
	            callBack();
	        }
	        return address;
	    },
	    createSearch: function createSearch(content, callBack) {
	        (0, _jquery2.default)('.search_place').append(content);
	        if (callBack) {
	            callBack();
	        }
	        return (0, _jquery2.default)('.search_place');
	    },
	    getSearchTips: function getSearchTips(keywords, first, second) {
	        var latlng = void 0,
	            city = void 0;
	        if (first && (typeof first === 'undefined' ? 'undefined' : _typeof(first)) == 'object') {
	            latlng = L.latLng(first);
	            city = second;
	        } else {
	            latlng = L.latLng(second);
	            city = first;
	        }
	        var location = new _location.Location();
	        return location.getInputtips(keywords, city, latlng);
	    },
	    getSearch: function getSearch(keywords, city) {
	        var location = new _location.Location();
	        return location.getSearch(keywords, city);
	    },
	    getLatlng: function getLatlng(address) {
	        var location = new _location.Location();
	        return location.getLatlng(address);
	    },
	    getSubdistrict: function getSubdistrict(address) {
	        var location = new _location.Location();
	        return location.getSubdistrict(address);
	    },
	    changeMap: function changeMap(map, type, road) {
	        var layer = void 0,
	            layer2 = void 0;
	        var center = void 0;
	        switch (type) {
	            case 'google':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('Google.Normal.Map', {});
	                map.map_source = 'google';
	                break;
	            case 'google-satellite':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('Google.Satellite.Map', {});
	                map.map_source = 'google-satellite';
	                break;
	            case 'gaode':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('GaoDe.Normal.Map', {});
	                map.map_source = 'gaode';
	                break;
	            case 'gaode-satellite':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('GaoDe.Satellite.Map', {});
	                map.map_source = 'gaode-satellite';
	                break;
	            case 'baidu':
	                center = map.getCenter();
	                map.options.crs = L.CRS.Baidu;
	                layer = L.tileLayer.baidu({ layer: 'vec' });
	                map.setView(center);
	                map.map_source = 'baidu';
	                break;
	            case 'baidu-satellite':
	                center = map.getCenter();
	                map.options.crs = L.CRS.Baidu;
	                layer = L.tileLayer.baidu({ layer: 'img_d' });
	                map.setView(center);
	                map.map_source = 'baidu-satellite';
	                break;
	            case 'geoq':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('Geoq.Normal.Map', {});
	                map.map_source = 'geoq';
	                break;
	            case 'geoq-satellite':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('GaoDe.Satellite.Map', {});
	                map.map_source = 'geoq-satellite';
	                break;
	            case 'tianditu':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('TianDiTu.Normal.Map', {});
	                layer2 = L.tileLayer.chinaProvider('TianDiTu.Normal.Annotion', {});
	                map.map_source = 'tianditu';
	                break;
	            case 'tianditu-satellite':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('TianDiTu.Satellite.Map', {});
	                layer2 = L.tileLayer.chinaProvider('TianDiTu.Satellite.Annotion', {});
	                map.map_source = 'tianditu-satellite';
	                break;
	            case 'geoq-bb':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue', {});
	                map.map_source = 'geoq-bb';
	                break;
	            case 'geoq-bb-satellite':
	                map.options.crs = L.CRS.EPSG3857;
	                layer = L.tileLayer.chinaProvider('GaoDe.Satellite.Map', {});
	                map.map_source = 'geoq-bb-satellite';
	                break;
	        }
	        map.eachLayer(function (layer) {
	            if (layer._url) {
	                map.removeLayer(layer);
	            }
	        });
	        map.addLayer(layer, true);
	        if (type == 'tianditu' || type == 'tianditu-satellite') {
	            map.addLayer(layer2, true);
	        }
	        if (road) {
	            if (type == 'baidu' || type == 'baidu-satellite') {
	                map.addLayer(L.tileLayer.baidu({ layer: 'time' }), true);
	                map.road = true;
	            } else {
	                map.addLayer(L.tileLayer.chinaProvider('GaoDe.Road.Map', {}), true);
	                map.road = false;
	            }
	        }
	        return this;
	    },
	    initLine: function initLine(map) {
	        var line = new L.Control.LinearMeasurement({
	            unitSystem: 'metric',
	            color: '#0D9BF2',
	            type: 'line',
	            show_last_node: false
	        });
	        map.addControl(line);
	        return line;
	    },
	    startLine: function startLine(map, classname) {
	        var line = new L.Control.LinearMeasurement({
	            unitSystem: 'metric',
	            color: '#0D9BF2',
	            type: 'line',
	            show_last_node: false,
	            tool_className: classname
	        });
	        map.addControl(line);
	        (0, _jquery2.default)('.leaflet-grab').addClass('leaflet-pointer');
	        (0, _jquery2.default)('.leaflet-grab').removeClass('leaflet-grab');
	        return line.initRuler();
	    },
	    endLine: function endLine(line) {
	        (0, _jquery2.default)('.leaflet-pointer').addClass('leaflet-grab');
	        (0, _jquery2.default)('.leaflet-pointer').removeClass('leaflet-pointer');
	        //console.log(line);
	        //line.resetRuler(!!line.mainLayer);
	    },
	    drawArrow: function drawArrow(polyline) {
	        var decorator = L.polylineDecorator(polyline, {
	            patterns: [{ offset: 25, repeat: 100, symbol: L.Symbol.arrowHead({ pixelSize: 10, pathOptions: { fillOpacity: 1, weight: 0 } }) }]
	        }).addTo(map);

	        return decorator;
	    },
	    setPatterns: function setPatterns(decorator, options) {
	        var patterns = [{
	            offset: 25,
	            repeat: 100,
	            symbol: L.Symbol.arrowHead({
	                pixelSize: options.pixelSize,
	                pathOptions: options.pathOptions
	            })
	        }];
	        decorator.setPatterns(patterns);
	        return this;
	    },
	    arrowCluster: function arrowCluster(map) {
	        var collisionLayer = L.LayerGroup.collision({ margin: 5 });
	        map.addLayer(collisionLayer);
	        return collisionLayer;
	    },
	    addCluster: function addCluster(markers, map, cluster_options) {
	        for (var i = 0; i < markers.length; i++) {
	            map.removeLayer(markers[i]);
	        }
	        var cluster = void 0;
	        if (cluster_options) {
	            cluster = L.markerClusterGroup({
	                iconCreateFunction: function iconCreateFunction(cluster) {
	                    var childCount = cluster.getChildCount();

	                    var c = ' marker-cluster-';
	                    if (childCount < 10) {
	                        c += 'small';
	                        cluster_options.iconSize = new L.Point(40, 40);
	                    } else if (childCount < 100) {
	                        c += 'medium';
	                        cluster_options.iconSize = new L.Point(48, 48);
	                    } else {
	                        c += 'large';
	                        cluster_options.iconSize = new L.Point(60, 60);
	                    }
	                    cluster_options.className = 'marker-cluster ' + cluster_options.uniqueName + c;
	                    cluster_options.html = '<div><span>' + childCount + '</span></div>';
	                    return L.divIcon(cluster_options);
	                }
	            });
	        } else {
	            cluster = L.markerClusterGroup();
	        }
	        cluster.addLayers(markers);
	        map.addLayer(cluster);
	        return cluster;
	    },
	    removeCluster: function removeCluster(cluster, markers, map) {
	        cluster.remove();
	        for (var i = 0; i < markers.length; i++) {
	            map.addLayer(markers[i]);
	        }
	    },
	    addToCluster: function addToCluster(map, layers, cluster) {
	        for (var i = 0; i < layers.length; i++) {
	            if (map.hasLayer(layers[i])) {
	                layers[i].remove();
	            } else {}
	        }
	        cluster.addLayers(layers);
	    },
	    removeFromCluster: function removeFromCluster(map, layers, cluster) {
	        for (var i = 0; i < layers.length; i++) {
	            if (map.hasLayer(layers[i])) {} else {
	                map.addLayer(layers[i]);
	            }
	        }
	        cluster.removeLayers(layers);
	    },
	    showBackground: function showBackground(map, url) {
	        map.dragging.disable();
	        map.doubleClickZoom.disable();
	        map.boxZoom.disable();
	        map.touchZoom.disable();
	        map.scrollWheelZoom.disable();
	        var imageUrl = url;
	        var imageBounds = [map.getCenter()];
	        var options = {
	            'zIndex': 2000,
	            'className': ' backgroundImg',
	            'crossOrigin': true
	        };
	        var background = L.imageOverlay(imageUrl, imageBounds, options).addTo(map);
	        background.setBounds(map.getBounds());

	        (0, _jquery2.default)('.top_menu').hide();
	        (0, _jquery2.default)('.button_group').hide();
	        (0, _jquery2.default)('.switch_group').hide();
	        (0, _jquery2.default)('.card-div-border').hide();
	        (0, _jquery2.default)('.marker-cluster').hide();
	        map.on('resize', function () {
	            if ((0, _jquery2.default)('.backgroundImg').length > 0) {
	                map.dragging.disable();
	                map.doubleClickZoom.disable();
	                map.boxZoom.disable();
	                map.touchZoom.disable();
	                map.scrollWheelZoom.disable();
	                background.setBounds(map.getBounds());
	            } else {
	                map.scrollWheelZoom.enable();
	                map.dragging.enable();
	                map.doubleClickZoom.enable();
	                map.boxZoom.enable();
	                map.touchZoom.enable();
	            }
	        });
	        map.on('move', function () {
	            background.setBounds(map.getBounds());
	        });

	        return background;
	    },
	    hideBackground: function hideBackground(map, background) {
	        map.scrollWheelZoom.enable();
	        map.dragging.enable();
	        map.doubleClickZoom.enable();
	        map.boxZoom.enable();
	        map.touchZoom.enable();
	        background.remove();
	        (0, _jquery2.default)('.top_menu').show();
	        (0, _jquery2.default)('.switch_group').show();
	        (0, _jquery2.default)('.button_group').show();
	        (0, _jquery2.default)('.marker-cluster').show();
	    },
	    showTransparentBg: function showTransparentBg(map) {
	        map.dragging.disable();
	        map.doubleClickZoom.disable();
	        map.boxZoom.disable();
	        map.touchZoom.disable();
	        map.scrollWheelZoom.disable();
	        var imageBounds = [map.getCenter()];
	        var options = {
	            'zIndex': 2000,
	            'className': ' leaflet-tile-transparent',
	            'crossOrigin': true
	        };
	        var background = L.imageOverlay('', imageBounds, options).addTo(map);
	        background.setBounds(map.getBounds());
	        map.on('resize', function () {
	            if ((0, _jquery2.default)('.leaflet-tile-transparent').length > 0) {
	                map.dragging.disable();
	                map.doubleClickZoom.disable();
	                map.boxZoom.disable();
	                map.touchZoom.disable();
	                map.scrollWheelZoom.disable();
	                background.setBounds(map.getBounds());
	            } else {
	                map.scrollWheelZoom.enable();
	                map.dragging.enable();
	                map.doubleClickZoom.enable();
	                map.boxZoom.enable();
	                map.touchZoom.enable();
	            }
	        });
	        map.on('move', function () {
	            background.setBounds(map.getBounds());
	        });

	        return background;
	    },
	    hideTransparentBg: function hideTransparentBg(map, background) {
	        map.scrollWheelZoom.enable();
	        map.dragging.enable();
	        map.doubleClickZoom.enable();
	        map.boxZoom.enable();
	        map.touchZoom.enable();
	        background.remove();
	    },
	    changeIcon: function changeIcon(marker, latlng, options) {
	        var myIcon = L.divIcon(options);
	        marker.setIcon(myIcon);
	        marker.setLatLng(latlng);
	        return marker;
	    },
	    drawPolygon: function drawPolygon(map, latlngs, option, fitBounds, callBack) {
	        var polygon = L.polygon(latlngs, option).addTo(map);
	        if (fitBounds) {
	            map.fitBounds(polygon.getBounds());
	        }
	        if (callBack) {
	            callBack();
	        }
	        return polygon;
	    },
	    initPolygon: function initPolygon(map) {
	        var editableLayers = new L.FeatureGroup();
	        map.addLayer(editableLayers);
	        var options = {
	            position: 'topright',
	            draw: {
	                polyline: false,
	                marker: false,
	                polygon: false,
	                circle: false, // Turns off this drawing tool
	                rectangle: {
	                    shapeOptions: {
	                        clickable: false
	                    }
	                },
	                circlemarker: false
	            },
	            edit: {
	                featureGroup: editableLayers, //REQUIRED!!
	                remove: true
	            }
	        };

	        var drawControl = new L.Control.Draw(options);
	        map.addControl(drawControl);

	        map.on(L.Draw.Event.CREATED, function (e) {
	            var type = e.layerType,
	                layer = e.layer;
	            editableLayers.addLayer(layer);
	        });

	        (0, _jquery2.default)('.leaflet-draw').hide();
	    },
	    startPolygon: function startPolygon() {
	        (0, _jquery2.default)(".leaflet-draw-draw-rectangle").children('span').click();
	    },
	    cancelPolygon: function cancelPolygon() {
	        if ((0, _jquery2.default)(".leaflet-draw-actions").children('li').children('a').children('span').length == 0) {
	            (0, _jquery2.default)(".leaflet-draw-actions").children('li').children('a').append('<span>cancel</span>');
	            (0, _jquery2.default)(".leaflet-draw-actions").children('li').children('a').children('span').click();
	        } else {
	            (0, _jquery2.default)(".leaflet-draw-actions").children('li').children('a').children('span').click();
	        }
	    },
	    removePolygon: function removePolygon(layer) {
	        layer.remove();
	    },
	    endRemovePolygon: function endRemovePolygon() {
	        if ((0, _jquery2.default)('.leaflet-draw-actions-bottom').children('li:first').children('a').children('span').length == 0) {
	            (0, _jquery2.default)('.leaflet-draw-actions-bottom').children('li:first').children('a').append('<span>save</span>');
	            (0, _jquery2.default)('.leaflet-draw-actions-bottom').children('li:first').children('a').children('span').click();
	        } else {
	            (0, _jquery2.default)('.leaflet-draw-actions-bottom').children('li:first').children('a').children('span').click();
	        }
	    },
	    changeContainerBg: function changeContainerBg(url) {
	        (0, _jquery2.default)('.leaflet-container').css("background-image", 'url(' + url + ')');
	    },
	    showMarkerList: function showMarkerList(map, callBack) {
	        var _this = this;
	        var flag = 0;
	        var bounds = void 0;
	        var rect = void 0;
	        var rectLayer = void 0;
	        map.off("mousemove");
	        map.on("mousemove", function (event) {
	            if (flag == 0) {
	                var first_latlng = event.latlng;
	                var first_point = map.latLngToLayerPoint(first_latlng);
	                var first_pointRT = L.point(first_point.x + 50, first_point.y + 50);
	                var first_pointLB = L.point(first_point.x - 50, first_point.y - 50);
	                bounds = L.bounds(first_pointRT, first_pointLB);
	            }
	            flag = 1;
	            if (bounds.contains(event.containerPoint)) {} else {
	                var latlng = event.latlng;
	                var point = map.latLngToLayerPoint(latlng);
	                var pointRT = L.point(point.x + 50, point.y + 50);
	                var pointLB = L.point(point.x - 50, point.y - 50);
	                bounds = L.bounds(pointRT, pointLB);
	                var latlngRT = map.layerPointToLatLng(pointRT);
	                var latlngLB = map.layerPointToLatLng(pointLB);
	                rect = L.rectangle([latlngRT, latlngLB], { color: "#ff7800", weight: 1 });
	                rect.on('popupopen', function () {
	                    map.off('mousemove');
	                });
	                rect.on('popupclose', function () {
	                    rectLayer.remove();
	                    _this.showMarkerList(map, callBack);
	                });
	                var layers = [];
	                map.eachLayer(function (layer) {
	                    if (layer._icon != undefined && (0, _jquery2.default)(layer._icon).hasClass('leaflet-marker-icon') && !(0, _jquery2.default)(layer._icon).hasClass('my-cross-icon')) {
	                        if (!(0, _jquery2.default)(layer._icon).hasClass('marker-cluster')) {
	                            if (bounds.contains(map.latLngToLayerPoint(layer._latlng))) {
	                                layers.push(layer);
	                            }
	                        } else {
	                            if (bounds.contains(map.latLngToLayerPoint(layer._latlng))) {
	                                _jquery2.default.each(layer.getAllChildMarkers(), function (i, e) {
	                                    layers.push(this);
	                                });
	                            }
	                        }
	                    }
	                });
	                if (layers.length > 0) {
	                    if (map.hasLayer(rectLayer)) {
	                        rectLayer.setBounds([latlngRT, latlngLB]);
	                    } else {
	                        rectLayer = rect.addTo(map);
	                    }
	                } else {
	                    if (map.hasLayer(rectLayer)) {
	                        rectLayer.remove();
	                    }
	                }
	                if (callBack) {
	                    callBack(layers, bounds, rect, rectLayer, latlngRT, latlngLB);
	                }
	            }
	        });
	    },
	    showMarkerList2: function showMarkerList2(map, callBack) {
	        var layers = [];
	        var bounds = void 0;
	        var rect = void 0;
	        var rectLayer = void 0;
	        map.eachLayer(function (layer) {
	            if (layer._icon != undefined && (0, _jquery2.default)(layer._icon).hasClass('leaflet-marker-icon') && !(0, _jquery2.default)(layer._icon).hasClass('my-cross-icon')) {
	                if (!(0, _jquery2.default)(layer._icon).hasClass('marker-cluster')) {
	                    layer.on('mouseover', function () {
	                        var latlng = layer._latlng;
	                        var point = map.latLngToLayerPoint(latlng);
	                        var pointRT = L.point(point.x + 50, point.y + 50);
	                        var pointLB = L.point(point.x - 50, point.y - 50);
	                        bounds = L.bounds(pointRT, pointLB);
	                        var latlngRT = map.layerPointToLatLng(pointRT);
	                        var latlngLB = map.layerPointToLatLng(pointLB);
	                        rect = L.rectangle([latlngRT, latlngLB], { color: "#ff7800", weight: 1 });
	                    });
	                } else {
	                    _jquery2.default.each(layer.getAllChildMarkers(), function (i, e) {
	                        e.on('mouseover', function () {});
	                    });
	                }
	            }
	        });
	    },
	    closeMarkerList: function closeMarkerList(map, callback) {
	        map.off('mousemove');
	        if (callback) {
	            callback();
	        }
	    },
	    drawCircle: function drawCircle(map, latlng, options, callback) {
	        var circle = L.circle(latlng, options).addTo(map);
	        if (callback) {
	            callback();
	        }
	        return circle;
	    },
	    pip: function pip(statesData) {
	        var leafletPip = __webpack_require__(19);
	        var gjLayer = L.geoJson(statesData);
	        var results = leafletPip.pointInLayer([-88, 38], gjLayer);
	        return results;
	    },
	    coverTips: function coverTips(map, markers, latlng, callback) {
	        var allBounds = [];
	        var size = void 0;
	        for (var i = 0; i < markers.length; i++) {
	            var point = map.latLngToLayerPoint(markers[i].getLatLng());
	            if (markers[i]._icon.childNodes.length > 0) {
	                if (markers[i]._icon.childNodes[0].clientWidth != 0 && markers[i]._icon.childNodes[0].clientHeight != 0) {
	                    size = [markers[i]._icon.childNodes[0].clientWidth, markers[i]._icon.childNodes[0].clientHeight];
	                } else {
	                    size = [markers[i]._icon.clientWidth, markers[i]._icon.clientHeight];
	                }
	            } else {
	                size = [markers[i]._icon.clientWidth, markers[i]._icon.clientHeight];
	            }
	            var rtlatlng = map.layerPointToLatLng(L.point([point.x + size[0] / 2, point.y - size[1]]));
	            var lblatlng = map.layerPointToLatLng(L.point([point.x - size[0] / 2, point.y]));
	            allBounds.push(L.latLngBounds(lblatlng, rtlatlng));
	        }
	        var mousePoint = map.latLngToLayerPoint(latlng);
	        var mouseRtLatlng = map.layerPointToLatLng(L.point([mousePoint.x + 7, mousePoint.y - 14]));
	        var mouseLbLatlng = map.layerPointToLatLng(L.point([mousePoint.x - 7, mousePoint.y]));
	        var mouseBounds = L.latLngBounds(mouseRtLatlng, mouseLbLatlng);
	        var coverMarkers = [];
	        var noCoverBounds = [];
	        for (var _i2 = 0; _i2 < allBounds.length; _i2++) {
	            if (allBounds[_i2].contains(latlng)) {
	                coverMarkers.push(markers[_i2]);
	            } else {
	                noCoverBounds.push(allBounds[_i2]);
	            }
	        }
	        var resultMarkers = [];
	        getCoverMarkers(coverMarkers, noCoverBounds, markers, allBounds, resultMarkers);
	        function getCoverMarkers(cMarkers, noBounds, allMarkers, allBounds, resultMarkers) {
	            var markers = [];
	            var bounds = noBounds;
	            for (var _i3 = 0; _i3 < noBounds.length; _i3++) {
	                for (var j = 0; j < cMarkers.length; j++) {
	                    var _point = map.latLngToContainerPoint(cMarkers[j].getLatLng());
	                    var _size = [cMarkers[j]._icon.childNodes[0].clientWidth, cMarkers[j]._icon.childNodes[0].clientHeight];
	                    var _rtlatlng = map.containerPointToLatLng(L.point([_point.x + _size[0] / 2, _point.y - _size[1]]));
	                    var _lblatlng = map.containerPointToLatLng(L.point([_point.x - _size[0] / 2, _point.y]));
	                    var markerBounds = L.latLngBounds(_rtlatlng, _lblatlng);
	                    if (noBounds[_i3] != undefined) {
	                        if (markerBounds.intersects(noBounds[_i3])) {
	                            for (var k = 0; k < allBounds.length; k++) {
	                                if (allBounds[k].equals(noBounds[_i3])) {
	                                    markers.push(allMarkers[k]);
	                                    resultMarkers.push(allMarkers[k]);
	                                }
	                            }
	                            bounds.splice(_i3, 1);
	                        }
	                    }
	                }
	            }
	            if (markers.length == 0) {
	                return resultMarkers;
	            } else {
	                getCoverMarkers(markers, bounds, allMarkers, allBounds, resultMarkers);
	            }
	        }
	        var rectMarkers = coverMarkers.concat(resultMarkers);
	        var latArray = [];
	        var lngArray = [];
	        for (var _i4 = 0; _i4 < rectMarkers.length; _i4++) {
	            var _point2 = map.latLngToContainerPoint(rectMarkers[_i4].getLatLng());
	            size = [rectMarkers[_i4]._icon.childNodes[0].clientWidth, rectMarkers[_i4]._icon.childNodes[0].clientHeight];
	            var _rtlatlng2 = map.containerPointToLatLng(L.point([_point2.x + size[0] / 2, _point2.y - size[1] / 3]));
	            var _lblatlng2 = map.containerPointToLatLng(L.point([_point2.x - size[0] / 2, _point2.y + size[1] / 1.5]));
	            latArray.push(_rtlatlng2.lat);
	            latArray.push(_lblatlng2.lat);
	            lngArray.push(_rtlatlng2.lng);
	            lngArray.push(_lblatlng2.lng);
	        }
	        var maxLat = Math.max.apply(null, latArray);
	        var minLat = Math.min.apply(null, latArray);
	        var maxLng = Math.max.apply(null, lngArray);
	        var minLng = Math.min.apply(null, lngArray);
	        var rect = void 0;
	        if (latArray.length > 0) {
	            rect = L.rectangle([[maxLat, maxLng], [minLat, minLng]], { className: 'leaflet-covertip-rect' });
	        }
	        if (callback) {
	            callback(map, rectMarkers, rect);
	        }
	        return rectMarkers;
	    },
	    showPopup: function showPopup(map, latlng, content, popupoptions, callback) {
	        var popup = L.popup(popupoptions).setLatLng(latlng).setContent(content).openOn(map);
	        if (callback) {
	            callback();
	        }
	        return popup;
	    },
	    showHeatMap: function showHeatMap(map, data, radius, callback) {
	        var heat = L.heatLayer(data, { radius: radius }).addTo(map);
	        if (callback) {
	            callback();
	        }
	        return heat;
	    },
	    marsTobaidu: function marsTobaidu(mars_point) {
	        var x_pi = 3.14159265358979324 * 3000.0 / 180.0;
	        var baidu_point = { lon: 0, lat: 0 };
	        var x = mars_point[1];
	        var y = mars_point[0];
	        var z = Math.sqrt(x * x + y * y) + 0.00002 * Math.sin(y * x_pi);
	        var theta = Math.atan2(y, x) + 0.000003 * Math.cos(x * x_pi);
	        baidu_point.lon = z * Math.cos(theta) + 0.0065;
	        baidu_point.lat = z * Math.sin(theta) + 0.006;
	        return baidu_point;
	    },
	    changeToMapbox: function changeToMapbox(map) {
	        map.eachLayer(function (layer) {
	            if (layer._url) {
	                map.removeLayer(layer);
	            }
	        });
	        var token = 'pk.eyJ1IjoiZW1peWFnbSIsImEiOiJjajdsazVkdWsxMG12MzJvNnF4dWE4dzdkIn0.95qn2oWmFfBAZsHMzO42vQ';
	        var gl = L.mapboxGL({
	            accessToken: token,
	            style: {
	                "version": 8,
	                //      style: 'mapbox://styles/mapbox/basic-v9',
	                //      "sprite": "mapbox://sprites/mapbox/streets-v8",
	                "sources": {
	                    "gaode-tiles": {
	                        "type": "raster",
	                        'tiles': ["http://webrd02.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}"],
	                        'tileSize': 256
	                    }
	                },
	                "layers": [{
	                    "id": "simple-tiles",
	                    "type": "raster",
	                    "source": "gaode-tiles",
	                    "minzoom": 0,
	                    "maxzoom": 22
	                }]
	            },
	            center: [30, 104],
	            zoom: 5,
	            pitch: 40.5
	        }).addTo(map);
	    },
	    drawDeckGl: function drawDeckGl() {
	        var GEOJSON = { "type": "FeatureCollection",
	            "features": [{ "type": "Feature", "properties": { "id": "65", "size": "550", "name": "新疆维吾尔自治区", "cp": [84.9023, 42.148], "childNum": 18 }, "geometry": { "type": "Polygon", "coordinates": [[[96.416, 42.7588], [96.416, 42.7148], [95.9766, 42.4951], [96.0645, 42.3193], [96.2402, 42.2314], [95.9766, 41.9238], [95.2734, 41.6162], [95.1855, 41.792], [94.5703, 41.4844], [94.043, 41.0889], [93.8672, 40.6934], [93.0762, 40.6494], [92.6367, 39.6387], [92.373, 39.3311], [92.373, 39.1113], [92.373, 39.0234], [90.1758, 38.4961], [90.3516, 38.2324], [90.6152, 38.3203], [90.5273, 37.8369], [91.0547, 37.4414], [91.3184, 37.0898], [90.7031, 36.7822], [90.791, 36.6064], [91.0547, 36.5186], [91.0547, 36.0791], [90.8789, 36.0352], [90, 36.2549], [89.9121, 36.0791], [89.7363, 36.0791], [89.209, 36.2988], [88.7695, 36.3428], [88.5938, 36.4746], [87.3633, 36.4307], [86.2207, 36.167], [86.1328, 35.8594], [85.6055, 35.6836], [85.0781, 35.7275], [84.1992, 35.376], [83.1445, 35.4199], [82.8809, 35.6836], [82.4414, 35.7275], [82.002, 35.332], [81.6504, 35.2441], [80.4199, 35.4199], [80.2441, 35.2881], [80.332, 35.1563], [80.2441, 35.2002], [79.8926, 34.8047], [79.8047, 34.4971], [79.1016, 34.4531], [79.0137, 34.3213], [78.2227, 34.7168], [78.0469, 35.2441], [78.0469, 35.5078], [77.4316, 35.4639], [76.8164, 35.6396], [76.5527, 35.8594], [76.2012, 35.8154], [75.9375, 36.0352], [76.0254, 36.4746], [75.8496, 36.6943], [75.498, 36.7383], [75.4102, 36.958], [75.0586, 37.002], [74.8828, 36.9141], [74.7949, 37.0459], [74.5313, 37.0898], [74.5313, 37.2217], [74.8828, 37.2217], [75.1465, 37.4414], [74.8828, 37.5732], [74.9707, 37.749], [74.8828, 38.4521], [74.3555, 38.6719], [74.1797, 38.6719], [74.0918, 38.54], [73.8281, 38.584], [73.7402, 38.8477], [73.8281, 38.9795], [73.4766, 39.375], [73.916, 39.5068], [73.916, 39.6826], [73.8281, 39.7705], [74.0039, 40.0342], [74.8828, 40.3418], [74.7949, 40.5176], [75.2344, 40.4297], [75.5859, 40.6494], [75.7617, 40.2979], [76.377, 40.3857], [76.9043, 41.001], [77.6074, 41.001], [78.1348, 41.2207], [78.1348, 41.3965], [80.1563, 42.0557], [80.2441, 42.2754], [80.1563, 42.627], [80.2441, 42.8467], [80.5078, 42.8906], [80.4199, 43.0664], [80.7715, 43.1982], [80.4199, 44.165], [80.4199, 44.6045], [79.9805, 44.8242], [79.9805, 44.9561], [81.7383, 45.3955], [82.0898, 45.2197], [82.5293, 45.2197], [82.2656, 45.6592], [83.0566, 47.2412], [83.6719, 47.0215], [84.7266, 47.0215], [84.9023, 46.8896], [85.5176, 47.0654], [85.6934, 47.2852], [85.5176, 48.1201], [85.7813, 48.4277], [86.5723, 48.5596], [86.8359, 48.8232], [86.748, 48.9551], [86.8359, 49.1309], [87.8027, 49.1748], [87.8906, 48.999], [87.7148, 48.9111], [88.0664, 48.7354], [87.9785, 48.6035], [88.5059, 48.3838], [88.6816, 48.1641], [89.1211, 47.9883], [89.5605, 48.0322], [89.7363, 47.8564], [90.0879, 47.8564], [90.3516, 47.6807], [90.5273, 47.2412], [90.8789, 46.9775], [91.0547, 46.582], [90.8789, 46.3184], [91.0547, 46.0107], [90.7031, 45.7471], [90.7031, 45.5273], [90.8789, 45.2197], [91.582, 45.0879], [93.5156, 44.9561], [94.7461, 44.3408], [95.3613, 44.2969], [95.3613, 44.0332], [95.5371, 43.9014], [95.8887, 43.2422], [96.3281, 42.9346], [96.416, 42.7588]]] } }, { "type": "Feature", "properties": { "id": "54", "size": "550", "name": "西藏自治区", "cp": [87.8695, 31.6846], "childNum": 7 }, "geometry": { "type": "Polygon", "coordinates": [[[79.0137, 34.3213], [79.1016, 34.4531], [79.8047, 34.4971], [79.8926, 34.8047], [80.2441, 35.2002], [80.332, 35.1563], [80.2441, 35.2881], [80.4199, 35.4199], [81.6504, 35.2441], [82.002, 35.332], [82.4414, 35.7275], [82.8809, 35.6836], [83.1445, 35.4199], [84.1992, 35.376], [85.0781, 35.7275], [85.6055, 35.6836], [86.1328, 35.8594], [86.2207, 36.167], [87.3633, 36.4307], [88.5938, 36.4746], [88.7695, 36.3428], [89.209, 36.2988], [89.7363, 36.0791], [89.3848, 36.0352], [89.4727, 35.9033], [89.7363, 35.7715], [89.7363, 35.4199], [89.4727, 35.376], [89.4727, 35.2441], [89.5605, 34.8926], [89.8242, 34.8486], [89.7363, 34.6729], [89.8242, 34.3652], [89.6484, 34.0137], [90.0879, 33.4863], [90.7031, 33.1348], [91.4063, 33.1348], [91.9336, 32.8271], [92.1973, 32.8271], [92.2852, 32.7393], [92.9883, 32.7393], [93.5156, 32.4756], [93.7793, 32.5635], [94.1309, 32.4316], [94.6582, 32.6074], [95.1855, 32.4316], [95.0098, 32.2998], [95.1855, 32.3438], [95.2734, 32.2119], [95.3613, 32.168], [95.3613, 31.9922], [95.4492, 31.8164], [95.8008, 31.6846], [95.9766, 31.8164], [96.1523, 31.5967], [96.2402, 31.9482], [96.5039, 31.7285], [96.8555, 31.6846], [96.7676, 31.9922], [97.2949, 32.0801], [97.3828, 32.5635], [97.7344, 32.5195], [98.1738, 32.3438], [98.4375, 31.8604], [98.877, 31.4209], [98.6133, 31.2012], [98.9648, 30.7617], [99.1406, 29.2676], [98.9648, 29.1357], [98.9648, 28.8281], [98.7891, 28.8721], [98.7891, 29.0039], [98.7012, 28.916], [98.6133, 28.5205], [98.7891, 28.3447], [98.7012, 28.2129], [98.3496, 28.125], [98.2617, 28.3887], [98.1738, 28.125], [97.5586, 28.5205], [97.2949, 28.0811], [97.3828, 27.9053], [97.0313, 27.7295], [96.5039, 28.125], [95.7129, 28.2568], [95.3613, 28.125], [95.2734, 27.9492], [94.2188, 27.5537], [93.8672, 27.0264], [93.6035, 26.9385], [92.1094, 26.8506], [92.0215, 27.4658], [91.582, 27.5537], [91.582, 27.9053], [91.4063, 28.0371], [91.0547, 27.8613], [90.7031, 28.0811], [89.8242, 28.2129], [89.6484, 28.1689], [89.1211, 27.5977], [89.1211, 27.334], [89.0332, 27.2021], [88.7695, 27.4219], [88.8574, 27.9932], [88.6816, 28.125], [88.1543, 27.9053], [87.8906, 27.9492], [87.7148, 27.8174], [87.0996, 27.8174], [86.748, 28.125], [86.5723, 28.125], [86.4844, 27.9053], [86.1328, 28.125], [86.0449, 27.9053], [85.6934, 28.3447], [85.6055, 28.2568], [85.166, 28.3447], [85.166, 28.6523], [84.9023, 28.5645], [84.4629, 28.7402], [84.2871, 28.8721], [84.1992, 29.2236], [84.1113, 29.2676], [83.584, 29.1797], [83.2324, 29.5752], [82.1777, 30.0586], [82.0898, 30.3223], [81.3867, 30.3662], [81.2109, 30.0146], [81.0352, 30.2344], [80.0684, 30.5859], [79.7168, 30.9375], [79.0137, 31.0693], [78.75, 31.333], [78.8379, 31.5967], [78.6621, 31.8164], [78.75, 31.9043], [78.4863, 32.124], [78.3984, 32.5195], [78.75, 32.6953], [78.9258, 32.3438], [79.2773, 32.5635], [79.1016, 33.1787], [78.6621, 33.6621], [78.6621, 34.1016], [78.9258, 34.1455], [79.0137, 34.3213]]] } }, { "type": "Feature", "properties": { "id": "15", "size": "450", "name": "内蒙古自治区", "cp": [112.5977, 46.3408], "childNum": 12 }, "geometry": { "type": "Polygon", "coordinates": [[[97.207, 42.8027], [99.4922, 42.583], [100.8105, 42.6709], [101.7773, 42.4951], [102.041, 42.2314], [102.7441, 42.1436], [103.3594, 41.8799], [103.8867, 41.792], [104.502, 41.8799], [104.502, 41.6602], [105.0293, 41.5723], [105.7324, 41.9238], [107.4023, 42.4512], [109.4238, 42.4512], [110.3906, 42.7588], [111.0059, 43.3301], [111.9727, 43.6816], [111.9727, 43.8135], [111.4453, 44.3848], [111.7969, 45], [111.9727, 45.0879], [113.6426, 44.7363], [114.1699, 44.9561], [114.5215, 45.3955], [115.6641, 45.4395], [116.1914, 45.7031], [116.2793, 45.9668], [116.543, 46.2744], [117.334, 46.3623], [117.4219, 46.582], [117.7734, 46.5381], [118.3008, 46.7578], [118.7402, 46.7139], [118.916, 46.7578], [119.0918, 46.6699], [119.707, 46.626], [119.9707, 46.7139], [119.707, 47.1973], [118.4766, 47.9883], [117.8613, 48.0322], [117.334, 47.6807], [116.8066, 47.9004], [116.1914, 47.8564], [115.9277, 47.6807], [115.5762, 47.9004], [115.4883, 48.1641], [115.8398, 48.252], [115.8398, 48.5596], [116.7188, 49.834], [117.7734, 49.5264], [118.5645, 49.9219], [119.2676, 50.0977], [119.3555, 50.3174], [119.1797, 50.3613], [119.5313, 50.7568], [119.5313, 50.8887], [119.707, 51.0645], [120.1465, 51.6797], [120.6738, 51.9434], [120.7617, 52.1191], [120.7617, 52.251], [120.5859, 52.3389], [120.6738, 52.5146], [120.4102, 52.6465], [120.0586, 52.6025], [120.0586, 52.7344], [120.8496, 53.2617], [121.4648, 53.3496], [121.8164, 53.042], [121.2012, 52.5586], [121.6406, 52.4268], [121.7285, 52.2949], [121.9922, 52.2949], [122.168, 52.5146], [122.6953, 52.251], [122.6074, 52.0752], [122.959, 51.3281], [123.3105, 51.2402], [123.6621, 51.3721], [124.3652, 51.2842], [124.541, 51.3721], [124.8926, 51.3721], [125.0684, 51.6357], [125.332, 51.6357], [126.0352, 51.0205], [125.7715, 50.7568], [125.7715, 50.5371], [125.332, 50.1416], [125.1563, 49.834], [125.2441, 49.1748], [124.8047, 49.1309], [124.4531, 48.1201], [124.2773, 48.5156], [122.4316, 47.373], [123.0469, 46.7139], [123.3984, 46.8896], [123.3984, 46.9775], [123.4863, 46.9775], [123.5742, 46.8457], [123.5742, 46.8896], [123.5742, 46.6699], [123.0469, 46.582], [123.2227, 46.2305], [122.7832, 46.0107], [122.6953, 45.7031], [122.4316, 45.8789], [122.2559, 45.791], [121.8164, 46.0107], [121.7285, 45.7471], [121.9043, 45.7031], [122.2559, 45.2637], [122.0801, 44.8682], [122.3438, 44.2529], [123.1348, 44.4727], [123.4863, 43.7256], [123.3105, 43.5059], [123.6621, 43.374], [123.5742, 43.0225], [123.3105, 42.9785], [123.1348, 42.8027], [122.7832, 42.7148], [122.3438, 42.8467], [122.3438, 42.6709], [121.9922, 42.7148], [121.7285, 42.4512], [121.4648, 42.4951], [120.498, 42.0996], [120.1465, 41.7041], [119.8828, 42.1875], [119.5313, 42.3633], [119.3555, 42.2754], [119.2676, 41.7041], [119.4434, 41.6162], [119.2676, 41.3086], [118.3887, 41.3086], [118.125, 41.748], [118.3008, 41.792], [118.3008, 42.0996], [118.125, 42.0557], [117.9492, 42.2314], [118.0371, 42.4072], [117.7734, 42.627], [117.5098, 42.583], [117.334, 42.4512], [116.8945, 42.4072], [116.8066, 42.0117], [116.2793, 42.0117], [116.0156, 41.792], [115.9277, 41.9238], [115.2246, 41.5723], [114.9609, 41.6162], [114.873, 42.0996], [114.5215, 42.1436], [114.1699, 41.792], [114.2578, 41.5723], [113.9063, 41.4404], [113.9941, 41.2207], [113.9063, 41.1328], [114.082, 40.7373], [114.082, 40.5176], [113.8184, 40.5176], [113.5547, 40.3418], [113.2031, 40.3857], [112.7637, 40.166], [112.3242, 40.2539], [111.9727, 39.5947], [111.4453, 39.6387], [111.3574, 39.4189], [111.0938, 39.375], [111.0938, 39.5947], [110.6543, 39.2871], [110.127, 39.4629], [110.2148, 39.2871], [109.8633, 39.2432], [109.9512, 39.1553], [108.9844, 38.3203], [109.0723, 38.0127], [108.8965, 37.9688], [108.8086, 38.0127], [108.7207, 37.7051], [108.1934, 37.6172], [107.666, 37.8809], [107.3145, 38.1006], [106.7871, 38.1885], [106.5234, 38.3203], [106.9629, 38.9795], [106.7871, 39.375], [106.3477, 39.2871], [105.9082, 38.7158], [105.8203, 37.793], [104.3262, 37.4414], [103.4473, 37.8369], [103.3594, 38.0127], [103.5352, 38.1445], [103.4473, 38.3643], [104.2383, 38.9795], [104.0625, 39.4189], [103.3594, 39.3311], [103.0078, 39.1113], [102.4805, 39.2432], [101.8652, 39.1113], [102.041, 38.8916], [101.7773, 38.6719], [101.3379, 38.7598], [101.25, 39.0234], [100.9863, 38.9355], [100.8105, 39.4189], [100.5469, 39.4189], [100.0195, 39.7705], [99.4922, 39.8584], [100.1074, 40.2539], [100.1953, 40.6494], [99.9316, 41.001], [99.2285, 40.8691], [99.0527, 40.6934], [98.9648, 40.7813], [98.7891, 40.6055], [98.5254, 40.7373], [98.6133, 40.6494], [98.3496, 40.5615], [98.3496, 40.9131], [97.4707, 41.4844], [97.8223, 41.6162], [97.8223, 41.748], [97.207, 42.8027]]] } }, { "type": "Feature", "properties": { "id": "63", "size": "800", "name": "青海省", "cp": [95.2402, 35.4199], "childNum": 8 }, "geometry": { "type": "Polygon", "coordinates": [[[89.7363, 36.0791], [89.9121, 36.0791], [90, 36.2549], [90.8789, 36.0352], [91.0547, 36.0791], [91.0547, 36.5186], [90.791, 36.6064], [90.7031, 36.7822], [91.3184, 37.0898], [91.0547, 37.4414], [90.5273, 37.8369], [90.6152, 38.3203], [90.3516, 38.2324], [90.1758, 38.4961], [92.373, 39.0234], [92.373, 39.1113], [93.1641, 39.1992], [93.1641, 38.9795], [93.6914, 38.9355], [93.8672, 38.7158], [94.3066, 38.7598], [94.5703, 38.3643], [95.0098, 38.4082], [95.4492, 38.2764], [95.7129, 38.3643], [96.2402, 38.1006], [96.416, 38.2324], [96.6797, 38.1885], [96.6797, 38.4521], [97.1191, 38.584], [97.0313, 39.1992], [98.1738, 38.8037], [98.3496, 39.0234], [98.6133, 38.9355], [98.7891, 39.0674], [99.1406, 38.9355], [99.8438, 38.3643], [100.1953, 38.2764], [100.0195, 38.4521], [100.1074, 38.4961], [100.459, 38.2764], [100.7227, 38.2324], [101.1621, 37.8369], [101.5137, 37.8809], [101.7773, 37.6172], [101.9531, 37.7051], [102.1289, 37.4414], [102.5684, 37.1777], [102.4805, 36.958], [102.6563, 36.8262], [102.5684, 36.7383], [102.832, 36.3428], [103.0078, 36.2549], [102.9199, 36.0791], [102.9199, 35.9033], [102.6563, 35.7715], [102.832, 35.5957], [102.4805, 35.5957], [102.3047, 35.4199], [102.3926, 35.2002], [101.9531, 34.8486], [101.9531, 34.6289], [102.2168, 34.4092], [102.1289, 34.2773], [101.6895, 34.1016], [100.9863, 34.3652], [100.8105, 34.2773], [101.25, 33.6621], [101.5137, 33.7061], [101.6016, 33.5303], [101.7773, 33.5303], [101.6895, 33.3105], [101.7773, 33.2227], [101.6016, 33.1348], [101.1621, 33.2227], [101.25, 32.6953], [100.7227, 32.6514], [100.7227, 32.5195], [100.3711, 32.7393], [100.1074, 32.6514], [100.1074, 32.8711], [99.8438, 33.0029], [99.7559, 32.7393], [99.2285, 32.915], [99.2285, 33.0469], [98.877, 33.1787], [98.4375, 34.0576], [97.8223, 34.1895], [97.6465, 34.1016], [97.7344, 33.9258], [97.3828, 33.8818], [97.4707, 33.5742], [97.7344, 33.3984], [97.3828, 32.8711], [97.4707, 32.6953], [97.7344, 32.5195], [97.3828, 32.5635], [97.2949, 32.0801], [96.7676, 31.9922], [96.8555, 31.6846], [96.5039, 31.7285], [96.2402, 31.9482], [96.1523, 31.5967], [95.9766, 31.8164], [95.8008, 31.6846], [95.4492, 31.8164], [95.3613, 31.9922], [95.3613, 32.168], [95.2734, 32.2119], [95.1855, 32.3438], [95.0098, 32.2998], [95.1855, 32.4316], [94.6582, 32.6074], [94.1309, 32.4316], [93.7793, 32.5635], [93.5156, 32.4756], [92.9883, 32.7393], [92.2852, 32.7393], [92.1973, 32.8271], [91.9336, 32.8271], [91.4063, 33.1348], [90.7031, 33.1348], [90.0879, 33.4863], [89.6484, 34.0137], [89.8242, 34.3652], [89.7363, 34.6729], [89.8242, 34.8486], [89.5605, 34.8926], [89.4727, 35.2441], [89.4727, 35.376], [89.7363, 35.4199], [89.7363, 35.7715], [89.4727, 35.9033], [89.3848, 36.0352], [89.7363, 36.0791]]] } }, { "type": "Feature", "properties": { "id": "51", "size": "900", "name": "四川省", "cp": [101.9199, 30.1904], "childNum": 21 }, "geometry": { "type": "Polygon", "coordinates": [[[101.7773, 33.5303], [101.8652, 33.5742], [101.9531, 33.4424], [101.8652, 33.0908], [102.4805, 33.4424], [102.2168, 33.9258], [102.9199, 34.3213], [103.0957, 34.1895], [103.1836, 33.7939], [104.1504, 33.6182], [104.2383, 33.3984], [104.4141, 33.3105], [104.3262, 33.2227], [104.4141, 33.0469], [104.3262, 32.8711], [104.4141, 32.7393], [105.2051, 32.6074], [105.3809, 32.7393], [105.3809, 32.8711], [105.4688, 32.915], [105.5566, 32.7393], [106.084, 32.8711], [106.084, 32.7393], [106.3477, 32.6514], [107.0508, 32.6953], [107.1387, 32.4756], [107.2266, 32.4316], [107.4023, 32.5195], [108.0176, 32.168], [108.2813, 32.2559], [108.5449, 32.2119], [108.3691, 32.168], [108.2813, 31.9043], [108.5449, 31.6846], [108.1934, 31.5088], [107.9297, 30.8496], [107.4902, 30.8496], [107.4023, 30.7617], [107.4902, 30.6299], [107.0508, 30.0146], [106.7871, 30.0146], [106.6113, 30.3223], [106.2598, 30.1904], [105.8203, 30.4541], [105.6445, 30.2783], [105.5566, 30.1025], [105.7324, 29.8828], [105.293, 29.5313], [105.4688, 29.3115], [105.7324, 29.2676], [105.8203, 28.96], [106.2598, 28.8721], [106.3477, 28.5205], [105.9961, 28.7402], [105.6445, 28.4326], [105.9082, 28.125], [106.1719, 28.125], [106.3477, 27.8174], [105.6445, 27.6416], [105.5566, 27.7734], [105.293, 27.7295], [105.2051, 27.9932], [105.0293, 28.0811], [104.8535, 27.9053], [104.4141, 27.9492], [104.3262, 28.0371], [104.4141, 28.125], [104.4141, 28.2568], [104.2383, 28.4326], [104.4141, 28.6084], [103.8867, 28.6523], [103.7988, 28.3008], [103.4473, 28.125], [103.4473, 27.7734], [102.9199, 27.29], [103.0078, 26.3672], [102.6563, 26.1914], [102.5684, 26.3672], [102.1289, 26.1035], [101.8652, 26.0596], [101.6016, 26.2354], [101.6895, 26.3672], [101.4258, 26.5869], [101.4258, 26.8066], [101.4258, 26.7188], [101.1621, 27.0264], [101.1621, 27.1582], [100.7227, 27.8613], [100.3711, 27.8174], [100.2832, 27.7295], [100.0195, 28.125], [100.1953, 28.3447], [99.668, 28.8281], [99.4043, 28.5205], [99.4043, 28.1689], [99.2285, 28.3008], [99.1406, 29.2676], [98.9648, 30.7617], [98.6133, 31.2012], [98.877, 31.4209], [98.4375, 31.8604], [98.1738, 32.3438], [97.7344, 32.5195], [97.4707, 32.6953], [97.3828, 32.8711], [97.7344, 33.3984], [97.4707, 33.5742], [97.3828, 33.8818], [97.7344, 33.9258], [97.6465, 34.1016], [97.8223, 34.1895], [98.4375, 34.0576], [98.877, 33.1787], [99.2285, 33.0469], [99.2285, 32.915], [99.7559, 32.7393], [99.8438, 33.0029], [100.1074, 32.8711], [100.1074, 32.6514], [100.3711, 32.7393], [100.7227, 32.5195], [100.7227, 32.6514], [101.25, 32.6953], [101.1621, 33.2227], [101.6016, 33.1348], [101.7773, 33.2227], [101.6895, 33.3105], [101.7773, 33.5303]]] } }, { "type": "Feature", "properties": { "id": "23", "size": "700", "name": "黑龙江省", "cp": [126.1445, 48.7156], "childNum": 13 }, "geometry": { "type": "Polygon", "coordinates": [[[121.4648, 53.3496], [123.6621, 53.5693], [124.8926, 53.0859], [125.0684, 53.2178], [125.5957, 53.0859], [125.6836, 52.9102], [126.123, 52.7783], [126.0352, 52.6025], [126.2109, 52.5146], [126.3867, 52.2949], [126.3867, 52.207], [126.5625, 52.1631], [126.4746, 51.9434], [126.9141, 51.3721], [126.8262, 51.2842], [127.002, 51.3281], [126.9141, 51.1084], [127.2656, 50.7568], [127.3535, 50.2734], [127.6172, 50.2295], [127.5293, 49.8779], [127.793, 49.6143], [128.7598, 49.5703], [129.1113, 49.3506], [129.4629, 49.4385], [130.2539, 48.8672], [130.6934, 48.8672], [130.5176, 48.6475], [130.8691, 48.2959], [130.6934, 48.1201], [131.0449, 47.6807], [132.5391, 47.7246], [132.627, 47.9443], [133.0664, 48.1201], [133.5059, 48.1201], [134.209, 48.3838], [135.0879, 48.4277], [134.7363, 48.252], [134.5605, 47.9883], [134.7363, 47.6807], [134.5605, 47.4609], [134.3848, 47.4609], [134.209, 47.2852], [134.209, 47.1533], [133.8574, 46.5381], [133.9453, 46.2744], [133.5059, 45.835], [133.418, 45.5713], [133.2422, 45.5273], [133.0664, 45.1318], [132.8906, 45.0439], [131.9238, 45.3516], [131.5723, 45.0439], [131.0449, 44.8682], [131.3086, 44.0771], [131.2207, 43.7256], [131.3086, 43.4619], [130.8691, 43.418], [130.5176, 43.6377], [130.3418, 43.9893], [129.9902, 43.8574], [129.9023, 44.0332], [129.8145, 43.9014], [129.2871, 43.8135], [129.1992, 43.5938], [128.8477, 43.5498], [128.4961, 44.165], [128.4082, 44.4727], [128.0566, 44.3408], [128.0566, 44.1211], [127.7051, 44.1211], [127.5293, 44.6045], [127.0898, 44.6045], [127.002, 44.7803], [127.0898, 45], [126.9141, 45.1318], [126.5625, 45.2637], [126.0352, 45.1758], [125.7715, 45.3076], [125.6836, 45.5273], [125.0684, 45.3955], [124.8926, 45.5273], [124.3652, 45.4395], [124.0137, 45.7471], [123.9258, 46.2305], [123.2227, 46.2305], [123.0469, 46.582], [123.5742, 46.6699], [123.5742, 46.8896], [123.5742, 46.8457], [123.4863, 46.9775], [123.3984, 46.9775], [123.3984, 46.8896], [123.0469, 46.7139], [122.4316, 47.373], [124.2773, 48.5156], [124.4531, 48.1201], [124.8047, 49.1309], [125.2441, 49.1748], [125.1563, 49.834], [125.332, 50.1416], [125.7715, 50.5371], [125.7715, 50.7568], [126.0352, 51.0205], [125.332, 51.6357], [125.0684, 51.6357], [124.8926, 51.3721], [124.541, 51.3721], [124.3652, 51.2842], [123.6621, 51.3721], [123.3105, 51.2402], [122.959, 51.3281], [122.6074, 52.0752], [122.6953, 52.251], [122.168, 52.5146], [121.9922, 52.2949], [121.7285, 52.2949], [121.6406, 52.4268], [121.2012, 52.5586], [121.8164, 53.042], [121.4648, 53.3496]]] } }, { "type": "Feature", "properties": { "id": "62", "size": "690", "name": "甘肃省", "cp": [99.7129, 38.166], "childNum": 14 }, "geometry": { "type": "Polygon", "coordinates": [[[96.416, 42.7148], [97.207, 42.8027], [97.8223, 41.748], [97.8223, 41.6162], [97.4707, 41.4844], [98.3496, 40.9131], [98.3496, 40.5615], [98.6133, 40.6494], [98.5254, 40.7373], [98.7891, 40.6055], [98.9648, 40.7813], [99.0527, 40.6934], [99.2285, 40.8691], [99.9316, 41.001], [100.1953, 40.6494], [100.1074, 40.2539], [99.4922, 39.8584], [100.0195, 39.7705], [100.5469, 39.4189], [100.8105, 39.4189], [100.9863, 38.9355], [101.25, 39.0234], [101.3379, 38.7598], [101.7773, 38.6719], [102.041, 38.8916], [101.8652, 39.1113], [102.4805, 39.2432], [103.0078, 39.1113], [103.3594, 39.3311], [104.0625, 39.4189], [104.2383, 38.9795], [103.4473, 38.3643], [103.5352, 38.1445], [103.3594, 38.0127], [103.4473, 37.8369], [104.3262, 37.4414], [104.5898, 37.4414], [104.5898, 37.2217], [104.8535, 37.2217], [105.293, 36.8262], [105.2051, 36.6943], [105.4688, 36.123], [105.293, 35.9912], [105.3809, 35.7715], [105.7324, 35.7275], [105.8203, 35.5518], [105.9961, 35.4639], [105.9082, 35.4199], [105.9961, 35.4199], [106.084, 35.376], [106.2598, 35.4199], [106.3477, 35.2441], [106.5234, 35.332], [106.4355, 35.6836], [106.6992, 35.6836], [106.9629, 35.8154], [106.875, 36.123], [106.5234, 36.2549], [106.5234, 36.4746], [106.4355, 36.5625], [106.6113, 36.7822], [106.6113, 37.0898], [107.3145, 37.0898], [107.3145, 36.9141], [108.7207, 36.3428], [108.6328, 35.9912], [108.5449, 35.8594], [108.6328, 35.5518], [108.5449, 35.2881], [107.7539, 35.2881], [107.7539, 35.1123], [107.8418, 35.0244], [107.666, 34.9365], [107.2266, 34.8926], [106.9629, 35.0684], [106.6113, 35.0684], [106.5234, 34.7607], [106.3477, 34.585], [106.6992, 34.3213], [106.5234, 34.2773], [106.6113, 34.1455], [106.4355, 33.9258], [106.5234, 33.5303], [105.9961, 33.6182], [105.7324, 33.3984], [105.9961, 33.1787], [105.9082, 33.0029], [105.4688, 32.915], [105.3809, 32.8711], [105.3809, 32.7393], [105.2051, 32.6074], [104.4141, 32.7393], [104.3262, 32.8711], [104.4141, 33.0469], [104.3262, 33.2227], [104.4141, 33.3105], [104.2383, 33.3984], [104.1504, 33.6182], [103.1836, 33.7939], [103.0957, 34.1895], [102.9199, 34.3213], [102.2168, 33.9258], [102.4805, 33.4424], [101.8652, 33.0908], [101.9531, 33.4424], [101.8652, 33.5742], [101.7773, 33.5303], [101.6016, 33.5303], [101.5137, 33.7061], [101.25, 33.6621], [100.8105, 34.2773], [100.9863, 34.3652], [101.6895, 34.1016], [102.1289, 34.2773], [102.2168, 34.4092], [101.9531, 34.6289], [101.9531, 34.8486], [102.3926, 35.2002], [102.3047, 35.4199], [102.4805, 35.5957], [102.832, 35.5957], [102.6563, 35.7715], [102.9199, 35.9033], [102.9199, 36.0791], [103.0078, 36.2549], [102.832, 36.3428], [102.5684, 36.7383], [102.6563, 36.8262], [102.4805, 36.958], [102.5684, 37.1777], [102.1289, 37.4414], [101.9531, 37.7051], [101.7773, 37.6172], [101.5137, 37.8809], [101.1621, 37.8369], [100.7227, 38.2324], [100.459, 38.2764], [100.1074, 38.4961], [100.0195, 38.4521], [100.1953, 38.2764], [99.8438, 38.3643], [99.1406, 38.9355], [98.7891, 39.0674], [98.6133, 38.9355], [98.3496, 39.0234], [98.1738, 38.8037], [97.0313, 39.1992], [97.1191, 38.584], [96.6797, 38.4521], [96.6797, 38.1885], [96.416, 38.2324], [96.2402, 38.1006], [95.7129, 38.3643], [95.4492, 38.2764], [95.0098, 38.4082], [94.5703, 38.3643], [94.3066, 38.7598], [93.8672, 38.7158], [93.6914, 38.9355], [93.1641, 38.9795], [93.1641, 39.1992], [92.373, 39.1113], [92.373, 39.3311], [92.6367, 39.6387], [93.0762, 40.6494], [93.8672, 40.6934], [94.043, 41.0889], [94.5703, 41.4844], [95.1855, 41.792], [95.2734, 41.6162], [95.9766, 41.9238], [96.2402, 42.2314], [96.0645, 42.3193], [95.9766, 42.4951], [96.416, 42.7148]]] } }, { "type": "Feature", "properties": { "id": "53", "size": "1200", "name": "云南省", "cp": [101.0652, 25.1807], "childNum": 16 }, "geometry": { "type": "Polygon", "coordinates": [[[98.1738, 28.125], [98.2617, 28.3887], [98.3496, 28.125], [98.7012, 28.2129], [98.7891, 28.3447], [98.6133, 28.5205], [98.7012, 28.916], [98.7891, 29.0039], [98.7891, 28.8721], [98.9648, 28.8281], [98.9648, 29.1357], [99.1406, 29.2676], [99.2285, 28.3008], [99.4043, 28.1689], [99.4043, 28.5205], [99.668, 28.8281], [100.1953, 28.3447], [100.0195, 28.125], [100.2832, 27.7295], [100.3711, 27.8174], [100.7227, 27.8613], [101.1621, 27.1582], [101.1621, 27.0264], [101.4258, 26.7188], [101.4258, 26.8066], [101.4258, 26.5869], [101.6895, 26.3672], [101.6016, 26.2354], [101.8652, 26.0596], [102.1289, 26.1035], [102.5684, 26.3672], [102.6563, 26.1914], [103.0078, 26.3672], [102.9199, 27.29], [103.4473, 27.7734], [103.4473, 28.125], [103.7988, 28.3008], [103.8867, 28.6523], [104.4141, 28.6084], [104.2383, 28.4326], [104.4141, 28.2568], [104.4141, 28.125], [104.3262, 28.0371], [104.4141, 27.9492], [104.8535, 27.9053], [105.0293, 28.0811], [105.2051, 27.9932], [105.293, 27.7295], [105.2051, 27.3779], [104.5898, 27.334], [104.4141, 27.4658], [104.1504, 27.2461], [103.8867, 27.4219], [103.623, 27.0264], [103.7109, 26.9824], [103.7109, 26.7627], [103.8867, 26.543], [104.4141, 26.6748], [104.6777, 26.4111], [104.3262, 25.708], [104.8535, 25.2246], [104.5898, 25.0488], [104.6777, 24.9609], [104.502, 24.7412], [104.6777, 24.3457], [104.7656, 24.4775], [105.0293, 24.4336], [105.2051, 24.082], [105.4688, 24.0381], [105.5566, 24.126], [105.9961, 24.126], [106.1719, 23.8184], [106.1719, 23.5547], [105.6445, 23.4229], [105.5566, 23.2031], [105.293, 23.3789], [104.8535, 23.1592], [104.7656, 22.8516], [104.3262, 22.6758], [104.1504, 22.8076], [103.9746, 22.5439], [103.623, 22.7637], [103.5352, 22.5879], [103.3594, 22.8076], [103.0957, 22.4561], [102.4805, 22.7637], [102.3047, 22.4121], [101.8652, 22.3682], [101.7773, 22.5], [101.6016, 22.1924], [101.8652, 21.6211], [101.7773, 21.1377], [101.6016, 21.2256], [101.25, 21.1816], [101.1621, 21.7529], [100.6348, 21.4453], [100.1074, 21.4893], [99.9316, 22.0605], [99.2285, 22.1484], [99.4043, 22.5879], [99.3164, 22.7197], [99.4922, 23.0713], [98.877, 23.2031], [98.7012, 23.9502], [98.877, 24.126], [98.1738, 24.082], [97.7344, 23.8623], [97.5586, 23.9063], [97.7344, 24.126], [97.6465, 24.4336], [97.5586, 24.4336], [97.5586, 24.7412], [97.7344, 24.8291], [97.8223, 25.2686], [98.1738, 25.4004], [98.1738, 25.6201], [98.3496, 25.5762], [98.5254, 25.8398], [98.7012, 25.8838], [98.6133, 26.0596], [98.7012, 26.1475], [98.7891, 26.5869], [98.7012, 27.5098], [98.5254, 27.6416], [98.3496, 27.5098], [98.1738, 28.125]]] } }, { "type": "Feature", "properties": { "id": "45", "size": "1450", "name": "广西壮族自治区", "cp": [107.7813, 23.6426], "childNum": 14 }, "geometry": { "type": "Polygon", "coordinates": [[[104.502, 24.7412], [104.6777, 24.6094], [105.2051, 24.9609], [105.9961, 24.6533], [106.1719, 24.7852], [106.1719, 24.9609], [106.875, 25.1807], [107.0508, 25.2686], [106.9629, 25.4883], [107.2266, 25.6201], [107.4902, 25.2246], [107.7539, 25.2246], [107.8418, 25.1367], [108.1055, 25.2246], [108.1934, 25.4443], [108.3691, 25.5322], [108.6328, 25.3125], [108.6328, 25.5762], [109.0723, 25.5322], [108.9844, 25.752], [109.3359, 25.708], [109.5117, 26.0156], [109.7754, 25.8838], [109.9512, 26.1914], [110.2148, 25.9717], [110.5664, 26.3232], [111.1816, 26.3232], [111.2695, 26.2354], [111.2695, 25.8838], [111.4453, 25.8398], [111.0059, 25.0049], [111.0938, 24.9609], [111.3574, 25.1367], [111.5332, 24.6533], [111.709, 24.7852], [112.0605, 24.7412], [111.8848, 24.6533], [112.0605, 24.3457], [111.8848, 24.2139], [111.8848, 23.9941], [111.7969, 23.8184], [111.6211, 23.8184], [111.6211, 23.6865], [111.3574, 23.4668], [111.4453, 23.0273], [111.2695, 22.8076], [110.7422, 22.5439], [110.7422, 22.2803], [110.6543, 22.1484], [110.3027, 22.1484], [110.3027, 21.8848], [109.9512, 21.8408], [109.8633, 21.665], [109.7754, 21.6211], [109.7754, 21.4014], [109.5996, 21.4453], [109.1602, 21.3574], [109.248, 20.874], [109.0723, 20.9619], [109.0723, 21.5332], [108.7207, 21.5332], [108.6328, 21.665], [108.2813, 21.4893], [107.8418, 21.6211], [107.4023, 21.6211], [107.0508, 21.7969], [107.0508, 21.9287], [106.6992, 22.0166], [106.6113, 22.4121], [106.7871, 22.7637], [106.6992, 22.8955], [105.9082, 22.9395], [105.5566, 23.0713], [105.5566, 23.2031], [105.6445, 23.4229], [106.1719, 23.5547], [106.1719, 23.8184], [105.9961, 24.126], [105.5566, 24.126], [105.4688, 24.0381], [105.2051, 24.082], [105.0293, 24.4336], [104.7656, 24.4775], [104.6777, 24.3457], [104.502, 24.7412]]] } }, { "type": "Feature", "properties": { "id": "43", "size": "1700", "name": "湖南省", "cp": [111.5332, 27.3779], "childNum": 14 }, "geometry": { "type": "Polygon", "coordinates": [[[109.248, 28.4766], [109.248, 29.1357], [109.5117, 29.6191], [109.6875, 29.6191], [109.7754, 29.751], [110.4785, 29.6631], [110.6543, 29.751], [110.4785, 30.0146], [110.8301, 30.1465], [111.7969, 29.9268], [112.2363, 29.5313], [112.5, 29.6191], [112.6758, 29.5752], [112.9395, 29.7949], [113.0273, 29.751], [112.9395, 29.4873], [113.0273, 29.4434], [113.5547, 29.8389], [113.5547, 29.707], [113.7305, 29.5752], [113.6426, 29.3115], [113.7305, 29.0918], [113.9063, 29.0479], [114.1699, 28.8281], [114.082, 28.5645], [114.2578, 28.3447], [113.7305, 27.9492], [113.6426, 27.5977], [113.6426, 27.3779], [113.8184, 27.29], [113.7305, 27.1143], [113.9063, 26.9385], [113.9063, 26.6309], [114.082, 26.5869], [113.9941, 26.1914], [114.2578, 26.1475], [113.9941, 26.0596], [113.9063, 25.4443], [113.6426, 25.3125], [113.2031, 25.5322], [112.8516, 25.3564], [113.0273, 25.2246], [113.0273, 24.9609], [112.8516, 24.917], [112.5879, 25.1367], [112.2363, 25.1807], [112.1484, 24.873], [112.0605, 24.7412], [111.709, 24.7852], [111.5332, 24.6533], [111.3574, 25.1367], [111.0938, 24.9609], [111.0059, 25.0049], [111.4453, 25.8398], [111.2695, 25.8838], [111.2695, 26.2354], [111.1816, 26.3232], [110.5664, 26.3232], [110.2148, 25.9717], [109.9512, 26.1914], [109.7754, 25.8838], [109.5117, 26.0156], [109.4238, 26.2793], [109.248, 26.3232], [109.4238, 26.5869], [109.3359, 26.7188], [109.5117, 26.8066], [109.5117, 27.0264], [109.3359, 27.1582], [108.8965, 27.0264], [108.8086, 27.1143], [109.4238, 27.5977], [109.3359, 27.9053], [109.3359, 28.2568], [109.248, 28.4766]]] } }, { "type": "Feature", "properties": { "id": "61", "size": "1150", "name": "陕西省", "cp": [109.5996, 35.7396], "childNum": 10 }, "geometry": { "type": "Polygon", "coordinates": [[[105.4688, 32.915], [105.9082, 33.0029], [105.9961, 33.1787], [105.7324, 33.3984], [105.9961, 33.6182], [106.5234, 33.5303], [106.4355, 33.9258], [106.6113, 34.1455], [106.5234, 34.2773], [106.6992, 34.3213], [106.3477, 34.585], [106.5234, 34.7607], [106.6113, 35.0684], [106.9629, 35.0684], [107.2266, 34.8926], [107.666, 34.9365], [107.8418, 35.0244], [107.7539, 35.1123], [107.7539, 35.2881], [108.5449, 35.2881], [108.6328, 35.5518], [108.5449, 35.8594], [108.6328, 35.9912], [108.7207, 36.3428], [107.3145, 36.9141], [107.3145, 37.0898], [107.3145, 37.6172], [107.666, 37.8809], [108.1934, 37.6172], [108.7207, 37.7051], [108.8086, 38.0127], [108.8965, 37.9688], [109.0723, 38.0127], [108.9844, 38.3203], [109.9512, 39.1553], [109.8633, 39.2432], [110.2148, 39.2871], [110.127, 39.4629], [110.6543, 39.2871], [111.0938, 39.5947], [111.0938, 39.375], [111.1816, 39.2432], [110.918, 38.7158], [110.8301, 38.4961], [110.4785, 38.1885], [110.4785, 37.9688], [110.8301, 37.6611], [110.3906, 37.002], [110.4785, 36.123], [110.5664, 35.6396], [110.2148, 34.8926], [110.2148, 34.6729], [110.3906, 34.585], [110.4785, 34.2334], [110.6543, 34.1455], [110.6543, 33.8379], [111.0059, 33.5303], [111.0059, 33.2666], [110.7422, 33.1348], [110.5664, 33.2666], [110.3027, 33.1787], [109.5996, 33.2666], [109.4238, 33.1348], [109.7754, 33.0469], [109.7754, 32.915], [110.127, 32.7393], [110.127, 32.6074], [109.6875, 32.6074], [109.5117, 32.4316], [109.5996, 31.7285], [109.248, 31.7285], [109.0723, 31.9482], [108.5449, 32.2119], [108.2813, 32.2559], [108.0176, 32.168], [107.4023, 32.5195], [107.2266, 32.4316], [107.1387, 32.4756], [107.0508, 32.6953], [106.3477, 32.6514], [106.084, 32.7393], [106.084, 32.8711], [105.5566, 32.7393], [105.4688, 32.915]]] } }, { "type": "Feature", "properties": { "id": "44", "size": "1600", "name": "广东省", "cp": [113.4668, 22.8076], "childNum": 21 }, "geometry": { "type": "Polygon", "coordinates": [[[109.7754, 21.4014], [109.7754, 21.6211], [109.8633, 21.665], [109.9512, 21.8408], [110.3027, 21.8848], [110.3027, 22.1484], [110.6543, 22.1484], [110.7422, 22.2803], [110.7422, 22.5439], [111.2695, 22.8076], [111.4453, 23.0273], [111.3574, 23.4668], [111.6211, 23.6865], [111.6211, 23.8184], [111.7969, 23.8184], [111.8848, 23.9941], [111.8848, 24.2139], [112.0605, 24.3457], [111.8848, 24.6533], [112.0605, 24.7412], [112.1484, 24.873], [112.2363, 25.1807], [112.5879, 25.1367], [112.8516, 24.917], [113.0273, 24.9609], [113.0273, 25.2246], [112.8516, 25.3564], [113.2031, 25.5322], [113.6426, 25.3125], [113.9063, 25.4443], [113.9941, 25.2686], [114.6094, 25.4004], [114.7852, 25.2686], [114.6973, 25.1367], [114.4336, 24.9609], [114.1699, 24.6973], [114.4336, 24.5215], [115.4004, 24.7852], [115.8398, 24.5654], [115.752, 24.7852], [115.9277, 24.917], [116.2793, 24.7852], [116.3672, 24.873], [116.543, 24.6094], [116.7188, 24.6533], [116.9824, 24.1699], [116.9824, 23.9063], [117.1582, 23.5547], [117.334, 23.2471], [116.8945, 23.3789], [116.6309, 23.1152], [116.543, 22.8516], [115.9277, 22.7197], [115.6641, 22.7637], [115.5762, 22.6318], [115.0488, 22.6758], [114.6094, 22.3682], [114.3457, 22.5439], [113.9941, 22.5], [113.8184, 22.1924], [114.3457, 22.1484], [114.4336, 22.0166], [114.082, 21.9287], [113.9941, 21.7969], [113.5547, 22.0166], [113.1152, 21.8408], [112.9395, 21.5771], [112.4121, 21.4453], [112.2363, 21.5332], [111.5332, 21.4893], [111.2695, 21.3574], [110.7422, 21.3574], [110.6543, 21.2256], [110.7422, 20.918], [110.4785, 20.874], [110.6543, 20.2588], [110.5664, 20.2588], [110.3906, 20.127], [110.0391, 20.127], [109.8633, 20.127], [109.8633, 20.3027], [109.5996, 20.918], [109.7754, 21.4014], [109.7754, 21.4014]], [[113.5986, 22.1649], [113.6096, 22.1265], [113.5547, 22.11], [113.5437, 22.2034], [113.5767, 22.2034], [113.5986, 22.1649]]] } }, { "type": "Feature", "properties": { "id": "22", "size": "1120", "name": "吉林省", "cp": [125.7746, 43.5938], "childNum": 9 }, "geometry": { "type": "Polygon", "coordinates": [[[123.2227, 46.2305], [123.9258, 46.2305], [124.0137, 45.7471], [124.3652, 45.4395], [124.8926, 45.5273], [125.0684, 45.3955], [125.6836, 45.5273], [125.7715, 45.3076], [126.0352, 45.1758], [126.5625, 45.2637], [126.9141, 45.1318], [127.0898, 45], [127.002, 44.7803], [127.0898, 44.6045], [127.5293, 44.6045], [127.7051, 44.1211], [128.0566, 44.1211], [128.0566, 44.3408], [128.4082, 44.4727], [128.4961, 44.165], [128.8477, 43.5498], [129.1992, 43.5938], [129.2871, 43.8135], [129.8145, 43.9014], [129.9023, 44.0332], [129.9902, 43.8574], [130.3418, 43.9893], [130.5176, 43.6377], [130.8691, 43.418], [131.3086, 43.4619], [131.3086, 43.3301], [131.1328, 42.9346], [130.4297, 42.7148], [130.6055, 42.6709], [130.6055, 42.4512], [130.2539, 42.7588], [130.2539, 42.8906], [130.166, 42.9785], [129.9023, 43.0225], [129.7266, 42.4951], [129.375, 42.4512], [128.9355, 42.0117], [128.0566, 42.0117], [128.3203, 41.5723], [128.1445, 41.3525], [127.0898, 41.5283], [127.1777, 41.5723], [126.9141, 41.792], [126.6504, 41.6602], [126.4746, 41.3965], [126.123, 40.957], [125.6836, 40.8691], [125.5957, 40.9131], [125.7715, 41.2207], [125.332, 41.6602], [125.332, 41.9678], [125.4199, 42.0996], [125.332, 42.1436], [124.8926, 42.8027], [124.8926, 43.0664], [124.7168, 43.0664], [124.4531, 42.8467], [124.2773, 43.2422], [123.8379, 43.4619], [123.6621, 43.374], [123.3105, 43.5059], [123.4863, 43.7256], [123.1348, 44.4727], [122.3438, 44.2529], [122.0801, 44.8682], [122.2559, 45.2637], [121.9043, 45.7031], [121.7285, 45.7471], [121.8164, 46.0107], [122.2559, 45.791], [122.4316, 45.8789], [122.6953, 45.7031], [122.7832, 46.0107], [123.2227, 46.2305]]] } }, { "type": "Feature", "properties": { "id": "13", "size": "1300", "name": "河北省", "cp": [115.4004, 39.4688], "childNum": 11 }, "geometry": { "type": "MultiPolygon", "coordinates": [[[[114.5215, 39.5068], [114.3457, 39.8584], [113.9941, 39.9902], [114.5215, 40.3418], [114.3457, 40.3857], [114.2578, 40.6055], [114.082, 40.7373], [113.9063, 41.1328], [113.9941, 41.2207], [113.9063, 41.4404], [114.2578, 41.5723], [114.1699, 41.792], [114.5215, 42.1436], [114.873, 42.0996], [114.9609, 41.6162], [115.2246, 41.5723], [115.9277, 41.9238], [116.0156, 41.792], [116.2793, 42.0117], [116.8066, 42.0117], [116.8945, 42.4072], [117.334, 42.4512], [117.5098, 42.583], [117.7734, 42.627], [118.0371, 42.4072], [117.9492, 42.2314], [118.125, 42.0557], [118.3008, 42.0996], [118.3008, 41.792], [118.125, 41.748], [118.3887, 41.3086], [119.2676, 41.3086], [118.8281, 40.8252], [119.2676, 40.5176], [119.5313, 40.5615], [119.707, 40.1221], [119.8828, 39.9463], [119.5313, 39.6826], [119.4434, 39.4189], [118.916, 39.0674], [118.4766, 38.9355], [118.125, 39.0234], [118.0371, 39.1992], [118.0371, 39.2432], [117.8613, 39.4189], [117.9492, 39.5947], [117.6855, 39.5947], [117.5098, 39.7705], [117.5098, 39.9902], [117.6855, 39.9902], [117.6855, 40.0781], [117.4219, 40.21], [117.2461, 40.5176], [117.4219, 40.6494], [116.9824, 40.6934], [116.6309, 41.0449], [116.3672, 40.9131], [116.4551, 40.7813], [116.1914, 40.7813], [116.1035, 40.6055], [115.752, 40.5615], [115.9277, 40.2539], [115.4004, 39.9463], [115.4883, 39.6387], [115.752, 39.5068], [116.1914, 39.5947], [116.3672, 39.4629], [116.543, 39.5947], [116.8066, 39.5947], [116.8945, 39.1113], [116.7188, 38.9355], [116.7188, 38.8037], [117.2461, 38.54], [117.5977, 38.6279], [117.9492, 38.3203], [117.4219, 37.8369], [116.8066, 37.8369], [116.4551, 37.4854], [116.2793, 37.5732], [116.2793, 37.3535], [116.0156, 37.3535], [115.752, 36.9141], [115.3125, 36.5186], [115.4883, 36.167], [115.3125, 36.0791], [115.1367, 36.2109], [114.9609, 36.0791], [114.873, 36.123], [113.7305, 36.3428], [113.4668, 36.6504], [113.7305, 36.8701], [113.7305, 37.1338], [114.1699, 37.6611], [113.9941, 37.7051], [113.8184, 38.1445], [113.5547, 38.2764], [113.5547, 38.54], [113.8184, 38.8037], [113.8184, 38.9355], [113.9063, 39.0234], [114.3457, 39.0674], [114.5215, 39.5068]]], [[[117.2461, 40.0781], [117.1582, 39.8145], [117.1582, 39.6387], [116.8945, 39.6826], [116.8945, 39.8145], [116.8066, 39.9902], [117.2461, 40.0781]]]] } }, { "type": "Feature", "properties": { "id": "42", "size": "1500", "name": "湖北省", "cp": [112.2363, 31.1572], "childNum": 17 }, "geometry": { "type": "Polygon", "coordinates": [[[110.2148, 31.1572], [110.127, 31.377], [109.6875, 31.5527], [109.7754, 31.6846], [109.5996, 31.7285], [109.5117, 32.4316], [109.6875, 32.6074], [110.127, 32.6074], [110.127, 32.7393], [109.7754, 32.915], [109.7754, 33.0469], [109.4238, 33.1348], [109.5996, 33.2666], [110.3027, 33.1787], [110.5664, 33.2666], [110.7422, 33.1348], [111.0059, 33.2666], [111.5332, 32.6074], [112.3242, 32.3438], [113.2031, 32.4316], [113.4668, 32.2998], [113.7305, 32.4316], [113.8184, 31.8604], [113.9941, 31.7725], [114.1699, 31.8604], [114.5215, 31.7725], [114.6094, 31.5527], [114.7852, 31.4648], [115.1367, 31.5967], [115.2246, 31.4209], [115.4004, 31.4209], [115.5762, 31.2012], [116.0156, 31.0254], [115.752, 30.6738], [116.1035, 30.1904], [116.1035, 29.8389], [115.9277, 29.707], [115.4883, 29.7949], [114.873, 29.3994], [114.2578, 29.3555], [113.9063, 29.0479], [113.7305, 29.0918], [113.6426, 29.3115], [113.7305, 29.5752], [113.5547, 29.707], [113.5547, 29.8389], [113.0273, 29.4434], [112.9395, 29.4873], [113.0273, 29.751], [112.9395, 29.7949], [112.6758, 29.5752], [112.5, 29.6191], [112.2363, 29.5313], [111.7969, 29.9268], [110.8301, 30.1465], [110.4785, 30.0146], [110.6543, 29.751], [110.4785, 29.6631], [109.7754, 29.751], [109.6875, 29.6191], [109.5117, 29.6191], [109.248, 29.1357], [109.0723, 29.3555], [108.9844, 29.3115], [108.6328, 29.8389], [108.457, 29.7949], [108.5449, 30.2344], [108.457, 30.4102], [108.6328, 30.5859], [108.8086, 30.498], [109.0723, 30.6299], [109.1602, 30.542], [109.248, 30.6299], [109.4238, 30.542], [109.8633, 30.8936], [110.0391, 30.8057], [110.2148, 31.1572]]] } }, { "type": "Feature", "properties": { "id": "52", "size": "2000", "name": "贵州省", "cp": [106.6113, 26.9385], "childNum": 9 }, "geometry": { "type": "Polygon", "coordinates": [[[104.1504, 27.2461], [104.4141, 27.4658], [104.5898, 27.334], [105.2051, 27.3779], [105.293, 27.7295], [105.5566, 27.7734], [105.6445, 27.6416], [106.3477, 27.8174], [106.1719, 28.125], [105.9082, 28.125], [105.6445, 28.4326], [105.9961, 28.7402], [106.3477, 28.5205], [106.5234, 28.5645], [106.4355, 28.7842], [106.5234, 28.7842], [106.6113, 28.6523], [106.6113, 28.5205], [106.6992, 28.4766], [106.875, 28.7842], [107.4023, 28.8721], [107.4023, 29.1797], [107.5781, 29.2236], [107.8418, 29.1357], [107.8418, 29.0039], [108.2813, 29.0918], [108.3691, 28.6523], [108.5449, 28.6523], [108.5449, 28.3887], [108.7207, 28.4766], [108.7207, 28.2129], [109.0723, 28.2129], [109.248, 28.4766], [109.3359, 28.2568], [109.3359, 27.9053], [109.4238, 27.5977], [108.8086, 27.1143], [108.8965, 27.0264], [109.3359, 27.1582], [109.5117, 27.0264], [109.5117, 26.8066], [109.3359, 26.7188], [109.4238, 26.5869], [109.248, 26.3232], [109.4238, 26.2793], [109.5117, 26.0156], [109.3359, 25.708], [108.9844, 25.752], [109.0723, 25.5322], [108.6328, 25.5762], [108.6328, 25.3125], [108.3691, 25.5322], [108.1934, 25.4443], [108.1055, 25.2246], [107.8418, 25.1367], [107.7539, 25.2246], [107.4902, 25.2246], [107.2266, 25.6201], [106.9629, 25.4883], [107.0508, 25.2686], [106.875, 25.1807], [106.1719, 24.9609], [106.1719, 24.7852], [105.9961, 24.6533], [105.2051, 24.9609], [104.6777, 24.6094], [104.502, 24.7412], [104.6777, 24.9609], [104.5898, 25.0488], [104.8535, 25.2246], [104.3262, 25.708], [104.6777, 26.4111], [104.4141, 26.6748], [103.8867, 26.543], [103.7109, 26.7627], [103.7109, 26.9824], [103.623, 27.0264], [103.8867, 27.4219], [104.1504, 27.2461]]] } }, { "type": "Feature", "properties": { "id": "37", "size": "1500", "name": "山东省", "cp": [118.7402, 36.4307], "childNum": 17 }, "geometry": { "type": "Polygon", "coordinates": [[[115.4883, 36.167], [115.3125, 36.5186], [115.752, 36.9141], [116.0156, 37.3535], [116.2793, 37.3535], [116.2793, 37.5732], [116.4551, 37.4854], [116.8066, 37.8369], [117.4219, 37.8369], [117.9492, 38.3203], [118.125, 38.1445], [118.916, 38.1445], [119.3555, 37.6611], [119.0039, 37.5293], [119.0039, 37.3535], [119.3555, 37.1338], [119.707, 37.1338], [119.8828, 37.3975], [120.498, 37.8369], [120.5859, 38.1445], [120.9375, 38.4521], [121.0254, 37.8369], [121.2012, 37.6611], [121.9043, 37.4854], [122.168, 37.6172], [122.2559, 37.4854], [122.6074, 37.4854], [122.6953, 37.3535], [122.6074, 36.9141], [122.4316, 36.7822], [121.8164, 36.8701], [121.7285, 36.6943], [121.1133, 36.6064], [121.1133, 36.4307], [121.377, 36.2549], [120.7617, 36.167], [120.9375, 35.8594], [120.6738, 36.0352], [119.707, 35.4639], [119.9707, 34.9805], [119.3555, 35.0244], [119.2676, 35.1123], [118.916, 35.0244], [118.7402, 34.7168], [118.4766, 34.6729], [118.3887, 34.4092], [118.2129, 34.4092], [118.125, 34.6289], [117.9492, 34.6729], [117.5977, 34.4531], [117.334, 34.585], [117.2461, 34.4531], [116.8066, 34.9365], [116.4551, 34.8926], [116.3672, 34.6289], [116.1914, 34.585], [115.5762, 34.585], [115.4004, 34.8486], [114.7852, 35.0684], [115.0488, 35.376], [115.2246, 35.4199], [115.4883, 35.7275], [116.1035, 36.0791], [115.3125, 35.8154], [115.4883, 36.167]]] } }, { "type": "Feature", "properties": { "id": "36", "size": "1700", "name": "江西省", "cp": [116.0156, 27.29], "childNum": 11 }, "geometry": { "type": "Polygon", "coordinates": [[[114.2578, 28.3447], [114.082, 28.5645], [114.1699, 28.8281], [113.9063, 29.0479], [114.2578, 29.3555], [114.873, 29.3994], [115.4883, 29.7949], [115.9277, 29.707], [116.1035, 29.8389], [116.2793, 29.7949], [116.7188, 30.0586], [116.8945, 29.9268], [116.7188, 29.751], [116.7188, 29.6191], [117.1582, 29.707], [117.0703, 29.8389], [117.1582, 29.9268], [117.5098, 29.6191], [118.0371, 29.5752], [118.2129, 29.3994], [118.0371, 29.1797], [118.0371, 29.0479], [118.3887, 28.7842], [118.4766, 28.3447], [118.4766, 28.3008], [118.3008, 28.0811], [117.7734, 27.8174], [117.5098, 27.9932], [116.9824, 27.6416], [117.1582, 27.29], [117.0703, 27.1143], [116.543, 26.8066], [116.6309, 26.4551], [116.3672, 26.2354], [116.4551, 26.1035], [116.1914, 25.8838], [116.0156, 25.2686], [115.8398, 25.2246], [115.9277, 24.917], [115.752, 24.7852], [115.8398, 24.5654], [115.4004, 24.7852], [114.4336, 24.5215], [114.1699, 24.6973], [114.4336, 24.9609], [114.6973, 25.1367], [114.7852, 25.2686], [114.6094, 25.4004], [113.9941, 25.2686], [113.9063, 25.4443], [113.9941, 26.0596], [114.2578, 26.1475], [113.9941, 26.1914], [114.082, 26.5869], [113.9063, 26.6309], [113.9063, 26.9385], [113.7305, 27.1143], [113.8184, 27.29], [113.6426, 27.3779], [113.6426, 27.5977], [113.7305, 27.9492], [114.2578, 28.3447]]] } }, { "type": "Feature", "properties": { "id": "41", "size": "1700", "name": "河南省", "cp": [113.0668, 33.8818], "childNum": 17 }, "geometry": { "type": "Polygon", "coordinates": [[[110.3906, 34.585], [110.8301, 34.6289], [111.1816, 34.8047], [111.5332, 34.8486], [111.7969, 35.0684], [112.0605, 35.0684], [112.0605, 35.2881], [112.7637, 35.2002], [113.1152, 35.332], [113.6426, 35.6836], [113.7305, 36.3428], [114.873, 36.123], [114.9609, 36.0791], [115.1367, 36.2109], [115.3125, 36.0791], [115.4883, 36.167], [115.3125, 35.8154], [116.1035, 36.0791], [115.4883, 35.7275], [115.2246, 35.4199], [115.0488, 35.376], [114.7852, 35.0684], [115.4004, 34.8486], [115.5762, 34.585], [116.1914, 34.585], [116.1914, 34.4092], [116.543, 34.2773], [116.6309, 33.9258], [116.1914, 33.7061], [116.0156, 33.9697], [115.6641, 34.0576], [115.5762, 33.9258], [115.5762, 33.6621], [115.4004, 33.5303], [115.3125, 33.1787], [114.873, 33.1348], [114.873, 33.0029], [115.1367, 32.8711], [115.2246, 32.6074], [115.5762, 32.4316], [115.8398, 32.5195], [115.9277, 31.7725], [115.4883, 31.6846], [115.4004, 31.4209], [115.2246, 31.4209], [115.1367, 31.5967], [114.7852, 31.4648], [114.6094, 31.5527], [114.5215, 31.7725], [114.1699, 31.8604], [113.9941, 31.7725], [113.8184, 31.8604], [113.7305, 32.4316], [113.4668, 32.2998], [113.2031, 32.4316], [112.3242, 32.3438], [111.5332, 32.6074], [111.0059, 33.2666], [111.0059, 33.5303], [110.6543, 33.8379], [110.6543, 34.1455], [110.4785, 34.2334], [110.3906, 34.585]]] } }, { "type": "Feature", "properties": { "id": "21", "size": "1500", "name": "辽宁省", "cp": [122.0438, 41.0889], "childNum": 14 }, "geometry": { "type": "Polygon", "coordinates": [[[119.2676, 41.3086], [119.4434, 41.6162], [119.2676, 41.7041], [119.3555, 42.2754], [119.5313, 42.3633], [119.8828, 42.1875], [120.1465, 41.7041], [120.498, 42.0996], [121.4648, 42.4951], [121.7285, 42.4512], [121.9922, 42.7148], [122.3438, 42.6709], [122.3438, 42.8467], [122.7832, 42.7148], [123.1348, 42.8027], [123.3105, 42.9785], [123.5742, 43.0225], [123.6621, 43.374], [123.8379, 43.4619], [124.2773, 43.2422], [124.4531, 42.8467], [124.7168, 43.0664], [124.8926, 43.0664], [124.8926, 42.8027], [125.332, 42.1436], [125.4199, 42.0996], [125.332, 41.9678], [125.332, 41.6602], [125.7715, 41.2207], [125.5957, 40.9131], [125.6836, 40.8691], [124.541, 40.21], [124.1016, 39.6826], [123.3984, 39.6826], [123.1348, 39.4189], [123.1348, 39.0234], [122.0801, 39.0234], [121.5527, 38.7158], [121.1133, 38.6719], [120.9375, 38.9795], [121.377, 39.1992], [121.2012, 39.5508], [122.0801, 40.3857], [121.9922, 40.6934], [121.7285, 40.8252], [121.2012, 40.8252], [120.5859, 40.21], [119.8828, 39.9463], [119.707, 40.1221], [119.5313, 40.5615], [119.2676, 40.5176], [118.8281, 40.8252], [119.2676, 41.3086]]] } }, { "type": "Feature", "properties": { "id": "14", "size": "1450", "name": "山西省", "cp": [112.4121, 37.6611], "childNum": 11 }, "geometry": { "type": "Polygon", "coordinates": [[[110.918, 38.7158], [111.1816, 39.2432], [111.0938, 39.375], [111.3574, 39.4189], [111.4453, 39.6387], [111.9727, 39.5947], [112.3242, 40.2539], [112.7637, 40.166], [113.2031, 40.3857], [113.5547, 40.3418], [113.8184, 40.5176], [114.082, 40.5176], [114.082, 40.7373], [114.2578, 40.6055], [114.3457, 40.3857], [114.5215, 40.3418], [113.9941, 39.9902], [114.3457, 39.8584], [114.5215, 39.5068], [114.3457, 39.0674], [113.9063, 39.0234], [113.8184, 38.9355], [113.8184, 38.8037], [113.5547, 38.54], [113.5547, 38.2764], [113.8184, 38.1445], [113.9941, 37.7051], [114.1699, 37.6611], [113.7305, 37.1338], [113.7305, 36.8701], [113.4668, 36.6504], [113.7305, 36.3428], [113.6426, 35.6836], [113.1152, 35.332], [112.7637, 35.2002], [112.0605, 35.2881], [112.0605, 35.0684], [111.7969, 35.0684], [111.5332, 34.8486], [111.1816, 34.8047], [110.8301, 34.6289], [110.3906, 34.585], [110.2148, 34.6729], [110.2148, 34.8926], [110.5664, 35.6396], [110.4785, 36.123], [110.3906, 37.002], [110.8301, 37.6611], [110.4785, 37.9688], [110.4785, 38.1885], [110.8301, 38.4961], [110.918, 38.7158]]] } }, { "type": "Feature", "properties": { "id": "34", "size": "1700", "name": "安徽省", "cp": [117.2461, 32.0361], "childNum": 17 }, "geometry": { "type": "Polygon", "coordinates": [[[116.6309, 33.9258], [116.543, 34.2773], [116.1914, 34.4092], [116.1914, 34.585], [116.3672, 34.6289], [116.8945, 34.4092], [117.1582, 34.0576], [117.5977, 34.0137], [117.7734, 33.7061], [118.125, 33.75], [117.9492, 33.2227], [118.0371, 33.1348], [118.2129, 33.2227], [118.3008, 32.7832], [118.7402, 32.7393], [118.916, 32.959], [119.1797, 32.8271], [119.1797, 32.4756], [118.5645, 32.5635], [118.6523, 32.2119], [118.4766, 32.168], [118.3887, 31.9482], [118.916, 31.5527], [118.7402, 31.377], [118.8281, 31.2451], [119.3555, 31.2891], [119.4434, 31.1572], [119.6191, 31.1133], [119.6191, 31.0693], [119.4434, 30.6738], [119.2676, 30.6299], [119.3555, 30.4102], [118.916, 30.3223], [118.916, 29.9707], [118.7402, 29.707], [118.2129, 29.3994], [118.0371, 29.5752], [117.5098, 29.6191], [117.1582, 29.9268], [117.0703, 29.8389], [117.1582, 29.707], [116.7188, 29.6191], [116.7188, 29.751], [116.8945, 29.9268], [116.7188, 30.0586], [116.2793, 29.7949], [116.1035, 29.8389], [116.1035, 30.1904], [115.752, 30.6738], [116.0156, 31.0254], [115.5762, 31.2012], [115.4004, 31.4209], [115.4883, 31.6846], [115.9277, 31.7725], [115.8398, 32.5195], [115.5762, 32.4316], [115.2246, 32.6074], [115.1367, 32.8711], [114.873, 33.0029], [114.873, 33.1348], [115.3125, 33.1787], [115.4004, 33.5303], [115.5762, 33.6621], [115.5762, 33.9258], [115.6641, 34.0576], [116.0156, 33.9697], [116.1914, 33.7061], [116.6309, 33.9258]]] } }, { "type": "Feature", "properties": { "id": "35", "size": "2000", "name": "福建省", "cp": [118.3008, 25.9277], "childNum": 9 }, "geometry": { "type": "Polygon", "coordinates": [[[118.4766, 28.3008], [118.8281, 28.2568], [118.7402, 28.0371], [118.916, 27.4658], [119.2676, 27.4219], [119.6191, 27.6855], [119.7949, 27.29], [120.2344, 27.4219], [120.4102, 27.1582], [120.7617, 27.0264], [120.6738, 26.8945], [120.2344, 26.8506], [120.2344, 26.7188], [120.4102, 26.6748], [120.498, 26.3672], [120.2344, 26.2793], [120.4102, 26.1475], [120.0586, 26.1914], [119.9707, 25.9277], [119.7949, 25.9277], [119.9707, 25.4004], [119.7949, 25.2686], [119.5313, 25.1367], [119.4434, 25.0049], [119.2676, 25.0928], [118.916, 24.8291], [118.6523, 24.5215], [118.4766, 24.5215], [118.4766, 24.4336], [118.2129, 24.3457], [118.2129, 24.1699], [117.8613, 23.9941], [117.7734, 23.7744], [117.5098, 23.5986], [117.1582, 23.5547], [116.9824, 23.9063], [116.9824, 24.1699], [116.7188, 24.6533], [116.543, 24.6094], [116.3672, 24.873], [116.2793, 24.7852], [115.9277, 24.917], [115.8398, 25.2246], [116.0156, 25.2686], [116.1914, 25.8838], [116.4551, 26.1035], [116.3672, 26.2354], [116.6309, 26.4551], [116.543, 26.8066], [117.0703, 27.1143], [117.1582, 27.29], [116.9824, 27.6416], [117.5098, 27.9932], [117.7734, 27.8174], [118.3008, 28.0811], [118.4766, 28.3008]]] } }, { "type": "Feature", "properties": { "id": "33", "size": "2100", "name": "浙江省", "cp": [120.498, 29.0918], "childNum": 11 }, "geometry": { "type": "Polygon", "coordinates": [[[118.2129, 29.3994], [118.7402, 29.707], [118.916, 29.9707], [118.916, 30.3223], [119.3555, 30.4102], [119.2676, 30.6299], [119.4434, 30.6738], [119.6191, 31.0693], [119.6191, 31.1133], [119.9707, 31.1572], [120.498, 30.8057], [120.9375, 31.0254], [121.2891, 30.6738], [121.9922, 30.8057], [122.6953, 30.8936], [122.8711, 30.7178], [122.959, 30.1465], [122.6074, 30.1025], [122.6074, 29.9268], [122.168, 29.5313], [122.3438, 28.8721], [121.9922, 28.8721], [121.9922, 28.4326], [121.7285, 28.3447], [121.7285, 28.2129], [121.4648, 28.2129], [121.5527, 28.0371], [121.2891, 27.9492], [121.1133, 27.4219], [120.6738, 27.334], [120.6738, 27.1582], [120.9375, 27.0264], [120.7617, 27.0264], [120.4102, 27.1582], [120.2344, 27.4219], [119.7949, 27.29], [119.6191, 27.6855], [119.2676, 27.4219], [118.916, 27.4658], [118.7402, 28.0371], [118.8281, 28.2568], [118.4766, 28.3008], [118.4766, 28.3447], [118.3887, 28.7842], [118.0371, 29.0479], [118.0371, 29.1797], [118.2129, 29.3994]]] } }, { "type": "Feature", "properties": { "id": "32", "size": "1950", "name": "江苏省", "cp": [118.8586, 32.915], "childNum": 13 }, "geometry": { "type": "Polygon", "coordinates": [[[116.3672, 34.6289], [116.4551, 34.8926], [116.8066, 34.9365], [117.2461, 34.4531], [117.334, 34.585], [117.5977, 34.4531], [117.9492, 34.6729], [118.125, 34.6289], [118.2129, 34.4092], [118.3887, 34.4092], [118.4766, 34.6729], [118.7402, 34.7168], [118.916, 35.0244], [119.2676, 35.1123], [119.3555, 35.0244], [119.3555, 34.8486], [119.707, 34.585], [120.3223, 34.3652], [120.9375, 33.0469], [121.0254, 32.6514], [121.377, 32.4756], [121.4648, 32.168], [121.9043, 31.9922], [121.9922, 31.6846], [121.9922, 31.5967], [121.2012, 31.8604], [121.1133, 31.7285], [121.377, 31.5088], [121.2012, 31.4648], [120.9375, 31.0254], [120.498, 30.8057], [119.9707, 31.1572], [119.6191, 31.1133], [119.4434, 31.1572], [119.3555, 31.2891], [118.8281, 31.2451], [118.7402, 31.377], [118.916, 31.5527], [118.3887, 31.9482], [118.4766, 32.168], [118.6523, 32.2119], [118.5645, 32.5635], [119.1797, 32.4756], [119.1797, 32.8271], [118.916, 32.959], [118.7402, 32.7393], [118.3008, 32.7832], [118.2129, 33.2227], [118.0371, 33.1348], [117.9492, 33.2227], [118.125, 33.75], [117.7734, 33.7061], [117.5977, 34.0137], [117.1582, 34.0576], [116.8945, 34.4092], [116.3672, 34.6289]]] } }, { "type": "Feature", "properties": { "id": "50", "size": "2380", "name": "重庆市", "cp": [107.7539, 30.1904], "childNum": 40 }, "geometry": { "type": "Polygon", "coordinates": [[[108.5449, 31.6846], [108.2813, 31.9043], [108.3691, 32.168], [108.5449, 32.2119], [109.0723, 31.9482], [109.248, 31.7285], [109.5996, 31.7285], [109.7754, 31.6846], [109.6875, 31.5527], [110.127, 31.377], [110.2148, 31.1572], [110.0391, 30.8057], [109.8633, 30.8936], [109.4238, 30.542], [109.248, 30.6299], [109.1602, 30.542], [109.0723, 30.6299], [108.8086, 30.498], [108.6328, 30.5859], [108.457, 30.4102], [108.5449, 30.2344], [108.457, 29.7949], [108.6328, 29.8389], [108.9844, 29.3115], [109.0723, 29.3555], [109.248, 29.1357], [109.248, 28.4766], [109.0723, 28.2129], [108.7207, 28.2129], [108.7207, 28.4766], [108.5449, 28.3887], [108.5449, 28.6523], [108.3691, 28.6523], [108.2813, 29.0918], [107.8418, 29.0039], [107.8418, 29.1357], [107.5781, 29.2236], [107.4023, 29.1797], [107.4023, 28.8721], [106.875, 28.7842], [106.6992, 28.4766], [106.6113, 28.5205], [106.6113, 28.6523], [106.5234, 28.7842], [106.4355, 28.7842], [106.5234, 28.5645], [106.3477, 28.5205], [106.2598, 28.8721], [105.8203, 28.96], [105.7324, 29.2676], [105.4688, 29.3115], [105.293, 29.5313], [105.7324, 29.8828], [105.5566, 30.1025], [105.6445, 30.2783], [105.8203, 30.4541], [106.2598, 30.1904], [106.6113, 30.3223], [106.7871, 30.0146], [107.0508, 30.0146], [107.4902, 30.6299], [107.4023, 30.7617], [107.4902, 30.8496], [107.9297, 30.8496], [108.1934, 31.5088], [108.5449, 31.6846]]] } }, { "type": "Feature", "properties": { "id": "64", "size": "2100", "name": "宁夏回族自治区", "cp": [105.9961, 37.3096], "childNum": 5 }, "geometry": { "type": "Polygon", "coordinates": [[[104.3262, 37.4414], [105.8203, 37.793], [105.9082, 38.7158], [106.3477, 39.2871], [106.7871, 39.375], [106.9629, 38.9795], [106.5234, 38.3203], [106.7871, 38.1885], [107.3145, 38.1006], [107.666, 37.8809], [107.3145, 37.6172], [107.3145, 37.0898], [106.6113, 37.0898], [106.6113, 36.7822], [106.4355, 36.5625], [106.5234, 36.4746], [106.5234, 36.2549], [106.875, 36.123], [106.9629, 35.8154], [106.6992, 35.6836], [106.4355, 35.6836], [106.5234, 35.332], [106.3477, 35.2441], [106.2598, 35.4199], [106.084, 35.376], [105.9961, 35.4199], [106.084, 35.4639], [105.9961, 35.4639], [105.8203, 35.5518], [105.7324, 35.7275], [105.3809, 35.7715], [105.293, 35.9912], [105.4688, 36.123], [105.2051, 36.6943], [105.293, 36.8262], [104.8535, 37.2217], [104.5898, 37.2217], [104.5898, 37.4414], [104.3262, 37.4414]]] } }, { "type": "Feature", "properties": { "id": "46", "size": "4500", "name": "海南省", "cp": [109.9512, 19.2041], "childNum": 18 }, "geometry": { "type": "Polygon", "coordinates": [[[108.6328, 19.3799], [109.0723, 19.6436], [109.248, 19.9512], [109.5996, 20.0391], [110.0391, 20.127], [110.3906, 20.127], [110.5664, 20.2588], [110.6543, 20.2588], [111.0938, 19.9512], [111.2695, 19.9951], [110.6543, 19.1602], [110.5664, 18.6768], [110.2148, 18.5889], [110.0391, 18.3691], [109.8633, 18.3691], [109.6875, 18.1055], [108.9844, 18.2813], [108.6328, 18.457], [108.6328, 19.3799]]] } }, { "type": "Feature", "properties": { "id": "71", "size": "3000", "name": "台湾省", "cp": [120.0254, 23.5986], "childNum": 1 }, "geometry": { "type": "Polygon", "coordinates": [[[121.9043, 25.0488], [121.9922, 25.0049], [121.8164, 24.7412], [121.9043, 24.5654], [121.6406, 24.0381], [121.377, 23.1152], [121.0254, 22.6758], [120.8496, 22.0605], [120.7617, 21.9287], [120.6738, 22.3242], [120.2344, 22.5879], [120.0586, 23.0713], [120.1465, 23.6865], [121.0254, 25.0488], [121.5527, 25.3125], [121.9043, 25.0488]]] } }, { "type": "Feature", "properties": { "id": "11", "size": "5000", "name": "北京市", "cp": [116.4551, 40.2539], "childNum": 19 }, "geometry": { "type": "Polygon", "coordinates": [[[117.4219, 40.21], [117.334, 40.1221], [117.2461, 40.0781], [116.8066, 39.9902], [116.8945, 39.8145], [116.8945, 39.6826], [116.8066, 39.5947], [116.543, 39.5947], [116.3672, 39.4629], [116.1914, 39.5947], [115.752, 39.5068], [115.4883, 39.6387], [115.4004, 39.9463], [115.9277, 40.2539], [115.752, 40.5615], [116.1035, 40.6055], [116.1914, 40.7813], [116.4551, 40.7813], [116.3672, 40.9131], [116.6309, 41.0449], [116.9824, 40.6934], [117.4219, 40.6494], [117.2461, 40.5176], [117.4219, 40.21]]] } }, { "type": "Feature", "properties": { "id": "12", "size": "5000", "name": "天津市", "cp": [117.4219, 39.4189], "childNum": 18 }, "geometry": { "type": "Polygon", "coordinates": [[[116.8066, 39.5947], [116.8945, 39.6826], [117.1582, 39.6387], [117.1582, 39.8145], [117.2461, 40.0781], [117.334, 40.1221], [117.4219, 40.21], [117.6855, 40.0781], [117.6855, 39.9902], [117.5098, 39.9902], [117.5098, 39.7705], [117.6855, 39.5947], [117.9492, 39.5947], [117.8613, 39.4189], [118.0371, 39.2432], [118.0371, 39.1992], [117.8613, 39.1113], [117.5977, 38.6279], [117.2461, 38.54], [116.7188, 38.8037], [116.7188, 38.9355], [116.8945, 39.1113], [116.8066, 39.5947]]] } }, { "type": "Feature", "properties": { "id": "31", "size": "7500", "name": "上海市", "cp": [121.4648, 31.2891], "childNum": 19 }, "geometry": { "type": "Polygon", "coordinates": [[[120.9375, 31.0254], [121.2012, 31.4648], [121.377, 31.5088], [121.1133, 31.7285], [121.2012, 31.8604], [121.9922, 31.5967], [121.9043, 31.1572], [121.9922, 30.8057], [121.2891, 30.6738], [120.9375, 31.0254]]] } }, { "type": "Feature", "properties": { "id": "81", "size": "18000", "name": "香港特别行政区", "cp": [114.1178, 22.3242], "childNum": 1 }, "geometry": { "type": "Polygon", "coordinates": [[[114.6094, 22.4121], [114.5215, 22.1484], [114.3457, 22.1484], [113.9063, 22.1484], [113.8184, 22.1924], [113.9063, 22.4121], [114.1699, 22.5439], [114.3457, 22.5439], [114.4336, 22.5439], [114.4336, 22.4121], [114.6094, 22.4121]]] } }, { "type": "Feature", "properties": { "id": "82", "size": "27", "name": "澳门特别行政区", "cp": [111.5547, 22.1484], "childNum": 1 }, "geometry": { "type": "Polygon", "coordinates": [[[113.5986, 22.1649], [113.6096, 22.1265], [113.5547, 22.11], [113.5437, 22.2034], [113.5767, 22.2034], [113.5986, 22.1649]]] } }]
	        };

	        var INITIAL_VIEW_STATE = {
	            latitude: 30,
	            longitude: 104,
	            zoom: 3,
	            pitch: 40.5
	        };

	        var deckgl = new _core.Deck({
	            canvas: 'deck-canvas',
	            width: '100%',
	            height: '100%',
	            viewState: INITIAL_VIEW_STATE,
	            controller: _core.MapController,
	            onViewportChange: function onViewportChange(viewState) {
	                deckgl.setProps({ viewState: viewState });
	                //map.setProps({viewState});
	            }
	        });

	        deckgl.setProps({
	            layers: [new _core.GeoJsonLayer({
	                GEOJSON: GEOJSON,
	                stroked: true,
	                filled: true,
	                lineWidthMinPixels: 2,
	                opacity: 0.4,
	                getLineColor: function getLineColor() {
	                    return [255, 160, 100];
	                },
	                getFillColor: function getFillColor() {
	                    return [200, 160, 0, 180];
	                }
	            })]
	        });
	    },
	    drawHexbin: function drawHexbin(map, latlngs) {
	        var hexLayer = L.hexbinLayer().addTo(map);
	        // Random data generators
	        hexLayer.data(latlngs);
	        return hexLayer;
	    }
	};

	window.mauna_minimap = {
	    init: function init(data, callBack) {
	        var map_container = (0, _jquery2.default)('#' + data.map_container);
	        var id = data.map_container;
	        var latlng = data.latlng;
	        var zoom = data.zoom;
	        var map = basemap(id, latlng, zoom);
	        function basemap(map_container, latlng, zoom) {
	            var map = L.map(map_container, {
	                crs: L.CRS.EPSG3857, //默认墨卡托投影 ESPG：3857
	                attributionControl: false,
	                zoomsliderControl: false,
	                zoomControl: false,
	                maxZoom: 18,
	                minZoom: 4,
	                scrollWheelZoom: true,
	                touchZoom: false,
	                doubleClickZoom: false,
	                dragging: true
	            }).setView(latlng, zoom);
	            var osm = L.tileLayer.chinaProvider('GaoDe.Normal.Map', {});
	            osm.addTo(map);
	            return map;
	        }
	        if (callBack) {
	            callBack();
	        }
	        return map;
	    },
	    myIcon: function myIcon(map, latlng, options, markeropt) {
	        var myIcon = L.divIcon(options);
	        if (markeropt) {
	            markeropt.icon = myIcon;
	        } else {
	            markeropt = {
	                icon: myIcon
	            };
	        }
	        return L.marker(latlng, markeropt).addTo(map);
	    },
	    changeIcon: function changeIcon(marker, latlng, options) {
	        var myIcon = L.divIcon(options);
	        marker.setIcon(myIcon);
	        marker.setLatLng(latlng);
	        return marker;
	    }
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {/* @preserve
	 * Leaflet 1.3.1, a JS library for interactive maps. http://leafletjs.com
	 * (c) 2010-2017 Vladimir Agafonkin, (c) 2010-2011 CloudMade
	 */

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.L = {})));
	}(this, (function (exports) { 'use strict';

	var version = "1.3.1";

	/*
	 * @namespace Util
	 *
	 * Various utility functions, used by Leaflet internally.
	 */

	var freeze = Object.freeze;
	Object.freeze = function (obj) { return obj; };

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	function extend(dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	}

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	var create = Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})();

	// @function bind(fn: Function, …): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	function bind(fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	}

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	var lastId = 0;

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assigning it one if it doesn't have it.
	function stamp(obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++lastId;
		return obj._leaflet_id;
		/* eslint-enable */
	}

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.throttle` shortcut.
	function throttle(fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	}

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	function wrapNum(x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	}

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	function falseFn() { return false; }

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
	function formatNum(num, digits) {
		var pow = Math.pow(10, (digits === undefined ? 6 : digits));
		return Math.round(num * pow) / pow;
	}

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	function trim(str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	}

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	function splitWords(str) {
		return trim(str).split(/\s+/);
	}

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	function setOptions(obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	}

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	function getParamString(obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	}

	var templateRe = /\{ *([\w_-]+) *\}/g;

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values — they will be evaluated passing `data` as an argument.
	function template(str, data) {
		return str.replace(templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	}

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	var isArray = Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	};

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	function indexOf(array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	}

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	var emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
	var cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
			getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };

	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	function requestAnimFrame(fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, bind(fn, context));
		}
	}

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	function cancelAnimFrame(id) {
		if (id) {
			cancelFn.call(window, id);
		}
	}


	var Util = (Object.freeze || Object)({
		freeze: freeze,
		extend: extend,
		create: create,
		bind: bind,
		lastId: lastId,
		stamp: stamp,
		throttle: throttle,
		wrapNum: wrapNum,
		falseFn: falseFn,
		formatNum: formatNum,
		trim: trim,
		splitWords: splitWords,
		setOptions: setOptions,
		getParamString: getParamString,
		template: template,
		isArray: isArray,
		indexOf: indexOf,
		emptyImageUrl: emptyImageUrl,
		requestFn: requestFn,
		cancelFn: cancelFn,
		requestAnimFrame: requestAnimFrame,
		cancelAnimFrame: cancelAnimFrame
	});

	// @class Class
	// @aka L.Class

	// @section
	// @uninheritable

	// Thanks to John Resig and Dean Edwards for inspiration!

	function Class() {}

	Class.extend = function (props) {

		// @function extend(props: Object): Function
		// [Extends the current class](#class-inheritance) given the properties to be included.
		// Returns a Javascript function that is a class constructor (to be called with `new`).
		var NewClass = function () {

			// call the constructor
			if (this.initialize) {
				this.initialize.apply(this, arguments);
			}

			// call all constructor hooks
			this.callInitHooks();
		};

		var parentProto = NewClass.__super__ = this.prototype;

		var proto = create(parentProto);
		proto.constructor = NewClass;

		NewClass.prototype = proto;

		// inherit parent's statics
		for (var i in this) {
			if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
				NewClass[i] = this[i];
			}
		}

		// mix static properties into the class
		if (props.statics) {
			extend(NewClass, props.statics);
			delete props.statics;
		}

		// mix includes into the prototype
		if (props.includes) {
			checkDeprecatedMixinEvents(props.includes);
			extend.apply(null, [proto].concat(props.includes));
			delete props.includes;
		}

		// merge options
		if (proto.options) {
			props.options = extend(create(proto.options), props.options);
		}

		// mix given properties into the prototype
		extend(proto, props);

		proto._initHooks = [];

		// add method for calling all hooks
		proto.callInitHooks = function () {

			if (this._initHooksCalled) { return; }

			if (parentProto.callInitHooks) {
				parentProto.callInitHooks.call(this);
			}

			this._initHooksCalled = true;

			for (var i = 0, len = proto._initHooks.length; i < len; i++) {
				proto._initHooks[i].call(this);
			}
		};

		return NewClass;
	};


	// @function include(properties: Object): this
	// [Includes a mixin](#class-includes) into the current class.
	Class.include = function (props) {
		extend(this.prototype, props);
		return this;
	};

	// @function mergeOptions(options: Object): this
	// [Merges `options`](#class-options) into the defaults of the class.
	Class.mergeOptions = function (options) {
		extend(this.prototype.options, options);
		return this;
	};

	// @function addInitHook(fn: Function): this
	// Adds a [constructor hook](#class-constructor-hooks) to the class.
	Class.addInitHook = function (fn) { // (Function) || (String, args...)
		var args = Array.prototype.slice.call(arguments, 1);

		var init = typeof fn === 'function' ? fn : function () {
			this[fn].apply(this, args);
		};

		this.prototype._initHooks = this.prototype._initHooks || [];
		this.prototype._initHooks.push(init);
		return this;
	};

	function checkDeprecatedMixinEvents(includes) {
		if (typeof L === 'undefined' || !L || !L.Mixin) { return; }

		includes = isArray(includes) ? includes : [includes];

		for (var i = 0; i < includes.length; i++) {
			if (includes[i] === L.Mixin.Events) {
				console.warn('Deprecated include of L.Mixin.Events: ' +
					'this property will be removed in future releases, ' +
					'please inherit from L.Evented instead.', new Error().stack);
			}
		}
	}

	/*
	 * @class Evented
	 * @aka L.Evented
	 * @inherits Class
	 *
	 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
	 *
	 * @example
	 *
	 * ```js
	 * map.on('click', function(e) {
	 * 	alert(e.latlng);
	 * } );
	 * ```
	 *
	 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
	 *
	 * ```js
	 * function onClick(e) { ... }
	 *
	 * map.on('click', onClick);
	 * map.off('click', onClick);
	 * ```
	 */

	var Events = {
		/* @method on(type: String, fn: Function, context?: Object): this
		 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
		 *
		 * @alternative
		 * @method on(eventMap: Object): this
		 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
		 */
		on: function (types, fn, context) {

			// types can be a map of types/handlers
			if (typeof types === 'object') {
				for (var type in types) {
					// we don't process space-separated events here for performance;
					// it's a hot path since Layer uses the on(obj) syntax
					this._on(type, types[type], fn);
				}

			} else {
				// types can be a string of space-separated words
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._on(types[i], fn, context);
				}
			}

			return this;
		},

		/* @method off(type: String, fn?: Function, context?: Object): this
		 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
		 *
		 * @alternative
		 * @method off(eventMap: Object): this
		 * Removes a set of type/listener pairs.
		 *
		 * @alternative
		 * @method off: this
		 * Removes all listeners to all events on the object.
		 */
		off: function (types, fn, context) {

			if (!types) {
				// clear all listeners if called without arguments
				delete this._events;

			} else if (typeof types === 'object') {
				for (var type in types) {
					this._off(type, types[type], fn);
				}

			} else {
				types = splitWords(types);

				for (var i = 0, len = types.length; i < len; i++) {
					this._off(types[i], fn, context);
				}
			}

			return this;
		},

		// attach listener (without syntactic sugar now)
		_on: function (type, fn, context) {
			this._events = this._events || {};

			/* get/init listeners for type */
			var typeListeners = this._events[type];
			if (!typeListeners) {
				typeListeners = [];
				this._events[type] = typeListeners;
			}

			if (context === this) {
				// Less memory footprint.
				context = undefined;
			}
			var newListener = {fn: fn, ctx: context},
			    listeners = typeListeners;

			// check if fn already there
			for (var i = 0, len = listeners.length; i < len; i++) {
				if (listeners[i].fn === fn && listeners[i].ctx === context) {
					return;
				}
			}

			listeners.push(newListener);
		},

		_off: function (type, fn, context) {
			var listeners,
			    i,
			    len;

			if (!this._events) { return; }

			listeners = this._events[type];

			if (!listeners) {
				return;
			}

			if (!fn) {
				// Set all removed listeners to noop so they are not called if remove happens in fire
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].fn = falseFn;
				}
				// clear all listeners for a type if function isn't specified
				delete this._events[type];
				return;
			}

			if (context === this) {
				context = undefined;
			}

			if (listeners) {

				// find fn and remove it
				for (i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					if (l.ctx !== context) { continue; }
					if (l.fn === fn) {

						// set the removed listener to noop so that's not called if remove happens in fire
						l.fn = falseFn;

						if (this._firingCount) {
							/* copy array in case events are being fired */
							this._events[type] = listeners = listeners.slice();
						}
						listeners.splice(i, 1);

						return;
					}
				}
			}
		},

		// @method fire(type: String, data?: Object, propagate?: Boolean): this
		// Fires an event of the specified type. You can optionally provide an data
		// object — the first argument of the listener function will contain its
		// properties. The event can optionally be propagated to event parents.
		fire: function (type, data, propagate) {
			if (!this.listens(type, propagate)) { return this; }

			var event = extend({}, data, {
				type: type,
				target: this,
				sourceTarget: data && data.sourceTarget || this
			});

			if (this._events) {
				var listeners = this._events[type];

				if (listeners) {
					this._firingCount = (this._firingCount + 1) || 1;
					for (var i = 0, len = listeners.length; i < len; i++) {
						var l = listeners[i];
						l.fn.call(l.ctx || this, event);
					}

					this._firingCount--;
				}
			}

			if (propagate) {
				// propagate the event to parents (set with addEventParent)
				this._propagateEvent(event);
			}

			return this;
		},

		// @method listens(type: String): Boolean
		// Returns `true` if a particular event type has any listeners attached to it.
		listens: function (type, propagate) {
			var listeners = this._events && this._events[type];
			if (listeners && listeners.length) { return true; }

			if (propagate) {
				// also check parents for listeners if event propagates
				for (var id in this._eventParents) {
					if (this._eventParents[id].listens(type, propagate)) { return true; }
				}
			}
			return false;
		},

		// @method once(…): this
		// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
		once: function (types, fn, context) {

			if (typeof types === 'object') {
				for (var type in types) {
					this.once(type, types[type], fn);
				}
				return this;
			}

			var handler = bind(function () {
				this
				    .off(types, fn, context)
				    .off(types, handler, context);
			}, this);

			// add a listener that's executed once and removed after that
			return this
			    .on(types, fn, context)
			    .on(types, handler, context);
		},

		// @method addEventParent(obj: Evented): this
		// Adds an event parent - an `Evented` that will receive propagated events
		addEventParent: function (obj) {
			this._eventParents = this._eventParents || {};
			this._eventParents[stamp(obj)] = obj;
			return this;
		},

		// @method removeEventParent(obj: Evented): this
		// Removes an event parent, so it will stop receiving propagated events
		removeEventParent: function (obj) {
			if (this._eventParents) {
				delete this._eventParents[stamp(obj)];
			}
			return this;
		},

		_propagateEvent: function (e) {
			for (var id in this._eventParents) {
				this._eventParents[id].fire(e.type, extend({
					layer: e.target,
					propagatedFrom: e.target
				}, e), true);
			}
		}
	};

	// aliases; we should ditch those eventually

	// @method addEventListener(…): this
	// Alias to [`on(…)`](#evented-on)
	Events.addEventListener = Events.on;

	// @method removeEventListener(…): this
	// Alias to [`off(…)`](#evented-off)

	// @method clearAllEventListeners(…): this
	// Alias to [`off()`](#evented-off)
	Events.removeEventListener = Events.clearAllEventListeners = Events.off;

	// @method addOneTimeEventListener(…): this
	// Alias to [`once(…)`](#evented-once)
	Events.addOneTimeEventListener = Events.once;

	// @method fireEvent(…): this
	// Alias to [`fire(…)`](#evented-fire)
	Events.fireEvent = Events.fire;

	// @method hasEventListeners(…): Boolean
	// Alias to [`listens(…)`](#evented-listens)
	Events.hasEventListeners = Events.listens;

	var Evented = Class.extend(Events);

	/*
	 * @class Point
	 * @aka L.Point
	 *
	 * Represents a point with `x` and `y` coordinates in pixels.
	 *
	 * @example
	 *
	 * ```js
	 * var point = L.point(200, 300);
	 * ```
	 *
	 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
	 *
	 * ```js
	 * map.panBy([200, 300]);
	 * map.panBy(L.point(200, 300));
	 * ```
	 *
	 * Note that `Point` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function Point(x, y, round) {
		// @property x: Number; The `x` coordinate of the point
		this.x = (round ? Math.round(x) : x);
		// @property y: Number; The `y` coordinate of the point
		this.y = (round ? Math.round(y) : y);
	}

	var trunc = Math.trunc || function (v) {
		return v > 0 ? Math.floor(v) : Math.ceil(v);
	};

	Point.prototype = {

		// @method clone(): Point
		// Returns a copy of the current point.
		clone: function () {
			return new Point(this.x, this.y);
		},

		// @method add(otherPoint: Point): Point
		// Returns the result of addition of the current and the given points.
		add: function (point) {
			// non-destructive, returns a new point
			return this.clone()._add(toPoint(point));
		},

		_add: function (point) {
			// destructive, used directly for performance in situations where it's safe to modify existing point
			this.x += point.x;
			this.y += point.y;
			return this;
		},

		// @method subtract(otherPoint: Point): Point
		// Returns the result of subtraction of the given point from the current.
		subtract: function (point) {
			return this.clone()._subtract(toPoint(point));
		},

		_subtract: function (point) {
			this.x -= point.x;
			this.y -= point.y;
			return this;
		},

		// @method divideBy(num: Number): Point
		// Returns the result of division of the current point by the given number.
		divideBy: function (num) {
			return this.clone()._divideBy(num);
		},

		_divideBy: function (num) {
			this.x /= num;
			this.y /= num;
			return this;
		},

		// @method multiplyBy(num: Number): Point
		// Returns the result of multiplication of the current point by the given number.
		multiplyBy: function (num) {
			return this.clone()._multiplyBy(num);
		},

		_multiplyBy: function (num) {
			this.x *= num;
			this.y *= num;
			return this;
		},

		// @method scaleBy(scale: Point): Point
		// Multiply each coordinate of the current point by each coordinate of
		// `scale`. In linear algebra terms, multiply the point by the
		// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
		// defined by `scale`.
		scaleBy: function (point) {
			return new Point(this.x * point.x, this.y * point.y);
		},

		// @method unscaleBy(scale: Point): Point
		// Inverse of `scaleBy`. Divide each coordinate of the current point by
		// each coordinate of `scale`.
		unscaleBy: function (point) {
			return new Point(this.x / point.x, this.y / point.y);
		},

		// @method round(): Point
		// Returns a copy of the current point with rounded coordinates.
		round: function () {
			return this.clone()._round();
		},

		_round: function () {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this;
		},

		// @method floor(): Point
		// Returns a copy of the current point with floored coordinates (rounded down).
		floor: function () {
			return this.clone()._floor();
		},

		_floor: function () {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this;
		},

		// @method ceil(): Point
		// Returns a copy of the current point with ceiled coordinates (rounded up).
		ceil: function () {
			return this.clone()._ceil();
		},

		_ceil: function () {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this;
		},

		// @method trunc(): Point
		// Returns a copy of the current point with truncated coordinates (rounded towards zero).
		trunc: function () {
			return this.clone()._trunc();
		},

		_trunc: function () {
			this.x = trunc(this.x);
			this.y = trunc(this.y);
			return this;
		},

		// @method distanceTo(otherPoint: Point): Number
		// Returns the cartesian distance between the current and the given points.
		distanceTo: function (point) {
			point = toPoint(point);

			var x = point.x - this.x,
			    y = point.y - this.y;

			return Math.sqrt(x * x + y * y);
		},

		// @method equals(otherPoint: Point): Boolean
		// Returns `true` if the given point has the same coordinates.
		equals: function (point) {
			point = toPoint(point);

			return point.x === this.x &&
			       point.y === this.y;
		},

		// @method contains(otherPoint: Point): Boolean
		// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
		contains: function (point) {
			point = toPoint(point);

			return Math.abs(point.x) <= Math.abs(this.x) &&
			       Math.abs(point.y) <= Math.abs(this.y);
		},

		// @method toString(): String
		// Returns a string representation of the point for debugging purposes.
		toString: function () {
			return 'Point(' +
			        formatNum(this.x) + ', ' +
			        formatNum(this.y) + ')';
		}
	};

	// @factory L.point(x: Number, y: Number, round?: Boolean)
	// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

	// @alternative
	// @factory L.point(coords: Number[])
	// Expects an array of the form `[x, y]` instead.

	// @alternative
	// @factory L.point(coords: Object)
	// Expects a plain object of the form `{x: Number, y: Number}` instead.
	function toPoint(x, y, round) {
		if (x instanceof Point) {
			return x;
		}
		if (isArray(x)) {
			return new Point(x[0], x[1]);
		}
		if (x === undefined || x === null) {
			return x;
		}
		if (typeof x === 'object' && 'x' in x && 'y' in x) {
			return new Point(x.x, x.y);
		}
		return new Point(x, y, round);
	}

	/*
	 * @class Bounds
	 * @aka L.Bounds
	 *
	 * Represents a rectangular area in pixel coordinates.
	 *
	 * @example
	 *
	 * ```js
	 * var p1 = L.point(10, 10),
	 * p2 = L.point(40, 60),
	 * bounds = L.bounds(p1, p2);
	 * ```
	 *
	 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
	 *
	 * ```js
	 * otherBounds.intersects([[10, 10], [40, 60]]);
	 * ```
	 *
	 * Note that `Bounds` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function Bounds(a, b) {
		if (!a) { return; }

		var points = b ? [a, b] : a;

		for (var i = 0, len = points.length; i < len; i++) {
			this.extend(points[i]);
		}
	}

	Bounds.prototype = {
		// @method extend(point: Point): this
		// Extends the bounds to contain the given point.
		extend: function (point) { // (Point)
			point = toPoint(point);

			// @property min: Point
			// The top left corner of the rectangle.
			// @property max: Point
			// The bottom right corner of the rectangle.
			if (!this.min && !this.max) {
				this.min = point.clone();
				this.max = point.clone();
			} else {
				this.min.x = Math.min(point.x, this.min.x);
				this.max.x = Math.max(point.x, this.max.x);
				this.min.y = Math.min(point.y, this.min.y);
				this.max.y = Math.max(point.y, this.max.y);
			}
			return this;
		},

		// @method getCenter(round?: Boolean): Point
		// Returns the center point of the bounds.
		getCenter: function (round) {
			return new Point(
			        (this.min.x + this.max.x) / 2,
			        (this.min.y + this.max.y) / 2, round);
		},

		// @method getBottomLeft(): Point
		// Returns the bottom-left point of the bounds.
		getBottomLeft: function () {
			return new Point(this.min.x, this.max.y);
		},

		// @method getTopRight(): Point
		// Returns the top-right point of the bounds.
		getTopRight: function () { // -> Point
			return new Point(this.max.x, this.min.y);
		},

		// @method getTopLeft(): Point
		// Returns the top-left point of the bounds (i.e. [`this.min`](#bounds-min)).
		getTopLeft: function () {
			return this.min; // left, top
		},

		// @method getBottomRight(): Point
		// Returns the bottom-right point of the bounds (i.e. [`this.max`](#bounds-max)).
		getBottomRight: function () {
			return this.max; // right, bottom
		},

		// @method getSize(): Point
		// Returns the size of the given bounds
		getSize: function () {
			return this.max.subtract(this.min);
		},

		// @method contains(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle contains the given one.
		// @alternative
		// @method contains(point: Point): Boolean
		// Returns `true` if the rectangle contains the given point.
		contains: function (obj) {
			var min, max;

			if (typeof obj[0] === 'number' || obj instanceof Point) {
				obj = toPoint(obj);
			} else {
				obj = toBounds(obj);
			}

			if (obj instanceof Bounds) {
				min = obj.min;
				max = obj.max;
			} else {
				min = max = obj;
			}

			return (min.x >= this.min.x) &&
			       (max.x <= this.max.x) &&
			       (min.y >= this.min.y) &&
			       (max.y <= this.max.y);
		},

		// @method intersects(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle intersects the given bounds. Two bounds
		// intersect if they have at least one point in common.
		intersects: function (bounds) { // (Bounds) -> Boolean
			bounds = toBounds(bounds);

			var min = this.min,
			    max = this.max,
			    min2 = bounds.min,
			    max2 = bounds.max,
			    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
			    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

			return xIntersects && yIntersects;
		},

		// @method overlaps(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle overlaps the given bounds. Two bounds
		// overlap if their intersection is an area.
		overlaps: function (bounds) { // (Bounds) -> Boolean
			bounds = toBounds(bounds);

			var min = this.min,
			    max = this.max,
			    min2 = bounds.min,
			    max2 = bounds.max,
			    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
			    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

			return xOverlaps && yOverlaps;
		},

		isValid: function () {
			return !!(this.min && this.max);
		}
	};


	// @factory L.bounds(corner1: Point, corner2: Point)
	// Creates a Bounds object from two corners coordinate pairs.
	// @alternative
	// @factory L.bounds(points: Point[])
	// Creates a Bounds object from the given array of points.
	function toBounds(a, b) {
		if (!a || a instanceof Bounds) {
			return a;
		}
		return new Bounds(a, b);
	}

	/*
	 * @class LatLngBounds
	 * @aka L.LatLngBounds
	 *
	 * Represents a rectangular geographical area on a map.
	 *
	 * @example
	 *
	 * ```js
	 * var corner1 = L.latLng(40.712, -74.227),
	 * corner2 = L.latLng(40.774, -74.125),
	 * bounds = L.latLngBounds(corner1, corner2);
	 * ```
	 *
	 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
	 *
	 * ```js
	 * map.fitBounds([
	 * 	[40.712, -74.227],
	 * 	[40.774, -74.125]
	 * ]);
	 * ```
	 *
	 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
	 *
	 * Note that `LatLngBounds` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function LatLngBounds(corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
		if (!corner1) { return; }

		var latlngs = corner2 ? [corner1, corner2] : corner1;

		for (var i = 0, len = latlngs.length; i < len; i++) {
			this.extend(latlngs[i]);
		}
	}

	LatLngBounds.prototype = {

		// @method extend(latlng: LatLng): this
		// Extend the bounds to contain the given point

		// @alternative
		// @method extend(otherBounds: LatLngBounds): this
		// Extend the bounds to contain the given bounds
		extend: function (obj) {
			var sw = this._southWest,
			    ne = this._northEast,
			    sw2, ne2;

			if (obj instanceof LatLng) {
				sw2 = obj;
				ne2 = obj;

			} else if (obj instanceof LatLngBounds) {
				sw2 = obj._southWest;
				ne2 = obj._northEast;

				if (!sw2 || !ne2) { return this; }

			} else {
				return obj ? this.extend(toLatLng(obj) || toLatLngBounds(obj)) : this;
			}

			if (!sw && !ne) {
				this._southWest = new LatLng(sw2.lat, sw2.lng);
				this._northEast = new LatLng(ne2.lat, ne2.lng);
			} else {
				sw.lat = Math.min(sw2.lat, sw.lat);
				sw.lng = Math.min(sw2.lng, sw.lng);
				ne.lat = Math.max(ne2.lat, ne.lat);
				ne.lng = Math.max(ne2.lng, ne.lng);
			}

			return this;
		},

		// @method pad(bufferRatio: Number): LatLngBounds
		// Returns bounds created by extending or retracting the current bounds by a given ratio in each direction.
		// For example, a ratio of 0.5 extends the bounds by 50% in each direction.
		// Negative values will retract the bounds.
		pad: function (bufferRatio) {
			var sw = this._southWest,
			    ne = this._northEast,
			    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
			    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

			return new LatLngBounds(
			        new LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
			        new LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
		},

		// @method getCenter(): LatLng
		// Returns the center point of the bounds.
		getCenter: function () {
			return new LatLng(
			        (this._southWest.lat + this._northEast.lat) / 2,
			        (this._southWest.lng + this._northEast.lng) / 2);
		},

		// @method getSouthWest(): LatLng
		// Returns the south-west point of the bounds.
		getSouthWest: function () {
			return this._southWest;
		},

		// @method getNorthEast(): LatLng
		// Returns the north-east point of the bounds.
		getNorthEast: function () {
			return this._northEast;
		},

		// @method getNorthWest(): LatLng
		// Returns the north-west point of the bounds.
		getNorthWest: function () {
			return new LatLng(this.getNorth(), this.getWest());
		},

		// @method getSouthEast(): LatLng
		// Returns the south-east point of the bounds.
		getSouthEast: function () {
			return new LatLng(this.getSouth(), this.getEast());
		},

		// @method getWest(): Number
		// Returns the west longitude of the bounds
		getWest: function () {
			return this._southWest.lng;
		},

		// @method getSouth(): Number
		// Returns the south latitude of the bounds
		getSouth: function () {
			return this._southWest.lat;
		},

		// @method getEast(): Number
		// Returns the east longitude of the bounds
		getEast: function () {
			return this._northEast.lng;
		},

		// @method getNorth(): Number
		// Returns the north latitude of the bounds
		getNorth: function () {
			return this._northEast.lat;
		},

		// @method contains(otherBounds: LatLngBounds): Boolean
		// Returns `true` if the rectangle contains the given one.

		// @alternative
		// @method contains (latlng: LatLng): Boolean
		// Returns `true` if the rectangle contains the given point.
		contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
			if (typeof obj[0] === 'number' || obj instanceof LatLng || 'lat' in obj) {
				obj = toLatLng(obj);
			} else {
				obj = toLatLngBounds(obj);
			}

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2, ne2;

			if (obj instanceof LatLngBounds) {
				sw2 = obj.getSouthWest();
				ne2 = obj.getNorthEast();
			} else {
				sw2 = ne2 = obj;
			}

			return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
			       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
		},

		// @method intersects(otherBounds: LatLngBounds): Boolean
		// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
		intersects: function (bounds) {
			bounds = toLatLngBounds(bounds);

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2 = bounds.getSouthWest(),
			    ne2 = bounds.getNorthEast(),

			    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
			    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

			return latIntersects && lngIntersects;
		},

		// @method overlaps(otherBounds: Bounds): Boolean
		// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
		overlaps: function (bounds) {
			bounds = toLatLngBounds(bounds);

			var sw = this._southWest,
			    ne = this._northEast,
			    sw2 = bounds.getSouthWest(),
			    ne2 = bounds.getNorthEast(),

			    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
			    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

			return latOverlaps && lngOverlaps;
		},

		// @method toBBoxString(): String
		// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
		toBBoxString: function () {
			return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
		},

		// @method equals(otherBounds: LatLngBounds, maxMargin?: Number): Boolean
		// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds. The margin of error can be overridden by setting `maxMargin` to a small number.
		equals: function (bounds, maxMargin) {
			if (!bounds) { return false; }

			bounds = toLatLngBounds(bounds);

			return this._southWest.equals(bounds.getSouthWest(), maxMargin) &&
			       this._northEast.equals(bounds.getNorthEast(), maxMargin);
		},

		// @method isValid(): Boolean
		// Returns `true` if the bounds are properly initialized.
		isValid: function () {
			return !!(this._southWest && this._northEast);
		}
	};

	// TODO International date line?

	// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
	// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

	// @alternative
	// @factory L.latLngBounds(latlngs: LatLng[])
	// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
	function toLatLngBounds(a, b) {
		if (a instanceof LatLngBounds) {
			return a;
		}
		return new LatLngBounds(a, b);
	}

	/* @class LatLng
	 * @aka L.LatLng
	 *
	 * Represents a geographical point with a certain latitude and longitude.
	 *
	 * @example
	 *
	 * ```
	 * var latlng = L.latLng(50.5, 30.5);
	 * ```
	 *
	 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
	 *
	 * ```
	 * map.panTo([50, 30]);
	 * map.panTo({lon: 30, lat: 50});
	 * map.panTo({lat: 50, lng: 30});
	 * map.panTo(L.latLng(50, 30));
	 * ```
	 *
	 * Note that `LatLng` does not inherit from Leafet's `Class` object,
	 * which means new classes can't inherit from it, and new methods
	 * can't be added to it with the `include` function.
	 */

	function LatLng(lat, lng, alt) {
		if (isNaN(lat) || isNaN(lng)) {
			throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
		}

		// @property lat: Number
		// Latitude in degrees
		this.lat = +lat;

		// @property lng: Number
		// Longitude in degrees
		this.lng = +lng;

		// @property alt: Number
		// Altitude in meters (optional)
		if (alt !== undefined) {
			this.alt = +alt;
		}
	}

	LatLng.prototype = {
		// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
		// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overridden by setting `maxMargin` to a small number.
		equals: function (obj, maxMargin) {
			if (!obj) { return false; }

			obj = toLatLng(obj);

			var margin = Math.max(
			        Math.abs(this.lat - obj.lat),
			        Math.abs(this.lng - obj.lng));

			return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
		},

		// @method toString(): String
		// Returns a string representation of the point (for debugging purposes).
		toString: function (precision) {
			return 'LatLng(' +
			        formatNum(this.lat, precision) + ', ' +
			        formatNum(this.lng, precision) + ')';
		},

		// @method distanceTo(otherLatLng: LatLng): Number
		// Returns the distance (in meters) to the given `LatLng` calculated using the [Spherical Law of Cosines](https://en.wikipedia.org/wiki/Spherical_law_of_cosines).
		distanceTo: function (other) {
			return Earth.distance(this, toLatLng(other));
		},

		// @method wrap(): LatLng
		// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
		wrap: function () {
			return Earth.wrapLatLng(this);
		},

		// @method toBounds(sizeInMeters: Number): LatLngBounds
		// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
		toBounds: function (sizeInMeters) {
			var latAccuracy = 180 * sizeInMeters / 40075017,
			    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

			return toLatLngBounds(
			        [this.lat - latAccuracy, this.lng - lngAccuracy],
			        [this.lat + latAccuracy, this.lng + lngAccuracy]);
		},

		clone: function () {
			return new LatLng(this.lat, this.lng, this.alt);
		}
	};



	// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
	// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

	// @alternative
	// @factory L.latLng(coords: Array): LatLng
	// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

	// @alternative
	// @factory L.latLng(coords: Object): LatLng
	// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

	function toLatLng(a, b, c) {
		if (a instanceof LatLng) {
			return a;
		}
		if (isArray(a) && typeof a[0] !== 'object') {
			if (a.length === 3) {
				return new LatLng(a[0], a[1], a[2]);
			}
			if (a.length === 2) {
				return new LatLng(a[0], a[1]);
			}
			return null;
		}
		if (a === undefined || a === null) {
			return a;
		}
		if (typeof a === 'object' && 'lat' in a) {
			return new LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
		}
		if (b === undefined) {
			return null;
		}
		return new LatLng(a, b, c);
	}

	/*
	 * @namespace CRS
	 * @crs L.CRS.Base
	 * Object that defines coordinate reference systems for projecting
	 * geographical points into pixel (screen) coordinates and back (and to
	 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
	 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
	 *
	 * Leaflet defines the most usual CRSs by default. If you want to use a
	 * CRS not defined by default, take a look at the
	 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
	 *
	 * Note that the CRS instances do not inherit from Leafet's `Class` object,
	 * and can't be instantiated. Also, new classes can't inherit from them,
	 * and methods can't be added to them with the `include` function.
	 */

	var CRS = {
		// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
		// Projects geographical coordinates into pixel coordinates for a given zoom.
		latLngToPoint: function (latlng, zoom) {
			var projectedPoint = this.projection.project(latlng),
			    scale = this.scale(zoom);

			return this.transformation._transform(projectedPoint, scale);
		},

		// @method pointToLatLng(point: Point, zoom: Number): LatLng
		// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
		// zoom into geographical coordinates.
		pointToLatLng: function (point, zoom) {
			var scale = this.scale(zoom),
			    untransformedPoint = this.transformation.untransform(point, scale);

			return this.projection.unproject(untransformedPoint);
		},

		// @method project(latlng: LatLng): Point
		// Projects geographical coordinates into coordinates in units accepted for
		// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
		project: function (latlng) {
			return this.projection.project(latlng);
		},

		// @method unproject(point: Point): LatLng
		// Given a projected coordinate returns the corresponding LatLng.
		// The inverse of `project`.
		unproject: function (point) {
			return this.projection.unproject(point);
		},

		// @method scale(zoom: Number): Number
		// Returns the scale used when transforming projected coordinates into
		// pixel coordinates for a particular zoom. For example, it returns
		// `256 * 2^zoom` for Mercator-based CRS.
		scale: function (zoom) {
			return 256 * Math.pow(2, zoom);
		},

		// @method zoom(scale: Number): Number
		// Inverse of `scale()`, returns the zoom level corresponding to a scale
		// factor of `scale`.
		zoom: function (scale) {
			return Math.log(scale / 256) / Math.LN2;
		},

		// @method getProjectedBounds(zoom: Number): Bounds
		// Returns the projection's bounds scaled and transformed for the provided `zoom`.
		getProjectedBounds: function (zoom) {
			if (this.infinite) { return null; }

			var b = this.projection.bounds,
			    s = this.scale(zoom),
			    min = this.transformation.transform(b.min, s),
			    max = this.transformation.transform(b.max, s);

			return new Bounds(min, max);
		},

		// @method distance(latlng1: LatLng, latlng2: LatLng): Number
		// Returns the distance between two geographical coordinates.

		// @property code: String
		// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
		//
		// @property wrapLng: Number[]
		// An array of two numbers defining whether the longitude (horizontal) coordinate
		// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
		// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
		//
		// @property wrapLat: Number[]
		// Like `wrapLng`, but for the latitude (vertical) axis.

		// wrapLng: [min, max],
		// wrapLat: [min, max],

		// @property infinite: Boolean
		// If true, the coordinate space will be unbounded (infinite in both axes)
		infinite: false,

		// @method wrapLatLng(latlng: LatLng): LatLng
		// Returns a `LatLng` where lat and lng has been wrapped according to the
		// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
		wrapLatLng: function (latlng) {
			var lng = this.wrapLng ? wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
			    lat = this.wrapLat ? wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
			    alt = latlng.alt;

			return new LatLng(lat, lng, alt);
		},

		// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
		// Returns a `LatLngBounds` with the same size as the given one, ensuring
		// that its center is within the CRS's bounds.
		// Only accepts actual `L.LatLngBounds` instances, not arrays.
		wrapLatLngBounds: function (bounds) {
			var center = bounds.getCenter(),
			    newCenter = this.wrapLatLng(center),
			    latShift = center.lat - newCenter.lat,
			    lngShift = center.lng - newCenter.lng;

			if (latShift === 0 && lngShift === 0) {
				return bounds;
			}

			var sw = bounds.getSouthWest(),
			    ne = bounds.getNorthEast(),
			    newSw = new LatLng(sw.lat - latShift, sw.lng - lngShift),
			    newNe = new LatLng(ne.lat - latShift, ne.lng - lngShift);

			return new LatLngBounds(newSw, newNe);
		}
	};

	/*
	 * @namespace CRS
	 * @crs L.CRS.Earth
	 *
	 * Serves as the base for CRS that are global such that they cover the earth.
	 * Can only be used as the base for other CRS and cannot be used directly,
	 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
	 * meters.
	 */

	var Earth = extend({}, CRS, {
		wrapLng: [-180, 180],

		// Mean Earth Radius, as recommended for use by
		// the International Union of Geodesy and Geophysics,
		// see http://rosettacode.org/wiki/Haversine_formula
		R: 6371000,

		// distance between two geographical points using spherical law of cosines approximation
		distance: function (latlng1, latlng2) {
			var rad = Math.PI / 180,
			    lat1 = latlng1.lat * rad,
			    lat2 = latlng2.lat * rad,
			    sinDLat = Math.sin((latlng2.lat - latlng1.lat) * rad / 2),
			    sinDLon = Math.sin((latlng2.lng - latlng1.lng) * rad / 2),
			    a = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLon * sinDLon,
			    c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
			return this.R * c;
		}
	});

	/*
	 * @namespace Projection
	 * @projection L.Projection.SphericalMercator
	 *
	 * Spherical Mercator projection — the most common projection for online maps,
	 * used by almost all free and commercial tile providers. Assumes that Earth is
	 * a sphere. Used by the `EPSG:3857` CRS.
	 */

	var SphericalMercator = {

		R: 6378137,
		MAX_LATITUDE: 85.0511287798,

		project: function (latlng) {
			var d = Math.PI / 180,
			    max = this.MAX_LATITUDE,
			    lat = Math.max(Math.min(max, latlng.lat), -max),
			    sin = Math.sin(lat * d);

			return new Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
		},

		unproject: function (point) {
			var d = 180 / Math.PI;

			return new LatLng(
				(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
				point.x * d / this.R);
		},

		bounds: (function () {
			var d = 6378137 * Math.PI;
			return new Bounds([-d, -d], [d, d]);
		})()
	};

	/*
	 * @class Transformation
	 * @aka L.Transformation
	 *
	 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
	 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
	 * the reverse. Used by Leaflet in its projections code.
	 *
	 * @example
	 *
	 * ```js
	 * var transformation = L.transformation(2, 5, -1, 10),
	 * 	p = L.point(1, 2),
	 * 	p2 = transformation.transform(p), //  L.point(7, 8)
	 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
	 * ```
	 */


	// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
	// Creates a `Transformation` object with the given coefficients.
	function Transformation(a, b, c, d) {
		if (isArray(a)) {
			// use array properties
			this._a = a[0];
			this._b = a[1];
			this._c = a[2];
			this._d = a[3];
			return;
		}
		this._a = a;
		this._b = b;
		this._c = c;
		this._d = d;
	}

	Transformation.prototype = {
		// @method transform(point: Point, scale?: Number): Point
		// Returns a transformed point, optionally multiplied by the given scale.
		// Only accepts actual `L.Point` instances, not arrays.
		transform: function (point, scale) { // (Point, Number) -> Point
			return this._transform(point.clone(), scale);
		},

		// destructive transform (faster)
		_transform: function (point, scale) {
			scale = scale || 1;
			point.x = scale * (this._a * point.x + this._b);
			point.y = scale * (this._c * point.y + this._d);
			return point;
		},

		// @method untransform(point: Point, scale?: Number): Point
		// Returns the reverse transformation of the given point, optionally divided
		// by the given scale. Only accepts actual `L.Point` instances, not arrays.
		untransform: function (point, scale) {
			scale = scale || 1;
			return new Point(
			        (point.x / scale - this._b) / this._a,
			        (point.y / scale - this._d) / this._c);
		}
	};

	// factory L.transformation(a: Number, b: Number, c: Number, d: Number)

	// @factory L.transformation(a: Number, b: Number, c: Number, d: Number)
	// Instantiates a Transformation object with the given coefficients.

	// @alternative
	// @factory L.transformation(coefficients: Array): Transformation
	// Expects an coefficients array of the form
	// `[a: Number, b: Number, c: Number, d: Number]`.

	function toTransformation(a, b, c, d) {
		return new Transformation(a, b, c, d);
	}

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG3857
	 *
	 * The most common CRS for online maps, used by almost all free and commercial
	 * tile providers. Uses Spherical Mercator projection. Set in by default in
	 * Map's `crs` option.
	 */

	var EPSG3857 = extend({}, Earth, {
		code: 'EPSG:3857',
		projection: SphericalMercator,

		transformation: (function () {
			var scale = 0.5 / (Math.PI * SphericalMercator.R);
			return toTransformation(scale, 0.5, -scale, 0.5);
		}())
	});

	var EPSG900913 = extend({}, EPSG3857, {
		code: 'EPSG:900913'
	});

	// @namespace SVG; @section
	// There are several static functions which can be called without instantiating L.SVG:

	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	function svgCreate(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	function pointsToPath(rings, closed) {
		var str = '',
		i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}

	/*
	 * @namespace Browser
	 * @aka L.Browser
	 *
	 * A namespace with static properties for browser/feature detection used by Leaflet internally.
	 *
	 * @example
	 *
	 * ```js
	 * if (L.Browser.ielt9) {
	 *   alert('Upgrade your browser, dude!');
	 * }
	 * ```
	 */

	var style$1 = document.documentElement.style;

	// @property ie: Boolean; `true` for all Internet Explorer versions (not Edge).
	var ie = 'ActiveXObject' in window;

	// @property ielt9: Boolean; `true` for Internet Explorer versions less than 9.
	var ielt9 = ie && !document.addEventListener;

	// @property edge: Boolean; `true` for the Edge web browser.
	var edge = 'msLaunchUri' in navigator && !('documentMode' in document);

	// @property webkit: Boolean;
	// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
	var webkit = userAgentContains('webkit');

	// @property android: Boolean
	// `true` for any browser running on an Android platform.
	var android = userAgentContains('android');

	// @property android23: Boolean; `true` for browsers running on Android 2 or Android 3.
	var android23 = userAgentContains('android 2') || userAgentContains('android 3');

	/* See https://stackoverflow.com/a/17961266 for details on detecting stock Android */
	var webkitVer = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10); // also matches AppleWebKit
	// @property androidStock: Boolean; `true` for the Android stock browser (i.e. not Chrome)
	var androidStock = android && userAgentContains('Google') && webkitVer < 537 && !('AudioNode' in window);

	// @property opera: Boolean; `true` for the Opera browser
	var opera = !!window.opera;

	// @property chrome: Boolean; `true` for the Chrome browser.
	var chrome = userAgentContains('chrome');

	// @property gecko: Boolean; `true` for gecko-based browsers like Firefox.
	var gecko = userAgentContains('gecko') && !webkit && !opera && !ie;

	// @property safari: Boolean; `true` for the Safari browser.
	var safari = !chrome && userAgentContains('safari');

	var phantom = userAgentContains('phantom');

	// @property opera12: Boolean
	// `true` for the Opera browser supporting CSS transforms (version 12 or later).
	var opera12 = 'OTransition' in style$1;

	// @property win: Boolean; `true` when the browser is running in a Windows platform
	var win = navigator.platform.indexOf('Win') === 0;

	// @property ie3d: Boolean; `true` for all Internet Explorer versions supporting CSS transforms.
	var ie3d = ie && ('transition' in style$1);

	// @property webkit3d: Boolean; `true` for webkit-based browsers supporting CSS transforms.
	var webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23;

	// @property gecko3d: Boolean; `true` for gecko-based browsers supporting CSS transforms.
	var gecko3d = 'MozPerspective' in style$1;

	// @property any3d: Boolean
	// `true` for all browsers supporting CSS transforms.
	var any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantom;

	// @property mobile: Boolean; `true` for all browsers running in a mobile device.
	var mobile = typeof orientation !== 'undefined' || userAgentContains('mobile');

	// @property mobileWebkit: Boolean; `true` for all webkit-based browsers in a mobile device.
	var mobileWebkit = mobile && webkit;

	// @property mobileWebkit3d: Boolean
	// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
	var mobileWebkit3d = mobile && webkit3d;

	// @property msPointer: Boolean
	// `true` for browsers implementing the Microsoft touch events model (notably IE10).
	var msPointer = !window.PointerEvent && window.MSPointerEvent;

	// @property pointer: Boolean
	// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
	var pointer = !!(window.PointerEvent || msPointer);

	// @property touch: Boolean
	// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
	// This does not necessarily mean that the browser is running in a computer with
	// a touchscreen, it only means that the browser is capable of understanding
	// touch events.
	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	// @property mobileOpera: Boolean; `true` for the Opera browser in a mobile device.
	var mobileOpera = mobile && opera;

	// @property mobileGecko: Boolean
	// `true` for gecko-based browsers running in a mobile device.
	var mobileGecko = mobile && gecko;

	// @property retina: Boolean
	// `true` for browsers on a high-resolution "retina" screen.
	var retina = (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1;


	// @property canvas: Boolean
	// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
	var canvas = (function () {
		return !!document.createElement('canvas').getContext;
	}());

	// @property svg: Boolean
	// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
	var svg = !!(document.createElementNS && svgCreate('svg').createSVGRect);

	// @property vml: Boolean
	// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
	var vml = !svg && (function () {
		try {
			var div = document.createElement('div');
			div.innerHTML = '<v:shape adj="1"/>';

			var shape = div.firstChild;
			shape.style.behavior = 'url(#default#VML)';

			return shape && (typeof shape.adj === 'object');

		} catch (e) {
			return false;
		}
	}());


	function userAgentContains(str) {
		return navigator.userAgent.toLowerCase().indexOf(str) >= 0;
	}


	var Browser = (Object.freeze || Object)({
		ie: ie,
		ielt9: ielt9,
		edge: edge,
		webkit: webkit,
		android: android,
		android23: android23,
		androidStock: androidStock,
		opera: opera,
		chrome: chrome,
		gecko: gecko,
		safari: safari,
		phantom: phantom,
		opera12: opera12,
		win: win,
		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		any3d: any3d,
		mobile: mobile,
		mobileWebkit: mobileWebkit,
		mobileWebkit3d: mobileWebkit3d,
		msPointer: msPointer,
		pointer: pointer,
		touch: touch,
		mobileOpera: mobileOpera,
		mobileGecko: mobileGecko,
		retina: retina,
		canvas: canvas,
		svg: svg,
		vml: vml
	});

	/*
	 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
	 */


	var POINTER_DOWN =   msPointer ? 'MSPointerDown'   : 'pointerdown';
	var POINTER_MOVE =   msPointer ? 'MSPointerMove'   : 'pointermove';
	var POINTER_UP =     msPointer ? 'MSPointerUp'     : 'pointerup';
	var POINTER_CANCEL = msPointer ? 'MSPointerCancel' : 'pointercancel';
	var TAG_WHITE_LIST = ['INPUT', 'SELECT', 'OPTION'];

	var _pointers = {};
	var _pointerDocListener = false;

	// DomEvent.DoubleTap needs to know about this
	var _pointersCount = 0;

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	function addPointerListener(obj, type, handler, id) {
		if (type === 'touchstart') {
			_addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			_addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			_addPointerEnd(obj, handler, id);
		}

		return this;
	}

	function removePointerListener(obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(POINTER_UP, handler, false);
			obj.removeEventListener(POINTER_CANCEL, handler, false);
		}

		return this;
	}

	function _addPointerStart(obj, handler, id) {
		var onDown = bind(function (e) {
			if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					preventDefault(e);
				} else {
					return;
				}
			}

			_handlePointer(e, handler);
		});

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!_pointerDocListener) {
			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(POINTER_DOWN, _globalPointerDown, true);
			document.documentElement.addEventListener(POINTER_MOVE, _globalPointerMove, true);
			document.documentElement.addEventListener(POINTER_UP, _globalPointerUp, true);
			document.documentElement.addEventListener(POINTER_CANCEL, _globalPointerUp, true);

			_pointerDocListener = true;
		}
	}

	function _globalPointerDown(e) {
		_pointers[e.pointerId] = e;
		_pointersCount++;
	}

	function _globalPointerMove(e) {
		if (_pointers[e.pointerId]) {
			_pointers[e.pointerId] = e;
		}
	}

	function _globalPointerUp(e) {
		delete _pointers[e.pointerId];
		_pointersCount--;
	}

	function _handlePointer(e, handler) {
		e.touches = [];
		for (var i in _pointers) {
			e.touches.push(_pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	}

	function _addPointerMove(obj, handler, id) {
		var onMove = function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			_handlePointer(e, handler);
		};

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(POINTER_MOVE, onMove, false);
	}

	function _addPointerEnd(obj, handler, id) {
		var onUp = function (e) {
			_handlePointer(e, handler);
		};

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(POINTER_UP, onUp, false);
		obj.addEventListener(POINTER_CANCEL, onUp, false);
	}

	/*
	 * Extends the event handling code with double tap support for mobile browsers.
	 */

	var _touchstart = msPointer ? 'MSPointerDown' : pointer ? 'pointerdown' : 'touchstart';
	var _touchend = msPointer ? 'MSPointerUp' : pointer ? 'pointerup' : 'touchend';
	var _pre = '_leaflet_';

	// inspired by Zepto touch code by Thomas Fuchs
	function addDoubleTapListener(obj, handler, id) {
		var last, touch$$1,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (pointer) {
				if ((!edge) || e.pointerType === 'mouse') { return; }
				count = _pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch$$1 = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (doubleTap && !touch$$1.cancelBubble) {
				if (pointer) {
					if ((!edge) || e.pointerType === 'mouse') { return; }
					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch$$1) {
						prop = touch$$1[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch$$1) : prop;
					}
					touch$$1 = newTouch;
				}
				touch$$1.type = 'dblclick';
				handler(touch$$1);
				last = null;
			}
		}

		obj[_pre + _touchstart + id] = onTouchStart;
		obj[_pre + _touchend + id] = onTouchEnd;
		obj[_pre + 'dblclick' + id] = handler;

		obj.addEventListener(_touchstart, onTouchStart, false);
		obj.addEventListener(_touchend, onTouchEnd, false);

		// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
		obj.addEventListener('dblclick', handler, false);

		return this;
	}

	function removeDoubleTapListener(obj, id) {
		var touchstart = obj[_pre + _touchstart + id],
		    touchend = obj[_pre + _touchend + id],
		    dblclick = obj[_pre + 'dblclick' + id];

		obj.removeEventListener(_touchstart, touchstart, false);
		obj.removeEventListener(_touchend, touchend, false);
		if (!edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}

	/*
	 * @namespace DomEvent
	 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
	 */

	// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	function on(obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				addOne(obj, type, types[type], fn);
			}
		} else {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				addOne(obj, types[i], fn, context);
			}
		}

		return this;
	}

	var eventsKey = '_leaflet_events';

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	function off(obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				removeOne(obj, type, types[type], fn);
			}
		} else if (types) {
			types = splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				removeOne(obj, types[i], fn, context);
			}
		} else {
			for (var j in obj[eventsKey]) {
				removeOne(obj, j, obj[eventsKey][j]);
			}
			delete obj[eventsKey];
		}

		return this;
	}

	function addOne(obj, type, fn, context) {
		var id = type + stamp(fn) + (context ? '_' + stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (pointer && type.indexOf('touch') === 0) {
			// Needs DomEvent.Pointer.js
			addPointerListener(obj, type, handler, id);

		} else if (touch && (type === 'dblclick') && addDoubleTapListener &&
		           !(pointer && chrome)) {
			// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
			// See #5180
			addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && android) {
					handler = function (e) {
						filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;
	}

	function removeOne(obj, type, fn, context) {

		var id = type + stamp(fn) + (context ? '_' + stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (pointer && type.indexOf('touch') === 0) {
			removePointerListener(obj, type, id);

		} else if (touch && (type === 'dblclick') && removeDoubleTapListener &&
		           !(pointer && chrome)) {
			removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;
	}

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	function stopPropagation(e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		skipped(e);

		return this;
	}

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	function disableScrollPropagation(el) {
		addOne(el, 'mousewheel', stopPropagation);
		return this;
	}

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	function disableClickPropagation(el) {
		on(el, 'mousedown touchstart dblclick', stopPropagation);
		addOne(el, 'click', fakeStop);
		return this;
	}

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	function preventDefault(e) {
		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	}

	// @function stop(ev: DOMEvent): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	function stop(e) {
		preventDefault(e);
		stopPropagation(e);
		return this;
	}

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	function getMousePosition(e, container) {
		if (!container) {
			return new Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		var scaleX = rect.width / container.offsetWidth || 1;
		var scaleY = rect.height / container.offsetHeight || 1;
		return new Point(
			e.clientX / scaleX - rect.left - container.clientLeft,
			e.clientY / scaleY - rect.top - container.clientTop);
	}

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	var wheelPxFactor =
		(win && chrome) ? 2 * window.devicePixelRatio :
		gecko ? window.devicePixelRatio : 1;

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	function getWheelDelta(e) {
		return (edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	}

	var skipEvents = {};

	function fakeStop(e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with skipped(e)
		skipEvents[e.type] = true;
	}

	function skipped(e) {
		var events = skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		skipEvents[e.type] = false;
		return events;
	}

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	function isExternalTarget(el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	}

	var lastClick;

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	function filterClick(e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = lastClick && (timeStamp - lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			stop(e);
			return;
		}
		lastClick = timeStamp;

		handler(e);
	}




	var DomEvent = (Object.freeze || Object)({
		on: on,
		off: off,
		stopPropagation: stopPropagation,
		disableScrollPropagation: disableScrollPropagation,
		disableClickPropagation: disableClickPropagation,
		preventDefault: preventDefault,
		stop: stop,
		getMousePosition: getMousePosition,
		getWheelDelta: getWheelDelta,
		fakeStop: fakeStop,
		skipped: skipped,
		isExternalTarget: isExternalTarget,
		addListener: on,
		removeListener: off
	});

	/*
	 * @namespace DomUtil
	 *
	 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
	 * tree, used by Leaflet internally.
	 *
	 * Most functions expecting or returning a `HTMLElement` also work for
	 * SVG elements. The only difference is that classes refer to CSS classes
	 * in HTML and SVG classes in SVG.
	 */


	// @property TRANSFORM: String
	// Vendor-prefixed transform style name (e.g. `'webkitTransform'` for WebKit).
	var TRANSFORM = testProp(
		['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transition style name.
	var TRANSITION = testProp(
		['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	// @property TRANSITION_END: String
	// Vendor-prefixed transitionend event name.
	var TRANSITION_END =
		TRANSITION === 'webkitTransition' || TRANSITION === 'OTransition' ? TRANSITION + 'End' : 'transitionend';


	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	function get(id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	}

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	function getStyle(el, style) {
		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}
		return value === 'auto' ? null : value;
	}

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	function create$1(tagName, className, container) {
		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}
		return el;
	}

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	function remove(el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	}

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	function empty(el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	}

	// @function toFront(el: HTMLElement)
	// Makes `el` the last child of its parent, so it renders in front of the other children.
	function toFront(el) {
		var parent = el.parentNode;
		if (parent.lastChild !== el) {
			parent.appendChild(el);
		}
	}

	// @function toBack(el: HTMLElement)
	// Makes `el` the first child of its parent, so it renders behind the other children.
	function toBack(el) {
		var parent = el.parentNode;
		if (parent.firstChild !== el) {
			parent.insertBefore(el, parent.firstChild);
		}
	}

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	function hasClass(el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	}

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	function addClass(el, name) {
		if (el.classList !== undefined) {
			var classes = splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!hasClass(el, name)) {
			var className = getClass(el);
			setClass(el, (className ? className + ' ' : '') + name);
		}
	}

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	function removeClass(el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			setClass(el, trim((' ' + getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	}

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	function setClass(el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	}

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	function getClass(el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	}

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	function setOpacity(el, value) {
		if ('opacity' in el.style) {
			el.style.opacity = value;
		} else if ('filter' in el.style) {
			_setOpacityIE(el, value);
		}
	}

	function _setOpacityIE(el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	}

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	function testProp(props) {
		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	}

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	function setTransform(el, offset, scale) {
		var pos = offset || new Point(0, 0);

		el.style[TRANSFORM] =
			(ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	}

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	function setPosition(el, point) {

		/*eslint-disable */
		el._leaflet_pos = point;
		/* eslint-enable */

		if (any3d) {
			setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	}

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	function getPosition(el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new Point(0, 0);
	}

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	var disableTextSelection;
	var enableTextSelection;
	var _userSelect;
	if ('onselectstart' in document) {
		disableTextSelection = function () {
			on(window, 'selectstart', preventDefault);
		};
		enableTextSelection = function () {
			off(window, 'selectstart', preventDefault);
		};
	} else {
		var userSelectProperty = testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				_userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = _userSelect;
				_userSelect = undefined;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	function disableImageDrag() {
		on(window, 'dragstart', preventDefault);
	}

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	function enableImageDrag() {
		off(window, 'dragstart', preventDefault);
	}

	var _outlineElement;
	var _outlineStyle;
	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	function preventOutline(element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element.style) { return; }
		restoreOutline();
		_outlineElement = element;
		_outlineStyle = element.style.outline;
		element.style.outline = 'none';
		on(window, 'keydown', restoreOutline);
	}

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	function restoreOutline() {
		if (!_outlineElement) { return; }
		_outlineElement.style.outline = _outlineStyle;
		_outlineElement = undefined;
		_outlineStyle = undefined;
		off(window, 'keydown', restoreOutline);
	}


	var DomUtil = (Object.freeze || Object)({
		TRANSFORM: TRANSFORM,
		TRANSITION: TRANSITION,
		TRANSITION_END: TRANSITION_END,
		get: get,
		getStyle: getStyle,
		create: create$1,
		remove: remove,
		empty: empty,
		toFront: toFront,
		toBack: toBack,
		hasClass: hasClass,
		addClass: addClass,
		removeClass: removeClass,
		setClass: setClass,
		getClass: getClass,
		setOpacity: setOpacity,
		testProp: testProp,
		setTransform: setTransform,
		setPosition: setPosition,
		getPosition: getPosition,
		disableTextSelection: disableTextSelection,
		enableTextSelection: enableTextSelection,
		disableImageDrag: disableImageDrag,
		enableImageDrag: enableImageDrag,
		preventOutline: preventOutline,
		restoreOutline: restoreOutline
	});

	/*
	 * @class PosAnimation
	 * @aka L.PosAnimation
	 * @inherits Evented
	 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
	 *
	 * @example
	 * ```js
	 * var fx = new L.PosAnimation();
	 * fx.run(el, [300, 500], 0.5);
	 * ```
	 *
	 * @constructor L.PosAnimation()
	 * Creates a `PosAnimation` object.
	 *
	 */

	var PosAnimation = Evented.extend({

		// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
		// Run an animation of a given element to a new position, optionally setting
		// duration in seconds (`0.25` by default) and easing linearity factor (3rd
		// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
		// `0.5` by default).
		run: function (el, newPos, duration, easeLinearity) {
			this.stop();

			this._el = el;
			this._inProgress = true;
			this._duration = duration || 0.25;
			this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

			this._startPos = getPosition(el);
			this._offset = newPos.subtract(this._startPos);
			this._startTime = +new Date();

			// @event start: Event
			// Fired when the animation starts
			this.fire('start');

			this._animate();
		},

		// @method stop()
		// Stops the animation (if currently running).
		stop: function () {
			if (!this._inProgress) { return; }

			this._step(true);
			this._complete();
		},

		_animate: function () {
			// animation loop
			this._animId = requestAnimFrame(this._animate, this);
			this._step();
		},

		_step: function (round) {
			var elapsed = (+new Date()) - this._startTime,
			    duration = this._duration * 1000;

			if (elapsed < duration) {
				this._runFrame(this._easeOut(elapsed / duration), round);
			} else {
				this._runFrame(1);
				this._complete();
			}
		},

		_runFrame: function (progress, round) {
			var pos = this._startPos.add(this._offset.multiplyBy(progress));
			if (round) {
				pos._round();
			}
			setPosition(this._el, pos);

			// @event step: Event
			// Fired continuously during the animation.
			this.fire('step');
		},

		_complete: function () {
			cancelAnimFrame(this._animId);

			this._inProgress = false;
			// @event end: Event
			// Fired when the animation ends.
			this.fire('end');
		},

		_easeOut: function (t) {
			return 1 - Math.pow(1 - t, this._easeOutPower);
		}
	});

	/*
	 * @class Map
	 * @aka L.Map
	 * @inherits Evented
	 *
	 * The central class of the API — it is used to create a map on a page and manipulate it.
	 *
	 * @example
	 *
	 * ```js
	 * // initialize the map on the "map" div with a given center and zoom
	 * var map = L.map('map', {
	 * 	center: [51.505, -0.09],
	 * 	zoom: 13
	 * });
	 * ```
	 *
	 */

	var Map = Evented.extend({

		options: {
			// @section Map State Options
			// @option crs: CRS = L.CRS.EPSG3857
			// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
			// sure what it means.
			crs: EPSG3857,

			// @option center: LatLng = undefined
			// Initial geographic center of the map
			center: undefined,

			// @option zoom: Number = undefined
			// Initial map zoom level
			zoom: undefined,

			// @option minZoom: Number = *
			// Minimum zoom level of the map.
			// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
			// the lowest of their `minZoom` options will be used instead.
			minZoom: undefined,

			// @option maxZoom: Number = *
			// Maximum zoom level of the map.
			// If not specified and at least one `GridLayer` or `TileLayer` is in the map,
			// the highest of their `maxZoom` options will be used instead.
			maxZoom: undefined,

			// @option layers: Layer[] = []
			// Array of layers that will be added to the map initially
			layers: [],

			// @option maxBounds: LatLngBounds = null
			// When this option is set, the map restricts the view to the given
			// geographical bounds, bouncing the user back if the user tries to pan
			// outside the view. To set the restriction dynamically, use
			// [`setMaxBounds`](#map-setmaxbounds) method.
			maxBounds: undefined,

			// @option renderer: Renderer = *
			// The default method for drawing vector layers on the map. `L.SVG`
			// or `L.Canvas` by default depending on browser support.
			renderer: undefined,


			// @section Animation Options
			// @option zoomAnimation: Boolean = true
			// Whether the map zoom animation is enabled. By default it's enabled
			// in all browsers that support CSS3 Transitions except Android.
			zoomAnimation: true,

			// @option zoomAnimationThreshold: Number = 4
			// Won't animate zoom if the zoom difference exceeds this value.
			zoomAnimationThreshold: 4,

			// @option fadeAnimation: Boolean = true
			// Whether the tile fade animation is enabled. By default it's enabled
			// in all browsers that support CSS3 Transitions except Android.
			fadeAnimation: true,

			// @option markerZoomAnimation: Boolean = true
			// Whether markers animate their zoom with the zoom animation, if disabled
			// they will disappear for the length of the animation. By default it's
			// enabled in all browsers that support CSS3 Transitions except Android.
			markerZoomAnimation: true,

			// @option transform3DLimit: Number = 2^23
			// Defines the maximum size of a CSS translation transform. The default
			// value should not be changed unless a web browser positions layers in
			// the wrong place after doing a large `panBy`.
			transform3DLimit: 8388608, // Precision limit of a 32-bit float

			// @section Interaction Options
			// @option zoomSnap: Number = 1
			// Forces the map's zoom level to always be a multiple of this, particularly
			// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
			// By default, the zoom level snaps to the nearest integer; lower values
			// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
			// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
			zoomSnap: 1,

			// @option zoomDelta: Number = 1
			// Controls how much the map's zoom level will change after a
			// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
			// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
			// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
			zoomDelta: 1,

			// @option trackResize: Boolean = true
			// Whether the map automatically handles browser window resize to update itself.
			trackResize: true
		},

		initialize: function (id, options) { // (HTMLElement or String, Object)
			options = setOptions(this, options);

			this._initContainer(id);
			this._initLayout();

			// hack for https://github.com/Leaflet/Leaflet/issues/1980
			this._onResize = bind(this._onResize, this);

			this._initEvents();

			if (options.maxBounds) {
				this.setMaxBounds(options.maxBounds);
			}

			if (options.zoom !== undefined) {
				this._zoom = this._limitZoom(options.zoom);
			}

			if (options.center && options.zoom !== undefined) {
				this.setView(toLatLng(options.center), options.zoom, {reset: true});
			}

			this._handlers = [];
			this._layers = {};
			this._zoomBoundLayers = {};
			this._sizeChanged = true;

			this.callInitHooks();

			// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
			this._zoomAnimated = TRANSITION && any3d && !mobileOpera &&
					this.options.zoomAnimation;

			// zoom transitions run with the same duration for all layers, so if one of transitionend events
			// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
			if (this._zoomAnimated) {
				this._createAnimProxy();
				on(this._proxy, TRANSITION_END, this._catchTransitionEnd, this);
			}

			this._addLayers(this.options.layers);
		},


		// @section Methods for modifying map state

		// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
		// Sets the view of the map (geographical center and zoom) with the given
		// animation options.
		setView: function (center, zoom, options) {

			zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
			center = this._limitCenter(toLatLng(center), zoom, this.options.maxBounds);
			options = options || {};

			this._stop();

			if (this._loaded && !options.reset && options !== true) {

				if (options.animate !== undefined) {
					options.zoom = extend({animate: options.animate}, options.zoom);
					options.pan = extend({animate: options.animate, duration: options.duration}, options.pan);
				}

				// try animating pan or zoom
				var moved = (this._zoom !== zoom) ?
					this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
					this._tryAnimatedPan(center, options.pan);

				if (moved) {
					// prevent resize handler call, the view will refresh after animation anyway
					clearTimeout(this._sizeTimer);
					return this;
				}
			}

			// animation didn't start, just reset the map view
			this._resetView(center, zoom);

			return this;
		},

		// @method setZoom(zoom: Number, options?: Zoom/pan options): this
		// Sets the zoom of the map.
		setZoom: function (zoom, options) {
			if (!this._loaded) {
				this._zoom = zoom;
				return this;
			}
			return this.setView(this.getCenter(), zoom, {zoom: options});
		},

		// @method zoomIn(delta?: Number, options?: Zoom options): this
		// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
		zoomIn: function (delta, options) {
			delta = delta || (any3d ? this.options.zoomDelta : 1);
			return this.setZoom(this._zoom + delta, options);
		},

		// @method zoomOut(delta?: Number, options?: Zoom options): this
		// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
		zoomOut: function (delta, options) {
			delta = delta || (any3d ? this.options.zoomDelta : 1);
			return this.setZoom(this._zoom - delta, options);
		},

		// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
		// Zooms the map while keeping a specified geographical point on the map
		// stationary (e.g. used internally for scroll zoom and double-click zoom).
		// @alternative
		// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
		// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
		setZoomAround: function (latlng, zoom, options) {
			var scale = this.getZoomScale(zoom),
			    viewHalf = this.getSize().divideBy(2),
			    containerPoint = latlng instanceof Point ? latlng : this.latLngToContainerPoint(latlng),

			    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
			    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

			return this.setView(newCenter, zoom, {zoom: options});
		},

		_getBoundsCenterZoom: function (bounds, options) {

			options = options || {};
			bounds = bounds.getBounds ? bounds.getBounds() : toLatLngBounds(bounds);

			var paddingTL = toPoint(options.paddingTopLeft || options.padding || [0, 0]),
			    paddingBR = toPoint(options.paddingBottomRight || options.padding || [0, 0]),

			    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

			zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

			if (zoom === Infinity) {
				return {
					center: bounds.getCenter(),
					zoom: zoom
				};
			}

			var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

			    swPoint = this.project(bounds.getSouthWest(), zoom),
			    nePoint = this.project(bounds.getNorthEast(), zoom),
			    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

			return {
				center: center,
				zoom: zoom
			};
		},

		// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
		// Sets a map view that contains the given geographical bounds with the
		// maximum zoom level possible.
		fitBounds: function (bounds, options) {

			bounds = toLatLngBounds(bounds);

			if (!bounds.isValid()) {
				throw new Error('Bounds are not valid.');
			}

			var target = this._getBoundsCenterZoom(bounds, options);
			return this.setView(target.center, target.zoom, options);
		},

		// @method fitWorld(options?: fitBounds options): this
		// Sets a map view that mostly contains the whole world with the maximum
		// zoom level possible.
		fitWorld: function (options) {
			return this.fitBounds([[-90, -180], [90, 180]], options);
		},

		// @method panTo(latlng: LatLng, options?: Pan options): this
		// Pans the map to a given center.
		panTo: function (center, options) { // (LatLng)
			return this.setView(center, this._zoom, {pan: options});
		},

		// @method panBy(offset: Point, options?: Pan options): this
		// Pans the map by a given number of pixels (animated).
		panBy: function (offset, options) {
			offset = toPoint(offset).round();
			options = options || {};

			if (!offset.x && !offset.y) {
				return this.fire('moveend');
			}
			// If we pan too far, Chrome gets issues with tiles
			// and makes them disappear or appear in the wrong place (slightly offset) #2602
			if (options.animate !== true && !this.getSize().contains(offset)) {
				this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
				return this;
			}

			if (!this._panAnim) {
				this._panAnim = new PosAnimation();

				this._panAnim.on({
					'step': this._onPanTransitionStep,
					'end': this._onPanTransitionEnd
				}, this);
			}

			// don't fire movestart if animating inertia
			if (!options.noMoveStart) {
				this.fire('movestart');
			}

			// animate pan unless animate: false specified
			if (options.animate !== false) {
				addClass(this._mapPane, 'leaflet-pan-anim');

				var newPos = this._getMapPanePos().subtract(offset).round();
				this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
			} else {
				this._rawPanBy(offset);
				this.fire('move').fire('moveend');
			}

			return this;
		},

		// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
		// Sets the view of the map (geographical center and zoom) performing a smooth
		// pan-zoom animation.
		flyTo: function (targetCenter, targetZoom, options) {

			options = options || {};
			if (options.animate === false || !any3d) {
				return this.setView(targetCenter, targetZoom, options);
			}

			this._stop();

			var from = this.project(this.getCenter()),
			    to = this.project(targetCenter),
			    size = this.getSize(),
			    startZoom = this._zoom;

			targetCenter = toLatLng(targetCenter);
			targetZoom = targetZoom === undefined ? startZoom : targetZoom;

			var w0 = Math.max(size.x, size.y),
			    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
			    u1 = (to.distanceTo(from)) || 1,
			    rho = 1.42,
			    rho2 = rho * rho;

			function r(i) {
				var s1 = i ? -1 : 1,
				    s2 = i ? w1 : w0,
				    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
				    b1 = 2 * s2 * rho2 * u1,
				    b = t1 / b1,
				    sq = Math.sqrt(b * b + 1) - b;

				    // workaround for floating point precision bug when sq = 0, log = -Infinite,
				    // thus triggering an infinite loop in flyTo
				    var log = sq < 0.000000001 ? -18 : Math.log(sq);

				return log;
			}

			function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
			function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
			function tanh(n) { return sinh(n) / cosh(n); }

			var r0 = r(0);

			function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
			function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

			function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

			var start = Date.now(),
			    S = (r(1) - r0) / rho,
			    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

			function frame() {
				var t = (Date.now() - start) / duration,
				    s = easeOut(t) * S;

				if (t <= 1) {
					this._flyToFrame = requestAnimFrame(frame, this);

					this._move(
						this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
						this.getScaleZoom(w0 / w(s), startZoom),
						{flyTo: true});

				} else {
					this
						._move(targetCenter, targetZoom)
						._moveEnd(true);
				}
			}

			this._moveStart(true, options.noMoveStart);

			frame.call(this);
			return this;
		},

		// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
		// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
		// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
		flyToBounds: function (bounds, options) {
			var target = this._getBoundsCenterZoom(bounds, options);
			return this.flyTo(target.center, target.zoom, options);
		},

		// @method setMaxBounds(bounds: Bounds): this
		// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
		setMaxBounds: function (bounds) {
			bounds = toLatLngBounds(bounds);

			if (!bounds.isValid()) {
				this.options.maxBounds = null;
				return this.off('moveend', this._panInsideMaxBounds);
			} else if (this.options.maxBounds) {
				this.off('moveend', this._panInsideMaxBounds);
			}

			this.options.maxBounds = bounds;

			if (this._loaded) {
				this._panInsideMaxBounds();
			}

			return this.on('moveend', this._panInsideMaxBounds);
		},

		// @method setMinZoom(zoom: Number): this
		// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
		setMinZoom: function (zoom) {
			var oldZoom = this.options.minZoom;
			this.options.minZoom = zoom;

			if (this._loaded && oldZoom !== zoom) {
				this.fire('zoomlevelschange');

				if (this.getZoom() < this.options.minZoom) {
					return this.setZoom(zoom);
				}
			}

			return this;
		},

		// @method setMaxZoom(zoom: Number): this
		// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
		setMaxZoom: function (zoom) {
			var oldZoom = this.options.maxZoom;
			this.options.maxZoom = zoom;

			if (this._loaded && oldZoom !== zoom) {
				this.fire('zoomlevelschange');

				if (this.getZoom() > this.options.maxZoom) {
					return this.setZoom(zoom);
				}
			}

			return this;
		},

		// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
		// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
		panInsideBounds: function (bounds, options) {
			this._enforcingBounds = true;
			var center = this.getCenter(),
			    newCenter = this._limitCenter(center, this._zoom, toLatLngBounds(bounds));

			if (!center.equals(newCenter)) {
				this.panTo(newCenter, options);
			}

			this._enforcingBounds = false;
			return this;
		},

		// @method invalidateSize(options: Zoom/pan options): this
		// Checks if the map container size changed and updates the map if so —
		// call it after you've changed the map size dynamically, also animating
		// pan by default. If `options.pan` is `false`, panning will not occur.
		// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
		// that it doesn't happen often even if the method is called many
		// times in a row.

		// @alternative
		// @method invalidateSize(animate: Boolean): this
		// Checks if the map container size changed and updates the map if so —
		// call it after you've changed the map size dynamically, also animating
		// pan by default.
		invalidateSize: function (options) {
			if (!this._loaded) { return this; }

			options = extend({
				animate: false,
				pan: true
			}, options === true ? {animate: true} : options);

			var oldSize = this.getSize();
			this._sizeChanged = true;
			this._lastCenter = null;

			var newSize = this.getSize(),
			    oldCenter = oldSize.divideBy(2).round(),
			    newCenter = newSize.divideBy(2).round(),
			    offset = oldCenter.subtract(newCenter);

			if (!offset.x && !offset.y) { return this; }

			if (options.animate && options.pan) {
				this.panBy(offset);

			} else {
				if (options.pan) {
					this._rawPanBy(offset);
				}

				this.fire('move');

				if (options.debounceMoveend) {
					clearTimeout(this._sizeTimer);
					this._sizeTimer = setTimeout(bind(this.fire, this, 'moveend'), 200);
				} else {
					this.fire('moveend');
				}
			}

			// @section Map state change events
			// @event resize: ResizeEvent
			// Fired when the map is resized.
			return this.fire('resize', {
				oldSize: oldSize,
				newSize: newSize
			});
		},

		// @section Methods for modifying map state
		// @method stop(): this
		// Stops the currently running `panTo` or `flyTo` animation, if any.
		stop: function () {
			this.setZoom(this._limitZoom(this._zoom));
			if (!this.options.zoomSnap) {
				this.fire('viewreset');
			}
			return this._stop();
		},

		// @section Geolocation methods
		// @method locate(options?: Locate options): this
		// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
		// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
		// and optionally sets the map view to the user's location with respect to
		// detection accuracy (or to the world view if geolocation failed).
		// Note that, if your page doesn't use HTTPS, this method will fail in
		// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
		// See `Locate options` for more details.
		locate: function (options) {

			options = this._locateOptions = extend({
				timeout: 10000,
				watch: false
				// setView: false
				// maxZoom: <Number>
				// maximumAge: 0
				// enableHighAccuracy: false
			}, options);

			if (!('geolocation' in navigator)) {
				this._handleGeolocationError({
					code: 0,
					message: 'Geolocation not supported.'
				});
				return this;
			}

			var onResponse = bind(this._handleGeolocationResponse, this),
			    onError = bind(this._handleGeolocationError, this);

			if (options.watch) {
				this._locationWatchId =
				        navigator.geolocation.watchPosition(onResponse, onError, options);
			} else {
				navigator.geolocation.getCurrentPosition(onResponse, onError, options);
			}
			return this;
		},

		// @method stopLocate(): this
		// Stops watching location previously initiated by `map.locate({watch: true})`
		// and aborts resetting the map view if map.locate was called with
		// `{setView: true}`.
		stopLocate: function () {
			if (navigator.geolocation && navigator.geolocation.clearWatch) {
				navigator.geolocation.clearWatch(this._locationWatchId);
			}
			if (this._locateOptions) {
				this._locateOptions.setView = false;
			}
			return this;
		},

		_handleGeolocationError: function (error) {
			var c = error.code,
			    message = error.message ||
			            (c === 1 ? 'permission denied' :
			            (c === 2 ? 'position unavailable' : 'timeout'));

			if (this._locateOptions.setView && !this._loaded) {
				this.fitWorld();
			}

			// @section Location events
			// @event locationerror: ErrorEvent
			// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
			this.fire('locationerror', {
				code: c,
				message: 'Geolocation error: ' + message + '.'
			});
		},

		_handleGeolocationResponse: function (pos) {
			var lat = pos.coords.latitude,
			    lng = pos.coords.longitude,
			    latlng = new LatLng(lat, lng),
			    bounds = latlng.toBounds(pos.coords.accuracy),
			    options = this._locateOptions;

			if (options.setView) {
				var zoom = this.getBoundsZoom(bounds);
				this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
			}

			var data = {
				latlng: latlng,
				bounds: bounds,
				timestamp: pos.timestamp
			};

			for (var i in pos.coords) {
				if (typeof pos.coords[i] === 'number') {
					data[i] = pos.coords[i];
				}
			}

			// @event locationfound: LocationEvent
			// Fired when geolocation (using the [`locate`](#map-locate) method)
			// went successfully.
			this.fire('locationfound', data);
		},

		// TODO Appropriate docs section?
		// @section Other Methods
		// @method addHandler(name: String, HandlerClass: Function): this
		// Adds a new `Handler` to the map, given its name and constructor function.
		addHandler: function (name, HandlerClass) {
			if (!HandlerClass) { return this; }

			var handler = this[name] = new HandlerClass(this);

			this._handlers.push(handler);

			if (this.options[name]) {
				handler.enable();
			}

			return this;
		},

		// @method remove(): this
		// Destroys the map and clears all related event listeners.
		remove: function () {

			this._initEvents(true);

			if (this._containerId !== this._container._leaflet_id) {
				throw new Error('Map container is being reused by another instance');
			}

			try {
				// throws error in IE6-8
				delete this._container._leaflet_id;
				delete this._containerId;
			} catch (e) {
				/*eslint-disable */
				this._container._leaflet_id = undefined;
				/* eslint-enable */
				this._containerId = undefined;
			}

			if (this._locationWatchId !== undefined) {
				this.stopLocate();
			}

			this._stop();

			remove(this._mapPane);

			if (this._clearControlPos) {
				this._clearControlPos();
			}

			this._clearHandlers();

			if (this._loaded) {
				// @section Map state change events
				// @event unload: Event
				// Fired when the map is destroyed with [remove](#map-remove) method.
				this.fire('unload');
			}

			var i;
			for (i in this._layers) {
				this._layers[i].remove();
			}
			for (i in this._panes) {
				remove(this._panes[i]);
			}

			this._layers = [];
			this._panes = [];
			delete this._mapPane;
			delete this._renderer;

			return this;
		},

		// @section Other Methods
		// @method createPane(name: String, container?: HTMLElement): HTMLElement
		// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
		// then returns it. The pane is created as a child of `container`, or
		// as a child of the main map pane if not set.
		createPane: function (name, container) {
			var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
			    pane = create$1('div', className, container || this._mapPane);

			if (name) {
				this._panes[name] = pane;
			}
			return pane;
		},

		// @section Methods for Getting Map State

		// @method getCenter(): LatLng
		// Returns the geographical center of the map view
		getCenter: function () {
			this._checkIfLoaded();

			if (this._lastCenter && !this._moved()) {
				return this._lastCenter;
			}
			return this.layerPointToLatLng(this._getCenterLayerPoint());
		},

		// @method getZoom(): Number
		// Returns the current zoom level of the map view
		getZoom: function () {
			return this._zoom;
		},

		// @method getBounds(): LatLngBounds
		// Returns the geographical bounds visible in the current map view
		getBounds: function () {
			var bounds = this.getPixelBounds(),
			    sw = this.unproject(bounds.getBottomLeft()),
			    ne = this.unproject(bounds.getTopRight());

			return new LatLngBounds(sw, ne);
		},

		// @method getMinZoom(): Number
		// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
		getMinZoom: function () {
			return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
		},

		// @method getMaxZoom(): Number
		// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
		getMaxZoom: function () {
			return this.options.maxZoom === undefined ?
				(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
				this.options.maxZoom;
		},

		// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
		// Returns the maximum zoom level on which the given bounds fit to the map
		// view in its entirety. If `inside` (optional) is set to `true`, the method
		// instead returns the minimum zoom level on which the map view fits into
		// the given bounds in its entirety.
		getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
			bounds = toLatLngBounds(bounds);
			padding = toPoint(padding || [0, 0]);

			var zoom = this.getZoom() || 0,
			    min = this.getMinZoom(),
			    max = this.getMaxZoom(),
			    nw = bounds.getNorthWest(),
			    se = bounds.getSouthEast(),
			    size = this.getSize().subtract(padding),
			    boundsSize = toBounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
			    snap = any3d ? this.options.zoomSnap : 1,
			    scalex = size.x / boundsSize.x,
			    scaley = size.y / boundsSize.y,
			    scale = inside ? Math.max(scalex, scaley) : Math.min(scalex, scaley);

			zoom = this.getScaleZoom(scale, zoom);

			if (snap) {
				zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
				zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
			}

			return Math.max(min, Math.min(max, zoom));
		},

		// @method getSize(): Point
		// Returns the current size of the map container (in pixels).
		getSize: function () {
			if (!this._size || this._sizeChanged) {
				this._size = new Point(
					this._container.clientWidth || 0,
					this._container.clientHeight || 0);

				this._sizeChanged = false;
			}
			return this._size.clone();
		},

		// @method getPixelBounds(): Bounds
		// Returns the bounds of the current map view in projected pixel
		// coordinates (sometimes useful in layer and overlay implementations).
		getPixelBounds: function (center, zoom) {
			var topLeftPoint = this._getTopLeftPoint(center, zoom);
			return new Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
		},

		// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
		// the map pane? "left point of the map layer" can be confusing, specially
		// since there can be negative offsets.
		// @method getPixelOrigin(): Point
		// Returns the projected pixel coordinates of the top left point of
		// the map layer (useful in custom layer and overlay implementations).
		getPixelOrigin: function () {
			this._checkIfLoaded();
			return this._pixelOrigin;
		},

		// @method getPixelWorldBounds(zoom?: Number): Bounds
		// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
		// If `zoom` is omitted, the map's current zoom level is used.
		getPixelWorldBounds: function (zoom) {
			return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
		},

		// @section Other Methods

		// @method getPane(pane: String|HTMLElement): HTMLElement
		// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
		getPane: function (pane) {
			return typeof pane === 'string' ? this._panes[pane] : pane;
		},

		// @method getPanes(): Object
		// Returns a plain object containing the names of all [panes](#map-pane) as keys and
		// the panes as values.
		getPanes: function () {
			return this._panes;
		},

		// @method getContainer: HTMLElement
		// Returns the HTML element that contains the map.
		getContainer: function () {
			return this._container;
		},


		// @section Conversion Methods

		// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
		// Returns the scale factor to be applied to a map transition from zoom level
		// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
		getZoomScale: function (toZoom, fromZoom) {
			// TODO replace with universal implementation after refactoring projections
			var crs = this.options.crs;
			fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
			return crs.scale(toZoom) / crs.scale(fromZoom);
		},

		// @method getScaleZoom(scale: Number, fromZoom: Number): Number
		// Returns the zoom level that the map would end up at, if it is at `fromZoom`
		// level and everything is scaled by a factor of `scale`. Inverse of
		// [`getZoomScale`](#map-getZoomScale).
		getScaleZoom: function (scale, fromZoom) {
			var crs = this.options.crs;
			fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
			var zoom = crs.zoom(scale * crs.scale(fromZoom));
			return isNaN(zoom) ? Infinity : zoom;
		},

		// @method project(latlng: LatLng, zoom: Number): Point
		// Projects a geographical coordinate `LatLng` according to the projection
		// of the map's CRS, then scales it according to `zoom` and the CRS's
		// `Transformation`. The result is pixel coordinate relative to
		// the CRS origin.
		project: function (latlng, zoom) {
			zoom = zoom === undefined ? this._zoom : zoom;
			return this.options.crs.latLngToPoint(toLatLng(latlng), zoom);
		},

		// @method unproject(point: Point, zoom: Number): LatLng
		// Inverse of [`project`](#map-project).
		unproject: function (point, zoom) {
			zoom = zoom === undefined ? this._zoom : zoom;
			return this.options.crs.pointToLatLng(toPoint(point), zoom);
		},

		// @method layerPointToLatLng(point: Point): LatLng
		// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
		// returns the corresponding geographical coordinate (for the current zoom level).
		layerPointToLatLng: function (point) {
			var projectedPoint = toPoint(point).add(this.getPixelOrigin());
			return this.unproject(projectedPoint);
		},

		// @method latLngToLayerPoint(latlng: LatLng): Point
		// Given a geographical coordinate, returns the corresponding pixel coordinate
		// relative to the [origin pixel](#map-getpixelorigin).
		latLngToLayerPoint: function (latlng) {
			var projectedPoint = this.project(toLatLng(latlng))._round();
			return projectedPoint._subtract(this.getPixelOrigin());
		},

		// @method wrapLatLng(latlng: LatLng): LatLng
		// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
		// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
		// CRS's bounds.
		// By default this means longitude is wrapped around the dateline so its
		// value is between -180 and +180 degrees.
		wrapLatLng: function (latlng) {
			return this.options.crs.wrapLatLng(toLatLng(latlng));
		},

		// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
		// Returns a `LatLngBounds` with the same size as the given one, ensuring that
		// its center is within the CRS's bounds.
		// By default this means the center longitude is wrapped around the dateline so its
		// value is between -180 and +180 degrees, and the majority of the bounds
		// overlaps the CRS's bounds.
		wrapLatLngBounds: function (latlng) {
			return this.options.crs.wrapLatLngBounds(toLatLngBounds(latlng));
		},

		// @method distance(latlng1: LatLng, latlng2: LatLng): Number
		// Returns the distance between two geographical coordinates according to
		// the map's CRS. By default this measures distance in meters.
		distance: function (latlng1, latlng2) {
			return this.options.crs.distance(toLatLng(latlng1), toLatLng(latlng2));
		},

		// @method containerPointToLayerPoint(point: Point): Point
		// Given a pixel coordinate relative to the map container, returns the corresponding
		// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
		containerPointToLayerPoint: function (point) { // (Point)
			return toPoint(point).subtract(this._getMapPanePos());
		},

		// @method layerPointToContainerPoint(point: Point): Point
		// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
		// returns the corresponding pixel coordinate relative to the map container.
		layerPointToContainerPoint: function (point) { // (Point)
			return toPoint(point).add(this._getMapPanePos());
		},

		// @method containerPointToLatLng(point: Point): LatLng
		// Given a pixel coordinate relative to the map container, returns
		// the corresponding geographical coordinate (for the current zoom level).
		containerPointToLatLng: function (point) {
			var layerPoint = this.containerPointToLayerPoint(toPoint(point));
			return this.layerPointToLatLng(layerPoint);
		},

		// @method latLngToContainerPoint(latlng: LatLng): Point
		// Given a geographical coordinate, returns the corresponding pixel coordinate
		// relative to the map container.
		latLngToContainerPoint: function (latlng) {
			return this.layerPointToContainerPoint(this.latLngToLayerPoint(toLatLng(latlng)));
		},

		// @method mouseEventToContainerPoint(ev: MouseEvent): Point
		// Given a MouseEvent object, returns the pixel coordinate relative to the
		// map container where the event took place.
		mouseEventToContainerPoint: function (e) {
			return getMousePosition(e, this._container);
		},

		// @method mouseEventToLayerPoint(ev: MouseEvent): Point
		// Given a MouseEvent object, returns the pixel coordinate relative to
		// the [origin pixel](#map-getpixelorigin) where the event took place.
		mouseEventToLayerPoint: function (e) {
			return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
		},

		// @method mouseEventToLatLng(ev: MouseEvent): LatLng
		// Given a MouseEvent object, returns geographical coordinate where the
		// event took place.
		mouseEventToLatLng: function (e) { // (MouseEvent)
			return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
		},


		// map initialization methods

		_initContainer: function (id) {
			var container = this._container = get(id);

			if (!container) {
				throw new Error('Map container not found.');
			} else if (container._leaflet_id) {
				throw new Error('Map container is already initialized.');
			}

			on(container, 'scroll', this._onScroll, this);
			this._containerId = stamp(container);
		},

		_initLayout: function () {
			var container = this._container;

			this._fadeAnimated = this.options.fadeAnimation && any3d;

			addClass(container, 'leaflet-container' +
				(touch ? ' leaflet-touch' : '') +
				(retina ? ' leaflet-retina' : '') +
				(ielt9 ? ' leaflet-oldie' : '') +
				(safari ? ' leaflet-safari' : '') +
				(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

			var position = getStyle(container, 'position');

			if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
				container.style.position = 'relative';
			}

			this._initPanes();

			if (this._initControlPos) {
				this._initControlPos();
			}
		},

		_initPanes: function () {
			var panes = this._panes = {};
			this._paneRenderers = {};

			// @section
			//
			// Panes are DOM elements used to control the ordering of layers on the map. You
			// can access panes with [`map.getPane`](#map-getpane) or
			// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
			// [`map.createPane`](#map-createpane) method.
			//
			// Every map has the following default panes that differ only in zIndex.
			//
			// @pane mapPane: HTMLElement = 'auto'
			// Pane that contains all other map panes

			this._mapPane = this.createPane('mapPane', this._container);
			setPosition(this._mapPane, new Point(0, 0));

			// @pane tilePane: HTMLElement = 200
			// Pane for `GridLayer`s and `TileLayer`s
			this.createPane('tilePane');
			// @pane overlayPane: HTMLElement = 400
			// Pane for vectors (`Path`s, like `Polyline`s and `Polygon`s), `ImageOverlay`s and `VideoOverlay`s
			this.createPane('shadowPane');
			// @pane shadowPane: HTMLElement = 500
			// Pane for overlay shadows (e.g. `Marker` shadows)
			this.createPane('overlayPane');
			// @pane markerPane: HTMLElement = 600
			// Pane for `Icon`s of `Marker`s
			this.createPane('markerPane');
			// @pane tooltipPane: HTMLElement = 650
			// Pane for `Tooltip`s.
			this.createPane('tooltipPane');
			// @pane popupPane: HTMLElement = 700
			// Pane for `Popup`s.
			this.createPane('popupPane');

			if (!this.options.markerZoomAnimation) {
				addClass(panes.markerPane, 'leaflet-zoom-hide');
				addClass(panes.shadowPane, 'leaflet-zoom-hide');
			}
		},


		// private methods that modify map state

		// @section Map state change events
		_resetView: function (center, zoom) {
			setPosition(this._mapPane, new Point(0, 0));

			var loading = !this._loaded;
			this._loaded = true;
			zoom = this._limitZoom(zoom);

			this.fire('viewprereset');

			var zoomChanged = this._zoom !== zoom;
			this
				._moveStart(zoomChanged, false)
				._move(center, zoom)
				._moveEnd(zoomChanged);

			// @event viewreset: Event
			// Fired when the map needs to redraw its content (this usually happens
			// on map zoom or load). Very useful for creating custom overlays.
			this.fire('viewreset');

			// @event load: Event
			// Fired when the map is initialized (when its center and zoom are set
			// for the first time).
			if (loading) {
				this.fire('load');
			}
		},

		_moveStart: function (zoomChanged, noMoveStart) {
			// @event zoomstart: Event
			// Fired when the map zoom is about to change (e.g. before zoom animation).
			// @event movestart: Event
			// Fired when the view of the map starts changing (e.g. user starts dragging the map).
			if (zoomChanged) {
				this.fire('zoomstart');
			}
			if (!noMoveStart) {
				this.fire('movestart');
			}
			return this;
		},

		_move: function (center, zoom, data) {
			if (zoom === undefined) {
				zoom = this._zoom;
			}
			var zoomChanged = this._zoom !== zoom;

			this._zoom = zoom;
			this._lastCenter = center;
			this._pixelOrigin = this._getNewPixelOrigin(center);

			// @event zoom: Event
			// Fired repeatedly during any change in zoom level, including zoom
			// and fly animations.
			if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
				this.fire('zoom', data);
			}

			// @event move: Event
			// Fired repeatedly during any movement of the map, including pan and
			// fly animations.
			return this.fire('move', data);
		},

		_moveEnd: function (zoomChanged) {
			// @event zoomend: Event
			// Fired when the map has changed, after any animations.
			if (zoomChanged) {
				this.fire('zoomend');
			}

			// @event moveend: Event
			// Fired when the center of the map stops changing (e.g. user stopped
			// dragging the map).
			return this.fire('moveend');
		},

		_stop: function () {
			cancelAnimFrame(this._flyToFrame);
			if (this._panAnim) {
				this._panAnim.stop();
			}
			return this;
		},

		_rawPanBy: function (offset) {
			setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
		},

		_getZoomSpan: function () {
			return this.getMaxZoom() - this.getMinZoom();
		},

		_panInsideMaxBounds: function () {
			if (!this._enforcingBounds) {
				this.panInsideBounds(this.options.maxBounds);
			}
		},

		_checkIfLoaded: function () {
			if (!this._loaded) {
				throw new Error('Set map center and zoom first.');
			}
		},

		// DOM event handling

		// @section Interaction events
		_initEvents: function (remove$$1) {
			this._targets = {};
			this._targets[stamp(this._container)] = this;

			var onOff = remove$$1 ? off : on;

			// @event click: MouseEvent
			// Fired when the user clicks (or taps) the map.
			// @event dblclick: MouseEvent
			// Fired when the user double-clicks (or double-taps) the map.
			// @event mousedown: MouseEvent
			// Fired when the user pushes the mouse button on the map.
			// @event mouseup: MouseEvent
			// Fired when the user releases the mouse button on the map.
			// @event mouseover: MouseEvent
			// Fired when the mouse enters the map.
			// @event mouseout: MouseEvent
			// Fired when the mouse leaves the map.
			// @event mousemove: MouseEvent
			// Fired while the mouse moves over the map.
			// @event contextmenu: MouseEvent
			// Fired when the user pushes the right mouse button on the map, prevents
			// default browser context menu from showing if there are listeners on
			// this event. Also fired on mobile when the user holds a single touch
			// for a second (also called long press).
			// @event keypress: KeyboardEvent
			// Fired when the user presses a key from the keyboard while the map is focused.
			onOff(this._container, 'click dblclick mousedown mouseup ' +
				'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

			if (this.options.trackResize) {
				onOff(window, 'resize', this._onResize, this);
			}

			if (any3d && this.options.transform3DLimit) {
				(remove$$1 ? this.off : this.on).call(this, 'moveend', this._onMoveEnd);
			}
		},

		_onResize: function () {
			cancelAnimFrame(this._resizeRequest);
			this._resizeRequest = requestAnimFrame(
			        function () { this.invalidateSize({debounceMoveend: true}); }, this);
		},

		_onScroll: function () {
			this._container.scrollTop  = 0;
			this._container.scrollLeft = 0;
		},

		_onMoveEnd: function () {
			var pos = this._getMapPanePos();
			if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
				// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
				// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
				this._resetView(this.getCenter(), this.getZoom());
			}
		},

		_findEventTargets: function (e, type) {
			var targets = [],
			    target,
			    isHover = type === 'mouseout' || type === 'mouseover',
			    src = e.target || e.srcElement,
			    dragging = false;

			while (src) {
				target = this._targets[stamp(src)];
				if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
					// Prevent firing click after you just dragged an object.
					dragging = true;
					break;
				}
				if (target && target.listens(type, true)) {
					if (isHover && !isExternalTarget(src, e)) { break; }
					targets.push(target);
					if (isHover) { break; }
				}
				if (src === this._container) { break; }
				src = src.parentNode;
			}
			if (!targets.length && !dragging && !isHover && isExternalTarget(src, e)) {
				targets = [this];
			}
			return targets;
		},

		_handleDOMEvent: function (e) {
			if (!this._loaded || skipped(e)) { return; }

			var type = e.type;

			if (type === 'mousedown' || type === 'keypress') {
				// prevents outline when clicking on keyboard-focusable element
				preventOutline(e.target || e.srcElement);
			}

			this._fireDOMEvent(e, type);
		},

		_mouseEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu'],

		_fireDOMEvent: function (e, type, targets) {

			if (e.type === 'click') {
				// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
				// @event preclick: MouseEvent
				// Fired before mouse click on the map (sometimes useful when you
				// want something to happen on click before any existing click
				// handlers start running).
				var synth = extend({}, e);
				synth.type = 'preclick';
				this._fireDOMEvent(synth, synth.type, targets);
			}

			if (e._stopped) { return; }

			// Find the layer the event is propagating from and its parents.
			targets = (targets || []).concat(this._findEventTargets(e, type));

			if (!targets.length) { return; }

			var target = targets[0];
			if (type === 'contextmenu' && target.listens(type, true)) {
				preventDefault(e);
			}

			var data = {
				originalEvent: e
			};

			if (e.type !== 'keypress') {
				var isMarker = target.getLatLng && (!target._radius || target._radius <= 10);
				data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
				data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
				data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
			}

			for (var i = 0; i < targets.length; i++) {
				targets[i].fire(type, data, true);
				if (data.originalEvent._stopped ||
					(targets[i].options.bubblingMouseEvents === false && indexOf(this._mouseEvents, type) !== -1)) { return; }
			}
		},

		_draggableMoved: function (obj) {
			obj = obj.dragging && obj.dragging.enabled() ? obj : this;
			return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
		},

		_clearHandlers: function () {
			for (var i = 0, len = this._handlers.length; i < len; i++) {
				this._handlers[i].disable();
			}
		},

		// @section Other Methods

		// @method whenReady(fn: Function, context?: Object): this
		// Runs the given function `fn` when the map gets initialized with
		// a view (center and zoom) and at least one layer, or immediately
		// if it's already initialized, optionally passing a function context.
		whenReady: function (callback, context) {
			if (this._loaded) {
				callback.call(context || this, {target: this});
			} else {
				this.on('load', callback, context);
			}
			return this;
		},


		// private methods for getting map state

		_getMapPanePos: function () {
			return getPosition(this._mapPane) || new Point(0, 0);
		},

		_moved: function () {
			var pos = this._getMapPanePos();
			return pos && !pos.equals([0, 0]);
		},

		_getTopLeftPoint: function (center, zoom) {
			var pixelOrigin = center && zoom !== undefined ?
				this._getNewPixelOrigin(center, zoom) :
				this.getPixelOrigin();
			return pixelOrigin.subtract(this._getMapPanePos());
		},

		_getNewPixelOrigin: function (center, zoom) {
			var viewHalf = this.getSize()._divideBy(2);
			return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
		},

		_latLngToNewLayerPoint: function (latlng, zoom, center) {
			var topLeft = this._getNewPixelOrigin(center, zoom);
			return this.project(latlng, zoom)._subtract(topLeft);
		},

		_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
			var topLeft = this._getNewPixelOrigin(center, zoom);
			return toBounds([
				this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
				this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
			]);
		},

		// layer point of the current center
		_getCenterLayerPoint: function () {
			return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
		},

		// offset of the specified place to the current center in pixels
		_getCenterOffset: function (latlng) {
			return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
		},

		// adjust center for view to get inside bounds
		_limitCenter: function (center, zoom, bounds) {

			if (!bounds) { return center; }

			var centerPoint = this.project(center, zoom),
			    viewHalf = this.getSize().divideBy(2),
			    viewBounds = new Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
			    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

			// If offset is less than a pixel, ignore.
			// This prevents unstable projections from getting into
			// an infinite loop of tiny offsets.
			if (offset.round().equals([0, 0])) {
				return center;
			}

			return this.unproject(centerPoint.add(offset), zoom);
		},

		// adjust offset for view to get inside bounds
		_limitOffset: function (offset, bounds) {
			if (!bounds) { return offset; }

			var viewBounds = this.getPixelBounds(),
			    newBounds = new Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

			return offset.add(this._getBoundsOffset(newBounds, bounds));
		},

		// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
		_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
			var projectedMaxBounds = toBounds(
			        this.project(maxBounds.getNorthEast(), zoom),
			        this.project(maxBounds.getSouthWest(), zoom)
			    ),
			    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
			    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

			    dx = this._rebound(minOffset.x, -maxOffset.x),
			    dy = this._rebound(minOffset.y, -maxOffset.y);

			return new Point(dx, dy);
		},

		_rebound: function (left, right) {
			return left + right > 0 ?
				Math.round(left - right) / 2 :
				Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
		},

		_limitZoom: function (zoom) {
			var min = this.getMinZoom(),
			    max = this.getMaxZoom(),
			    snap = any3d ? this.options.zoomSnap : 1;
			if (snap) {
				zoom = Math.round(zoom / snap) * snap;
			}
			return Math.max(min, Math.min(max, zoom));
		},

		_onPanTransitionStep: function () {
			this.fire('move');
		},

		_onPanTransitionEnd: function () {
			removeClass(this._mapPane, 'leaflet-pan-anim');
			this.fire('moveend');
		},

		_tryAnimatedPan: function (center, options) {
			// difference between the new and current centers in pixels
			var offset = this._getCenterOffset(center)._trunc();

			// don't animate too far unless animate: true specified in options
			if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

			this.panBy(offset, options);

			return true;
		},

		_createAnimProxy: function () {

			var proxy = this._proxy = create$1('div', 'leaflet-proxy leaflet-zoom-animated');
			this._panes.mapPane.appendChild(proxy);

			this.on('zoomanim', function (e) {
				var prop = TRANSFORM,
				    transform = this._proxy.style[prop];

				setTransform(this._proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

				// workaround for case when transform is the same and so transitionend event is not fired
				if (transform === this._proxy.style[prop] && this._animatingZoom) {
					this._onZoomTransitionEnd();
				}
			}, this);

			this.on('load moveend', function () {
				var c = this.getCenter(),
				    z = this.getZoom();
				setTransform(this._proxy, this.project(c, z), this.getZoomScale(z, 1));
			}, this);

			this._on('unload', this._destroyAnimProxy, this);
		},

		_destroyAnimProxy: function () {
			remove(this._proxy);
			delete this._proxy;
		},

		_catchTransitionEnd: function (e) {
			if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
				this._onZoomTransitionEnd();
			}
		},

		_nothingToAnimate: function () {
			return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
		},

		_tryAnimatedZoom: function (center, zoom, options) {

			if (this._animatingZoom) { return true; }

			options = options || {};

			// don't animate if disabled, not supported or zoom difference is too large
			if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
			        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

			// offset is the pixel coords of the zoom origin relative to the current center
			var scale = this.getZoomScale(zoom),
			    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

			// don't animate if the zoom origin isn't within one screen from the current center, unless forced
			if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

			requestAnimFrame(function () {
				this
				    ._moveStart(true, false)
				    ._animateZoom(center, zoom, true);
			}, this);

			return true;
		},

		_animateZoom: function (center, zoom, startAnim, noUpdate) {
			if (!this._mapPane) { return; }

			if (startAnim) {
				this._animatingZoom = true;

				// remember what center/zoom to set after animation
				this._animateToCenter = center;
				this._animateToZoom = zoom;

				addClass(this._mapPane, 'leaflet-zoom-anim');
			}

			// @event zoomanim: ZoomAnimEvent
			// Fired on every frame of a zoom animation
			this.fire('zoomanim', {
				center: center,
				zoom: zoom,
				noUpdate: noUpdate
			});

			// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
			setTimeout(bind(this._onZoomTransitionEnd, this), 250);
		},

		_onZoomTransitionEnd: function () {
			if (!this._animatingZoom) { return; }

			if (this._mapPane) {
				removeClass(this._mapPane, 'leaflet-zoom-anim');
			}

			this._animatingZoom = false;

			this._move(this._animateToCenter, this._animateToZoom);

			// This anim frame should prevent an obscure iOS webkit tile loading race condition.
			requestAnimFrame(function () {
				this._moveEnd(true);
			}, this);
		}
	});

	// @section

	// @factory L.map(id: String, options?: Map options)
	// Instantiates a map object given the DOM ID of a `<div>` element
	// and optionally an object literal with `Map options`.
	//
	// @alternative
	// @factory L.map(el: HTMLElement, options?: Map options)
	// Instantiates a map object given an instance of a `<div>` HTML element
	// and optionally an object literal with `Map options`.
	function createMap(id, options) {
		return new Map(id, options);
	}

	/*
	 * @class Control
	 * @aka L.Control
	 * @inherits Class
	 *
	 * L.Control is a base class for implementing map controls. Handles positioning.
	 * All other controls extend from this class.
	 */

	var Control = Class.extend({
		// @section
		// @aka Control options
		options: {
			// @option position: String = 'topright'
			// The position of the control (one of the map corners). Possible values are `'topleft'`,
			// `'topright'`, `'bottomleft'` or `'bottomright'`
			position: 'topright'
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		/* @section
		 * Classes extending L.Control will inherit the following methods:
		 *
		 * @method getPosition: string
		 * Returns the position of the control.
		 */
		getPosition: function () {
			return this.options.position;
		},

		// @method setPosition(position: string): this
		// Sets the position of the control.
		setPosition: function (position) {
			var map = this._map;

			if (map) {
				map.removeControl(this);
			}

			this.options.position = position;

			if (map) {
				map.addControl(this);
			}

			return this;
		},

		// @method getContainer: HTMLElement
		// Returns the HTMLElement that contains the control.
		getContainer: function () {
			return this._container;
		},

		// @method addTo(map: Map): this
		// Adds the control to the given map.
		addTo: function (map) {
			this.remove();
			this._map = map;

			var container = this._container = this.onAdd(map),
			    pos = this.getPosition(),
			    corner = map._controlCorners[pos];

			addClass(container, 'leaflet-control');

			if (pos.indexOf('bottom') !== -1) {
				corner.insertBefore(container, corner.firstChild);
			} else {
				corner.appendChild(container);
			}

			return this;
		},

		// @method remove: this
		// Removes the control from the map it is currently active on.
		remove: function () {
			if (!this._map) {
				return this;
			}

			remove(this._container);

			if (this.onRemove) {
				this.onRemove(this._map);
			}

			this._map = null;

			return this;
		},

		_refocusOnMap: function (e) {
			// if map exists and event is not a keyboard event
			if (this._map && e && e.screenX > 0 && e.screenY > 0) {
				this._map.getContainer().focus();
			}
		}
	});

	var control = function (options) {
		return new Control(options);
	};

	/* @section Extension methods
	 * @uninheritable
	 *
	 * Every control should extend from `L.Control` and (re-)implement the following methods.
	 *
	 * @method onAdd(map: Map): HTMLElement
	 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
	 *
	 * @method onRemove(map: Map)
	 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
	 */

	/* @namespace Map
	 * @section Methods for Layers and Controls
	 */
	Map.include({
		// @method addControl(control: Control): this
		// Adds the given control to the map
		addControl: function (control) {
			control.addTo(this);
			return this;
		},

		// @method removeControl(control: Control): this
		// Removes the given control from the map
		removeControl: function (control) {
			control.remove();
			return this;
		},

		_initControlPos: function () {
			var corners = this._controlCorners = {},
			    l = 'leaflet-',
			    container = this._controlContainer =
			            create$1('div', l + 'control-container', this._container);

			function createCorner(vSide, hSide) {
				var className = l + vSide + ' ' + l + hSide;

				corners[vSide + hSide] = create$1('div', className, container);
			}

			createCorner('top', 'left');
			createCorner('top', 'right');
			createCorner('bottom', 'left');
			createCorner('bottom', 'right');
		},

		_clearControlPos: function () {
			for (var i in this._controlCorners) {
				remove(this._controlCorners[i]);
			}
			remove(this._controlContainer);
			delete this._controlCorners;
			delete this._controlContainer;
		}
	});

	/*
	 * @class Control.Layers
	 * @aka L.Control.Layers
	 * @inherits Control
	 *
	 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control/)). Extends `Control`.
	 *
	 * @example
	 *
	 * ```js
	 * var baseLayers = {
	 * 	"Mapbox": mapbox,
	 * 	"OpenStreetMap": osm
	 * };
	 *
	 * var overlays = {
	 * 	"Marker": marker,
	 * 	"Roads": roadsLayer
	 * };
	 *
	 * L.control.layers(baseLayers, overlays).addTo(map);
	 * ```
	 *
	 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
	 *
	 * ```js
	 * {
	 *     "<someName1>": layer1,
	 *     "<someName2>": layer2
	 * }
	 * ```
	 *
	 * The layer names can contain HTML, which allows you to add additional styling to the items:
	 *
	 * ```js
	 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
	 * ```
	 */

	var Layers = Control.extend({
		// @section
		// @aka Control.Layers options
		options: {
			// @option collapsed: Boolean = true
			// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
			collapsed: true,
			position: 'topright',

			// @option autoZIndex: Boolean = true
			// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
			autoZIndex: true,

			// @option hideSingleBase: Boolean = false
			// If `true`, the base layers in the control will be hidden when there is only one.
			hideSingleBase: false,

			// @option sortLayers: Boolean = false
			// Whether to sort the layers. When `false`, layers will keep the order
			// in which they were added to the control.
			sortLayers: false,

			// @option sortFunction: Function = *
			// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
			// that will be used for sorting the layers, when `sortLayers` is `true`.
			// The function receives both the `L.Layer` instances and their names, as in
			// `sortFunction(layerA, layerB, nameA, nameB)`.
			// By default, it sorts layers alphabetically by their name.
			sortFunction: function (layerA, layerB, nameA, nameB) {
				return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
			}
		},

		initialize: function (baseLayers, overlays, options) {
			setOptions(this, options);

			this._layerControlInputs = [];
			this._layers = [];
			this._lastZIndex = 0;
			this._handlingClick = false;

			for (var i in baseLayers) {
				this._addLayer(baseLayers[i], i);
			}

			for (i in overlays) {
				this._addLayer(overlays[i], i, true);
			}
		},

		onAdd: function (map) {
			this._initLayout();
			this._update();

			this._map = map;
			map.on('zoomend', this._checkDisabledLayers, this);

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].layer.on('add remove', this._onLayerChange, this);
			}

			return this._container;
		},

		addTo: function (map) {
			Control.prototype.addTo.call(this, map);
			// Trigger expand after Layers Control has been inserted into DOM so that is now has an actual height.
			return this._expandIfNotCollapsed();
		},

		onRemove: function () {
			this._map.off('zoomend', this._checkDisabledLayers, this);

			for (var i = 0; i < this._layers.length; i++) {
				this._layers[i].layer.off('add remove', this._onLayerChange, this);
			}
		},

		// @method addBaseLayer(layer: Layer, name: String): this
		// Adds a base layer (radio button entry) with the given name to the control.
		addBaseLayer: function (layer, name) {
			this._addLayer(layer, name);
			return (this._map) ? this._update() : this;
		},

		// @method addOverlay(layer: Layer, name: String): this
		// Adds an overlay (checkbox entry) with the given name to the control.
		addOverlay: function (layer, name) {
			this._addLayer(layer, name, true);
			return (this._map) ? this._update() : this;
		},

		// @method removeLayer(layer: Layer): this
		// Remove the given layer from the control.
		removeLayer: function (layer) {
			layer.off('add remove', this._onLayerChange, this);

			var obj = this._getLayer(stamp(layer));
			if (obj) {
				this._layers.splice(this._layers.indexOf(obj), 1);
			}
			return (this._map) ? this._update() : this;
		},

		// @method expand(): this
		// Expand the control container if collapsed.
		expand: function () {
			addClass(this._container, 'leaflet-control-layers-expanded');
			this._form.style.height = null;
			var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
			if (acceptableHeight < this._form.clientHeight) {
				addClass(this._form, 'leaflet-control-layers-scrollbar');
				this._form.style.height = acceptableHeight + 'px';
			} else {
				removeClass(this._form, 'leaflet-control-layers-scrollbar');
			}
			this._checkDisabledLayers();
			return this;
		},

		// @method collapse(): this
		// Collapse the control container if expanded.
		collapse: function () {
			removeClass(this._container, 'leaflet-control-layers-expanded');
			return this;
		},

		_initLayout: function () {
			var className = 'leaflet-control-layers',
			    container = this._container = create$1('div', className),
			    collapsed = this.options.collapsed;

			// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
			container.setAttribute('aria-haspopup', true);

			disableClickPropagation(container);
			disableScrollPropagation(container);

			var form = this._form = create$1('form', className + '-list');

			if (collapsed) {
				this._map.on('click', this.collapse, this);

				if (!android) {
					on(container, {
						mouseenter: this.expand,
						mouseleave: this.collapse
					}, this);
				}
			}

			var link = this._layersLink = create$1('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (touch) {
				on(link, 'click', stop);
				on(link, 'click', this.expand, this);
			} else {
				on(link, 'focus', this.expand, this);
			}

			if (!collapsed) {
				this.expand();
			}

			this._baseLayersList = create$1('div', className + '-base', form);
			this._separator = create$1('div', className + '-separator', form);
			this._overlaysList = create$1('div', className + '-overlays', form);

			container.appendChild(form);
		},

		_getLayer: function (id) {
			for (var i = 0; i < this._layers.length; i++) {

				if (this._layers[i] && stamp(this._layers[i].layer) === id) {
					return this._layers[i];
				}
			}
		},

		_addLayer: function (layer, name, overlay) {
			if (this._map) {
				layer.on('add remove', this._onLayerChange, this);
			}

			this._layers.push({
				layer: layer,
				name: name,
				overlay: overlay
			});

			if (this.options.sortLayers) {
				this._layers.sort(bind(function (a, b) {
					return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
				}, this));
			}

			if (this.options.autoZIndex && layer.setZIndex) {
				this._lastZIndex++;
				layer.setZIndex(this._lastZIndex);
			}

			this._expandIfNotCollapsed();
		},

		_update: function () {
			if (!this._container) { return this; }

			empty(this._baseLayersList);
			empty(this._overlaysList);

			this._layerControlInputs = [];
			var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

			for (i = 0; i < this._layers.length; i++) {
				obj = this._layers[i];
				this._addItem(obj);
				overlaysPresent = overlaysPresent || obj.overlay;
				baseLayersPresent = baseLayersPresent || !obj.overlay;
				baseLayersCount += !obj.overlay ? 1 : 0;
			}

			// Hide base layers section if there's only one layer.
			if (this.options.hideSingleBase) {
				baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
				this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
			}

			this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

			return this;
		},

		_onLayerChange: function (e) {
			if (!this._handlingClick) {
				this._update();
			}

			var obj = this._getLayer(stamp(e.target));

			// @namespace Map
			// @section Layer events
			// @event baselayerchange: LayersControlEvent
			// Fired when the base layer is changed through the [layer control](#control-layers).
			// @event overlayadd: LayersControlEvent
			// Fired when an overlay is selected through the [layer control](#control-layers).
			// @event overlayremove: LayersControlEvent
			// Fired when an overlay is deselected through the [layer control](#control-layers).
			// @namespace Control.Layers
			var type = obj.overlay ?
				(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
				(e.type === 'add' ? 'baselayerchange' : null);

			if (type) {
				this._map.fire(type, obj);
			}
		},

		// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
		_createRadioElement: function (name, checked) {

			var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
					name + '"' + (checked ? ' checked="checked"' : '') + '/>';

			var radioFragment = document.createElement('div');
			radioFragment.innerHTML = radioHtml;

			return radioFragment.firstChild;
		},

		_addItem: function (obj) {
			var label = document.createElement('label'),
			    checked = this._map.hasLayer(obj.layer),
			    input;

			if (obj.overlay) {
				input = document.createElement('input');
				input.type = 'checkbox';
				input.className = 'leaflet-control-layers-selector';
				input.defaultChecked = checked;
			} else {
				input = this._createRadioElement('leaflet-base-layers', checked);
			}

			this._layerControlInputs.push(input);
			input.layerId = stamp(obj.layer);

			on(input, 'click', this._onInputClick, this);

			var name = document.createElement('span');
			name.innerHTML = ' ' + obj.name;

			// Helps from preventing layer control flicker when checkboxes are disabled
			// https://github.com/Leaflet/Leaflet/issues/2771
			var holder = document.createElement('div');

			label.appendChild(holder);
			holder.appendChild(input);
			holder.appendChild(name);

			var container = obj.overlay ? this._overlaysList : this._baseLayersList;
			container.appendChild(label);

			this._checkDisabledLayers();
			return label;
		},

		_onInputClick: function () {
			var inputs = this._layerControlInputs,
			    input, layer;
			var addedLayers = [],
			    removedLayers = [];

			this._handlingClick = true;

			for (var i = inputs.length - 1; i >= 0; i--) {
				input = inputs[i];
				layer = this._getLayer(input.layerId).layer;

				if (input.checked) {
					addedLayers.push(layer);
				} else if (!input.checked) {
					removedLayers.push(layer);
				}
			}

			// Bugfix issue 2318: Should remove all old layers before readding new ones
			for (i = 0; i < removedLayers.length; i++) {
				if (this._map.hasLayer(removedLayers[i])) {
					this._map.removeLayer(removedLayers[i]);
				}
			}
			for (i = 0; i < addedLayers.length; i++) {
				if (!this._map.hasLayer(addedLayers[i])) {
					this._map.addLayer(addedLayers[i]);
				}
			}

			this._handlingClick = false;

			this._refocusOnMap();
		},

		_checkDisabledLayers: function () {
			var inputs = this._layerControlInputs,
			    input,
			    layer,
			    zoom = this._map.getZoom();

			for (var i = inputs.length - 1; i >= 0; i--) {
				input = inputs[i];
				layer = this._getLayer(input.layerId).layer;
				input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
				                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

			}
		},

		_expandIfNotCollapsed: function () {
			if (this._map && !this.options.collapsed) {
				this.expand();
			}
			return this;
		},

		_expand: function () {
			// Backward compatibility, remove me in 1.1.
			return this.expand();
		},

		_collapse: function () {
			// Backward compatibility, remove me in 1.1.
			return this.collapse();
		}

	});


	// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
	// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
	var layers = function (baseLayers, overlays, options) {
		return new Layers(baseLayers, overlays, options);
	};

	/*
	 * @class Control.Zoom
	 * @aka L.Control.Zoom
	 * @inherits Control
	 *
	 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
	 */

	var Zoom = Control.extend({
		// @section
		// @aka Control.Zoom options
		options: {
			position: 'topleft',

			// @option zoomInText: String = '+'
			// The text set on the 'zoom in' button.
			zoomInText: '+',

			// @option zoomInTitle: String = 'Zoom in'
			// The title set on the 'zoom in' button.
			zoomInTitle: 'Zoom in',

			// @option zoomOutText: String = '&#x2212;'
			// The text set on the 'zoom out' button.
			zoomOutText: '&#x2212;',

			// @option zoomOutTitle: String = 'Zoom out'
			// The title set on the 'zoom out' button.
			zoomOutTitle: 'Zoom out'
		},

		onAdd: function (map) {
			var zoomName = 'leaflet-control-zoom',
			    container = create$1('div', zoomName + ' leaflet-bar'),
			    options = this.options;

			this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
			        zoomName + '-in',  container, this._zoomIn);
			this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
			        zoomName + '-out', container, this._zoomOut);

			this._updateDisabled();
			map.on('zoomend zoomlevelschange', this._updateDisabled, this);

			return container;
		},

		onRemove: function (map) {
			map.off('zoomend zoomlevelschange', this._updateDisabled, this);
		},

		disable: function () {
			this._disabled = true;
			this._updateDisabled();
			return this;
		},

		enable: function () {
			this._disabled = false;
			this._updateDisabled();
			return this;
		},

		_zoomIn: function (e) {
			if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
				this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
			}
		},

		_zoomOut: function (e) {
			if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
				this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
			}
		},

		_createButton: function (html, title, className, container, fn) {
			var link = create$1('a', className, container);
			link.innerHTML = html;
			link.href = '#';
			link.title = title;

			/*
			 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
			 */
			link.setAttribute('role', 'button');
			link.setAttribute('aria-label', title);

			disableClickPropagation(link);
			on(link, 'click', stop);
			on(link, 'click', fn, this);
			on(link, 'click', this._refocusOnMap, this);

			return link;
		},

		_updateDisabled: function () {
			var map = this._map,
			    className = 'leaflet-disabled';

			removeClass(this._zoomInButton, className);
			removeClass(this._zoomOutButton, className);

			if (this._disabled || map._zoom === map.getMinZoom()) {
				addClass(this._zoomOutButton, className);
			}
			if (this._disabled || map._zoom === map.getMaxZoom()) {
				addClass(this._zoomInButton, className);
			}
		}
	});

	// @namespace Map
	// @section Control options
	// @option zoomControl: Boolean = true
	// Whether a [zoom control](#control-zoom) is added to the map by default.
	Map.mergeOptions({
		zoomControl: true
	});

	Map.addInitHook(function () {
		if (this.options.zoomControl) {
			this.zoomControl = new Zoom();
			this.addControl(this.zoomControl);
		}
	});

	// @namespace Control.Zoom
	// @factory L.control.zoom(options: Control.Zoom options)
	// Creates a zoom control
	var zoom = function (options) {
		return new Zoom(options);
	};

	/*
	 * @class Control.Scale
	 * @aka L.Control.Scale
	 * @inherits Control
	 *
	 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
	 *
	 * @example
	 *
	 * ```js
	 * L.control.scale().addTo(map);
	 * ```
	 */

	var Scale = Control.extend({
		// @section
		// @aka Control.Scale options
		options: {
			position: 'bottomleft',

			// @option maxWidth: Number = 100
			// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
			maxWidth: 100,

			// @option metric: Boolean = True
			// Whether to show the metric scale line (m/km).
			metric: true,

			// @option imperial: Boolean = True
			// Whether to show the imperial scale line (mi/ft).
			imperial: true

			// @option updateWhenIdle: Boolean = false
			// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
		},

		onAdd: function (map) {
			var className = 'leaflet-control-scale',
			    container = create$1('div', className),
			    options = this.options;

			this._addScales(options, className + '-line', container);

			map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
			map.whenReady(this._update, this);

			return container;
		},

		onRemove: function (map) {
			map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		},

		_addScales: function (options, className, container) {
			if (options.metric) {
				this._mScale = create$1('div', className, container);
			}
			if (options.imperial) {
				this._iScale = create$1('div', className, container);
			}
		},

		_update: function () {
			var map = this._map,
			    y = map.getSize().y / 2;

			var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

			this._updateScales(maxMeters);
		},

		_updateScales: function (maxMeters) {
			if (this.options.metric && maxMeters) {
				this._updateMetric(maxMeters);
			}
			if (this.options.imperial && maxMeters) {
				this._updateImperial(maxMeters);
			}
		},

		_updateMetric: function (maxMeters) {
			var meters = this._getRoundNum(maxMeters),
			    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

			this._updateScale(this._mScale, label, meters / maxMeters);
		},

		_updateImperial: function (maxMeters) {
			var maxFeet = maxMeters * 3.2808399,
			    maxMiles, miles, feet;

			if (maxFeet > 5280) {
				maxMiles = maxFeet / 5280;
				miles = this._getRoundNum(maxMiles);
				this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

			} else {
				feet = this._getRoundNum(maxFeet);
				this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
			}
		},

		_updateScale: function (scale, text, ratio) {
			scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
			scale.innerHTML = text;
		},

		_getRoundNum: function (num) {
			var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
			    d = num / pow10;

			d = d >= 10 ? 10 :
			    d >= 5 ? 5 :
			    d >= 3 ? 3 :
			    d >= 2 ? 2 : 1;

			return pow10 * d;
		}
	});


	// @factory L.control.scale(options?: Control.Scale options)
	// Creates an scale control with the given options.
	var scale = function (options) {
		return new Scale(options);
	};

	/*
	 * @class Control.Attribution
	 * @aka L.Control.Attribution
	 * @inherits Control
	 *
	 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
	 */

	var Attribution = Control.extend({
		// @section
		// @aka Control.Attribution options
		options: {
			position: 'bottomright',

			// @option prefix: String = 'Leaflet'
			// The HTML text shown before the attributions. Pass `false` to disable.
			prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
		},

		initialize: function (options) {
			setOptions(this, options);

			this._attributions = {};
		},

		onAdd: function (map) {
			map.attributionControl = this;
			this._container = create$1('div', 'leaflet-control-attribution');
			disableClickPropagation(this._container);

			// TODO ugly, refactor
			for (var i in map._layers) {
				if (map._layers[i].getAttribution) {
					this.addAttribution(map._layers[i].getAttribution());
				}
			}

			this._update();

			return this._container;
		},

		// @method setPrefix(prefix: String): this
		// Sets the text before the attributions.
		setPrefix: function (prefix) {
			this.options.prefix = prefix;
			this._update();
			return this;
		},

		// @method addAttribution(text: String): this
		// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
		addAttribution: function (text) {
			if (!text) { return this; }

			if (!this._attributions[text]) {
				this._attributions[text] = 0;
			}
			this._attributions[text]++;

			this._update();

			return this;
		},

		// @method removeAttribution(text: String): this
		// Removes an attribution text.
		removeAttribution: function (text) {
			if (!text) { return this; }

			if (this._attributions[text]) {
				this._attributions[text]--;
				this._update();
			}

			return this;
		},

		_update: function () {
			if (!this._map) { return; }

			var attribs = [];

			for (var i in this._attributions) {
				if (this._attributions[i]) {
					attribs.push(i);
				}
			}

			var prefixAndAttribs = [];

			if (this.options.prefix) {
				prefixAndAttribs.push(this.options.prefix);
			}
			if (attribs.length) {
				prefixAndAttribs.push(attribs.join(', '));
			}

			this._container.innerHTML = prefixAndAttribs.join(' | ');
		}
	});

	// @namespace Map
	// @section Control options
	// @option attributionControl: Boolean = true
	// Whether a [attribution control](#control-attribution) is added to the map by default.
	Map.mergeOptions({
		attributionControl: true
	});

	Map.addInitHook(function () {
		if (this.options.attributionControl) {
			new Attribution().addTo(this);
		}
	});

	// @namespace Control.Attribution
	// @factory L.control.attribution(options: Control.Attribution options)
	// Creates an attribution control.
	var attribution = function (options) {
		return new Attribution(options);
	};

	Control.Layers = Layers;
	Control.Zoom = Zoom;
	Control.Scale = Scale;
	Control.Attribution = Attribution;

	control.layers = layers;
	control.zoom = zoom;
	control.scale = scale;
	control.attribution = attribution;

	/*
		L.Handler is a base class for handler classes that are used internally to inject
		interaction features like dragging to classes like Map and Marker.
	*/

	// @class Handler
	// @aka L.Handler
	// Abstract class for map interaction handlers

	var Handler = Class.extend({
		initialize: function (map) {
			this._map = map;
		},

		// @method enable(): this
		// Enables the handler
		enable: function () {
			if (this._enabled) { return this; }

			this._enabled = true;
			this.addHooks();
			return this;
		},

		// @method disable(): this
		// Disables the handler
		disable: function () {
			if (!this._enabled) { return this; }

			this._enabled = false;
			this.removeHooks();
			return this;
		},

		// @method enabled(): Boolean
		// Returns `true` if the handler is enabled
		enabled: function () {
			return !!this._enabled;
		}

		// @section Extension methods
		// Classes inheriting from `Handler` must implement the two following methods:
		// @method addHooks()
		// Called when the handler is enabled, should add event hooks.
		// @method removeHooks()
		// Called when the handler is disabled, should remove the event hooks added previously.
	});

	// @section There is static function which can be called without instantiating L.Handler:
	// @function addTo(map: Map, name: String): this
	// Adds a new Handler to the given map with the given name.
	Handler.addTo = function (map, name) {
		map.addHandler(name, this);
		return this;
	};

	var Mixin = {Events: Events};

	/*
	 * @class Draggable
	 * @aka L.Draggable
	 * @inherits Evented
	 *
	 * A class for making DOM elements draggable (including touch support).
	 * Used internally for map and marker dragging. Only works for elements
	 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
	 *
	 * @example
	 * ```js
	 * var draggable = new L.Draggable(elementToDrag);
	 * draggable.enable();
	 * ```
	 */

	var START = touch ? 'touchstart mousedown' : 'mousedown';
	var END = {
		mousedown: 'mouseup',
		touchstart: 'touchend',
		pointerdown: 'touchend',
		MSPointerDown: 'touchend'
	};
	var MOVE = {
		mousedown: 'mousemove',
		touchstart: 'touchmove',
		pointerdown: 'touchmove',
		MSPointerDown: 'touchmove'
	};


	var Draggable = Evented.extend({

		options: {
			// @section
			// @aka Draggable options
			// @option clickTolerance: Number = 3
			// The max number of pixels a user can shift the mouse pointer during a click
			// for it to be considered a valid click (as opposed to a mouse drag).
			clickTolerance: 3
		},

		// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline?: Boolean, options?: Draggable options)
		// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
		initialize: function (element, dragStartTarget, preventOutline$$1, options) {
			setOptions(this, options);

			this._element = element;
			this._dragStartTarget = dragStartTarget || element;
			this._preventOutline = preventOutline$$1;
		},

		// @method enable()
		// Enables the dragging ability
		enable: function () {
			if (this._enabled) { return; }

			on(this._dragStartTarget, START, this._onDown, this);

			this._enabled = true;
		},

		// @method disable()
		// Disables the dragging ability
		disable: function () {
			if (!this._enabled) { return; }

			// If we're currently dragging this draggable,
			// disabling it counts as first ending the drag.
			if (Draggable._dragging === this) {
				this.finishDrag();
			}

			off(this._dragStartTarget, START, this._onDown, this);

			this._enabled = false;
			this._moved = false;
		},

		_onDown: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }

			this._moved = false;

			if (hasClass(this._element, 'leaflet-zoom-anim')) { return; }

			if (Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
			Draggable._dragging = this;  // Prevent dragging multiple objects at once.

			if (this._preventOutline) {
				preventOutline(this._element);
			}

			disableImageDrag();
			disableTextSelection();

			if (this._moving) { return; }

			// @event down: Event
			// Fired when a drag is about to start.
			this.fire('down');

			var first = e.touches ? e.touches[0] : e;

			this._startPoint = new Point(first.clientX, first.clientY);

			on(document, MOVE[e.type], this._onMove, this);
			on(document, END[e.type], this._onUp, this);
		},

		_onMove: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }

			if (e.touches && e.touches.length > 1) {
				this._moved = true;
				return;
			}

			var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
			    newPoint = new Point(first.clientX, first.clientY),
			    offset = newPoint.subtract(this._startPoint);

			if (!offset.x && !offset.y) { return; }
			if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

			preventDefault(e);

			if (!this._moved) {
				// @event dragstart: Event
				// Fired when a drag starts
				this.fire('dragstart');

				this._moved = true;
				this._startPos = getPosition(this._element).subtract(offset);

				addClass(document.body, 'leaflet-dragging');

				this._lastTarget = e.target || e.srcElement;
				// IE and Edge do not give the <use> element, so fetch it
				// if necessary
				if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
					this._lastTarget = this._lastTarget.correspondingUseElement;
				}
				addClass(this._lastTarget, 'leaflet-drag-target');
			}

			this._newPos = this._startPos.add(offset);
			this._moving = true;

			cancelAnimFrame(this._animRequest);
			this._lastEvent = e;
			this._animRequest = requestAnimFrame(this._updatePosition, this, true);
		},

		_updatePosition: function () {
			var e = {originalEvent: this._lastEvent};

			// @event predrag: Event
			// Fired continuously during dragging *before* each corresponding
			// update of the element's position.
			this.fire('predrag', e);
			setPosition(this._element, this._newPos);

			// @event drag: Event
			// Fired continuously during dragging.
			this.fire('drag', e);
		},

		_onUp: function (e) {
			// Ignore simulated events, since we handle both touch and
			// mouse explicitly; otherwise we risk getting duplicates of
			// touch events, see #4315.
			// Also ignore the event if disabled; this happens in IE11
			// under some circumstances, see #3666.
			if (e._simulated || !this._enabled) { return; }
			this.finishDrag();
		},

		finishDrag: function () {
			removeClass(document.body, 'leaflet-dragging');

			if (this._lastTarget) {
				removeClass(this._lastTarget, 'leaflet-drag-target');
				this._lastTarget = null;
			}

			for (var i in MOVE) {
				off(document, MOVE[i], this._onMove, this);
				off(document, END[i], this._onUp, this);
			}

			enableImageDrag();
			enableTextSelection();

			if (this._moved && this._moving) {
				// ensure drag is not fired after dragend
				cancelAnimFrame(this._animRequest);

				// @event dragend: DragEndEvent
				// Fired when the drag ends.
				this.fire('dragend', {
					distance: this._newPos.distanceTo(this._startPos)
				});
			}

			this._moving = false;
			Draggable._dragging = false;
		}

	});

	/*
	 * @namespace LineUtil
	 *
	 * Various utility functions for polyline points processing, used by Leaflet internally to make polylines lightning-fast.
	 */

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	function simplify(points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		    // stage 1: vertex reduction
		    points = _reducePoints(points, sqTolerance);

		    // stage 2: Douglas-Peucker simplification
		    points = _simplifyDP(points, sqTolerance);

		return points;
	}

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	function pointToSegmentDistance(p, p1, p2) {
		return Math.sqrt(_sqClosestPointOnSegment(p, p1, p2, true));
	}

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	function closestPointOnSegment(p, p1, p2) {
		return _sqClosestPointOnSegment(p, p1, p2);
	}

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	function _simplifyDP(points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		    markers[0] = markers[len - 1] = 1;

		_simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	}

	function _simplifyDPStep(points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = _sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			_simplifyDPStep(points, markers, sqTolerance, first, index);
			_simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	}

	// reduce points that are too close to each other to a single point
	function _reducePoints(points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (_sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	}

	var _lastCode;

	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	function clipSegment(a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? _lastCode : _getBitCode(a, bounds),
		    codeB = _getBitCode(b, bounds),

		    codeOut, p, newCode;

		    // save 2nd code to avoid calculating it on the next segment
		    _lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = _getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = _getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	}

	function _getEdgeIntersection(a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new Point(x, y, round);
	}

	function _getBitCode(p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	}

	// square distance (to avoid unnecessary Math.sqrt calls)
	function _sqDist(p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	}

	// return closest point on segment or distance to that point
	function _sqClosestPointOnSegment(p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new Point(x, y);
	}


	// @function isFlat(latlngs: LatLng[]): Boolean
	// Returns true if `latlngs` is a flat array, false is nested.
	function isFlat(latlngs) {
		return !isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
	}

	function _flat(latlngs) {
		console.warn('Deprecated use of _flat, please use L.LineUtil.isFlat instead.');
		return isFlat(latlngs);
	}


	var LineUtil = (Object.freeze || Object)({
		simplify: simplify,
		pointToSegmentDistance: pointToSegmentDistance,
		closestPointOnSegment: closestPointOnSegment,
		clipSegment: clipSegment,
		_getEdgeIntersection: _getEdgeIntersection,
		_getBitCode: _getBitCode,
		_sqClosestPointOnSegment: _sqClosestPointOnSegment,
		isFlat: isFlat,
		_flat: _flat
	});

	/*
	 * @namespace PolyUtil
	 * Various utility functions for polygon geometries.
	 */

	/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
	 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
	 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
	 * performance. Note that polygon points needs different algorithm for clipping
	 * than polyline, so there's a separate method for it.
	 */
	function clipPolygon(points, bounds, round) {
		var clippedPoints,
		    edges = [1, 4, 2, 8],
		    i, j, k,
		    a, b,
		    len, edge, p;

		for (i = 0, len = points.length; i < len; i++) {
			points[i]._code = _getBitCode(points[i], bounds);
		}

		// for each edge (left, bottom, right, top)
		for (k = 0; k < 4; k++) {
			edge = edges[k];
			clippedPoints = [];

			for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
				a = points[i];
				b = points[j];

				// if a is inside the clip window
				if (!(a._code & edge)) {
					// if b is outside the clip window (a->b goes out of screen)
					if (b._code & edge) {
						p = _getEdgeIntersection(b, a, edge, bounds, round);
						p._code = _getBitCode(p, bounds);
						clippedPoints.push(p);
					}
					clippedPoints.push(a);

				// else if b is inside the clip window (a->b enters the screen)
				} else if (!(b._code & edge)) {
					p = _getEdgeIntersection(b, a, edge, bounds, round);
					p._code = _getBitCode(p, bounds);
					clippedPoints.push(p);
				}
			}
			points = clippedPoints;
		}

		return points;
	}


	var PolyUtil = (Object.freeze || Object)({
		clipPolygon: clipPolygon
	});

	/*
	 * @namespace Projection
	 * @section
	 * Leaflet comes with a set of already defined Projections out of the box:
	 *
	 * @projection L.Projection.LonLat
	 *
	 * Equirectangular, or Plate Carree projection — the most simple projection,
	 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
	 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
	 * `EPSG:4326` and `Simple` CRS.
	 */

	var LonLat = {
		project: function (latlng) {
			return new Point(latlng.lng, latlng.lat);
		},

		unproject: function (point) {
			return new LatLng(point.y, point.x);
		},

		bounds: new Bounds([-180, -90], [180, 90])
	};

	/*
	 * @namespace Projection
	 * @projection L.Projection.Mercator
	 *
	 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
	 */

	var Mercator = {
		R: 6378137,
		R_MINOR: 6356752.314245179,

		bounds: new Bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

		project: function (latlng) {
			var d = Math.PI / 180,
			    r = this.R,
			    y = latlng.lat * d,
			    tmp = this.R_MINOR / r,
			    e = Math.sqrt(1 - tmp * tmp),
			    con = e * Math.sin(y);

			var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
			y = -r * Math.log(Math.max(ts, 1E-10));

			return new Point(latlng.lng * d * r, y);
		},

		unproject: function (point) {
			var d = 180 / Math.PI,
			    r = this.R,
			    tmp = this.R_MINOR / r,
			    e = Math.sqrt(1 - tmp * tmp),
			    ts = Math.exp(-point.y / r),
			    phi = Math.PI / 2 - 2 * Math.atan(ts);

			for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
				con = e * Math.sin(phi);
				con = Math.pow((1 - con) / (1 + con), e / 2);
				dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
				phi += dphi;
			}

			return new LatLng(phi * d, point.x * d / r);
		}
	};

	/*
	 * @class Projection

	 * An object with methods for projecting geographical coordinates of the world onto
	 * a flat surface (and back). See [Map projection](http://en.wikipedia.org/wiki/Map_projection).

	 * @property bounds: Bounds
	 * The bounds (specified in CRS units) where the projection is valid

	 * @method project(latlng: LatLng): Point
	 * Projects geographical coordinates into a 2D point.
	 * Only accepts actual `L.LatLng` instances, not arrays.

	 * @method unproject(point: Point): LatLng
	 * The inverse of `project`. Projects a 2D point into a geographical location.
	 * Only accepts actual `L.Point` instances, not arrays.

	 * Note that the projection instances do not inherit from Leafet's `Class` object,
	 * and can't be instantiated. Also, new classes can't inherit from them,
	 * and methods can't be added to them with the `include` function.

	 */




	var index = (Object.freeze || Object)({
		LonLat: LonLat,
		Mercator: Mercator,
		SphericalMercator: SphericalMercator
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG3395
	 *
	 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
	 */
	var EPSG3395 = extend({}, Earth, {
		code: 'EPSG:3395',
		projection: Mercator,

		transformation: (function () {
			var scale = 0.5 / (Math.PI * Mercator.R);
			return toTransformation(scale, 0.5, -scale, 0.5);
		}())
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.EPSG4326
	 *
	 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
	 *
	 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
	 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
	 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
	 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
	 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
	 */

	var EPSG4326 = extend({}, Earth, {
		code: 'EPSG:4326',
		projection: LonLat,
		transformation: toTransformation(1 / 180, 1, -1 / 180, 0.5)
	});

	/*
	 * @namespace CRS
	 * @crs L.CRS.Simple
	 *
	 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
	 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
	 * axis should still be inverted (going from bottom to top). `distance()` returns
	 * simple euclidean distance.
	 */

	var Simple = extend({}, CRS, {
		projection: LonLat,
		transformation: toTransformation(1, 0, -1, 0),

		scale: function (zoom) {
			return Math.pow(2, zoom);
		},

		zoom: function (scale) {
			return Math.log(scale) / Math.LN2;
		},

		distance: function (latlng1, latlng2) {
			var dx = latlng2.lng - latlng1.lng,
			    dy = latlng2.lat - latlng1.lat;

			return Math.sqrt(dx * dx + dy * dy);
		},

		infinite: true
	});

	CRS.Earth = Earth;
	CRS.EPSG3395 = EPSG3395;
	CRS.EPSG3857 = EPSG3857;
	CRS.EPSG900913 = EPSG900913;
	CRS.EPSG4326 = EPSG4326;
	CRS.Simple = Simple;

	/*
	 * @class Layer
	 * @inherits Evented
	 * @aka L.Layer
	 * @aka ILayer
	 *
	 * A set of methods from the Layer base class that all Leaflet layers use.
	 * Inherits all methods, options and events from `L.Evented`.
	 *
	 * @example
	 *
	 * ```js
	 * var layer = L.Marker(latlng).addTo(map);
	 * layer.addTo(map);
	 * layer.remove();
	 * ```
	 *
	 * @event add: Event
	 * Fired after the layer is added to a map
	 *
	 * @event remove: Event
	 * Fired after the layer is removed from a map
	 */


	var Layer = Evented.extend({

		// Classes extending `L.Layer` will inherit the following options:
		options: {
			// @option pane: String = 'overlayPane'
			// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
			pane: 'overlayPane',

			// @option attribution: String = null
			// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
			attribution: null,

			bubblingMouseEvents: true
		},

		/* @section
		 * Classes extending `L.Layer` will inherit the following methods:
		 *
		 * @method addTo(map: Map|LayerGroup): this
		 * Adds the layer to the given map or layer group.
		 */
		addTo: function (map) {
			map.addLayer(this);
			return this;
		},

		// @method remove: this
		// Removes the layer from the map it is currently active on.
		remove: function () {
			return this.removeFrom(this._map || this._mapToAdd);
		},

		// @method removeFrom(map: Map): this
		// Removes the layer from the given map
		removeFrom: function (obj) {
			if (obj) {
				obj.removeLayer(this);
			}
			return this;
		},

		// @method getPane(name? : String): HTMLElement
		// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
		getPane: function (name) {
			return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
		},

		addInteractiveTarget: function (targetEl) {
			this._map._targets[stamp(targetEl)] = this;
			return this;
		},

		removeInteractiveTarget: function (targetEl) {
			delete this._map._targets[stamp(targetEl)];
			return this;
		},

		// @method getAttribution: String
		// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
		getAttribution: function () {
			return this.options.attribution;
		},

		_layerAdd: function (e) {
			var map = e.target;

			// check in case layer gets added and then removed before the map is ready
			if (!map.hasLayer(this)) { return; }

			this._map = map;
			this._zoomAnimated = map._zoomAnimated;

			if (this.getEvents) {
				var events = this.getEvents();
				map.on(events, this);
				this.once('remove', function () {
					map.off(events, this);
				}, this);
			}

			this.onAdd(map);

			if (this.getAttribution && map.attributionControl) {
				map.attributionControl.addAttribution(this.getAttribution());
			}

			this.fire('add');
			map.fire('layeradd', {layer: this});
		}
	});

	/* @section Extension methods
	 * @uninheritable
	 *
	 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
	 *
	 * @method onAdd(map: Map): this
	 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
	 *
	 * @method onRemove(map: Map): this
	 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
	 *
	 * @method getEvents(): Object
	 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
	 *
	 * @method getAttribution(): String
	 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
	 *
	 * @method beforeAdd(map: Map): this
	 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
	 */


	/* @namespace Map
	 * @section Layer events
	 *
	 * @event layeradd: LayerEvent
	 * Fired when a new layer is added to the map.
	 *
	 * @event layerremove: LayerEvent
	 * Fired when some layer is removed from the map
	 *
	 * @section Methods for Layers and Controls
	 */
	Map.include({
		// @method addLayer(layer: Layer): this
		// Adds the given layer to the map
		addLayer: function (layer) {
			if (!layer._layerAdd) {
				throw new Error('The provided object is not a Layer.');
			}

			var id = stamp(layer);
			if (this._layers[id]) { return this; }
			this._layers[id] = layer;

			layer._mapToAdd = this;

			if (layer.beforeAdd) {
				layer.beforeAdd(this);
			}

			this.whenReady(layer._layerAdd, layer);

			return this;
		},

		// @method removeLayer(layer: Layer): this
		// Removes the given layer from the map.
		removeLayer: function (layer) {
			var id = stamp(layer);

			if (!this._layers[id]) { return this; }

			if (this._loaded) {
				layer.onRemove(this);
			}

			if (layer.getAttribution && this.attributionControl) {
				this.attributionControl.removeAttribution(layer.getAttribution());
			}

			delete this._layers[id];

			if (this._loaded) {
				this.fire('layerremove', {layer: layer});
				layer.fire('remove');
			}

			layer._map = layer._mapToAdd = null;

			return this;
		},

		// @method hasLayer(layer: Layer): Boolean
		// Returns `true` if the given layer is currently added to the map
		hasLayer: function (layer) {
			return !!layer && (stamp(layer) in this._layers);
		},

		/* @method eachLayer(fn: Function, context?: Object): this
		 * Iterates over the layers of the map, optionally specifying context of the iterator function.
		 * ```
		 * map.eachLayer(function(layer){
		 *     layer.bindPopup('Hello');
		 * });
		 * ```
		 */
		eachLayer: function (method, context) {
			for (var i in this._layers) {
				method.call(context, this._layers[i]);
			}
			return this;
		},

		_addLayers: function (layers) {
			layers = layers ? (isArray(layers) ? layers : [layers]) : [];

			for (var i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		},

		_addZoomLimit: function (layer) {
			if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
				this._zoomBoundLayers[stamp(layer)] = layer;
				this._updateZoomLevels();
			}
		},

		_removeZoomLimit: function (layer) {
			var id = stamp(layer);

			if (this._zoomBoundLayers[id]) {
				delete this._zoomBoundLayers[id];
				this._updateZoomLevels();
			}
		},

		_updateZoomLevels: function () {
			var minZoom = Infinity,
			    maxZoom = -Infinity,
			    oldZoomSpan = this._getZoomSpan();

			for (var i in this._zoomBoundLayers) {
				var options = this._zoomBoundLayers[i].options;

				minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
				maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
			}

			this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
			this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

			// @section Map state change events
			// @event zoomlevelschange: Event
			// Fired when the number of zoomlevels on the map is changed due
			// to adding or removing a layer.
			if (oldZoomSpan !== this._getZoomSpan()) {
				this.fire('zoomlevelschange');
			}

			if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
				this.setZoom(this._layersMaxZoom);
			}
			if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
				this.setZoom(this._layersMinZoom);
			}
		}
	});

	/*
	 * @class LayerGroup
	 * @aka L.LayerGroup
	 * @inherits Layer
	 *
	 * Used to group several layers and handle them as one. If you add it to the map,
	 * any layers added or removed from the group will be added/removed on the map as
	 * well. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.layerGroup([marker1, marker2])
	 * 	.addLayer(polyline)
	 * 	.addTo(map);
	 * ```
	 */

	var LayerGroup = Layer.extend({

		initialize: function (layers, options) {
			setOptions(this, options);

			this._layers = {};

			var i, len;

			if (layers) {
				for (i = 0, len = layers.length; i < len; i++) {
					this.addLayer(layers[i]);
				}
			}
		},

		// @method addLayer(layer: Layer): this
		// Adds the given layer to the group.
		addLayer: function (layer) {
			var id = this.getLayerId(layer);

			this._layers[id] = layer;

			if (this._map) {
				this._map.addLayer(layer);
			}

			return this;
		},

		// @method removeLayer(layer: Layer): this
		// Removes the given layer from the group.
		// @alternative
		// @method removeLayer(id: Number): this
		// Removes the layer with the given internal ID from the group.
		removeLayer: function (layer) {
			var id = layer in this._layers ? layer : this.getLayerId(layer);

			if (this._map && this._layers[id]) {
				this._map.removeLayer(this._layers[id]);
			}

			delete this._layers[id];

			return this;
		},

		// @method hasLayer(layer: Layer): Boolean
		// Returns `true` if the given layer is currently added to the group.
		// @alternative
		// @method hasLayer(id: Number): Boolean
		// Returns `true` if the given internal ID is currently added to the group.
		hasLayer: function (layer) {
			return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
		},

		// @method clearLayers(): this
		// Removes all the layers from the group.
		clearLayers: function () {
			return this.eachLayer(this.removeLayer, this);
		},

		// @method invoke(methodName: String, …): this
		// Calls `methodName` on every layer contained in this group, passing any
		// additional parameters. Has no effect if the layers contained do not
		// implement `methodName`.
		invoke: function (methodName) {
			var args = Array.prototype.slice.call(arguments, 1),
			    i, layer;

			for (i in this._layers) {
				layer = this._layers[i];

				if (layer[methodName]) {
					layer[methodName].apply(layer, args);
				}
			}

			return this;
		},

		onAdd: function (map) {
			this.eachLayer(map.addLayer, map);
		},

		onRemove: function (map) {
			this.eachLayer(map.removeLayer, map);
		},

		// @method eachLayer(fn: Function, context?: Object): this
		// Iterates over the layers of the group, optionally specifying context of the iterator function.
		// ```js
		// group.eachLayer(function (layer) {
		// 	layer.bindPopup('Hello');
		// });
		// ```
		eachLayer: function (method, context) {
			for (var i in this._layers) {
				method.call(context, this._layers[i]);
			}
			return this;
		},

		// @method getLayer(id: Number): Layer
		// Returns the layer with the given internal ID.
		getLayer: function (id) {
			return this._layers[id];
		},

		// @method getLayers(): Layer[]
		// Returns an array of all the layers added to the group.
		getLayers: function () {
			var layers = [];
			this.eachLayer(layers.push, layers);
			return layers;
		},

		// @method setZIndex(zIndex: Number): this
		// Calls `setZIndex` on every layer contained in this group, passing the z-index.
		setZIndex: function (zIndex) {
			return this.invoke('setZIndex', zIndex);
		},

		// @method getLayerId(layer: Layer): Number
		// Returns the internal ID for a layer
		getLayerId: function (layer) {
			return stamp(layer);
		}
	});


	// @factory L.layerGroup(layers?: Layer[], options?: Object)
	// Create a layer group, optionally given an initial set of layers and an `options` object.
	var layerGroup = function (layers, options) {
		return new LayerGroup(layers, options);
	};

	/*
	 * @class FeatureGroup
	 * @aka L.FeatureGroup
	 * @inherits LayerGroup
	 *
	 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
	 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
	 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
	 * handler, it will handle events from any of the layers. This includes mouse events
	 * and custom events.
	 *  * Has `layeradd` and `layerremove` events
	 *
	 * @example
	 *
	 * ```js
	 * L.featureGroup([marker1, marker2, polyline])
	 * 	.bindPopup('Hello world!')
	 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
	 * 	.addTo(map);
	 * ```
	 */

	var FeatureGroup = LayerGroup.extend({

		addLayer: function (layer) {
			if (this.hasLayer(layer)) {
				return this;
			}

			layer.addEventParent(this);

			LayerGroup.prototype.addLayer.call(this, layer);

			// @event layeradd: LayerEvent
			// Fired when a layer is added to this `FeatureGroup`
			return this.fire('layeradd', {layer: layer});
		},

		removeLayer: function (layer) {
			if (!this.hasLayer(layer)) {
				return this;
			}
			if (layer in this._layers) {
				layer = this._layers[layer];
			}

			layer.removeEventParent(this);

			LayerGroup.prototype.removeLayer.call(this, layer);

			// @event layerremove: LayerEvent
			// Fired when a layer is removed from this `FeatureGroup`
			return this.fire('layerremove', {layer: layer});
		},

		// @method setStyle(style: Path options): this
		// Sets the given path options to each layer of the group that has a `setStyle` method.
		setStyle: function (style) {
			return this.invoke('setStyle', style);
		},

		// @method bringToFront(): this
		// Brings the layer group to the top of all other layers
		bringToFront: function () {
			return this.invoke('bringToFront');
		},

		// @method bringToBack(): this
		// Brings the layer group to the back of all other layers
		bringToBack: function () {
			return this.invoke('bringToBack');
		},

		// @method getBounds(): LatLngBounds
		// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
		getBounds: function () {
			var bounds = new LatLngBounds();

			for (var id in this._layers) {
				var layer = this._layers[id];
				bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
			}
			return bounds;
		}
	});

	// @factory L.featureGroup(layers: Layer[])
	// Create a feature group, optionally given an initial set of layers.
	var featureGroup = function (layers) {
		return new FeatureGroup(layers);
	};

	/*
	 * @class Icon
	 * @aka L.Icon
	 *
	 * Represents an icon to provide when creating a marker.
	 *
	 * @example
	 *
	 * ```js
	 * var myIcon = L.icon({
	 *     iconUrl: 'my-icon.png',
	 *     iconRetinaUrl: 'my-icon@2x.png',
	 *     iconSize: [38, 95],
	 *     iconAnchor: [22, 94],
	 *     popupAnchor: [-3, -76],
	 *     shadowUrl: 'my-icon-shadow.png',
	 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
	 *     shadowSize: [68, 95],
	 *     shadowAnchor: [22, 94]
	 * });
	 *
	 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
	 * ```
	 *
	 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
	 *
	 */

	var Icon = Class.extend({

		/* @section
		 * @aka Icon options
		 *
		 * @option iconUrl: String = null
		 * **(required)** The URL to the icon image (absolute or relative to your script path).
		 *
		 * @option iconRetinaUrl: String = null
		 * The URL to a retina sized version of the icon image (absolute or relative to your
		 * script path). Used for Retina screen devices.
		 *
		 * @option iconSize: Point = null
		 * Size of the icon image in pixels.
		 *
		 * @option iconAnchor: Point = null
		 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
		 * will be aligned so that this point is at the marker's geographical location. Centered
		 * by default if size is specified, also can be set in CSS with negative margins.
		 *
		 * @option popupAnchor: Point = [0, 0]
		 * The coordinates of the point from which popups will "open", relative to the icon anchor.
		 *
		 * @option tooltipAnchor: Point = [0, 0]
		 * The coordinates of the point from which tooltips will "open", relative to the icon anchor.
		 *
		 * @option shadowUrl: String = null
		 * The URL to the icon shadow image. If not specified, no shadow image will be created.
		 *
		 * @option shadowRetinaUrl: String = null
		 *
		 * @option shadowSize: Point = null
		 * Size of the shadow image in pixels.
		 *
		 * @option shadowAnchor: Point = null
		 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
		 * as iconAnchor if not specified).
		 *
		 * @option className: String = ''
		 * A custom class name to assign to both icon and shadow images. Empty by default.
		 */

		options: {
			popupAnchor: [0, 0],
			tooltipAnchor: [0, 0],
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		// @method createIcon(oldIcon?: HTMLElement): HTMLElement
		// Called internally when the icon has to be shown, returns a `<img>` HTML element
		// styled according to the options.
		createIcon: function (oldIcon) {
			return this._createIcon('icon', oldIcon);
		},

		// @method createShadow(oldIcon?: HTMLElement): HTMLElement
		// As `createIcon`, but for the shadow beneath it.
		createShadow: function (oldIcon) {
			return this._createIcon('shadow', oldIcon);
		},

		_createIcon: function (name, oldIcon) {
			var src = this._getIconUrl(name);

			if (!src) {
				if (name === 'icon') {
					throw new Error('iconUrl not set in Icon options (see the docs).');
				}
				return null;
			}

			var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
			this._setIconStyles(img, name);

			return img;
		},

		_setIconStyles: function (img, name) {
			var options = this.options;
			var sizeOption = options[name + 'Size'];

			if (typeof sizeOption === 'number') {
				sizeOption = [sizeOption, sizeOption];
			}

			var size = toPoint(sizeOption),
			    anchor = toPoint(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
			            size && size.divideBy(2, true));

			img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

			if (anchor) {
				img.style.marginLeft = (-anchor.x) + 'px';
				img.style.marginTop  = (-anchor.y) + 'px';
			}

			if (size) {
				img.style.width  = size.x + 'px';
				img.style.height = size.y + 'px';
			}
		},

		_createImg: function (src, el) {
			el = el || document.createElement('img');
			el.src = src;
			return el;
		},

		_getIconUrl: function (name) {
			return retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
		}
	});


	// @factory L.icon(options: Icon options)
	// Creates an icon instance with the given options.
	function icon(options) {
		return new Icon(options);
	}

	/*
	 * @miniclass Icon.Default (Icon)
	 * @aka L.Icon.Default
	 * @section
	 *
	 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
	 * no icon is specified. Points to the blue marker image distributed with Leaflet
	 * releases.
	 *
	 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
	 * (which is a set of `Icon options`).
	 *
	 * If you want to _completely_ replace the default icon, override the
	 * `L.Marker.prototype.options.icon` with your own icon instead.
	 */

	var IconDefault = Icon.extend({

		options: {
			iconUrl:       'marker-icon.png',
			iconRetinaUrl: 'marker-icon-2x.png',
			shadowUrl:     'marker-shadow.png',
			iconSize:    [25, 41],
			iconAnchor:  [12, 41],
			popupAnchor: [1, -34],
			tooltipAnchor: [16, -28],
			shadowSize:  [41, 41]
		},

		_getIconUrl: function (name) {
			if (!IconDefault.imagePath) {	// Deprecated, backwards-compatibility only
				IconDefault.imagePath = this._detectIconPath();
			}

			// @option imagePath: String
			// `Icon.Default` will try to auto-detect the location of the
			// blue icon images. If you are placing these images in a non-standard
			// way, set this option to point to the right path.
			return (this.options.imagePath || IconDefault.imagePath) + Icon.prototype._getIconUrl.call(this, name);
		},

		_detectIconPath: function () {
			var el = create$1('div',  'leaflet-default-icon-path', document.body);
			var path = getStyle(el, 'background-image') ||
			           getStyle(el, 'backgroundImage');	// IE8

			document.body.removeChild(el);

			if (path === null || path.indexOf('url') !== 0) {
				path = '';
			} else {
				path = path.replace(/^url\(["']?/, '').replace(/marker-icon\.png["']?\)$/, '');
			}

			return path;
		}
	});

	/*
	 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
	 */


	/* @namespace Marker
	 * @section Interaction handlers
	 *
	 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
	 *
	 * ```js
	 * marker.dragging.disable();
	 * ```
	 *
	 * @property dragging: Handler
	 * Marker dragging handler (by both mouse and touch). Only valid when the marker is on the map (Otherwise set [`marker.options.draggable`](#marker-draggable)).
	 */

	var MarkerDrag = Handler.extend({
		initialize: function (marker) {
			this._marker = marker;
		},

		addHooks: function () {
			var icon = this._marker._icon;

			if (!this._draggable) {
				this._draggable = new Draggable(icon, icon, true);
			}

			this._draggable.on({
				dragstart: this._onDragStart,
				predrag: this._onPreDrag,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this).enable();

			addClass(icon, 'leaflet-marker-draggable');
		},

		removeHooks: function () {
			this._draggable.off({
				dragstart: this._onDragStart,
				predrag: this._onPreDrag,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this).disable();

			if (this._marker._icon) {
				removeClass(this._marker._icon, 'leaflet-marker-draggable');
			}
		},

		moved: function () {
			return this._draggable && this._draggable._moved;
		},

		_adjustPan: function (e) {
			var marker = this._marker,
			    map = marker._map,
			    speed = this._marker.options.autoPanSpeed,
			    padding = this._marker.options.autoPanPadding,
			    iconPos = L.DomUtil.getPosition(marker._icon),
			    bounds = map.getPixelBounds(),
			    origin = map.getPixelOrigin();

			var panBounds = toBounds(
				bounds.min._subtract(origin).add(padding),
				bounds.max._subtract(origin).subtract(padding)
			);

			if (!panBounds.contains(iconPos)) {
				// Compute incremental movement
				var movement = toPoint(
					(Math.max(panBounds.max.x, iconPos.x) - panBounds.max.x) / (bounds.max.x - panBounds.max.x) -
					(Math.min(panBounds.min.x, iconPos.x) - panBounds.min.x) / (bounds.min.x - panBounds.min.x),

					(Math.max(panBounds.max.y, iconPos.y) - panBounds.max.y) / (bounds.max.y - panBounds.max.y) -
					(Math.min(panBounds.min.y, iconPos.y) - panBounds.min.y) / (bounds.min.y - panBounds.min.y)
				).multiplyBy(speed);

				map.panBy(movement, {animate: false});

				this._draggable._newPos._add(movement);
				this._draggable._startPos._add(movement);

				L.DomUtil.setPosition(marker._icon, this._draggable._newPos);
				this._onDrag(e);

				this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
			}
		},

		_onDragStart: function () {
			// @section Dragging events
			// @event dragstart: Event
			// Fired when the user starts dragging the marker.

			// @event movestart: Event
			// Fired when the marker starts moving (because of dragging).

			this._oldLatLng = this._marker.getLatLng();
			this._marker
			    .closePopup()
			    .fire('movestart')
			    .fire('dragstart');
		},

		_onPreDrag: function (e) {
			if (this._marker.options.autoPan) {
				cancelAnimFrame(this._panRequest);
				this._panRequest = requestAnimFrame(this._adjustPan.bind(this, e));
			}
		},

		_onDrag: function (e) {
			var marker = this._marker,
			    shadow = marker._shadow,
			iconPos = getPosition(marker._icon),
			    latlng = marker._map.layerPointToLatLng(iconPos);

			// update shadow position
			if (shadow) {
				setPosition(shadow, iconPos);
			}

			marker._latlng = latlng;
			e.latlng = latlng;
			e.oldLatLng = this._oldLatLng;

			// @event drag: Event
			// Fired repeatedly while the user drags the marker.
			marker
			    .fire('move', e)
			    .fire('drag', e);
		},

		_onDragEnd: function (e) {
			// @event dragend: DragEndEvent
			// Fired when the user stops dragging the marker.

			 cancelAnimFrame(this._panRequest);

			// @event moveend: Event
			// Fired when the marker stops moving (because of dragging).
			delete this._oldLatLng;
			this._marker
			    .fire('moveend')
			    .fire('dragend', e);
		}
	});

	/*
	 * @class Marker
	 * @inherits Interactive layer
	 * @aka L.Marker
	 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.marker([50.5, 30.5]).addTo(map);
	 * ```
	 */

	var Marker = Layer.extend({

		// @section
		// @aka Marker options
		options: {
			// @option icon: Icon = *
			// Icon instance to use for rendering the marker.
			// See [Icon documentation](#L.Icon) for details on how to customize the marker icon.
			// If not specified, a common instance of `L.Icon.Default` is used.
			icon: new IconDefault(),

			// Option inherited from "Interactive layer" abstract class
			interactive: true,

			// @option draggable: Boolean = false
			// Whether the marker is draggable with mouse/touch or not.
			draggable: false,

			// @option autoPan: Boolean = false
			// Set it to `true` if you want the map to do panning animation when marker hits the edges.
			autoPan: false,

			// @option autoPanPadding: Point = Point(50, 50)
			// Equivalent of setting both top left and bottom right autopan padding to the same value.
			autoPanPadding: [50, 50],

			// @option autoPanSpeed: Number = 10
			// Number of pixels the map should move by.
			autoPanSpeed: 10,

			// @option keyboard: Boolean = true
			// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
			keyboard: true,

			// @option title: String = ''
			// Text for the browser tooltip that appear on marker hover (no tooltip by default).
			title: '',

			// @option alt: String = ''
			// Text for the `alt` attribute of the icon image (useful for accessibility).
			alt: '',

			// @option zIndexOffset: Number = 0
			// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
			zIndexOffset: 0,

			// @option opacity: Number = 1.0
			// The opacity of the marker.
			opacity: 1,

			// @option riseOnHover: Boolean = false
			// If `true`, the marker will get on top of others when you hover the mouse over it.
			riseOnHover: false,

			// @option riseOffset: Number = 250
			// The z-index offset used for the `riseOnHover` feature.
			riseOffset: 250,

			// @option pane: String = 'markerPane'
			// `Map pane` where the markers icon will be added.
			pane: 'markerPane',

			// @option bubblingMouseEvents: Boolean = false
			// When `true`, a mouse event on this marker will trigger the same event on the map
			// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
			bubblingMouseEvents: false
		},

		/* @section
		 *
		 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
		 */

		initialize: function (latlng, options) {
			setOptions(this, options);
			this._latlng = toLatLng(latlng);
		},

		onAdd: function (map) {
			this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

			if (this._zoomAnimated) {
				map.on('zoomanim', this._animateZoom, this);
			}

			this._initIcon();
			this.update();
		},

		onRemove: function (map) {
			if (this.dragging && this.dragging.enabled()) {
				this.options.draggable = true;
				this.dragging.removeHooks();
			}
			delete this.dragging;

			if (this._zoomAnimated) {
				map.off('zoomanim', this._animateZoom, this);
			}

			this._removeIcon();
			this._removeShadow();
		},

		getEvents: function () {
			return {
				zoom: this.update,
				viewreset: this.update
			};
		},

		// @method getLatLng: LatLng
		// Returns the current geographical position of the marker.
		getLatLng: function () {
			return this._latlng;
		},

		// @method setLatLng(latlng: LatLng): this
		// Changes the marker position to the given point.
		setLatLng: function (latlng) {
			var oldLatLng = this._latlng;
			this._latlng = toLatLng(latlng);
			this.update();

			// @event move: Event
			// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
			return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
		},

		// @method setZIndexOffset(offset: Number): this
		// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
		setZIndexOffset: function (offset) {
			this.options.zIndexOffset = offset;
			return this.update();
		},

		// @method setIcon(icon: Icon): this
		// Changes the marker icon.
		setIcon: function (icon) {

			this.options.icon = icon;

			if (this._map) {
				this._initIcon();
				this.update();
			}

			if (this._popup) {
				this.bindPopup(this._popup, this._popup.options);
			}

			return this;
		},

		getElement: function () {
			return this._icon;
		},

		update: function () {

			if (this._icon && this._map) {
				var pos = this._map.latLngToLayerPoint(this._latlng).round();
				this._setPos(pos);
			}

			return this;
		},

		_initIcon: function () {
			var options = this.options,
			    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

			var icon = options.icon.createIcon(this._icon),
			    addIcon = false;

			// if we're not reusing the icon, remove the old one and init new one
			if (icon !== this._icon) {
				if (this._icon) {
					this._removeIcon();
				}
				addIcon = true;

				if (options.title) {
					icon.title = options.title;
				}

				if (icon.tagName === 'IMG') {
					icon.alt = options.alt || '';
				}
			}

			addClass(icon, classToAdd);

			if (options.keyboard) {
				icon.tabIndex = '0';
			}

			this._icon = icon;

			if (options.riseOnHover) {
				this.on({
					mouseover: this._bringToFront,
					mouseout: this._resetZIndex
				});
			}

			var newShadow = options.icon.createShadow(this._shadow),
			    addShadow = false;

			if (newShadow !== this._shadow) {
				this._removeShadow();
				addShadow = true;
			}

			if (newShadow) {
				addClass(newShadow, classToAdd);
				newShadow.alt = '';
			}
			this._shadow = newShadow;


			if (options.opacity < 1) {
				this._updateOpacity();
			}


			if (addIcon) {
				this.getPane().appendChild(this._icon);
			}
			this._initInteraction();
			if (newShadow && addShadow) {
				this.getPane('shadowPane').appendChild(this._shadow);
			}
		},

		_removeIcon: function () {
			if (this.options.riseOnHover) {
				this.off({
					mouseover: this._bringToFront,
					mouseout: this._resetZIndex
				});
			}

			remove(this._icon);
			this.removeInteractiveTarget(this._icon);

			this._icon = null;
		},

		_removeShadow: function () {
			if (this._shadow) {
				remove(this._shadow);
			}
			this._shadow = null;
		},

		_setPos: function (pos) {
			setPosition(this._icon, pos);

			if (this._shadow) {
				setPosition(this._shadow, pos);
			}

			this._zIndex = pos.y + this.options.zIndexOffset;

			this._resetZIndex();
		},

		_updateZIndex: function (offset) {
			this._icon.style.zIndex = this._zIndex + offset;
		},

		_animateZoom: function (opt) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

			this._setPos(pos);
		},

		_initInteraction: function () {

			if (!this.options.interactive) { return; }

			addClass(this._icon, 'leaflet-interactive');

			this.addInteractiveTarget(this._icon);

			if (MarkerDrag) {
				var draggable = this.options.draggable;
				if (this.dragging) {
					draggable = this.dragging.enabled();
					this.dragging.disable();
				}

				this.dragging = new MarkerDrag(this);

				if (draggable) {
					this.dragging.enable();
				}
			}
		},

		// @method setOpacity(opacity: Number): this
		// Changes the opacity of the marker.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;
			if (this._map) {
				this._updateOpacity();
			}

			return this;
		},

		_updateOpacity: function () {
			var opacity = this.options.opacity;

			setOpacity(this._icon, opacity);

			if (this._shadow) {
				setOpacity(this._shadow, opacity);
			}
		},

		_bringToFront: function () {
			this._updateZIndex(this.options.riseOffset);
		},

		_resetZIndex: function () {
			this._updateZIndex(0);
		},

		_getPopupAnchor: function () {
			return this.options.icon.options.popupAnchor;
		},

		_getTooltipAnchor: function () {
			return this.options.icon.options.tooltipAnchor;
		}
	});


	// factory L.marker(latlng: LatLng, options? : Marker options)

	// @factory L.marker(latlng: LatLng, options? : Marker options)
	// Instantiates a Marker object given a geographical point and optionally an options object.
	function marker(latlng, options) {
		return new Marker(latlng, options);
	}

	/*
	 * @class Path
	 * @aka L.Path
	 * @inherits Interactive layer
	 *
	 * An abstract class that contains options and constants shared between vector
	 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
	 */

	var Path = Layer.extend({

		// @section
		// @aka Path options
		options: {
			// @option stroke: Boolean = true
			// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
			stroke: true,

			// @option color: String = '#3388ff'
			// Stroke color
			color: '#3388ff',

			// @option weight: Number = 3
			// Stroke width in pixels
			weight: 3,

			// @option opacity: Number = 1.0
			// Stroke opacity
			opacity: 1,

			// @option lineCap: String= 'round'
			// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
			lineCap: 'round',

			// @option lineJoin: String = 'round'
			// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
			lineJoin: 'round',

			// @option dashArray: String = null
			// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
			dashArray: null,

			// @option dashOffset: String = null
			// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
			dashOffset: null,

			// @option fill: Boolean = depends
			// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
			fill: false,

			// @option fillColor: String = *
			// Fill color. Defaults to the value of the [`color`](#path-color) option
			fillColor: null,

			// @option fillOpacity: Number = 0.2
			// Fill opacity.
			fillOpacity: 0.2,

			// @option fillRule: String = 'evenodd'
			// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
			fillRule: 'evenodd',

			// className: '',

			// Option inherited from "Interactive layer" abstract class
			interactive: true,

			// @option bubblingMouseEvents: Boolean = true
			// When `true`, a mouse event on this path will trigger the same event on the map
			// (unless [`L.DomEvent.stopPropagation`](#domevent-stoppropagation) is used).
			bubblingMouseEvents: true
		},

		beforeAdd: function (map) {
			// Renderer is set here because we need to call renderer.getEvents
			// before this.getEvents.
			this._renderer = map.getRenderer(this);
		},

		onAdd: function () {
			this._renderer._initPath(this);
			this._reset();
			this._renderer._addPath(this);
		},

		onRemove: function () {
			this._renderer._removePath(this);
		},

		// @method redraw(): this
		// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
		redraw: function () {
			if (this._map) {
				this._renderer._updatePath(this);
			}
			return this;
		},

		// @method setStyle(style: Path options): this
		// Changes the appearance of a Path based on the options in the `Path options` object.
		setStyle: function (style) {
			setOptions(this, style);
			if (this._renderer) {
				this._renderer._updateStyle(this);
			}
			return this;
		},

		// @method bringToFront(): this
		// Brings the layer to the top of all path layers.
		bringToFront: function () {
			if (this._renderer) {
				this._renderer._bringToFront(this);
			}
			return this;
		},

		// @method bringToBack(): this
		// Brings the layer to the bottom of all path layers.
		bringToBack: function () {
			if (this._renderer) {
				this._renderer._bringToBack(this);
			}
			return this;
		},

		getElement: function () {
			return this._path;
		},

		_reset: function () {
			// defined in child classes
			this._project();
			this._update();
		},

		_clickTolerance: function () {
			// used when doing hit detection for Canvas layers
			return (this.options.stroke ? this.options.weight / 2 : 0) + this._renderer.options.tolerance;
		}
	});

	/*
	 * @class CircleMarker
	 * @aka L.CircleMarker
	 * @inherits Path
	 *
	 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
	 */

	var CircleMarker = Path.extend({

		// @section
		// @aka CircleMarker options
		options: {
			fill: true,

			// @option radius: Number = 10
			// Radius of the circle marker, in pixels
			radius: 10
		},

		initialize: function (latlng, options) {
			setOptions(this, options);
			this._latlng = toLatLng(latlng);
			this._radius = this.options.radius;
		},

		// @method setLatLng(latLng: LatLng): this
		// Sets the position of a circle marker to a new location.
		setLatLng: function (latlng) {
			this._latlng = toLatLng(latlng);
			this.redraw();
			return this.fire('move', {latlng: this._latlng});
		},

		// @method getLatLng(): LatLng
		// Returns the current geographical position of the circle marker
		getLatLng: function () {
			return this._latlng;
		},

		// @method setRadius(radius: Number): this
		// Sets the radius of a circle marker. Units are in pixels.
		setRadius: function (radius) {
			this.options.radius = this._radius = radius;
			return this.redraw();
		},

		// @method getRadius(): Number
		// Returns the current radius of the circle
		getRadius: function () {
			return this._radius;
		},

		setStyle : function (options) {
			var radius = options && options.radius || this._radius;
			Path.prototype.setStyle.call(this, options);
			this.setRadius(radius);
			return this;
		},

		_project: function () {
			this._point = this._map.latLngToLayerPoint(this._latlng);
			this._updateBounds();
		},

		_updateBounds: function () {
			var r = this._radius,
			    r2 = this._radiusY || r,
			    w = this._clickTolerance(),
			    p = [r + w, r2 + w];
			this._pxBounds = new Bounds(this._point.subtract(p), this._point.add(p));
		},

		_update: function () {
			if (this._map) {
				this._updatePath();
			}
		},

		_updatePath: function () {
			this._renderer._updateCircle(this);
		},

		_empty: function () {
			return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p) {
			return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
		}
	});


	// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
	// Instantiates a circle marker object given a geographical point, and an optional options object.
	function circleMarker(latlng, options) {
		return new CircleMarker(latlng, options);
	}

	/*
	 * @class Circle
	 * @aka L.Circle
	 * @inherits CircleMarker
	 *
	 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
	 *
	 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
	 *
	 * @example
	 *
	 * ```js
	 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
	 * ```
	 */

	var Circle = CircleMarker.extend({

		initialize: function (latlng, options, legacyOptions) {
			if (typeof options === 'number') {
				// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
				options = extend({}, legacyOptions, {radius: options});
			}
			setOptions(this, options);
			this._latlng = toLatLng(latlng);

			if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

			// @section
			// @aka Circle options
			// @option radius: Number; Radius of the circle, in meters.
			this._mRadius = this.options.radius;
		},

		// @method setRadius(radius: Number): this
		// Sets the radius of a circle. Units are in meters.
		setRadius: function (radius) {
			this._mRadius = radius;
			return this.redraw();
		},

		// @method getRadius(): Number
		// Returns the current radius of a circle. Units are in meters.
		getRadius: function () {
			return this._mRadius;
		},

		// @method getBounds(): LatLngBounds
		// Returns the `LatLngBounds` of the path.
		getBounds: function () {
			var half = [this._radius, this._radiusY || this._radius];

			return new LatLngBounds(
				this._map.layerPointToLatLng(this._point.subtract(half)),
				this._map.layerPointToLatLng(this._point.add(half)));
		},

		setStyle: Path.prototype.setStyle,

		_project: function () {

			var lng = this._latlng.lng,
			    lat = this._latlng.lat,
			    map = this._map,
			    crs = map.options.crs;

			if (crs.distance === Earth.distance) {
				var d = Math.PI / 180,
				    latR = (this._mRadius / Earth.R) / d,
				    top = map.project([lat + latR, lng]),
				    bottom = map.project([lat - latR, lng]),
				    p = top.add(bottom).divideBy(2),
				    lat2 = map.unproject(p).lat,
				    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
				            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

				if (isNaN(lngR) || lngR === 0) {
					lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
				}

				this._point = p.subtract(map.getPixelOrigin());
				this._radius = isNaN(lngR) ? 0 : p.x - map.project([lat2, lng - lngR]).x;
				this._radiusY = p.y - top.y;

			} else {
				var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

				this._point = map.latLngToLayerPoint(this._latlng);
				this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
			}

			this._updateBounds();
		}
	});

	// @factory L.circle(latlng: LatLng, options?: Circle options)
	// Instantiates a circle object given a geographical point, and an options object
	// which contains the circle radius.
	// @alternative
	// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
	// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
	// Do not use in new applications or plugins.
	function circle(latlng, options, legacyOptions) {
		return new Circle(latlng, options, legacyOptions);
	}

	/*
	 * @class Polyline
	 * @aka L.Polyline
	 * @inherits Path
	 *
	 * A class for drawing polyline overlays on a map. Extends `Path`.
	 *
	 * @example
	 *
	 * ```js
	 * // create a red polyline from an array of LatLng points
	 * var latlngs = [
	 * 	[45.51, -122.68],
	 * 	[37.77, -122.43],
	 * 	[34.04, -118.2]
	 * ];
	 *
	 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
	 *
	 * // zoom the map to the polyline
	 * map.fitBounds(polyline.getBounds());
	 * ```
	 *
	 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
	 *
	 * ```js
	 * // create a red polyline from an array of arrays of LatLng points
	 * var latlngs = [
	 * 	[[45.51, -122.68],
	 * 	 [37.77, -122.43],
	 * 	 [34.04, -118.2]],
	 * 	[[40.78, -73.91],
	 * 	 [41.83, -87.62],
	 * 	 [32.76, -96.72]]
	 * ];
	 * ```
	 */


	var Polyline = Path.extend({

		// @section
		// @aka Polyline options
		options: {
			// @option smoothFactor: Number = 1.0
			// How much to simplify the polyline on each zoom level. More means
			// better performance and smoother look, and less means more accurate representation.
			smoothFactor: 1.0,

			// @option noClip: Boolean = false
			// Disable polyline clipping.
			noClip: false
		},

		initialize: function (latlngs, options) {
			setOptions(this, options);
			this._setLatLngs(latlngs);
		},

		// @method getLatLngs(): LatLng[]
		// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
		getLatLngs: function () {
			return this._latlngs;
		},

		// @method setLatLngs(latlngs: LatLng[]): this
		// Replaces all the points in the polyline with the given array of geographical points.
		setLatLngs: function (latlngs) {
			this._setLatLngs(latlngs);
			return this.redraw();
		},

		// @method isEmpty(): Boolean
		// Returns `true` if the Polyline has no LatLngs.
		isEmpty: function () {
			return !this._latlngs.length;
		},

		// @method closestLayerPoint: Point
		// Returns the point closest to `p` on the Polyline.
		closestLayerPoint: function (p) {
			var minDistance = Infinity,
			    minPoint = null,
			    closest = _sqClosestPointOnSegment,
			    p1, p2;

			for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
				var points = this._parts[j];

				for (var i = 1, len = points.length; i < len; i++) {
					p1 = points[i - 1];
					p2 = points[i];

					var sqDist = closest(p, p1, p2, true);

					if (sqDist < minDistance) {
						minDistance = sqDist;
						minPoint = closest(p, p1, p2);
					}
				}
			}
			if (minPoint) {
				minPoint.distance = Math.sqrt(minDistance);
			}
			return minPoint;
		},

		// @method getCenter(): LatLng
		// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
		getCenter: function () {
			// throws error when not yet added to map as this center calculation requires projected coordinates
			if (!this._map) {
				throw new Error('Must add layer to map before using getCenter()');
			}

			var i, halfDist, segDist, dist, p1, p2, ratio,
			    points = this._rings[0],
			    len = points.length;

			if (!len) { return null; }

			// polyline centroid algorithm; only uses the first ring if there are multiple

			for (i = 0, halfDist = 0; i < len - 1; i++) {
				halfDist += points[i].distanceTo(points[i + 1]) / 2;
			}

			// The line is so small in the current view that all points are on the same pixel.
			if (halfDist === 0) {
				return this._map.layerPointToLatLng(points[0]);
			}

			for (i = 0, dist = 0; i < len - 1; i++) {
				p1 = points[i];
				p2 = points[i + 1];
				segDist = p1.distanceTo(p2);
				dist += segDist;

				if (dist > halfDist) {
					ratio = (dist - halfDist) / segDist;
					return this._map.layerPointToLatLng([
						p2.x - ratio * (p2.x - p1.x),
						p2.y - ratio * (p2.y - p1.y)
					]);
				}
			}
		},

		// @method getBounds(): LatLngBounds
		// Returns the `LatLngBounds` of the path.
		getBounds: function () {
			return this._bounds;
		},

		// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
		// Adds a given point to the polyline. By default, adds to the first ring of
		// the polyline in case of a multi-polyline, but can be overridden by passing
		// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
		addLatLng: function (latlng, latlngs) {
			latlngs = latlngs || this._defaultShape();
			latlng = toLatLng(latlng);
			latlngs.push(latlng);
			this._bounds.extend(latlng);
			return this.redraw();
		},

		_setLatLngs: function (latlngs) {
			this._bounds = new LatLngBounds();
			this._latlngs = this._convertLatLngs(latlngs);
		},

		_defaultShape: function () {
			return isFlat(this._latlngs) ? this._latlngs : this._latlngs[0];
		},

		// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
		_convertLatLngs: function (latlngs) {
			var result = [],
			    flat = isFlat(latlngs);

			for (var i = 0, len = latlngs.length; i < len; i++) {
				if (flat) {
					result[i] = toLatLng(latlngs[i]);
					this._bounds.extend(result[i]);
				} else {
					result[i] = this._convertLatLngs(latlngs[i]);
				}
			}

			return result;
		},

		_project: function () {
			var pxBounds = new Bounds();
			this._rings = [];
			this._projectLatlngs(this._latlngs, this._rings, pxBounds);

			var w = this._clickTolerance(),
			    p = new Point(w, w);

			if (this._bounds.isValid() && pxBounds.isValid()) {
				pxBounds.min._subtract(p);
				pxBounds.max._add(p);
				this._pxBounds = pxBounds;
			}
		},

		// recursively turns latlngs into a set of rings with projected coordinates
		_projectLatlngs: function (latlngs, result, projectedBounds) {
			var flat = latlngs[0] instanceof LatLng,
			    len = latlngs.length,
			    i, ring;

			if (flat) {
				ring = [];
				for (i = 0; i < len; i++) {
					ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
					projectedBounds.extend(ring[i]);
				}
				result.push(ring);
			} else {
				for (i = 0; i < len; i++) {
					this._projectLatlngs(latlngs[i], result, projectedBounds);
				}
			}
		},

		// clip polyline by renderer bounds so that we have less to render for performance
		_clipPoints: function () {
			var bounds = this._renderer._bounds;

			this._parts = [];
			if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
				return;
			}

			if (this.options.noClip) {
				this._parts = this._rings;
				return;
			}

			var parts = this._parts,
			    i, j, k, len, len2, segment, points;

			for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
				points = this._rings[i];

				for (j = 0, len2 = points.length; j < len2 - 1; j++) {
					segment = clipSegment(points[j], points[j + 1], bounds, j, true);

					if (!segment) { continue; }

					parts[k] = parts[k] || [];
					parts[k].push(segment[0]);

					// if segment goes out of screen, or it's the last one, it's the end of the line part
					if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
						parts[k].push(segment[1]);
						k++;
					}
				}
			}
		},

		// simplify each clipped part of the polyline for performance
		_simplifyPoints: function () {
			var parts = this._parts,
			    tolerance = this.options.smoothFactor;

			for (var i = 0, len = parts.length; i < len; i++) {
				parts[i] = simplify(parts[i], tolerance);
			}
		},

		_update: function () {
			if (!this._map) { return; }

			this._clipPoints();
			this._simplifyPoints();
			this._updatePath();
		},

		_updatePath: function () {
			this._renderer._updatePoly(this);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p, closed) {
			var i, j, k, len, len2, part,
			    w = this._clickTolerance();

			if (!this._pxBounds || !this._pxBounds.contains(p)) { return false; }

			// hit detection for polylines
			for (i = 0, len = this._parts.length; i < len; i++) {
				part = this._parts[i];

				for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
					if (!closed && (j === 0)) { continue; }

					if (pointToSegmentDistance(p, part[k], part[j]) <= w) {
						return true;
					}
				}
			}
			return false;
		}
	});

	// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
	// Instantiates a polyline object given an array of geographical points and
	// optionally an options object. You can create a `Polyline` object with
	// multiple separate lines (`MultiPolyline`) by passing an array of arrays
	// of geographic points.
	function polyline(latlngs, options) {
		return new Polyline(latlngs, options);
	}

	// Retrocompat. Allow plugins to support Leaflet versions before and after 1.1.
	Polyline._flat = _flat;

	/*
	 * @class Polygon
	 * @aka L.Polygon
	 * @inherits Polyline
	 *
	 * A class for drawing polygon overlays on a map. Extends `Polyline`.
	 *
	 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
	 *
	 *
	 * @example
	 *
	 * ```js
	 * // create a red polygon from an array of LatLng points
	 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
	 *
	 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
	 *
	 * // zoom the map to the polygon
	 * map.fitBounds(polygon.getBounds());
	 * ```
	 *
	 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
	 *
	 * ```js
	 * var latlngs = [
	 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
	 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
	 * ];
	 * ```
	 *
	 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
	 *
	 * ```js
	 * var latlngs = [
	 *   [ // first polygon
	 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
	 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
	 *   ],
	 *   [ // second polygon
	 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
	 *   ]
	 * ];
	 * ```
	 */

	var Polygon = Polyline.extend({

		options: {
			fill: true
		},

		isEmpty: function () {
			return !this._latlngs.length || !this._latlngs[0].length;
		},

		getCenter: function () {
			// throws error when not yet added to map as this center calculation requires projected coordinates
			if (!this._map) {
				throw new Error('Must add layer to map before using getCenter()');
			}

			var i, j, p1, p2, f, area, x, y, center,
			    points = this._rings[0],
			    len = points.length;

			if (!len) { return null; }

			// polygon centroid algorithm; only uses the first ring if there are multiple

			area = x = y = 0;

			for (i = 0, j = len - 1; i < len; j = i++) {
				p1 = points[i];
				p2 = points[j];

				f = p1.y * p2.x - p2.y * p1.x;
				x += (p1.x + p2.x) * f;
				y += (p1.y + p2.y) * f;
				area += f * 3;
			}

			if (area === 0) {
				// Polygon is so small that all points are on same pixel.
				center = points[0];
			} else {
				center = [x / area, y / area];
			}
			return this._map.layerPointToLatLng(center);
		},

		_convertLatLngs: function (latlngs) {
			var result = Polyline.prototype._convertLatLngs.call(this, latlngs),
			    len = result.length;

			// remove last point if it equals first one
			if (len >= 2 && result[0] instanceof LatLng && result[0].equals(result[len - 1])) {
				result.pop();
			}
			return result;
		},

		_setLatLngs: function (latlngs) {
			Polyline.prototype._setLatLngs.call(this, latlngs);
			if (isFlat(this._latlngs)) {
				this._latlngs = [this._latlngs];
			}
		},

		_defaultShape: function () {
			return isFlat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
		},

		_clipPoints: function () {
			// polygons need a different clipping algorithm so we redefine that

			var bounds = this._renderer._bounds,
			    w = this.options.weight,
			    p = new Point(w, w);

			// increase clip padding by stroke width to avoid stroke on clip edges
			bounds = new Bounds(bounds.min.subtract(p), bounds.max.add(p));

			this._parts = [];
			if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
				return;
			}

			if (this.options.noClip) {
				this._parts = this._rings;
				return;
			}

			for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
				clipped = clipPolygon(this._rings[i], bounds, true);
				if (clipped.length) {
					this._parts.push(clipped);
				}
			}
		},

		_updatePath: function () {
			this._renderer._updatePoly(this, true);
		},

		// Needed by the `Canvas` renderer for interactivity
		_containsPoint: function (p) {
			var inside = false,
			    part, p1, p2, i, j, k, len, len2;

			if (!this._pxBounds.contains(p)) { return false; }

			// ray casting algorithm for detecting if point is in polygon
			for (i = 0, len = this._parts.length; i < len; i++) {
				part = this._parts[i];

				for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
					p1 = part[j];
					p2 = part[k];

					if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
						inside = !inside;
					}
				}
			}

			// also check if it's on polygon stroke
			return inside || Polyline.prototype._containsPoint.call(this, p, true);
		}

	});


	// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
	function polygon(latlngs, options) {
		return new Polygon(latlngs, options);
	}

	/*
	 * @class GeoJSON
	 * @aka L.GeoJSON
	 * @inherits FeatureGroup
	 *
	 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
	 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
	 *
	 * @example
	 *
	 * ```js
	 * L.geoJSON(data, {
	 * 	style: function (feature) {
	 * 		return {color: feature.properties.color};
	 * 	}
	 * }).bindPopup(function (layer) {
	 * 	return layer.feature.properties.description;
	 * }).addTo(map);
	 * ```
	 */

	var GeoJSON = FeatureGroup.extend({

		/* @section
		 * @aka GeoJSON options
		 *
		 * @option pointToLayer: Function = *
		 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
		 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
		 * The default is to spawn a default `Marker`:
		 * ```js
		 * function(geoJsonPoint, latlng) {
		 * 	return L.marker(latlng);
		 * }
		 * ```
		 *
		 * @option style: Function = *
		 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
		 * called internally when data is added.
		 * The default value is to not override any defaults:
		 * ```js
		 * function (geoJsonFeature) {
		 * 	return {}
		 * }
		 * ```
		 *
		 * @option onEachFeature: Function = *
		 * A `Function` that will be called once for each created `Feature`, after it has
		 * been created and styled. Useful for attaching events and popups to features.
		 * The default is to do nothing with the newly created layers:
		 * ```js
		 * function (feature, layer) {}
		 * ```
		 *
		 * @option filter: Function = *
		 * A `Function` that will be used to decide whether to include a feature or not.
		 * The default is to include all features:
		 * ```js
		 * function (geoJsonFeature) {
		 * 	return true;
		 * }
		 * ```
		 * Note: dynamically changing the `filter` option will have effect only on newly
		 * added data. It will _not_ re-evaluate already included features.
		 *
		 * @option coordsToLatLng: Function = *
		 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
		 * The default is the `coordsToLatLng` static method.
		 */

		initialize: function (geojson, options) {
			setOptions(this, options);

			this._layers = {};

			if (geojson) {
				this.addData(geojson);
			}
		},

		// @method addData( <GeoJSON> data ): this
		// Adds a GeoJSON object to the layer.
		addData: function (geojson) {
			var features = isArray(geojson) ? geojson : geojson.features,
			    i, len, feature;

			if (features) {
				for (i = 0, len = features.length; i < len; i++) {
					// only add this if geometry or geometries are set and not null
					feature = features[i];
					if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
						this.addData(feature);
					}
				}
				return this;
			}

			var options = this.options;

			if (options.filter && !options.filter(geojson)) { return this; }

			var layer = geometryToLayer(geojson, options);
			if (!layer) {
				return this;
			}
			layer.feature = asFeature(geojson);

			layer.defaultOptions = layer.options;
			this.resetStyle(layer);

			if (options.onEachFeature) {
				options.onEachFeature(geojson, layer);
			}

			return this.addLayer(layer);
		},

		// @method resetStyle( <Path> layer ): this
		// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
		resetStyle: function (layer) {
			// reset any custom styles
			layer.options = extend({}, layer.defaultOptions);
			this._setLayerStyle(layer, this.options.style);
			return this;
		},

		// @method setStyle( <Function> style ): this
		// Changes styles of GeoJSON vector layers with the given style function.
		setStyle: function (style) {
			return this.eachLayer(function (layer) {
				this._setLayerStyle(layer, style);
			}, this);
		},

		_setLayerStyle: function (layer, style) {
			if (typeof style === 'function') {
				style = style(layer.feature);
			}
			if (layer.setStyle) {
				layer.setStyle(style);
			}
		}
	});

	// @section
	// There are several static functions which can be called without instantiating L.GeoJSON:

	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	function geometryToLayer(geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    _coordsToLatLng = options && options.coordsToLatLng || coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = _coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = _coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new Marker(latlng));
			}
			return new FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, _coordsToLatLng);
			return new Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, _coordsToLatLng);
			return new Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	}

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	function coordsToLatLng(coords) {
		return new LatLng(coords[1], coords[0], coords[2]);
	}

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	function coordsToLatLngs(coords, levelsDeep, _coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
				coordsToLatLngs(coords[i], levelsDeep - 1, _coordsToLatLng) :
				(_coordsToLatLng || coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	}

	// @function latLngToCoords(latlng: LatLng, precision?: Number): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	function latLngToCoords(latlng, precision) {
		precision = typeof precision === 'number' ? precision : 6;
		return latlng.alt !== undefined ?
			[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision), formatNum(latlng.alt, precision)] :
			[formatNum(latlng.lng, precision), formatNum(latlng.lat, precision)];
	}

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	function latLngsToCoords(latlngs, levelsDeep, closed, precision) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				latLngsToCoords(latlngs[i], levelsDeep - 1, closed, precision) :
				latLngToCoords(latlngs[i], precision));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	}

	function getFeature(layer, newGeometry) {
		return layer.feature ?
			extend({}, layer.feature, {geometry: newGeometry}) :
			asFeature(newGeometry);
	}

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	function asFeature(geojson) {
		if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}

	var PointToGeoJSON = {
		toGeoJSON: function (precision) {
			return getFeature(this, {
				type: 'Point',
				coordinates: latLngToCoords(this.getLatLng(), precision)
			});
		}
	};

	// @namespace Marker
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
	Marker.include(PointToGeoJSON);

	// @namespace CircleMarker
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
	Circle.include(PointToGeoJSON);
	CircleMarker.include(PointToGeoJSON);


	// @namespace Polyline
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
	Polyline.include({
		toGeoJSON: function (precision) {
			var multi = !isFlat(this._latlngs);

			var coords = latLngsToCoords(this._latlngs, multi ? 1 : 0, false, precision);

			return getFeature(this, {
				type: (multi ? 'Multi' : '') + 'LineString',
				coordinates: coords
			});
		}
	});

	// @namespace Polygon
	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
	Polygon.include({
		toGeoJSON: function (precision) {
			var holes = !isFlat(this._latlngs),
			    multi = holes && !isFlat(this._latlngs[0]);

			var coords = latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true, precision);

			if (!holes) {
				coords = [coords];
			}

			return getFeature(this, {
				type: (multi ? 'Multi' : '') + 'Polygon',
				coordinates: coords
			});
		}
	});


	// @namespace LayerGroup
	LayerGroup.include({
		toMultiPoint: function (precision) {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON(precision).geometry.coordinates);
			});

			return getFeature(this, {
				type: 'MultiPoint',
				coordinates: coords
			});
		},

		// @method toGeoJSON(): Object
		// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `FeatureCollection`, `GeometryCollection`, or `MultiPoint`).
		toGeoJSON: function (precision) {

			var type = this.feature && this.feature.geometry && this.feature.geometry.type;

			if (type === 'MultiPoint') {
				return this.toMultiPoint(precision);
			}

			var isGeometryCollection = type === 'GeometryCollection',
			    jsons = [];

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					var json = layer.toGeoJSON(precision);
					if (isGeometryCollection) {
						jsons.push(json.geometry);
					} else {
						var feature = asFeature(json);
						// Squash nested feature collections
						if (feature.type === 'FeatureCollection') {
							jsons.push.apply(jsons, feature.features);
						} else {
							jsons.push(feature);
						}
					}
				}
			});

			if (isGeometryCollection) {
				return getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});

	// @namespace GeoJSON
	// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
	// Creates a GeoJSON layer. Optionally accepts an object in
	// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
	// (you can alternatively add it later with `addData` method) and an `options` object.
	function geoJSON(geojson, options) {
		return new GeoJSON(geojson, options);
	}

	// Backward compatibility.
	var geoJson = geoJSON;

	/*
	 * @class ImageOverlay
	 * @aka L.ImageOverlay
	 * @inherits Interactive layer
	 *
	 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
	 *
	 * @example
	 *
	 * ```js
	 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
	 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
	 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
	 * ```
	 */

	var ImageOverlay = Layer.extend({

		// @section
		// @aka ImageOverlay options
		options: {
			// @option opacity: Number = 1.0
			// The opacity of the image overlay.
			opacity: 1,

			// @option alt: String = ''
			// Text for the `alt` attribute of the image (useful for accessibility).
			alt: '',

			// @option interactive: Boolean = false
			// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
			interactive: false,

			// @option crossOrigin: Boolean = false
			// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
			crossOrigin: false,

			// @option errorOverlayUrl: String = ''
			// URL to the overlay image to show in place of the overlay that failed to load.
			errorOverlayUrl: '',

			// @option zIndex: Number = 1
			// The explicit [zIndex](https://developer.mozilla.org/docs/Web/CSS/CSS_Positioning/Understanding_z_index) of the tile layer.
			zIndex: 1,

			// @option className: String = ''
			// A custom class name to assign to the image. Empty by default.
			className: '',
		},

		initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
			this._url = url;
			this._bounds = toLatLngBounds(bounds);

			setOptions(this, options);
		},

		onAdd: function () {
			if (!this._image) {
				this._initImage();

				if (this.options.opacity < 1) {
					this._updateOpacity();
				}
			}

			if (this.options.interactive) {
				addClass(this._image, 'leaflet-interactive');
				this.addInteractiveTarget(this._image);
			}

			this.getPane().appendChild(this._image);
			this._reset();
		},

		onRemove: function () {
			remove(this._image);
			if (this.options.interactive) {
				this.removeInteractiveTarget(this._image);
			}
		},

		// @method setOpacity(opacity: Number): this
		// Sets the opacity of the overlay.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;

			if (this._image) {
				this._updateOpacity();
			}
			return this;
		},

		setStyle: function (styleOpts) {
			if (styleOpts.opacity) {
				this.setOpacity(styleOpts.opacity);
			}
			return this;
		},

		// @method bringToFront(): this
		// Brings the layer to the top of all overlays.
		bringToFront: function () {
			if (this._map) {
				toFront(this._image);
			}
			return this;
		},

		// @method bringToBack(): this
		// Brings the layer to the bottom of all overlays.
		bringToBack: function () {
			if (this._map) {
				toBack(this._image);
			}
			return this;
		},

		// @method setUrl(url: String): this
		// Changes the URL of the image.
		setUrl: function (url) {
			this._url = url;

			if (this._image) {
				this._image.src = url;
			}
			return this;
		},

		// @method setBounds(bounds: LatLngBounds): this
		// Update the bounds that this ImageOverlay covers
		setBounds: function (bounds) {
			this._bounds = toLatLngBounds(bounds);

			if (this._map) {
				this._reset();
			}
			return this;
		},

		getEvents: function () {
			var events = {
				zoom: this._reset,
				viewreset: this._reset
			};

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}

			return events;
		},

		// @method: setZIndex(value: Number) : this
		// Changes the [zIndex](#imageoverlay-zindex) of the image overlay.
		setZIndex: function (value) {
			this.options.zIndex = value;
			this._updateZIndex();
			return this;
		},

		// @method getBounds(): LatLngBounds
		// Get the bounds that this ImageOverlay covers
		getBounds: function () {
			return this._bounds;
		},

		// @method getElement(): HTMLElement
		// Returns the instance of [`HTMLImageElement`](https://developer.mozilla.org/docs/Web/API/HTMLImageElement)
		// used by this overlay.
		getElement: function () {
			return this._image;
		},

		_initImage: function () {
			var wasElementSupplied = this._url.tagName === 'IMG';
			var img = this._image = wasElementSupplied ? this._url : create$1('img');

			addClass(img, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(img, 'leaflet-zoom-animated'); }
			if (this.options.className) { addClass(img, this.options.className); }

			img.onselectstart = falseFn;
			img.onmousemove = falseFn;

			// @event load: Event
			// Fired when the ImageOverlay layer has loaded its image
			img.onload = bind(this.fire, this, 'load');
			img.onerror = bind(this._overlayOnError, this, 'error');

			if (this.options.crossOrigin) {
				img.crossOrigin = '';
			}

			if (this.options.zIndex) {
				this._updateZIndex();
			}

			if (wasElementSupplied) {
				this._url = img.src;
				return;
			}

			img.src = this._url;
			img.alt = this.options.alt;
		},

		_animateZoom: function (e) {
			var scale = this._map.getZoomScale(e.zoom),
			    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

			setTransform(this._image, offset, scale);
		},

		_reset: function () {
			var image = this._image,
			    bounds = new Bounds(
			        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
			        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
			    size = bounds.getSize();

			setPosition(image, bounds.min);

			image.style.width  = size.x + 'px';
			image.style.height = size.y + 'px';
		},

		_updateOpacity: function () {
			setOpacity(this._image, this.options.opacity);
		},

		_updateZIndex: function () {
			if (this._image && this.options.zIndex !== undefined && this.options.zIndex !== null) {
				this._image.style.zIndex = this.options.zIndex;
			}
		},

		_overlayOnError: function () {
			// @event error: Event
			// Fired when the ImageOverlay layer has loaded its image
			this.fire('error');

			var errorUrl = this.options.errorOverlayUrl;
			if (errorUrl && this._url !== errorUrl) {
				this._url = errorUrl;
				this._image.src = errorUrl;
			}
		}
	});

	// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
	// Instantiates an image overlay object given the URL of the image and the
	// geographical bounds it is tied to.
	var imageOverlay = function (url, bounds, options) {
		return new ImageOverlay(url, bounds, options);
	};

	/*
	 * @class VideoOverlay
	 * @aka L.VideoOverlay
	 * @inherits ImageOverlay
	 *
	 * Used to load and display a video player over specific bounds of the map. Extends `ImageOverlay`.
	 *
	 * A video overlay uses the [`<video>`](https://developer.mozilla.org/docs/Web/HTML/Element/video)
	 * HTML5 element.
	 *
	 * @example
	 *
	 * ```js
	 * var videoUrl = 'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
	 * 	videoBounds = [[ 32, -130], [ 13, -100]];
	 * L.VideoOverlay(videoUrl, videoBounds ).addTo(map);
	 * ```
	 */

	var VideoOverlay = ImageOverlay.extend({

		// @section
		// @aka VideoOverlay options
		options: {
			// @option autoplay: Boolean = true
			// Whether the video starts playing automatically when loaded.
			autoplay: true,

			// @option loop: Boolean = true
			// Whether the video will loop back to the beginning when played.
			loop: true
		},

		_initImage: function () {
			var wasElementSupplied = this._url.tagName === 'VIDEO';
			var vid = this._image = wasElementSupplied ? this._url : create$1('video');

			addClass(vid, 'leaflet-image-layer');
			if (this._zoomAnimated) { addClass(vid, 'leaflet-zoom-animated'); }

			vid.onselectstart = falseFn;
			vid.onmousemove = falseFn;

			// @event load: Event
			// Fired when the video has finished loading the first frame
			vid.onloadeddata = bind(this.fire, this, 'load');

			if (wasElementSupplied) {
				var sourceElements = vid.getElementsByTagName('source');
				var sources = [];
				for (var j = 0; j < sourceElements.length; j++) {
					sources.push(sourceElements[j].src);
				}

				this._url = (sourceElements.length > 0) ? sources : [vid.src];
				return;
			}

			if (!isArray(this._url)) { this._url = [this._url]; }

			vid.autoplay = !!this.options.autoplay;
			vid.loop = !!this.options.loop;
			for (var i = 0; i < this._url.length; i++) {
				var source = create$1('source');
				source.src = this._url[i];
				vid.appendChild(source);
			}
		}

		// @method getElement(): HTMLVideoElement
		// Returns the instance of [`HTMLVideoElement`](https://developer.mozilla.org/docs/Web/API/HTMLVideoElement)
		// used by this overlay.
	});


	// @factory L.videoOverlay(video: String|Array|HTMLVideoElement, bounds: LatLngBounds, options?: VideoOverlay options)
	// Instantiates an image overlay object given the URL of the video (or array of URLs, or even a video element) and the
	// geographical bounds it is tied to.

	function videoOverlay(video, bounds, options) {
		return new VideoOverlay(video, bounds, options);
	}

	/*
	 * @class DivOverlay
	 * @inherits Layer
	 * @aka L.DivOverlay
	 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
	 */

	// @namespace DivOverlay
	var DivOverlay = Layer.extend({

		// @section
		// @aka DivOverlay options
		options: {
			// @option offset: Point = Point(0, 7)
			// The offset of the popup position. Useful to control the anchor
			// of the popup when opening it on some overlays.
			offset: [0, 7],

			// @option className: String = ''
			// A custom CSS class name to assign to the popup.
			className: '',

			// @option pane: String = 'popupPane'
			// `Map pane` where the popup will be added.
			pane: 'popupPane'
		},

		initialize: function (options, source) {
			setOptions(this, options);

			this._source = source;
		},

		onAdd: function (map) {
			this._zoomAnimated = map._zoomAnimated;

			if (!this._container) {
				this._initLayout();
			}

			if (map._fadeAnimated) {
				setOpacity(this._container, 0);
			}

			clearTimeout(this._removeTimeout);
			this.getPane().appendChild(this._container);
			this.update();

			if (map._fadeAnimated) {
				setOpacity(this._container, 1);
			}

			this.bringToFront();
		},

		onRemove: function (map) {
			if (map._fadeAnimated) {
				setOpacity(this._container, 0);
				this._removeTimeout = setTimeout(bind(remove, undefined, this._container), 200);
			} else {
				remove(this._container);
			}
		},

		// @namespace Popup
		// @method getLatLng: LatLng
		// Returns the geographical point of popup.
		getLatLng: function () {
			return this._latlng;
		},

		// @method setLatLng(latlng: LatLng): this
		// Sets the geographical point where the popup will open.
		setLatLng: function (latlng) {
			this._latlng = toLatLng(latlng);
			if (this._map) {
				this._updatePosition();
				this._adjustPan();
			}
			return this;
		},

		// @method getContent: String|HTMLElement
		// Returns the content of the popup.
		getContent: function () {
			return this._content;
		},

		// @method setContent(htmlContent: String|HTMLElement|Function): this
		// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
		setContent: function (content) {
			this._content = content;
			this.update();
			return this;
		},

		// @method getElement: String|HTMLElement
		// Alias for [getContent()](#popup-getcontent)
		getElement: function () {
			return this._container;
		},

		// @method update: null
		// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
		update: function () {
			if (!this._map) { return; }

			this._container.style.visibility = 'hidden';

			this._updateContent();
			this._updateLayout();
			this._updatePosition();

			this._container.style.visibility = '';

			this._adjustPan();
		},

		getEvents: function () {
			var events = {
				zoom: this._updatePosition,
				viewreset: this._updatePosition
			};

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}
			return events;
		},

		// @method isOpen: Boolean
		// Returns `true` when the popup is visible on the map.
		isOpen: function () {
			return !!this._map && this._map.hasLayer(this);
		},

		// @method bringToFront: this
		// Brings this popup in front of other popups (in the same map pane).
		bringToFront: function () {
			if (this._map) {
				toFront(this._container);
			}
			return this;
		},

		// @method bringToBack: this
		// Brings this popup to the back of other popups (in the same map pane).
		bringToBack: function () {
			if (this._map) {
				toBack(this._container);
			}
			return this;
		},

		_updateContent: function () {
			if (!this._content) { return; }

			var node = this._contentNode;
			var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

			if (typeof content === 'string') {
				node.innerHTML = content;
			} else {
				while (node.hasChildNodes()) {
					node.removeChild(node.firstChild);
				}
				node.appendChild(content);
			}
			this.fire('contentupdate');
		},

		_updatePosition: function () {
			if (!this._map) { return; }

			var pos = this._map.latLngToLayerPoint(this._latlng),
			    offset = toPoint(this.options.offset),
			    anchor = this._getAnchor();

			if (this._zoomAnimated) {
				setPosition(this._container, pos.add(anchor));
			} else {
				offset = offset.add(pos).add(anchor);
			}

			var bottom = this._containerBottom = -offset.y,
			    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

			// bottom position the popup in case the height of the popup changes (images loading etc)
			this._container.style.bottom = bottom + 'px';
			this._container.style.left = left + 'px';
		},

		_getAnchor: function () {
			return [0, 0];
		}

	});

	/*
	 * @class Popup
	 * @inherits DivOverlay
	 * @aka L.Popup
	 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
	 * open popups while making sure that only one popup is open at one time
	 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
	 *
	 * @example
	 *
	 * If you want to just bind a popup to marker click and then open it, it's really easy:
	 *
	 * ```js
	 * marker.bindPopup(popupContent).openPopup();
	 * ```
	 * Path overlays like polylines also have a `bindPopup` method.
	 * Here's a more complicated way to open a popup on a map:
	 *
	 * ```js
	 * var popup = L.popup()
	 * 	.setLatLng(latlng)
	 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
	 * 	.openOn(map);
	 * ```
	 */


	// @namespace Popup
	var Popup = DivOverlay.extend({

		// @section
		// @aka Popup options
		options: {
			// @option maxWidth: Number = 300
			// Max width of the popup, in pixels.
			maxWidth: 300,

			// @option minWidth: Number = 50
			// Min width of the popup, in pixels.
			minWidth: 50,

			// @option maxHeight: Number = null
			// If set, creates a scrollable container of the given height
			// inside a popup if its content exceeds it.
			maxHeight: null,

			// @option autoPan: Boolean = true
			// Set it to `false` if you don't want the map to do panning animation
			// to fit the opened popup.
			autoPan: true,

			// @option autoPanPaddingTopLeft: Point = null
			// The margin between the popup and the top left corner of the map
			// view after autopanning was performed.
			autoPanPaddingTopLeft: null,

			// @option autoPanPaddingBottomRight: Point = null
			// The margin between the popup and the bottom right corner of the map
			// view after autopanning was performed.
			autoPanPaddingBottomRight: null,

			// @option autoPanPadding: Point = Point(5, 5)
			// Equivalent of setting both top left and bottom right autopan padding to the same value.
			autoPanPadding: [5, 5],

			// @option keepInView: Boolean = false
			// Set it to `true` if you want to prevent users from panning the popup
			// off of the screen while it is open.
			keepInView: false,

			// @option closeButton: Boolean = true
			// Controls the presence of a close button in the popup.
			closeButton: true,

			// @option autoClose: Boolean = true
			// Set it to `false` if you want to override the default behavior of
			// the popup closing when another popup is opened.
			autoClose: true,

			// @option closeOnEscapeKey: Boolean = true
			// Set it to `false` if you want to override the default behavior of
			// the ESC key for closing of the popup.
			closeOnEscapeKey: true,

			// @option closeOnClick: Boolean = *
			// Set it if you want to override the default behavior of the popup closing when user clicks
			// on the map. Defaults to the map's [`closePopupOnClick`](#map-closepopuponclick) option.

			// @option className: String = ''
			// A custom CSS class name to assign to the popup.
			className: ''
		},

		// @namespace Popup
		// @method openOn(map: Map): this
		// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
		openOn: function (map) {
			map.openPopup(this);
			return this;
		},

		onAdd: function (map) {
			DivOverlay.prototype.onAdd.call(this, map);

			// @namespace Map
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup is opened in the map
			map.fire('popupopen', {popup: this});

			if (this._source) {
				// @namespace Layer
				// @section Popup events
				// @event popupopen: PopupEvent
				// Fired when a popup bound to this layer is opened
				this._source.fire('popupopen', {popup: this}, true);
				// For non-path layers, we toggle the popup when clicking
				// again the layer, so prevent the map to reopen it.
				if (!(this._source instanceof Path)) {
					this._source.on('preclick', stopPropagation);
				}
			}
		},

		onRemove: function (map) {
			DivOverlay.prototype.onRemove.call(this, map);

			// @namespace Map
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup in the map is closed
			map.fire('popupclose', {popup: this});

			if (this._source) {
				// @namespace Layer
				// @section Popup events
				// @event popupclose: PopupEvent
				// Fired when a popup bound to this layer is closed
				this._source.fire('popupclose', {popup: this}, true);
				if (!(this._source instanceof Path)) {
					this._source.off('preclick', stopPropagation);
				}
			}
		},

		getEvents: function () {
			var events = DivOverlay.prototype.getEvents.call(this);

			if (this.options.closeOnClick !== undefined ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
				events.preclick = this._close;
			}

			if (this.options.keepInView) {
				events.moveend = this._adjustPan;
			}

			return events;
		},

		_close: function () {
			if (this._map) {
				this._map.closePopup(this);
			}
		},

		_initLayout: function () {
			var prefix = 'leaflet-popup',
			    container = this._container = create$1('div',
				prefix + ' ' + (this.options.className || '') +
				' leaflet-zoom-animated');

			var wrapper = this._wrapper = create$1('div', prefix + '-content-wrapper', container);
			this._contentNode = create$1('div', prefix + '-content', wrapper);

			disableClickPropagation(wrapper);
			disableScrollPropagation(this._contentNode);
			on(wrapper, 'contextmenu', stopPropagation);

			this._tipContainer = create$1('div', prefix + '-tip-container', container);
			this._tip = create$1('div', prefix + '-tip', this._tipContainer);

			if (this.options.closeButton) {
				var closeButton = this._closeButton = create$1('a', prefix + '-close-button', container);
				closeButton.href = '#close';
				closeButton.innerHTML = '&#215;';

				on(closeButton, 'click', this._onCloseButtonClick, this);
			}
		},

		_updateLayout: function () {
			var container = this._contentNode,
			    style = container.style;

			style.width = '';
			style.whiteSpace = 'nowrap';

			var width = container.offsetWidth;
			width = Math.min(width, this.options.maxWidth);
			width = Math.max(width, this.options.minWidth);

			style.width = (width + 1) + 'px';
			style.whiteSpace = '';

			style.height = '';

			var height = container.offsetHeight,
			    maxHeight = this.options.maxHeight,
			    scrolledClass = 'leaflet-popup-scrolled';

			if (maxHeight && height > maxHeight) {
				style.height = maxHeight + 'px';
				addClass(container, scrolledClass);
			} else {
				removeClass(container, scrolledClass);
			}

			this._containerWidth = this._container.offsetWidth;
		},

		_animateZoom: function (e) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
			    anchor = this._getAnchor();
			setPosition(this._container, pos.add(anchor));
		},

		_adjustPan: function () {
			if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

			var map = this._map,
			    marginBottom = parseInt(getStyle(this._container, 'marginBottom'), 10) || 0,
			    containerHeight = this._container.offsetHeight + marginBottom,
			    containerWidth = this._containerWidth,
			    layerPos = new Point(this._containerLeft, -containerHeight - this._containerBottom);

			layerPos._add(getPosition(this._container));

			var containerPos = map.layerPointToContainerPoint(layerPos),
			    padding = toPoint(this.options.autoPanPadding),
			    paddingTL = toPoint(this.options.autoPanPaddingTopLeft || padding),
			    paddingBR = toPoint(this.options.autoPanPaddingBottomRight || padding),
			    size = map.getSize(),
			    dx = 0,
			    dy = 0;

			if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
				dx = containerPos.x + containerWidth - size.x + paddingBR.x;
			}
			if (containerPos.x - dx - paddingTL.x < 0) { // left
				dx = containerPos.x - paddingTL.x;
			}
			if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
				dy = containerPos.y + containerHeight - size.y + paddingBR.y;
			}
			if (containerPos.y - dy - paddingTL.y < 0) { // top
				dy = containerPos.y - paddingTL.y;
			}

			// @namespace Map
			// @section Popup events
			// @event autopanstart: Event
			// Fired when the map starts autopanning when opening a popup.
			if (dx || dy) {
				map
				    .fire('autopanstart')
				    .panBy([dx, dy]);
			}
		},

		_onCloseButtonClick: function (e) {
			this._close();
			stop(e);
		},

		_getAnchor: function () {
			// Where should we anchor the popup on the source layer?
			return toPoint(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
		}

	});

	// @namespace Popup
	// @factory L.popup(options?: Popup options, source?: Layer)
	// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
	var popup = function (options, source) {
		return new Popup(options, source);
	};


	/* @namespace Map
	 * @section Interaction Options
	 * @option closePopupOnClick: Boolean = true
	 * Set it to `false` if you don't want popups to close when user clicks the map.
	 */
	Map.mergeOptions({
		closePopupOnClick: true
	});


	// @namespace Map
	// @section Methods for Layers and Controls
	Map.include({
		// @method openPopup(popup: Popup): this
		// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
		// @alternative
		// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
		// Creates a popup with the specified content and options and opens it in the given point on a map.
		openPopup: function (popup, latlng, options) {
			if (!(popup instanceof Popup)) {
				popup = new Popup(options).setContent(popup);
			}

			if (latlng) {
				popup.setLatLng(latlng);
			}

			if (this.hasLayer(popup)) {
				return this;
			}

			if (this._popup && this._popup.options.autoClose) {
				this.closePopup();
			}

			this._popup = popup;
			return this.addLayer(popup);
		},

		// @method closePopup(popup?: Popup): this
		// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
		closePopup: function (popup) {
			if (!popup || popup === this._popup) {
				popup = this._popup;
				this._popup = null;
			}
			if (popup) {
				this.removeLayer(popup);
			}
			return this;
		}
	});

	/*
	 * @namespace Layer
	 * @section Popup methods example
	 *
	 * All layers share a set of methods convenient for binding popups to it.
	 *
	 * ```js
	 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
	 * layer.openPopup();
	 * layer.closePopup();
	 * ```
	 *
	 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
	 */

	// @section Popup methods
	Layer.include({

		// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
		// Binds a popup to the layer with the passed `content` and sets up the
		// necessary event listeners. If a `Function` is passed it will receive
		// the layer as the first argument and should return a `String` or `HTMLElement`.
		bindPopup: function (content, options) {

			if (content instanceof Popup) {
				setOptions(content, options);
				this._popup = content;
				content._source = this;
			} else {
				if (!this._popup || options) {
					this._popup = new Popup(options, this);
				}
				this._popup.setContent(content);
			}

			if (!this._popupHandlersAdded) {
				this.on({
					click: this._openPopup,
					keypress: this._onKeyPress,
					remove: this.closePopup,
					move: this._movePopup
				});
				this._popupHandlersAdded = true;
			}

			return this;
		},

		// @method unbindPopup(): this
		// Removes the popup previously bound with `bindPopup`.
		unbindPopup: function () {
			if (this._popup) {
				this.off({
					click: this._openPopup,
					keypress: this._onKeyPress,
					remove: this.closePopup,
					move: this._movePopup
				});
				this._popupHandlersAdded = false;
				this._popup = null;
			}
			return this;
		},

		// @method openPopup(latlng?: LatLng): this
		// Opens the bound popup at the specified `latlng` or at the default popup anchor if no `latlng` is passed.
		openPopup: function (layer, latlng) {
			if (!(layer instanceof Layer)) {
				latlng = layer;
				layer = this;
			}

			if (layer instanceof FeatureGroup) {
				for (var id in this._layers) {
					layer = this._layers[id];
					break;
				}
			}

			if (!latlng) {
				latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
			}

			if (this._popup && this._map) {
				// set popup source to this layer
				this._popup._source = layer;

				// update the popup (content, layout, ect...)
				this._popup.update();

				// open the popup on the map
				this._map.openPopup(this._popup, latlng);
			}

			return this;
		},

		// @method closePopup(): this
		// Closes the popup bound to this layer if it is open.
		closePopup: function () {
			if (this._popup) {
				this._popup._close();
			}
			return this;
		},

		// @method togglePopup(): this
		// Opens or closes the popup bound to this layer depending on its current state.
		togglePopup: function (target) {
			if (this._popup) {
				if (this._popup._map) {
					this.closePopup();
				} else {
					this.openPopup(target);
				}
			}
			return this;
		},

		// @method isPopupOpen(): boolean
		// Returns `true` if the popup bound to this layer is currently open.
		isPopupOpen: function () {
			return (this._popup ? this._popup.isOpen() : false);
		},

		// @method setPopupContent(content: String|HTMLElement|Popup): this
		// Sets the content of the popup bound to this layer.
		setPopupContent: function (content) {
			if (this._popup) {
				this._popup.setContent(content);
			}
			return this;
		},

		// @method getPopup(): Popup
		// Returns the popup bound to this layer.
		getPopup: function () {
			return this._popup;
		},

		_openPopup: function (e) {
			var layer = e.layer || e.target;

			if (!this._popup) {
				return;
			}

			if (!this._map) {
				return;
			}

			// prevent map click
			stop(e);

			// if this inherits from Path its a vector and we can just
			// open the popup at the new location
			if (layer instanceof Path) {
				this.openPopup(e.layer || e.target, e.latlng);
				return;
			}

			// otherwise treat it like a marker and figure out
			// if we should toggle it open/closed
			if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
				this.closePopup();
			} else {
				this.openPopup(layer, e.latlng);
			}
		},

		_movePopup: function (e) {
			this._popup.setLatLng(e.latlng);
		},

		_onKeyPress: function (e) {
			if (e.originalEvent.keyCode === 13) {
				this._openPopup(e);
			}
		}
	});

	/*
	 * @class Tooltip
	 * @inherits DivOverlay
	 * @aka L.Tooltip
	 * Used to display small texts on top of map layers.
	 *
	 * @example
	 *
	 * ```js
	 * marker.bindTooltip("my tooltip text").openTooltip();
	 * ```
	 * Note about tooltip offset. Leaflet takes two options in consideration
	 * for computing tooltip offsetting:
	 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
	 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
	 *   move it to the bottom. Negatives will move to the left and top.
	 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
	 *   should adapt this value if you use a custom icon.
	 */


	// @namespace Tooltip
	var Tooltip = DivOverlay.extend({

		// @section
		// @aka Tooltip options
		options: {
			// @option pane: String = 'tooltipPane'
			// `Map pane` where the tooltip will be added.
			pane: 'tooltipPane',

			// @option offset: Point = Point(0, 0)
			// Optional offset of the tooltip position.
			offset: [0, 0],

			// @option direction: String = 'auto'
			// Direction where to open the tooltip. Possible values are: `right`, `left`,
			// `top`, `bottom`, `center`, `auto`.
			// `auto` will dynamically switch between `right` and `left` according to the tooltip
			// position on the map.
			direction: 'auto',

			// @option permanent: Boolean = false
			// Whether to open the tooltip permanently or only on mouseover.
			permanent: false,

			// @option sticky: Boolean = false
			// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
			sticky: false,

			// @option interactive: Boolean = false
			// If true, the tooltip will listen to the feature events.
			interactive: false,

			// @option opacity: Number = 0.9
			// Tooltip container opacity.
			opacity: 0.9
		},

		onAdd: function (map) {
			DivOverlay.prototype.onAdd.call(this, map);
			this.setOpacity(this.options.opacity);

			// @namespace Map
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip is opened in the map.
			map.fire('tooltipopen', {tooltip: this});

			if (this._source) {
				// @namespace Layer
				// @section Tooltip events
				// @event tooltipopen: TooltipEvent
				// Fired when a tooltip bound to this layer is opened.
				this._source.fire('tooltipopen', {tooltip: this}, true);
			}
		},

		onRemove: function (map) {
			DivOverlay.prototype.onRemove.call(this, map);

			// @namespace Map
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip in the map is closed.
			map.fire('tooltipclose', {tooltip: this});

			if (this._source) {
				// @namespace Layer
				// @section Tooltip events
				// @event tooltipclose: TooltipEvent
				// Fired when a tooltip bound to this layer is closed.
				this._source.fire('tooltipclose', {tooltip: this}, true);
			}
		},

		getEvents: function () {
			var events = DivOverlay.prototype.getEvents.call(this);

			if (touch && !this.options.permanent) {
				events.preclick = this._close;
			}

			return events;
		},

		_close: function () {
			if (this._map) {
				this._map.closeTooltip(this);
			}
		},

		_initLayout: function () {
			var prefix = 'leaflet-tooltip',
			    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

			this._contentNode = this._container = create$1('div', className);
		},

		_updateLayout: function () {},

		_adjustPan: function () {},

		_setPosition: function (pos) {
			var map = this._map,
			    container = this._container,
			    centerPoint = map.latLngToContainerPoint(map.getCenter()),
			    tooltipPoint = map.layerPointToContainerPoint(pos),
			    direction = this.options.direction,
			    tooltipWidth = container.offsetWidth,
			    tooltipHeight = container.offsetHeight,
			    offset = toPoint(this.options.offset),
			    anchor = this._getAnchor();

			if (direction === 'top') {
				pos = pos.add(toPoint(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
			} else if (direction === 'bottom') {
				pos = pos.subtract(toPoint(tooltipWidth / 2 - offset.x, -offset.y, true));
			} else if (direction === 'center') {
				pos = pos.subtract(toPoint(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
			} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
				direction = 'right';
				pos = pos.add(toPoint(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
			} else {
				direction = 'left';
				pos = pos.subtract(toPoint(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
			}

			removeClass(container, 'leaflet-tooltip-right');
			removeClass(container, 'leaflet-tooltip-left');
			removeClass(container, 'leaflet-tooltip-top');
			removeClass(container, 'leaflet-tooltip-bottom');
			addClass(container, 'leaflet-tooltip-' + direction);
			setPosition(container, pos);
		},

		_updatePosition: function () {
			var pos = this._map.latLngToLayerPoint(this._latlng);
			this._setPosition(pos);
		},

		setOpacity: function (opacity) {
			this.options.opacity = opacity;

			if (this._container) {
				setOpacity(this._container, opacity);
			}
		},

		_animateZoom: function (e) {
			var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
			this._setPosition(pos);
		},

		_getAnchor: function () {
			// Where should we anchor the tooltip on the source layer?
			return toPoint(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
		}

	});

	// @namespace Tooltip
	// @factory L.tooltip(options?: Tooltip options, source?: Layer)
	// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
	var tooltip = function (options, source) {
		return new Tooltip(options, source);
	};

	// @namespace Map
	// @section Methods for Layers and Controls
	Map.include({

		// @method openTooltip(tooltip: Tooltip): this
		// Opens the specified tooltip.
		// @alternative
		// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
		// Creates a tooltip with the specified content and options and open it.
		openTooltip: function (tooltip, latlng, options) {
			if (!(tooltip instanceof Tooltip)) {
				tooltip = new Tooltip(options).setContent(tooltip);
			}

			if (latlng) {
				tooltip.setLatLng(latlng);
			}

			if (this.hasLayer(tooltip)) {
				return this;
			}

			return this.addLayer(tooltip);
		},

		// @method closeTooltip(tooltip?: Tooltip): this
		// Closes the tooltip given as parameter.
		closeTooltip: function (tooltip) {
			if (tooltip) {
				this.removeLayer(tooltip);
			}
			return this;
		}

	});

	/*
	 * @namespace Layer
	 * @section Tooltip methods example
	 *
	 * All layers share a set of methods convenient for binding tooltips to it.
	 *
	 * ```js
	 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
	 * layer.openTooltip();
	 * layer.closeTooltip();
	 * ```
	 */

	// @section Tooltip methods
	Layer.include({

		// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
		// Binds a tooltip to the layer with the passed `content` and sets up the
		// necessary event listeners. If a `Function` is passed it will receive
		// the layer as the first argument and should return a `String` or `HTMLElement`.
		bindTooltip: function (content, options) {

			if (content instanceof Tooltip) {
				setOptions(content, options);
				this._tooltip = content;
				content._source = this;
			} else {
				if (!this._tooltip || options) {
					this._tooltip = new Tooltip(options, this);
				}
				this._tooltip.setContent(content);

			}

			this._initTooltipInteractions();

			if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
				this.openTooltip();
			}

			return this;
		},

		// @method unbindTooltip(): this
		// Removes the tooltip previously bound with `bindTooltip`.
		unbindTooltip: function () {
			if (this._tooltip) {
				this._initTooltipInteractions(true);
				this.closeTooltip();
				this._tooltip = null;
			}
			return this;
		},

		_initTooltipInteractions: function (remove$$1) {
			if (!remove$$1 && this._tooltipHandlersAdded) { return; }
			var onOff = remove$$1 ? 'off' : 'on',
			    events = {
				remove: this.closeTooltip,
				move: this._moveTooltip
			    };
			if (!this._tooltip.options.permanent) {
				events.mouseover = this._openTooltip;
				events.mouseout = this.closeTooltip;
				if (this._tooltip.options.sticky) {
					events.mousemove = this._moveTooltip;
				}
				if (touch) {
					events.click = this._openTooltip;
				}
			} else {
				events.add = this._openTooltip;
			}
			this[onOff](events);
			this._tooltipHandlersAdded = !remove$$1;
		},

		// @method openTooltip(latlng?: LatLng): this
		// Opens the bound tooltip at the specified `latlng` or at the default tooltip anchor if no `latlng` is passed.
		openTooltip: function (layer, latlng) {
			if (!(layer instanceof Layer)) {
				latlng = layer;
				layer = this;
			}

			if (layer instanceof FeatureGroup) {
				for (var id in this._layers) {
					layer = this._layers[id];
					break;
				}
			}

			if (!latlng) {
				latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
			}

			if (this._tooltip && this._map) {

				// set tooltip source to this layer
				this._tooltip._source = layer;

				// update the tooltip (content, layout, ect...)
				this._tooltip.update();

				// open the tooltip on the map
				this._map.openTooltip(this._tooltip, latlng);

				// Tooltip container may not be defined if not permanent and never
				// opened.
				if (this._tooltip.options.interactive && this._tooltip._container) {
					addClass(this._tooltip._container, 'leaflet-clickable');
					this.addInteractiveTarget(this._tooltip._container);
				}
			}

			return this;
		},

		// @method closeTooltip(): this
		// Closes the tooltip bound to this layer if it is open.
		closeTooltip: function () {
			if (this._tooltip) {
				this._tooltip._close();
				if (this._tooltip.options.interactive && this._tooltip._container) {
					removeClass(this._tooltip._container, 'leaflet-clickable');
					this.removeInteractiveTarget(this._tooltip._container);
				}
			}
			return this;
		},

		// @method toggleTooltip(): this
		// Opens or closes the tooltip bound to this layer depending on its current state.
		toggleTooltip: function (target) {
			if (this._tooltip) {
				if (this._tooltip._map) {
					this.closeTooltip();
				} else {
					this.openTooltip(target);
				}
			}
			return this;
		},

		// @method isTooltipOpen(): boolean
		// Returns `true` if the tooltip bound to this layer is currently open.
		isTooltipOpen: function () {
			return this._tooltip.isOpen();
		},

		// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
		// Sets the content of the tooltip bound to this layer.
		setTooltipContent: function (content) {
			if (this._tooltip) {
				this._tooltip.setContent(content);
			}
			return this;
		},

		// @method getTooltip(): Tooltip
		// Returns the tooltip bound to this layer.
		getTooltip: function () {
			return this._tooltip;
		},

		_openTooltip: function (e) {
			var layer = e.layer || e.target;

			if (!this._tooltip || !this._map) {
				return;
			}
			this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
		},

		_moveTooltip: function (e) {
			var latlng = e.latlng, containerPoint, layerPoint;
			if (this._tooltip.options.sticky && e.originalEvent) {
				containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
				layerPoint = this._map.containerPointToLayerPoint(containerPoint);
				latlng = this._map.layerPointToLatLng(layerPoint);
			}
			this._tooltip.setLatLng(latlng);
		}
	});

	/*
	 * @class DivIcon
	 * @aka L.DivIcon
	 * @inherits Icon
	 *
	 * Represents a lightweight icon for markers that uses a simple `<div>`
	 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
	 *
	 * @example
	 * ```js
	 * var myIcon = L.divIcon({className: 'my-div-icon'});
	 * // you can set .my-div-icon styles in CSS
	 *
	 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
	 * ```
	 *
	 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
	 */

	var DivIcon = Icon.extend({
		options: {
			// @section
			// @aka DivIcon options
			iconSize: [12, 12], // also can be set through CSS

			// iconAnchor: (Point),
			// popupAnchor: (Point),

			// @option html: String = ''
			// Custom HTML code to put inside the div element, empty by default.
			html: false,

			// @option bgPos: Point = [0, 0]
			// Optional relative position of the background, in pixels
			bgPos: null,

			className: 'leaflet-div-icon'
		},

		createIcon: function (oldIcon) {
			var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
			    options = this.options;

			div.innerHTML = options.html !== false ? options.html : '';

			if (options.bgPos) {
				var bgPos = toPoint(options.bgPos);
				div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
			}
			this._setIconStyles(div, 'icon');

			return div;
		},

		createShadow: function () {
			return null;
		}
	});

	// @factory L.divIcon(options: DivIcon options)
	// Creates a `DivIcon` instance with the given options.
	function divIcon(options) {
		return new DivIcon(options);
	}

	Icon.Default = IconDefault;

	/*
	 * @class GridLayer
	 * @inherits Layer
	 * @aka L.GridLayer
	 *
	 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
	 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
	 *
	 *
	 * @section Synchronous usage
	 * @example
	 *
	 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
	 *
	 * ```js
	 * var CanvasLayer = L.GridLayer.extend({
	 *     createTile: function(coords){
	 *         // create a <canvas> element for drawing
	 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
	 *
	 *         // setup tile width and height according to the options
	 *         var size = this.getTileSize();
	 *         tile.width = size.x;
	 *         tile.height = size.y;
	 *
	 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
	 *         var ctx = tile.getContext('2d');
	 *
	 *         // return the tile so it can be rendered on screen
	 *         return tile;
	 *     }
	 * });
	 * ```
	 *
	 * @section Asynchronous usage
	 * @example
	 *
	 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
	 *
	 * ```js
	 * var CanvasLayer = L.GridLayer.extend({
	 *     createTile: function(coords, done){
	 *         var error;
	 *
	 *         // create a <canvas> element for drawing
	 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
	 *
	 *         // setup tile width and height according to the options
	 *         var size = this.getTileSize();
	 *         tile.width = size.x;
	 *         tile.height = size.y;
	 *
	 *         // draw something asynchronously and pass the tile to the done() callback
	 *         setTimeout(function() {
	 *             done(error, tile);
	 *         }, 1000);
	 *
	 *         return tile;
	 *     }
	 * });
	 * ```
	 *
	 * @section
	 */


	var GridLayer = Layer.extend({

		// @section
		// @aka GridLayer options
		options: {
			// @option tileSize: Number|Point = 256
			// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
			tileSize: 256,

			// @option opacity: Number = 1.0
			// Opacity of the tiles. Can be used in the `createTile()` function.
			opacity: 1,

			// @option updateWhenIdle: Boolean = (depends)
			// Load new tiles only when panning ends.
			// `true` by default on mobile browsers, in order to avoid too many requests and keep smooth navigation.
			// `false` otherwise in order to display new tiles _during_ panning, since it is easy to pan outside the
			// [`keepBuffer`](#gridlayer-keepbuffer) option in desktop browsers.
			updateWhenIdle: mobile,

			// @option updateWhenZooming: Boolean = true
			// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
			updateWhenZooming: true,

			// @option updateInterval: Number = 200
			// Tiles will not update more than once every `updateInterval` milliseconds when panning.
			updateInterval: 200,

			// @option zIndex: Number = 1
			// The explicit zIndex of the tile layer.
			zIndex: 1,

			// @option bounds: LatLngBounds = undefined
			// If set, tiles will only be loaded inside the set `LatLngBounds`.
			bounds: null,

			// @option minZoom: Number = 0
			// The minimum zoom level down to which this layer will be displayed (inclusive).
			minZoom: 0,

			// @option maxZoom: Number = undefined
			// The maximum zoom level up to which this layer will be displayed (inclusive).
			maxZoom: undefined,

			// @option maxNativeZoom: Number = undefined
			// Maximum zoom number the tile source has available. If it is specified,
			// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
			// from `maxNativeZoom` level and auto-scaled.
			maxNativeZoom: undefined,

			// @option minNativeZoom: Number = undefined
			// Minimum zoom number the tile source has available. If it is specified,
			// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
			// from `minNativeZoom` level and auto-scaled.
			minNativeZoom: undefined,

			// @option noWrap: Boolean = false
			// Whether the layer is wrapped around the antimeridian. If `true`, the
			// GridLayer will only be displayed once at low zoom levels. Has no
			// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
			// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
			// tiles outside the CRS limits.
			noWrap: false,

			// @option pane: String = 'tilePane'
			// `Map pane` where the grid layer will be added.
			pane: 'tilePane',

			// @option className: String = ''
			// A custom class name to assign to the tile layer. Empty by default.
			className: '',

			// @option keepBuffer: Number = 2
			// When panning the map, keep this many rows and columns of tiles before unloading them.
			keepBuffer: 2
		},

		initialize: function (options) {
			setOptions(this, options);
		},

		onAdd: function () {
			this._initContainer();

			this._levels = {};
			this._tiles = {};

			this._resetView();
			this._update();
		},

		beforeAdd: function (map) {
			map._addZoomLimit(this);
		},

		onRemove: function (map) {
			this._removeAllTiles();
			remove(this._container);
			map._removeZoomLimit(this);
			this._container = null;
			this._tileZoom = undefined;
		},

		// @method bringToFront: this
		// Brings the tile layer to the top of all tile layers.
		bringToFront: function () {
			if (this._map) {
				toFront(this._container);
				this._setAutoZIndex(Math.max);
			}
			return this;
		},

		// @method bringToBack: this
		// Brings the tile layer to the bottom of all tile layers.
		bringToBack: function () {
			if (this._map) {
				toBack(this._container);
				this._setAutoZIndex(Math.min);
			}
			return this;
		},

		// @method getContainer: HTMLElement
		// Returns the HTML element that contains the tiles for this layer.
		getContainer: function () {
			return this._container;
		},

		// @method setOpacity(opacity: Number): this
		// Changes the [opacity](#gridlayer-opacity) of the grid layer.
		setOpacity: function (opacity) {
			this.options.opacity = opacity;
			this._updateOpacity();
			return this;
		},

		// @method setZIndex(zIndex: Number): this
		// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
		setZIndex: function (zIndex) {
			this.options.zIndex = zIndex;
			this._updateZIndex();

			return this;
		},

		// @method isLoading: Boolean
		// Returns `true` if any tile in the grid layer has not finished loading.
		isLoading: function () {
			return this._loading;
		},

		// @method redraw: this
		// Causes the layer to clear all the tiles and request them again.
		redraw: function () {
			if (this._map) {
				this._removeAllTiles();
				this._update();
			}
			return this;
		},

		getEvents: function () {
			var events = {
				viewprereset: this._invalidateAll,
				viewreset: this._resetView,
				zoom: this._resetView,
				moveend: this._onMoveEnd
			};

			if (!this.options.updateWhenIdle) {
				// update tiles on move, but not more often than once per given interval
				if (!this._onMove) {
					this._onMove = throttle(this._onMoveEnd, this.options.updateInterval, this);
				}

				events.move = this._onMove;
			}

			if (this._zoomAnimated) {
				events.zoomanim = this._animateZoom;
			}

			return events;
		},

		// @section Extension methods
		// Layers extending `GridLayer` shall reimplement the following method.
		// @method createTile(coords: Object, done?: Function): HTMLElement
		// Called only internally, must be overridden by classes extending `GridLayer`.
		// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
		// is specified, it must be called when the tile has finished loading and drawing.
		createTile: function () {
			return document.createElement('div');
		},

		// @section
		// @method getTileSize: Point
		// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
		getTileSize: function () {
			var s = this.options.tileSize;
			return s instanceof Point ? s : new Point(s, s);
		},

		_updateZIndex: function () {
			if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
				this._container.style.zIndex = this.options.zIndex;
			}
		},

		_setAutoZIndex: function (compare) {
			// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

			var layers = this.getPane().children,
			    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

			for (var i = 0, len = layers.length, zIndex; i < len; i++) {

				zIndex = layers[i].style.zIndex;

				if (layers[i] !== this._container && zIndex) {
					edgeZIndex = compare(edgeZIndex, +zIndex);
				}
			}

			if (isFinite(edgeZIndex)) {
				this.options.zIndex = edgeZIndex + compare(-1, 1);
				this._updateZIndex();
			}
		},

		_updateOpacity: function () {
			if (!this._map) { return; }

			// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
			if (ielt9) { return; }

			setOpacity(this._container, this.options.opacity);

			var now = +new Date(),
			    nextFrame = false,
			    willPrune = false;

			for (var key in this._tiles) {
				var tile = this._tiles[key];
				if (!tile.current || !tile.loaded) { continue; }

				var fade = Math.min(1, (now - tile.loaded) / 200);

				setOpacity(tile.el, fade);
				if (fade < 1) {
					nextFrame = true;
				} else {
					if (tile.active) {
						willPrune = true;
					} else {
						this._onOpaqueTile(tile);
					}
					tile.active = true;
				}
			}

			if (willPrune && !this._noPrune) { this._pruneTiles(); }

			if (nextFrame) {
				cancelAnimFrame(this._fadeFrame);
				this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
			}
		},

		_onOpaqueTile: falseFn,

		_initContainer: function () {
			if (this._container) { return; }

			this._container = create$1('div', 'leaflet-layer ' + (this.options.className || ''));
			this._updateZIndex();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}

			this.getPane().appendChild(this._container);
		},

		_updateLevels: function () {

			var zoom = this._tileZoom,
			    maxZoom = this.options.maxZoom;

			if (zoom === undefined) { return undefined; }

			for (var z in this._levels) {
				if (this._levels[z].el.children.length || z === zoom) {
					this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
					this._onUpdateLevel(z);
				} else {
					remove(this._levels[z].el);
					this._removeTilesAtZoom(z);
					this._onRemoveLevel(z);
					delete this._levels[z];
				}
			}

			var level = this._levels[zoom],
			    map = this._map;

			if (!level) {
				level = this._levels[zoom] = {};

				level.el = create$1('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
				level.el.style.zIndex = maxZoom;

				level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
				level.zoom = zoom;

				this._setZoomTransform(level, map.getCenter(), map.getZoom());

				// force the browser to consider the newly added element for transition
				falseFn(level.el.offsetWidth);

				this._onCreateLevel(level);
			}

			this._level = level;

			return level;
		},

		_onUpdateLevel: falseFn,

		_onRemoveLevel: falseFn,

		_onCreateLevel: falseFn,

		_pruneTiles: function () {
			if (!this._map) {
				return;
			}

			var key, tile;

			var zoom = this._map.getZoom();
			if (zoom > this.options.maxZoom ||
				zoom < this.options.minZoom) {
				this._removeAllTiles();
				return;
			}

			for (key in this._tiles) {
				tile = this._tiles[key];
				tile.retain = tile.current;
			}

			for (key in this._tiles) {
				tile = this._tiles[key];
				if (tile.current && !tile.active) {
					var coords = tile.coords;
					if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
						this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
					}
				}
			}

			for (key in this._tiles) {
				if (!this._tiles[key].retain) {
					this._removeTile(key);
				}
			}
		},

		_removeTilesAtZoom: function (zoom) {
			for (var key in this._tiles) {
				if (this._tiles[key].coords.z !== zoom) {
					continue;
				}
				this._removeTile(key);
			}
		},

		_removeAllTiles: function () {
			for (var key in this._tiles) {
				this._removeTile(key);
			}
		},

		_invalidateAll: function () {
			for (var z in this._levels) {
				remove(this._levels[z].el);
				this._onRemoveLevel(z);
				delete this._levels[z];
			}
			this._removeAllTiles();

			this._tileZoom = undefined;
		},

		_retainParent: function (x, y, z, minZoom) {
			var x2 = Math.floor(x / 2),
			    y2 = Math.floor(y / 2),
			    z2 = z - 1,
			    coords2 = new Point(+x2, +y2);
			coords2.z = +z2;

			var key = this._tileCoordsToKey(coords2),
			    tile = this._tiles[key];

			if (tile && tile.active) {
				tile.retain = true;
				return true;

			} else if (tile && tile.loaded) {
				tile.retain = true;
			}

			if (z2 > minZoom) {
				return this._retainParent(x2, y2, z2, minZoom);
			}

			return false;
		},

		_retainChildren: function (x, y, z, maxZoom) {

			for (var i = 2 * x; i < 2 * x + 2; i++) {
				for (var j = 2 * y; j < 2 * y + 2; j++) {

					var coords = new Point(i, j);
					coords.z = z + 1;

					var key = this._tileCoordsToKey(coords),
					    tile = this._tiles[key];

					if (tile && tile.active) {
						tile.retain = true;
						continue;

					} else if (tile && tile.loaded) {
						tile.retain = true;
					}

					if (z + 1 < maxZoom) {
						this._retainChildren(i, j, z + 1, maxZoom);
					}
				}
			}
		},

		_resetView: function (e) {
			var animating = e && (e.pinch || e.flyTo);
			this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
		},

		_animateZoom: function (e) {
			this._setView(e.center, e.zoom, true, e.noUpdate);
		},

		_clampZoom: function (zoom) {
			var options = this.options;

			if (undefined !== options.minNativeZoom && zoom < options.minNativeZoom) {
				return options.minNativeZoom;
			}

			if (undefined !== options.maxNativeZoom && options.maxNativeZoom < zoom) {
				return options.maxNativeZoom;
			}

			return zoom;
		},

		_setView: function (center, zoom, noPrune, noUpdate) {
			var tileZoom = this._clampZoom(Math.round(zoom));
			if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
			    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
				tileZoom = undefined;
			}

			var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

			if (!noUpdate || tileZoomChanged) {

				this._tileZoom = tileZoom;

				if (this._abortLoading) {
					this._abortLoading();
				}

				this._updateLevels();
				this._resetGrid();

				if (tileZoom !== undefined) {
					this._update(center);
				}

				if (!noPrune) {
					this._pruneTiles();
				}

				// Flag to prevent _updateOpacity from pruning tiles during
				// a zoom anim or a pinch gesture
				this._noPrune = !!noPrune;
			}

			this._setZoomTransforms(center, zoom);
		},

		_setZoomTransforms: function (center, zoom) {
			for (var i in this._levels) {
				this._setZoomTransform(this._levels[i], center, zoom);
			}
		},

		_setZoomTransform: function (level, center, zoom) {
			var scale = this._map.getZoomScale(zoom, level.zoom),
			    translate = level.origin.multiplyBy(scale)
			        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

			if (any3d) {
				setTransform(level.el, translate, scale);
			} else {
				setPosition(level.el, translate);
			}
		},

		_resetGrid: function () {
			var map = this._map,
			    crs = map.options.crs,
			    tileSize = this._tileSize = this.getTileSize(),
			    tileZoom = this._tileZoom;

			var bounds = this._map.getPixelWorldBounds(this._tileZoom);
			if (bounds) {
				this._globalTileRange = this._pxBoundsToTileRange(bounds);
			}

			this._wrapX = crs.wrapLng && !this.options.noWrap && [
				Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
				Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
			];
			this._wrapY = crs.wrapLat && !this.options.noWrap && [
				Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
				Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
			];
		},

		_onMoveEnd: function () {
			if (!this._map || this._map._animatingZoom) { return; }

			this._update();
		},

		_getTiledPixelBounds: function (center) {
			var map = this._map,
			    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
			    scale = map.getZoomScale(mapZoom, this._tileZoom),
			    pixelCenter = map.project(center, this._tileZoom).floor(),
			    halfSize = map.getSize().divideBy(scale * 2);

			return new Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
		},

		// Private method to load tiles in the grid's active zoom level according to map bounds
		_update: function (center) {
			var map = this._map;
			if (!map) { return; }
			var zoom = this._clampZoom(map.getZoom());

			if (center === undefined) { center = map.getCenter(); }
			if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

			var pixelBounds = this._getTiledPixelBounds(center),
			    tileRange = this._pxBoundsToTileRange(pixelBounds),
			    tileCenter = tileRange.getCenter(),
			    queue = [],
			    margin = this.options.keepBuffer,
			    noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
			                              tileRange.getTopRight().add([margin, -margin]));

			// Sanity check: panic if the tile range contains Infinity somewhere.
			if (!(isFinite(tileRange.min.x) &&
			      isFinite(tileRange.min.y) &&
			      isFinite(tileRange.max.x) &&
			      isFinite(tileRange.max.y))) { throw new Error('Attempted to load an infinite number of tiles'); }

			for (var key in this._tiles) {
				var c = this._tiles[key].coords;
				if (c.z !== this._tileZoom || !noPruneRange.contains(new Point(c.x, c.y))) {
					this._tiles[key].current = false;
				}
			}

			// _update just loads more tiles. If the tile zoom level differs too much
			// from the map's, let _setView reset levels and prune old tiles.
			if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

			// create a queue of coordinates to load tiles from
			for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
				for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
					var coords = new Point(i, j);
					coords.z = this._tileZoom;

					if (!this._isValidTile(coords)) { continue; }

					var tile = this._tiles[this._tileCoordsToKey(coords)];
					if (tile) {
						tile.current = true;
					} else {
						queue.push(coords);
					}
				}
			}

			// sort tile queue to load tiles in order of their distance to center
			queue.sort(function (a, b) {
				return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
			});

			if (queue.length !== 0) {
				// if it's the first batch of tiles to load
				if (!this._loading) {
					this._loading = true;
					// @event loading: Event
					// Fired when the grid layer starts loading tiles.
					this.fire('loading');
				}

				// create DOM fragment to append tiles in one batch
				var fragment = document.createDocumentFragment();

				for (i = 0; i < queue.length; i++) {
					this._addTile(queue[i], fragment);
				}

				this._level.el.appendChild(fragment);
			}
		},

		_isValidTile: function (coords) {
			var crs = this._map.options.crs;

			if (!crs.infinite) {
				// don't load tile if it's out of bounds and not wrapped
				var bounds = this._globalTileRange;
				if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
				    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
			}

			if (!this.options.bounds) { return true; }

			// don't load tile if it doesn't intersect the bounds in options
			var tileBounds = this._tileCoordsToBounds(coords);
			return toLatLngBounds(this.options.bounds).overlaps(tileBounds);
		},

		_keyToBounds: function (key) {
			return this._tileCoordsToBounds(this._keyToTileCoords(key));
		},

		_tileCoordsToNwSe: function (coords) {
			var map = this._map,
			    tileSize = this.getTileSize(),
			    nwPoint = coords.scaleBy(tileSize),
			    sePoint = nwPoint.add(tileSize),
			    nw = map.unproject(nwPoint, coords.z),
			    se = map.unproject(sePoint, coords.z);
			return [nw, se];
		},

		// converts tile coordinates to its geographical bounds
		_tileCoordsToBounds: function (coords) {
			var bp = this._tileCoordsToNwSe(coords),
			    bounds = new LatLngBounds(bp[0], bp[1]);

			if (!this.options.noWrap) {
				bounds = this._map.wrapLatLngBounds(bounds);
			}
			return bounds;
		},
		// converts tile coordinates to key for the tile cache
		_tileCoordsToKey: function (coords) {
			return coords.x + ':' + coords.y + ':' + coords.z;
		},

		// converts tile cache key to coordinates
		_keyToTileCoords: function (key) {
			var k = key.split(':'),
			    coords = new Point(+k[0], +k[1]);
			coords.z = +k[2];
			return coords;
		},

		_removeTile: function (key) {
			var tile = this._tiles[key];
			if (!tile) { return; }

			// Cancels any pending http requests associated with the tile
			// unless we're on Android's stock browser,
			// see https://github.com/Leaflet/Leaflet/issues/137
			if (!androidStock) {
				tile.el.setAttribute('src', emptyImageUrl);
			}
			remove(tile.el);

			delete this._tiles[key];

			// @event tileunload: TileEvent
			// Fired when a tile is removed (e.g. when a tile goes off the screen).
			this.fire('tileunload', {
				tile: tile.el,
				coords: this._keyToTileCoords(key)
			});
		},

		_initTile: function (tile) {
			addClass(tile, 'leaflet-tile');

			var tileSize = this.getTileSize();
			tile.style.width = tileSize.x + 'px';
			tile.style.height = tileSize.y + 'px';

			tile.onselectstart = falseFn;
			tile.onmousemove = falseFn;

			// update opacity on tiles in IE7-8 because of filter inheritance problems
			if (ielt9 && this.options.opacity < 1) {
				setOpacity(tile, this.options.opacity);
			}

			// without this hack, tiles disappear after zoom on Chrome for Android
			// https://github.com/Leaflet/Leaflet/issues/2078
			if (android && !android23) {
				tile.style.WebkitBackfaceVisibility = 'hidden';
			}
		},

		_addTile: function (coords, container) {
			var tilePos = this._getTilePos(coords),
			    key = this._tileCoordsToKey(coords);

			var tile = this.createTile(this._wrapCoords(coords), bind(this._tileReady, this, coords));

			this._initTile(tile);

			// if createTile is defined with a second argument ("done" callback),
			// we know that tile is async and will be ready later; otherwise
			if (this.createTile.length < 2) {
				// mark tile as ready, but delay one frame for opacity animation to happen
				requestAnimFrame(bind(this._tileReady, this, coords, null, tile));
			}

			setPosition(tile, tilePos);

			// save tile in cache
			this._tiles[key] = {
				el: tile,
				coords: coords,
				current: true
			};

			container.appendChild(tile);
			// @event tileloadstart: TileEvent
			// Fired when a tile is requested and starts loading.
			this.fire('tileloadstart', {
				tile: tile,
				coords: coords
			});
		},

		_tileReady: function (coords, err, tile) {
			if (!this._map) { return; }

			if (err) {
				// @event tileerror: TileErrorEvent
				// Fired when there is an error loading a tile.
				this.fire('tileerror', {
					error: err,
					tile: tile,
					coords: coords
				});
			}

			var key = this._tileCoordsToKey(coords);

			tile = this._tiles[key];
			if (!tile) { return; }

			tile.loaded = +new Date();
			if (this._map._fadeAnimated) {
				setOpacity(tile.el, 0);
				cancelAnimFrame(this._fadeFrame);
				this._fadeFrame = requestAnimFrame(this._updateOpacity, this);
			} else {
				tile.active = true;
				this._pruneTiles();
			}

			if (!err) {
				addClass(tile.el, 'leaflet-tile-loaded');

				// @event tileload: TileEvent
				// Fired when a tile loads.
				this.fire('tileload', {
					tile: tile.el,
					coords: coords
				});
			}

			if (this._noTilesToLoad()) {
				this._loading = false;
				// @event load: Event
				// Fired when the grid layer loaded all visible tiles.
				this.fire('load');

				if (ielt9 || !this._map._fadeAnimated) {
					requestAnimFrame(this._pruneTiles, this);
				} else {
					// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
					// to trigger a pruning.
					setTimeout(bind(this._pruneTiles, this), 250);
				}
			}
		},

		_getTilePos: function (coords) {
			return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
		},

		_wrapCoords: function (coords) {
			var newCoords = new Point(
				this._wrapX ? wrapNum(coords.x, this._wrapX) : coords.x,
				this._wrapY ? wrapNum(coords.y, this._wrapY) : coords.y);
			newCoords.z = coords.z;
			return newCoords;
		},

		_pxBoundsToTileRange: function (bounds) {
			var tileSize = this.getTileSize();
			return new Bounds(
				bounds.min.unscaleBy(tileSize).floor(),
				bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
		},

		_noTilesToLoad: function () {
			for (var key in this._tiles) {
				if (!this._tiles[key].loaded) { return false; }
			}
			return true;
		}
	});

	// @factory L.gridLayer(options?: GridLayer options)
	// Creates a new instance of GridLayer with the supplied options.
	function gridLayer(options) {
		return new GridLayer(options);
	}

	/*
	 * @class TileLayer
	 * @inherits GridLayer
	 * @aka L.TileLayer
	 * Used to load and display tile layers on the map. Extends `GridLayer`.
	 *
	 * @example
	 *
	 * ```js
	 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
	 * ```
	 *
	 * @section URL template
	 * @example
	 *
	 * A string of the following form:
	 *
	 * ```
	 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
	 * ```
	 *
	 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add "&commat;2x" to the URL to load retina tiles.
	 *
	 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
	 *
	 * ```
	 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
	 * ```
	 */


	var TileLayer = GridLayer.extend({

		// @section
		// @aka TileLayer options
		options: {
			// @option minZoom: Number = 0
			// The minimum zoom level down to which this layer will be displayed (inclusive).
			minZoom: 0,

			// @option maxZoom: Number = 18
			// The maximum zoom level up to which this layer will be displayed (inclusive).
			maxZoom: 18,

			// @option subdomains: String|String[] = 'abc'
			// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
			subdomains: 'abc',

			// @option errorTileUrl: String = ''
			// URL to the tile image to show in place of the tile that failed to load.
			errorTileUrl: '',

			// @option zoomOffset: Number = 0
			// The zoom number used in tile URLs will be offset with this value.
			zoomOffset: 0,

			// @option tms: Boolean = false
			// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
			tms: false,

			// @option zoomReverse: Boolean = false
			// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
			zoomReverse: false,

			// @option detectRetina: Boolean = false
			// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
			detectRetina: false,

			// @option crossOrigin: Boolean = false
			// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
			crossOrigin: false
		},

		initialize: function (url, options) {

			this._url = url;

			options = setOptions(this, options);

			// detecting retina displays, adjusting tileSize and zoom levels
			if (options.detectRetina && retina && options.maxZoom > 0) {

				options.tileSize = Math.floor(options.tileSize / 2);

				if (!options.zoomReverse) {
					options.zoomOffset++;
					options.maxZoom--;
				} else {
					options.zoomOffset--;
					options.minZoom++;
				}

				options.minZoom = Math.max(0, options.minZoom);
			}

			if (typeof options.subdomains === 'string') {
				options.subdomains = options.subdomains.split('');
			}

			// for https://github.com/Leaflet/Leaflet/issues/137
			if (!android) {
				this.on('tileunload', this._onTileRemove);
			}
		},

		// @method setUrl(url: String, noRedraw?: Boolean): this
		// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
		setUrl: function (url, noRedraw) {
			this._url = url;

			if (!noRedraw) {
				this.redraw();
			}
			return this;
		},

		// @method createTile(coords: Object, done?: Function): HTMLElement
		// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
		// to return an `<img>` HTML element with the appropriate image URL given `coords`. The `done`
		// callback is called when the tile has been loaded.
		createTile: function (coords, done) {
			var tile = document.createElement('img');

			on(tile, 'load', bind(this._tileOnLoad, this, done, tile));
			on(tile, 'error', bind(this._tileOnError, this, done, tile));

			if (this.options.crossOrigin) {
				tile.crossOrigin = '';
			}

			/*
			 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
			 http://www.w3.org/TR/WCAG20-TECHS/H67
			*/
			tile.alt = '';

			/*
			 Set role="presentation" to force screen readers to ignore this
			 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
			*/
			tile.setAttribute('role', 'presentation');

			tile.src = this.getTileUrl(coords);

			return tile;
		},

		// @section Extension methods
		// @uninheritable
		// Layers extending `TileLayer` might reimplement the following method.
		// @method getTileUrl(coords: Object): String
		// Called only internally, returns the URL for a tile given its coordinates.
		// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
		getTileUrl: function (coords) {
			var data = {
				r: retina ? '@2x' : '',
				s: this._getSubdomain(coords),
				x: coords.x,
				y: coords.y,
				z: this._getZoomForUrl()
			};
			if (this._map && !this._map.options.crs.infinite) {
				var invertedY = this._globalTileRange.max.y - coords.y;
				if (this.options.tms) {
					data['y'] = invertedY;
				}
				data['-y'] = invertedY;
			}

			return template(this._url, extend(data, this.options));
		},

		_tileOnLoad: function (done, tile) {
			// For https://github.com/Leaflet/Leaflet/issues/3332
			if (ielt9) {
				setTimeout(bind(done, this, null, tile), 0);
			} else {
				done(null, tile);
			}
		},

		_tileOnError: function (done, tile, e) {
			var errorUrl = this.options.errorTileUrl;
			if (errorUrl && tile.getAttribute('src') !== errorUrl) {
				tile.src = errorUrl;
			}
			done(e, tile);
		},

		_onTileRemove: function (e) {
			e.tile.onload = null;
		},

		_getZoomForUrl: function () {
			var zoom = this._tileZoom,
			maxZoom = this.options.maxZoom,
			zoomReverse = this.options.zoomReverse,
			zoomOffset = this.options.zoomOffset;

			if (zoomReverse) {
				zoom = maxZoom - zoom;
			}

			return zoom + zoomOffset;
		},

		_getSubdomain: function (tilePoint) {
			var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
			return this.options.subdomains[index];
		},

		// stops loading all tiles in the background layer
		_abortLoading: function () {
			var i, tile;
			for (i in this._tiles) {
				if (this._tiles[i].coords.z !== this._tileZoom) {
					tile = this._tiles[i].el;

					tile.onload = falseFn;
					tile.onerror = falseFn;

					if (!tile.complete) {
						tile.src = emptyImageUrl;
						remove(tile);
						delete this._tiles[i];
					}
				}
			}
		}
	});


	// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
	// Instantiates a tile layer object given a `URL template` and optionally an options object.

	function tileLayer(url, options) {
		return new TileLayer(url, options);
	}

	/*
	 * @class TileLayer.WMS
	 * @inherits TileLayer
	 * @aka L.TileLayer.WMS
	 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
	 *
	 * @example
	 *
	 * ```js
	 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
	 * 	layers: 'nexrad-n0r-900913',
	 * 	format: 'image/png',
	 * 	transparent: true,
	 * 	attribution: "Weather data © 2012 IEM Nexrad"
	 * });
	 * ```
	 */

	var TileLayerWMS = TileLayer.extend({

		// @section
		// @aka TileLayer.WMS options
		// If any custom options not documented here are used, they will be sent to the
		// WMS server as extra parameters in each request URL. This can be useful for
		// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
		defaultWmsParams: {
			service: 'WMS',
			request: 'GetMap',

			// @option layers: String = ''
			// **(required)** Comma-separated list of WMS layers to show.
			layers: '',

			// @option styles: String = ''
			// Comma-separated list of WMS styles.
			styles: '',

			// @option format: String = 'image/jpeg'
			// WMS image format (use `'image/png'` for layers with transparency).
			format: 'image/jpeg',

			// @option transparent: Boolean = false
			// If `true`, the WMS service will return images with transparency.
			transparent: false,

			// @option version: String = '1.1.1'
			// Version of the WMS service to use
			version: '1.1.1'
		},

		options: {
			// @option crs: CRS = null
			// Coordinate Reference System to use for the WMS requests, defaults to
			// map CRS. Don't change this if you're not sure what it means.
			crs: null,

			// @option uppercase: Boolean = false
			// If `true`, WMS request parameter keys will be uppercase.
			uppercase: false
		},

		initialize: function (url, options) {

			this._url = url;

			var wmsParams = extend({}, this.defaultWmsParams);

			// all keys that are not TileLayer options go to WMS params
			for (var i in options) {
				if (!(i in this.options)) {
					wmsParams[i] = options[i];
				}
			}

			options = setOptions(this, options);

			var realRetina = options.detectRetina && retina ? 2 : 1;
			var tileSize = this.getTileSize();
			wmsParams.width = tileSize.x * realRetina;
			wmsParams.height = tileSize.y * realRetina;

			this.wmsParams = wmsParams;
		},

		onAdd: function (map) {

			this._crs = this.options.crs || map.options.crs;
			this._wmsVersion = parseFloat(this.wmsParams.version);

			var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
			this.wmsParams[projectionKey] = this._crs.code;

			TileLayer.prototype.onAdd.call(this, map);
		},

		getTileUrl: function (coords) {

			var tileBounds = this._tileCoordsToNwSe(coords),
			    crs = this._crs,
			    bounds = toBounds(crs.project(tileBounds[0]), crs.project(tileBounds[1])),
			    min = bounds.min,
			    max = bounds.max,
			    bbox = (this._wmsVersion >= 1.3 && this._crs === EPSG4326 ?
			    [min.y, min.x, max.y, max.x] :
			    [min.x, min.y, max.x, max.y]).join(','),
			url = L.TileLayer.prototype.getTileUrl.call(this, coords);
			return url +
				getParamString(this.wmsParams, url, this.options.uppercase) +
				(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
		},

		// @method setParams(params: Object, noRedraw?: Boolean): this
		// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
		setParams: function (params, noRedraw) {

			extend(this.wmsParams, params);

			if (!noRedraw) {
				this.redraw();
			}

			return this;
		}
	});


	// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
	// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
	function tileLayerWMS(url, options) {
		return new TileLayerWMS(url, options);
	}

	TileLayer.WMS = TileLayerWMS;
	tileLayer.wms = tileLayerWMS;

	/*
	 * @class Renderer
	 * @inherits Layer
	 * @aka L.Renderer
	 *
	 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
	 * DOM container of the renderer, its bounds, and its zoom animation.
	 *
	 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
	 * itself can be added or removed to the map. All paths use a renderer, which can
	 * be implicit (the map will decide the type of renderer and use it automatically)
	 * or explicit (using the [`renderer`](#path-renderer) option of the path).
	 *
	 * Do not use this class directly, use `SVG` and `Canvas` instead.
	 *
	 * @event update: Event
	 * Fired when the renderer updates its bounds, center and zoom, for example when
	 * its map has moved
	 */

	var Renderer = Layer.extend({

		// @section
		// @aka Renderer options
		options: {
			// @option padding: Number = 0.1
			// How much to extend the clip area around the map view (relative to its size)
			// e.g. 0.1 would be 10% of map view in each direction
			padding: 0.1,

			// @option tolerance: Number = 0
			// How much to extend click tolerance round a path/object on the map
			tolerance : 0
		},

		initialize: function (options) {
			setOptions(this, options);
			stamp(this);
			this._layers = this._layers || {};
		},

		onAdd: function () {
			if (!this._container) {
				this._initContainer(); // defined by renderer implementations

				if (this._zoomAnimated) {
					addClass(this._container, 'leaflet-zoom-animated');
				}
			}

			this.getPane().appendChild(this._container);
			this._update();
			this.on('update', this._updatePaths, this);
		},

		onRemove: function () {
			this.off('update', this._updatePaths, this);
			this._destroyContainer();
		},

		getEvents: function () {
			var events = {
				viewreset: this._reset,
				zoom: this._onZoom,
				moveend: this._update,
				zoomend: this._onZoomEnd
			};
			if (this._zoomAnimated) {
				events.zoomanim = this._onAnimZoom;
			}
			return events;
		},

		_onAnimZoom: function (ev) {
			this._updateTransform(ev.center, ev.zoom);
		},

		_onZoom: function () {
			this._updateTransform(this._map.getCenter(), this._map.getZoom());
		},

		_updateTransform: function (center, zoom) {
			var scale = this._map.getZoomScale(zoom, this._zoom),
			    position = getPosition(this._container),
			    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
			    currentCenterPoint = this._map.project(this._center, zoom),
			    destCenterPoint = this._map.project(center, zoom),
			    centerOffset = destCenterPoint.subtract(currentCenterPoint),

			    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

			if (any3d) {
				setTransform(this._container, topLeftOffset, scale);
			} else {
				setPosition(this._container, topLeftOffset);
			}
		},

		_reset: function () {
			this._update();
			this._updateTransform(this._center, this._zoom);

			for (var id in this._layers) {
				this._layers[id]._reset();
			}
		},

		_onZoomEnd: function () {
			for (var id in this._layers) {
				this._layers[id]._project();
			}
		},

		_updatePaths: function () {
			for (var id in this._layers) {
				this._layers[id]._update();
			}
		},

		_update: function () {
			// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
			// Subclasses are responsible of firing the 'update' event.
			var p = this.options.padding,
			    size = this._map.getSize(),
			    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

			this._bounds = new Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

			this._center = this._map.getCenter();
			this._zoom = this._map.getZoom();
		}
	});

	/*
	 * @class Canvas
	 * @inherits Renderer
	 * @aka L.Canvas
	 *
	 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
	 * Inherits `Renderer`.
	 *
	 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
	 * available in all web browsers, notably IE8, and overlapping geometries might
	 * not display properly in some edge cases.
	 *
	 * @example
	 *
	 * Use Canvas by default for all paths in the map:
	 *
	 * ```js
	 * var map = L.map('map', {
	 * 	renderer: L.canvas()
	 * });
	 * ```
	 *
	 * Use a Canvas renderer with extra padding for specific vector geometries:
	 *
	 * ```js
	 * var map = L.map('map');
	 * var myRenderer = L.canvas({ padding: 0.5 });
	 * var line = L.polyline( coordinates, { renderer: myRenderer } );
	 * var circle = L.circle( center, { renderer: myRenderer } );
	 * ```
	 */

	var Canvas = Renderer.extend({
		getEvents: function () {
			var events = Renderer.prototype.getEvents.call(this);
			events.viewprereset = this._onViewPreReset;
			return events;
		},

		_onViewPreReset: function () {
			// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
			this._postponeUpdatePaths = true;
		},

		onAdd: function () {
			Renderer.prototype.onAdd.call(this);

			// Redraw vectors since canvas is cleared upon removal,
			// in case of removing the renderer itself from the map.
			this._draw();
		},

		_initContainer: function () {
			var container = this._container = document.createElement('canvas');

			on(container, 'mousemove', throttle(this._onMouseMove, 32, this), this);
			on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this);
			on(container, 'mouseout', this._handleMouseOut, this);

			this._ctx = container.getContext('2d');
		},

		_destroyContainer: function () {
			delete this._ctx;
			remove(this._container);
			off(this._container);
			delete this._container;
		},

		_updatePaths: function () {
			if (this._postponeUpdatePaths) { return; }

			var layer;
			this._redrawBounds = null;
			for (var id in this._layers) {
				layer = this._layers[id];
				layer._update();
			}
			this._redraw();
		},

		_update: function () {
			if (this._map._animatingZoom && this._bounds) { return; }

			this._drawnLayers = {};

			Renderer.prototype._update.call(this);

			var b = this._bounds,
			    container = this._container,
			    size = b.getSize(),
			    m = retina ? 2 : 1;

			setPosition(container, b.min);

			// set canvas size (also clearing it); use double size on retina
			container.width = m * size.x;
			container.height = m * size.y;
			container.style.width = size.x + 'px';
			container.style.height = size.y + 'px';

			if (retina) {
				this._ctx.scale(2, 2);
			}

			// translate so we use the same path coordinates after canvas element moves
			this._ctx.translate(-b.min.x, -b.min.y);

			// Tell paths to redraw themselves
			this.fire('update');
		},

		_reset: function () {
			Renderer.prototype._reset.call(this);

			if (this._postponeUpdatePaths) {
				this._postponeUpdatePaths = false;
				this._updatePaths();
			}
		},

		_initPath: function (layer) {
			this._updateDashArray(layer);
			this._layers[stamp(layer)] = layer;

			var order = layer._order = {
				layer: layer,
				prev: this._drawLast,
				next: null
			};
			if (this._drawLast) { this._drawLast.next = order; }
			this._drawLast = order;
			this._drawFirst = this._drawFirst || this._drawLast;
		},

		_addPath: function (layer) {
			this._requestRedraw(layer);
		},

		_removePath: function (layer) {
			var order = layer._order;
			var next = order.next;
			var prev = order.prev;

			if (next) {
				next.prev = prev;
			} else {
				this._drawLast = prev;
			}
			if (prev) {
				prev.next = next;
			} else {
				this._drawFirst = next;
			}

			delete layer._order;

			delete this._layers[L.stamp(layer)];

			this._requestRedraw(layer);
		},

		_updatePath: function (layer) {
			// Redraw the union of the layer's old pixel
			// bounds and the new pixel bounds.
			this._extendRedrawBounds(layer);
			layer._project();
			layer._update();
			// The redraw will extend the redraw bounds
			// with the new pixel bounds.
			this._requestRedraw(layer);
		},

		_updateStyle: function (layer) {
			this._updateDashArray(layer);
			this._requestRedraw(layer);
		},

		_updateDashArray: function (layer) {
			if (layer.options.dashArray) {
				var parts = layer.options.dashArray.split(','),
				    dashArray = [],
				    i;
				for (i = 0; i < parts.length; i++) {
					dashArray.push(Number(parts[i]));
				}
				layer.options._dashArray = dashArray;
			}
		},

		_requestRedraw: function (layer) {
			if (!this._map) { return; }

			this._extendRedrawBounds(layer);
			this._redrawRequest = this._redrawRequest || requestAnimFrame(this._redraw, this);
		},

		_extendRedrawBounds: function (layer) {
			if (layer._pxBounds) {
				var padding = (layer.options.weight || 0) + 1;
				this._redrawBounds = this._redrawBounds || new Bounds();
				this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
				this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
			}
		},

		_redraw: function () {
			this._redrawRequest = null;

			if (this._redrawBounds) {
				this._redrawBounds.min._floor();
				this._redrawBounds.max._ceil();
			}

			this._clear(); // clear layers in redraw bounds
			this._draw(); // draw layers

			this._redrawBounds = null;
		},

		_clear: function () {
			var bounds = this._redrawBounds;
			if (bounds) {
				var size = bounds.getSize();
				this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
			} else {
				this._ctx.clearRect(0, 0, this._container.width, this._container.height);
			}
		},

		_draw: function () {
			var layer, bounds = this._redrawBounds;
			this._ctx.save();
			if (bounds) {
				var size = bounds.getSize();
				this._ctx.beginPath();
				this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
				this._ctx.clip();
			}

			this._drawing = true;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
					layer._updatePath();
				}
			}

			this._drawing = false;

			this._ctx.restore();  // Restore state before clipping.
		},

		_updatePoly: function (layer, closed) {
			if (!this._drawing) { return; }

			var i, j, len2, p,
			    parts = layer._parts,
			    len = parts.length,
			    ctx = this._ctx;

			if (!len) { return; }

			this._drawnLayers[layer._leaflet_id] = layer;

			ctx.beginPath();

			for (i = 0; i < len; i++) {
				for (j = 0, len2 = parts[i].length; j < len2; j++) {
					p = parts[i][j];
					ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
				}
				if (closed) {
					ctx.closePath();
				}
			}

			this._fillStroke(ctx, layer);

			// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
		},

		_updateCircle: function (layer) {

			if (!this._drawing || layer._empty()) { return; }

			var p = layer._point,
			    ctx = this._ctx,
			    r = Math.max(Math.round(layer._radius), 1),
			    s = (Math.max(Math.round(layer._radiusY), 1) || r) / r;

			this._drawnLayers[layer._leaflet_id] = layer;

			if (s !== 1) {
				ctx.save();
				ctx.scale(1, s);
			}

			ctx.beginPath();
			ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

			if (s !== 1) {
				ctx.restore();
			}

			this._fillStroke(ctx, layer);
		},

		_fillStroke: function (ctx, layer) {
			var options = layer.options;

			if (options.fill) {
				ctx.globalAlpha = options.fillOpacity;
				ctx.fillStyle = options.fillColor || options.color;
				ctx.fill(options.fillRule || 'evenodd');
			}

			if (options.stroke && options.weight !== 0) {
				if (ctx.setLineDash) {
					ctx.setLineDash(layer.options && layer.options._dashArray || []);
				}
				ctx.globalAlpha = options.opacity;
				ctx.lineWidth = options.weight;
				ctx.strokeStyle = options.color;
				ctx.lineCap = options.lineCap;
				ctx.lineJoin = options.lineJoin;
				ctx.stroke();
			}
		},

		// Canvas obviously doesn't have mouse events for individual drawn objects,
		// so we emulate that by calculating what's under the mouse on mousemove/click manually

		_onClick: function (e) {
			var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
					clickedLayer = layer;
				}
			}
			if (clickedLayer)  {
				fakeStop(e);
				this._fireEvent([clickedLayer], e);
			}
		},

		_onMouseMove: function (e) {
			if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

			var point = this._map.mouseEventToLayerPoint(e);
			this._handleMouseHover(e, point);
		},


		_handleMouseOut: function (e) {
			var layer = this._hoveredLayer;
			if (layer) {
				// if we're leaving the layer, fire mouseout
				removeClass(this._container, 'leaflet-interactive');
				this._fireEvent([layer], e, 'mouseout');
				this._hoveredLayer = null;
			}
		},

		_handleMouseHover: function (e, point) {
			var layer, candidateHoveredLayer;

			for (var order = this._drawFirst; order; order = order.next) {
				layer = order.layer;
				if (layer.options.interactive && layer._containsPoint(point)) {
					candidateHoveredLayer = layer;
				}
			}

			if (candidateHoveredLayer !== this._hoveredLayer) {
				this._handleMouseOut(e);

				if (candidateHoveredLayer) {
					addClass(this._container, 'leaflet-interactive'); // change cursor
					this._fireEvent([candidateHoveredLayer], e, 'mouseover');
					this._hoveredLayer = candidateHoveredLayer;
				}
			}

			if (this._hoveredLayer) {
				this._fireEvent([this._hoveredLayer], e);
			}
		},

		_fireEvent: function (layers, e, type) {
			this._map._fireDOMEvent(e, type || e.type, layers);
		},

		_bringToFront: function (layer) {
			var order = layer._order;
			var next = order.next;
			var prev = order.prev;

			if (next) {
				next.prev = prev;
			} else {
				// Already last
				return;
			}
			if (prev) {
				prev.next = next;
			} else if (next) {
				// Update first entry unless this is the
				// single entry
				this._drawFirst = next;
			}

			order.prev = this._drawLast;
			this._drawLast.next = order;

			order.next = null;
			this._drawLast = order;

			this._requestRedraw(layer);
		},

		_bringToBack: function (layer) {
			var order = layer._order;
			var next = order.next;
			var prev = order.prev;

			if (prev) {
				prev.next = next;
			} else {
				// Already first
				return;
			}
			if (next) {
				next.prev = prev;
			} else if (prev) {
				// Update last entry unless this is the
				// single entry
				this._drawLast = prev;
			}

			order.prev = null;

			order.next = this._drawFirst;
			this._drawFirst.prev = order;
			this._drawFirst = order;

			this._requestRedraw(layer);
		}
	});

	// @factory L.canvas(options?: Renderer options)
	// Creates a Canvas renderer with the given options.
	function canvas$1(options) {
		return canvas ? new Canvas(options) : null;
	}

	/*
	 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
	 */


	var vmlCreate = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();


	/*
	 * @class SVG
	 *
	 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
	 *
	 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
	 * with old versions of Internet Explorer.
	 */

	// mixin to redefine some SVG methods to handle VML syntax which is similar but with some differences
	var vmlMixin = {

		_initContainer: function () {
			this._container = create$1('div', 'leaflet-vml-container');
		},

		_update: function () {
			if (this._map._animatingZoom) { return; }
			Renderer.prototype._update.call(this);
			this.fire('update');
		},

		_initPath: function (layer) {
			var container = layer._container = vmlCreate('shape');

			addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

			container.coordsize = '1 1';

			layer._path = vmlCreate('path');
			container.appendChild(layer._path);

			this._updateStyle(layer);
			this._layers[stamp(layer)] = layer;
		},

		_addPath: function (layer) {
			var container = layer._container;
			this._container.appendChild(container);

			if (layer.options.interactive) {
				layer.addInteractiveTarget(container);
			}
		},

		_removePath: function (layer) {
			var container = layer._container;
			remove(container);
			layer.removeInteractiveTarget(container);
			delete this._layers[stamp(layer)];
		},

		_updateStyle: function (layer) {
			var stroke = layer._stroke,
			    fill = layer._fill,
			    options = layer.options,
			    container = layer._container;

			container.stroked = !!options.stroke;
			container.filled = !!options.fill;

			if (options.stroke) {
				if (!stroke) {
					stroke = layer._stroke = vmlCreate('stroke');
				}
				container.appendChild(stroke);
				stroke.weight = options.weight + 'px';
				stroke.color = options.color;
				stroke.opacity = options.opacity;

				if (options.dashArray) {
					stroke.dashStyle = isArray(options.dashArray) ?
					    options.dashArray.join(' ') :
					    options.dashArray.replace(/( *, *)/g, ' ');
				} else {
					stroke.dashStyle = '';
				}
				stroke.endcap = options.lineCap.replace('butt', 'flat');
				stroke.joinstyle = options.lineJoin;

			} else if (stroke) {
				container.removeChild(stroke);
				layer._stroke = null;
			}

			if (options.fill) {
				if (!fill) {
					fill = layer._fill = vmlCreate('fill');
				}
				container.appendChild(fill);
				fill.color = options.fillColor || options.color;
				fill.opacity = options.fillOpacity;

			} else if (fill) {
				container.removeChild(fill);
				layer._fill = null;
			}
		},

		_updateCircle: function (layer) {
			var p = layer._point.round(),
			    r = Math.round(layer._radius),
			    r2 = Math.round(layer._radiusY || r);

			this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
		},

		_setPath: function (layer, path) {
			layer._path.v = path;
		},

		_bringToFront: function (layer) {
			toFront(layer._container);
		},

		_bringToBack: function (layer) {
			toBack(layer._container);
		}
	};

	var create$2 = vml ? vmlCreate : svgCreate;

	/*
	 * @class SVG
	 * @inherits Renderer
	 * @aka L.SVG
	 *
	 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
	 * Inherits `Renderer`.
	 *
	 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
	 * available in all web browsers, notably Android 2.x and 3.x.
	 *
	 * Although SVG is not available on IE7 and IE8, these browsers support
	 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
	 * (a now deprecated technology), and the SVG renderer will fall back to VML in
	 * this case.
	 *
	 * @example
	 *
	 * Use SVG by default for all paths in the map:
	 *
	 * ```js
	 * var map = L.map('map', {
	 * 	renderer: L.svg()
	 * });
	 * ```
	 *
	 * Use a SVG renderer with extra padding for specific vector geometries:
	 *
	 * ```js
	 * var map = L.map('map');
	 * var myRenderer = L.svg({ padding: 0.5 });
	 * var line = L.polyline( coordinates, { renderer: myRenderer } );
	 * var circle = L.circle( center, { renderer: myRenderer } );
	 * ```
	 */

	var SVG = Renderer.extend({

		getEvents: function () {
			var events = Renderer.prototype.getEvents.call(this);
			events.zoomstart = this._onZoomStart;
			return events;
		},

		_initContainer: function () {
			this._container = create$2('svg');

			// makes it possible to click through svg root; we'll reset it back in individual paths
			this._container.setAttribute('pointer-events', 'none');

			this._rootGroup = create$2('g');
			this._container.appendChild(this._rootGroup);
		},

		_destroyContainer: function () {
			remove(this._container);
			off(this._container);
			delete this._container;
			delete this._rootGroup;
			delete this._svgSize;
		},

		_onZoomStart: function () {
			// Drag-then-pinch interactions might mess up the center and zoom.
			// In this case, the easiest way to prevent this is re-do the renderer
			//   bounds and padding when the zooming starts.
			this._update();
		},

		_update: function () {
			if (this._map._animatingZoom && this._bounds) { return; }

			Renderer.prototype._update.call(this);

			var b = this._bounds,
			    size = b.getSize(),
			    container = this._container;

			// set size of svg-container if changed
			if (!this._svgSize || !this._svgSize.equals(size)) {
				this._svgSize = size;
				container.setAttribute('width', size.x);
				container.setAttribute('height', size.y);
			}

			// movement: update container viewBox so that we don't have to change coordinates of individual layers
			setPosition(container, b.min);
			container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

			this.fire('update');
		},

		// methods below are called by vector layers implementations

		_initPath: function (layer) {
			var path = layer._path = create$2('path');

			// @namespace Path
			// @option className: String = null
			// Custom class name set on an element. Only for SVG renderer.
			if (layer.options.className) {
				addClass(path, layer.options.className);
			}

			if (layer.options.interactive) {
				addClass(path, 'leaflet-interactive');
			}

			this._updateStyle(layer);
			this._layers[stamp(layer)] = layer;
		},

		_addPath: function (layer) {
			if (!this._rootGroup) { this._initContainer(); }
			this._rootGroup.appendChild(layer._path);
			layer.addInteractiveTarget(layer._path);
		},

		_removePath: function (layer) {
			remove(layer._path);
			layer.removeInteractiveTarget(layer._path);
			delete this._layers[stamp(layer)];
		},

		_updatePath: function (layer) {
			layer._project();
			layer._update();
		},

		_updateStyle: function (layer) {
			var path = layer._path,
			    options = layer.options;

			if (!path) { return; }

			if (options.stroke) {
				path.setAttribute('stroke', options.color);
				path.setAttribute('stroke-opacity', options.opacity);
				path.setAttribute('stroke-width', options.weight);
				path.setAttribute('stroke-linecap', options.lineCap);
				path.setAttribute('stroke-linejoin', options.lineJoin);

				if (options.dashArray) {
					path.setAttribute('stroke-dasharray', options.dashArray);
				} else {
					path.removeAttribute('stroke-dasharray');
				}

				if (options.dashOffset) {
					path.setAttribute('stroke-dashoffset', options.dashOffset);
				} else {
					path.removeAttribute('stroke-dashoffset');
				}
			} else {
				path.setAttribute('stroke', 'none');
			}

			if (options.fill) {
				path.setAttribute('fill', options.fillColor || options.color);
				path.setAttribute('fill-opacity', options.fillOpacity);
				path.setAttribute('fill-rule', options.fillRule || 'evenodd');
			} else {
				path.setAttribute('fill', 'none');
			}
		},

		_updatePoly: function (layer, closed) {
			this._setPath(layer, pointsToPath(layer._parts, closed));
		},

		_updateCircle: function (layer) {
			var p = layer._point,
			    r = Math.max(Math.round(layer._radius), 1),
			    r2 = Math.max(Math.round(layer._radiusY), 1) || r,
			    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

			// drawing a circle with two half-arcs
			var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

			this._setPath(layer, d);
		},

		_setPath: function (layer, path) {
			layer._path.setAttribute('d', path);
		},

		// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
		_bringToFront: function (layer) {
			toFront(layer._path);
		},

		_bringToBack: function (layer) {
			toBack(layer._path);
		}
	});

	if (vml) {
		SVG.include(vmlMixin);
	}

	// @namespace SVG
	// @factory L.svg(options?: Renderer options)
	// Creates a SVG renderer with the given options.
	function svg$1(options) {
		return svg || vml ? new SVG(options) : null;
	}

	Map.include({
		// @namespace Map; @method getRenderer(layer: Path): Renderer
		// Returns the instance of `Renderer` that should be used to render the given
		// `Path`. It will ensure that the `renderer` options of the map and paths
		// are respected, and that the renderers do exist on the map.
		getRenderer: function (layer) {
			// @namespace Path; @option renderer: Renderer
			// Use this specific instance of `Renderer` for this path. Takes
			// precedence over the map's [default renderer](#map-renderer).
			var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

			if (!renderer) {
				// @namespace Map; @option preferCanvas: Boolean = false
				// Whether `Path`s should be rendered on a `Canvas` renderer.
				// By default, all `Path`s are rendered in a `SVG` renderer.
				renderer = this._renderer = (this.options.preferCanvas && canvas$1()) || svg$1();
			}

			if (!this.hasLayer(renderer)) {
				this.addLayer(renderer);
			}
			return renderer;
		},

		_getPaneRenderer: function (name) {
			if (name === 'overlayPane' || name === undefined) {
				return false;
			}

			var renderer = this._paneRenderers[name];
			if (renderer === undefined) {
				renderer = (SVG && svg$1({pane: name})) || (Canvas && canvas$1({pane: name}));
				this._paneRenderers[name] = renderer;
			}
			return renderer;
		}
	});

	/*
	 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
	 */

	/*
	 * @class Rectangle
	 * @aka L.Rectangle
	 * @inherits Polygon
	 *
	 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
	 *
	 * @example
	 *
	 * ```js
	 * // define rectangle geographical bounds
	 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
	 *
	 * // create an orange rectangle
	 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
	 *
	 * // zoom the map to the rectangle bounds
	 * map.fitBounds(bounds);
	 * ```
	 *
	 */


	var Rectangle = Polygon.extend({
		initialize: function (latLngBounds, options) {
			Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
		},

		// @method setBounds(latLngBounds: LatLngBounds): this
		// Redraws the rectangle with the passed bounds.
		setBounds: function (latLngBounds) {
			return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
		},

		_boundsToLatLngs: function (latLngBounds) {
			latLngBounds = toLatLngBounds(latLngBounds);
			return [
				latLngBounds.getSouthWest(),
				latLngBounds.getNorthWest(),
				latLngBounds.getNorthEast(),
				latLngBounds.getSouthEast()
			];
		}
	});


	// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
	function rectangle(latLngBounds, options) {
		return new Rectangle(latLngBounds, options);
	}

	SVG.create = create$2;
	SVG.pointsToPath = pointsToPath;

	GeoJSON.geometryToLayer = geometryToLayer;
	GeoJSON.coordsToLatLng = coordsToLatLng;
	GeoJSON.coordsToLatLngs = coordsToLatLngs;
	GeoJSON.latLngToCoords = latLngToCoords;
	GeoJSON.latLngsToCoords = latLngsToCoords;
	GeoJSON.getFeature = getFeature;
	GeoJSON.asFeature = asFeature;

	/*
	 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
	 * (zoom to a selected bounding box), enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @option boxZoom: Boolean = true
		// Whether the map can be zoomed to a rectangular area specified by
		// dragging the mouse while pressing the shift key.
		boxZoom: true
	});

	var BoxZoom = Handler.extend({
		initialize: function (map) {
			this._map = map;
			this._container = map._container;
			this._pane = map._panes.overlayPane;
			this._resetStateTimeout = 0;
			map.on('unload', this._destroy, this);
		},

		addHooks: function () {
			on(this._container, 'mousedown', this._onMouseDown, this);
		},

		removeHooks: function () {
			off(this._container, 'mousedown', this._onMouseDown, this);
		},

		moved: function () {
			return this._moved;
		},

		_destroy: function () {
			remove(this._pane);
			delete this._pane;
		},

		_resetState: function () {
			this._resetStateTimeout = 0;
			this._moved = false;
		},

		_clearDeferredResetState: function () {
			if (this._resetStateTimeout !== 0) {
				clearTimeout(this._resetStateTimeout);
				this._resetStateTimeout = 0;
			}
		},

		_onMouseDown: function (e) {
			if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

			// Clear the deferred resetState if it hasn't executed yet, otherwise it
			// will interrupt the interaction and orphan a box element in the container.
			this._clearDeferredResetState();
			this._resetState();

			disableTextSelection();
			disableImageDrag();

			this._startPoint = this._map.mouseEventToContainerPoint(e);

			on(document, {
				contextmenu: stop,
				mousemove: this._onMouseMove,
				mouseup: this._onMouseUp,
				keydown: this._onKeyDown
			}, this);
		},

		_onMouseMove: function (e) {
			if (!this._moved) {
				this._moved = true;

				this._box = create$1('div', 'leaflet-zoom-box', this._container);
				addClass(this._container, 'leaflet-crosshair');

				this._map.fire('boxzoomstart');
			}

			this._point = this._map.mouseEventToContainerPoint(e);

			var bounds = new Bounds(this._point, this._startPoint),
			    size = bounds.getSize();

			setPosition(this._box, bounds.min);

			this._box.style.width  = size.x + 'px';
			this._box.style.height = size.y + 'px';
		},

		_finish: function () {
			if (this._moved) {
				remove(this._box);
				removeClass(this._container, 'leaflet-crosshair');
			}

			enableTextSelection();
			enableImageDrag();

			off(document, {
				contextmenu: stop,
				mousemove: this._onMouseMove,
				mouseup: this._onMouseUp,
				keydown: this._onKeyDown
			}, this);
		},

		_onMouseUp: function (e) {
			if ((e.which !== 1) && (e.button !== 1)) { return; }

			this._finish();

			if (!this._moved) { return; }
			// Postpone to next JS tick so internal click event handling
			// still see it as "moved".
			this._clearDeferredResetState();
			this._resetStateTimeout = setTimeout(bind(this._resetState, this), 0);

			var bounds = new LatLngBounds(
			        this._map.containerPointToLatLng(this._startPoint),
			        this._map.containerPointToLatLng(this._point));

			this._map
				.fitBounds(bounds)
				.fire('boxzoomend', {boxZoomBounds: bounds});
		},

		_onKeyDown: function (e) {
			if (e.keyCode === 27) {
				this._finish();
			}
		}
	});

	// @section Handlers
	// @property boxZoom: Handler
	// Box (shift-drag with mouse) zoom handler.
	Map.addInitHook('addHandler', 'boxZoom', BoxZoom);

	/*
	 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options

	Map.mergeOptions({
		// @option doubleClickZoom: Boolean|String = true
		// Whether the map can be zoomed in by double clicking on it and
		// zoomed out by double clicking while holding shift. If passed
		// `'center'`, double-click zoom will zoom to the center of the
		//  view regardless of where the mouse was.
		doubleClickZoom: true
	});

	var DoubleClickZoom = Handler.extend({
		addHooks: function () {
			this._map.on('dblclick', this._onDoubleClick, this);
		},

		removeHooks: function () {
			this._map.off('dblclick', this._onDoubleClick, this);
		},

		_onDoubleClick: function (e) {
			var map = this._map,
			    oldZoom = map.getZoom(),
			    delta = map.options.zoomDelta,
			    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

			if (map.options.doubleClickZoom === 'center') {
				map.setZoom(zoom);
			} else {
				map.setZoomAround(e.containerPoint, zoom);
			}
		}
	});

	// @section Handlers
	//
	// Map properties include interaction handlers that allow you to control
	// interaction behavior in runtime, enabling or disabling certain features such
	// as dragging or touch zoom (see `Handler` methods). For example:
	//
	// ```js
	// map.doubleClickZoom.disable();
	// ```
	//
	// @property doubleClickZoom: Handler
	// Double click zoom handler.
	Map.addInitHook('addHandler', 'doubleClickZoom', DoubleClickZoom);

	/*
	 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @option dragging: Boolean = true
		// Whether the map be draggable with mouse/touch or not.
		dragging: true,

		// @section Panning Inertia Options
		// @option inertia: Boolean = *
		// If enabled, panning of the map will have an inertia effect where
		// the map builds momentum while dragging and continues moving in
		// the same direction for some time. Feels especially nice on touch
		// devices. Enabled by default unless running on old Android devices.
		inertia: !android23,

		// @option inertiaDeceleration: Number = 3000
		// The rate with which the inertial movement slows down, in pixels/second².
		inertiaDeceleration: 3400, // px/s^2

		// @option inertiaMaxSpeed: Number = Infinity
		// Max speed of the inertial movement, in pixels/second.
		inertiaMaxSpeed: Infinity, // px/s

		// @option easeLinearity: Number = 0.2
		easeLinearity: 0.2,

		// TODO refactor, move to CRS
		// @option worldCopyJump: Boolean = false
		// With this option enabled, the map tracks when you pan to another "copy"
		// of the world and seamlessly jumps to the original one so that all overlays
		// like markers and vector layers are still visible.
		worldCopyJump: false,

		// @option maxBoundsViscosity: Number = 0.0
		// If `maxBounds` is set, this option will control how solid the bounds
		// are when dragging the map around. The default value of `0.0` allows the
		// user to drag outside the bounds at normal speed, higher values will
		// slow down map dragging outside bounds, and `1.0` makes the bounds fully
		// solid, preventing the user from dragging outside the bounds.
		maxBoundsViscosity: 0.0
	});

	var Drag = Handler.extend({
		addHooks: function () {
			if (!this._draggable) {
				var map = this._map;

				this._draggable = new Draggable(map._mapPane, map._container);

				this._draggable.on({
					dragstart: this._onDragStart,
					drag: this._onDrag,
					dragend: this._onDragEnd
				}, this);

				this._draggable.on('predrag', this._onPreDragLimit, this);
				if (map.options.worldCopyJump) {
					this._draggable.on('predrag', this._onPreDragWrap, this);
					map.on('zoomend', this._onZoomEnd, this);

					map.whenReady(this._onZoomEnd, this);
				}
			}
			addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
			this._draggable.enable();
			this._positions = [];
			this._times = [];
		},

		removeHooks: function () {
			removeClass(this._map._container, 'leaflet-grab');
			removeClass(this._map._container, 'leaflet-touch-drag');
			this._draggable.disable();
		},

		moved: function () {
			return this._draggable && this._draggable._moved;
		},

		moving: function () {
			return this._draggable && this._draggable._moving;
		},

		_onDragStart: function () {
			var map = this._map;

			map._stop();
			if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
				var bounds = toLatLngBounds(this._map.options.maxBounds);

				this._offsetLimit = toBounds(
					this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
					this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
						.add(this._map.getSize()));

				this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
			} else {
				this._offsetLimit = null;
			}

			map
			    .fire('movestart')
			    .fire('dragstart');

			if (map.options.inertia) {
				this._positions = [];
				this._times = [];
			}
		},

		_onDrag: function (e) {
			if (this._map.options.inertia) {
				var time = this._lastTime = +new Date(),
				    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

				this._positions.push(pos);
				this._times.push(time);

				this._prunePositions(time);
			}

			this._map
			    .fire('move', e)
			    .fire('drag', e);
		},

		_prunePositions: function (time) {
			while (this._positions.length > 1 && time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		},

		_onZoomEnd: function () {
			var pxCenter = this._map.getSize().divideBy(2),
			    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

			this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
			this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
		},

		_viscousLimit: function (value, threshold) {
			return value - (value - threshold) * this._viscosity;
		},

		_onPreDragLimit: function () {
			if (!this._viscosity || !this._offsetLimit) { return; }

			var offset = this._draggable._newPos.subtract(this._draggable._startPos);

			var limit = this._offsetLimit;
			if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
			if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
			if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
			if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

			this._draggable._newPos = this._draggable._startPos.add(offset);
		},

		_onPreDragWrap: function () {
			// TODO refactor to be able to adjust map pane position after zoom
			var worldWidth = this._worldWidth,
			    halfWidth = Math.round(worldWidth / 2),
			    dx = this._initialWorldOffset,
			    x = this._draggable._newPos.x,
			    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
			    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
			    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

			this._draggable._absPos = this._draggable._newPos.clone();
			this._draggable._newPos.x = newX;
		},

		_onDragEnd: function (e) {
			var map = this._map,
			    options = map.options,

			    noInertia = !options.inertia || this._times.length < 2;

			map.fire('dragend', e);

			if (noInertia) {
				map.fire('moveend');

			} else {
				this._prunePositions(+new Date());

				var direction = this._lastPos.subtract(this._positions[0]),
				    duration = (this._lastTime - this._times[0]) / 1000,
				    ease = options.easeLinearity,

				    speedVector = direction.multiplyBy(ease / duration),
				    speed = speedVector.distanceTo([0, 0]),

				    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
				    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

				    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
				    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

				if (!offset.x && !offset.y) {
					map.fire('moveend');

				} else {
					offset = map._limitOffset(offset, map.options.maxBounds);

					requestAnimFrame(function () {
						map.panBy(offset, {
							duration: decelerationDuration,
							easeLinearity: ease,
							noMoveStart: true,
							animate: true
						});
					});
				}
			}
		}
	});

	// @section Handlers
	// @property dragging: Handler
	// Map dragging handler (by both mouse and touch).
	Map.addInitHook('addHandler', 'dragging', Drag);

	/*
	 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
	 */

	// @namespace Map
	// @section Keyboard Navigation Options
	Map.mergeOptions({
		// @option keyboard: Boolean = true
		// Makes the map focusable and allows users to navigate the map with keyboard
		// arrows and `+`/`-` keys.
		keyboard: true,

		// @option keyboardPanDelta: Number = 80
		// Amount of pixels to pan when pressing an arrow key.
		keyboardPanDelta: 80
	});

	var Keyboard = Handler.extend({

		keyCodes: {
			left:    [37],
			right:   [39],
			down:    [40],
			up:      [38],
			zoomIn:  [187, 107, 61, 171],
			zoomOut: [189, 109, 54, 173]
		},

		initialize: function (map) {
			this._map = map;

			this._setPanDelta(map.options.keyboardPanDelta);
			this._setZoomDelta(map.options.zoomDelta);
		},

		addHooks: function () {
			var container = this._map._container;

			// make the container focusable by tabbing
			if (container.tabIndex <= 0) {
				container.tabIndex = '0';
			}

			on(container, {
				focus: this._onFocus,
				blur: this._onBlur,
				mousedown: this._onMouseDown
			}, this);

			this._map.on({
				focus: this._addHooks,
				blur: this._removeHooks
			}, this);
		},

		removeHooks: function () {
			this._removeHooks();

			off(this._map._container, {
				focus: this._onFocus,
				blur: this._onBlur,
				mousedown: this._onMouseDown
			}, this);

			this._map.off({
				focus: this._addHooks,
				blur: this._removeHooks
			}, this);
		},

		_onMouseDown: function () {
			if (this._focused) { return; }

			var body = document.body,
			    docEl = document.documentElement,
			    top = body.scrollTop || docEl.scrollTop,
			    left = body.scrollLeft || docEl.scrollLeft;

			this._map._container.focus();

			window.scrollTo(left, top);
		},

		_onFocus: function () {
			this._focused = true;
			this._map.fire('focus');
		},

		_onBlur: function () {
			this._focused = false;
			this._map.fire('blur');
		},

		_setPanDelta: function (panDelta) {
			var keys = this._panKeys = {},
			    codes = this.keyCodes,
			    i, len;

			for (i = 0, len = codes.left.length; i < len; i++) {
				keys[codes.left[i]] = [-1 * panDelta, 0];
			}
			for (i = 0, len = codes.right.length; i < len; i++) {
				keys[codes.right[i]] = [panDelta, 0];
			}
			for (i = 0, len = codes.down.length; i < len; i++) {
				keys[codes.down[i]] = [0, panDelta];
			}
			for (i = 0, len = codes.up.length; i < len; i++) {
				keys[codes.up[i]] = [0, -1 * panDelta];
			}
		},

		_setZoomDelta: function (zoomDelta) {
			var keys = this._zoomKeys = {},
			    codes = this.keyCodes,
			    i, len;

			for (i = 0, len = codes.zoomIn.length; i < len; i++) {
				keys[codes.zoomIn[i]] = zoomDelta;
			}
			for (i = 0, len = codes.zoomOut.length; i < len; i++) {
				keys[codes.zoomOut[i]] = -zoomDelta;
			}
		},

		_addHooks: function () {
			on(document, 'keydown', this._onKeyDown, this);
		},

		_removeHooks: function () {
			off(document, 'keydown', this._onKeyDown, this);
		},

		_onKeyDown: function (e) {
			if (e.altKey || e.ctrlKey || e.metaKey) { return; }

			var key = e.keyCode,
			    map = this._map,
			    offset;

			if (key in this._panKeys) {

				if (map._panAnim && map._panAnim._inProgress) { return; }

				offset = this._panKeys[key];
				if (e.shiftKey) {
					offset = toPoint(offset).multiplyBy(3);
				}

				map.panBy(offset);

				if (map.options.maxBounds) {
					map.panInsideBounds(map.options.maxBounds);
				}

			} else if (key in this._zoomKeys) {
				map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

			} else if (key === 27 && map._popup && map._popup.options.closeOnEscapeKey) {
				map.closePopup();

			} else {
				return;
			}

			stop(e);
		}
	});

	// @section Handlers
	// @section Handlers
	// @property keyboard: Handler
	// Keyboard navigation handler.
	Map.addInitHook('addHandler', 'keyboard', Keyboard);

	/*
	 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @section Mousewheel options
		// @option scrollWheelZoom: Boolean|String = true
		// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
		// it will zoom to the center of the view regardless of where the mouse was.
		scrollWheelZoom: true,

		// @option wheelDebounceTime: Number = 40
		// Limits the rate at which a wheel can fire (in milliseconds). By default
		// user can't zoom via wheel more often than once per 40 ms.
		wheelDebounceTime: 40,

		// @option wheelPxPerZoomLevel: Number = 60
		// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
		// mean a change of one full zoom level. Smaller values will make wheel-zooming
		// faster (and vice versa).
		wheelPxPerZoomLevel: 60
	});

	var ScrollWheelZoom = Handler.extend({
		addHooks: function () {
			on(this._map._container, 'mousewheel', this._onWheelScroll, this);

			this._delta = 0;
		},

		removeHooks: function () {
			off(this._map._container, 'mousewheel', this._onWheelScroll, this);
		},

		_onWheelScroll: function (e) {
			var delta = getWheelDelta(e);

			var debounce = this._map.options.wheelDebounceTime;

			this._delta += delta;
			this._lastMousePos = this._map.mouseEventToContainerPoint(e);

			if (!this._startTime) {
				this._startTime = +new Date();
			}

			var left = Math.max(debounce - (+new Date() - this._startTime), 0);

			clearTimeout(this._timer);
			this._timer = setTimeout(bind(this._performZoom, this), left);

			stop(e);
		},

		_performZoom: function () {
			var map = this._map,
			    zoom = map.getZoom(),
			    snap = this._map.options.zoomSnap || 0;

			map._stop(); // stop panning and fly animations if any

			// map the delta with a sigmoid function to -4..4 range leaning on -1..1
			var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
			    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
			    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
			    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

			this._delta = 0;
			this._startTime = null;

			if (!delta) { return; }

			if (map.options.scrollWheelZoom === 'center') {
				map.setZoom(zoom + delta);
			} else {
				map.setZoomAround(this._lastMousePos, zoom + delta);
			}
		}
	});

	// @section Handlers
	// @property scrollWheelZoom: Handler
	// Scroll wheel zoom handler.
	Map.addInitHook('addHandler', 'scrollWheelZoom', ScrollWheelZoom);

	/*
	 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @section Touch interaction options
		// @option tap: Boolean = true
		// Enables mobile hacks for supporting instant taps (fixing 200ms click
		// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
		tap: true,

		// @option tapTolerance: Number = 15
		// The max number of pixels a user can shift his finger during touch
		// for it to be considered a valid tap.
		tapTolerance: 15
	});

	var Tap = Handler.extend({
		addHooks: function () {
			on(this._map._container, 'touchstart', this._onDown, this);
		},

		removeHooks: function () {
			off(this._map._container, 'touchstart', this._onDown, this);
		},

		_onDown: function (e) {
			if (!e.touches) { return; }

			preventDefault(e);

			this._fireClick = true;

			// don't simulate click or track longpress if more than 1 touch
			if (e.touches.length > 1) {
				this._fireClick = false;
				clearTimeout(this._holdTimeout);
				return;
			}

			var first = e.touches[0],
			    el = first.target;

			this._startPos = this._newPos = new Point(first.clientX, first.clientY);

			// if touching a link, highlight it
			if (el.tagName && el.tagName.toLowerCase() === 'a') {
				addClass(el, 'leaflet-active');
			}

			// simulate long hold but setting a timeout
			this._holdTimeout = setTimeout(bind(function () {
				if (this._isTapValid()) {
					this._fireClick = false;
					this._onUp();
					this._simulateEvent('contextmenu', first);
				}
			}, this), 1000);

			this._simulateEvent('mousedown', first);

			on(document, {
				touchmove: this._onMove,
				touchend: this._onUp
			}, this);
		},

		_onUp: function (e) {
			clearTimeout(this._holdTimeout);

			off(document, {
				touchmove: this._onMove,
				touchend: this._onUp
			}, this);

			if (this._fireClick && e && e.changedTouches) {

				var first = e.changedTouches[0],
				    el = first.target;

				if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
					removeClass(el, 'leaflet-active');
				}

				this._simulateEvent('mouseup', first);

				// simulate click if the touch didn't move too much
				if (this._isTapValid()) {
					this._simulateEvent('click', first);
				}
			}
		},

		_isTapValid: function () {
			return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
		},

		_onMove: function (e) {
			var first = e.touches[0];
			this._newPos = new Point(first.clientX, first.clientY);
			this._simulateEvent('mousemove', first);
		},

		_simulateEvent: function (type, e) {
			var simulatedEvent = document.createEvent('MouseEvents');

			simulatedEvent._simulated = true;
			e.target._simulatedClick = true;

			simulatedEvent.initMouseEvent(
			        type, true, true, window, 1,
			        e.screenX, e.screenY,
			        e.clientX, e.clientY,
			        false, false, false, false, 0, null);

			e.target.dispatchEvent(simulatedEvent);
		}
	});

	// @section Handlers
	// @property tap: Handler
	// Mobile touch hacks (quick tap and touch hold) handler.
	if (touch && !pointer) {
		Map.addInitHook('addHandler', 'tap', Tap);
	}

	/*
	 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
	 */

	// @namespace Map
	// @section Interaction Options
	Map.mergeOptions({
		// @section Touch interaction options
		// @option touchZoom: Boolean|String = *
		// Whether the map can be zoomed by touch-dragging with two fingers. If
		// passed `'center'`, it will zoom to the center of the view regardless of
		// where the touch events (fingers) were. Enabled for touch-capable web
		// browsers except for old Androids.
		touchZoom: touch && !android23,

		// @option bounceAtZoomLimits: Boolean = true
		// Set it to false if you don't want the map to zoom beyond min/max zoom
		// and then bounce back when pinch-zooming.
		bounceAtZoomLimits: true
	});

	var TouchZoom = Handler.extend({
		addHooks: function () {
			addClass(this._map._container, 'leaflet-touch-zoom');
			on(this._map._container, 'touchstart', this._onTouchStart, this);
		},

		removeHooks: function () {
			removeClass(this._map._container, 'leaflet-touch-zoom');
			off(this._map._container, 'touchstart', this._onTouchStart, this);
		},

		_onTouchStart: function (e) {
			var map = this._map;
			if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

			var p1 = map.mouseEventToContainerPoint(e.touches[0]),
			    p2 = map.mouseEventToContainerPoint(e.touches[1]);

			this._centerPoint = map.getSize()._divideBy(2);
			this._startLatLng = map.containerPointToLatLng(this._centerPoint);
			if (map.options.touchZoom !== 'center') {
				this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
			}

			this._startDist = p1.distanceTo(p2);
			this._startZoom = map.getZoom();

			this._moved = false;
			this._zooming = true;

			map._stop();

			on(document, 'touchmove', this._onTouchMove, this);
			on(document, 'touchend', this._onTouchEnd, this);

			preventDefault(e);
		},

		_onTouchMove: function (e) {
			if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

			var map = this._map,
			    p1 = map.mouseEventToContainerPoint(e.touches[0]),
			    p2 = map.mouseEventToContainerPoint(e.touches[1]),
			    scale = p1.distanceTo(p2) / this._startDist;

			this._zoom = map.getScaleZoom(scale, this._startZoom);

			if (!map.options.bounceAtZoomLimits && (
				(this._zoom < map.getMinZoom() && scale < 1) ||
				(this._zoom > map.getMaxZoom() && scale > 1))) {
				this._zoom = map._limitZoom(this._zoom);
			}

			if (map.options.touchZoom === 'center') {
				this._center = this._startLatLng;
				if (scale === 1) { return; }
			} else {
				// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
				var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
				if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
				this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
			}

			if (!this._moved) {
				map._moveStart(true, false);
				this._moved = true;
			}

			cancelAnimFrame(this._animRequest);

			var moveFn = bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
			this._animRequest = requestAnimFrame(moveFn, this, true);

			preventDefault(e);
		},

		_onTouchEnd: function () {
			if (!this._moved || !this._zooming) {
				this._zooming = false;
				return;
			}

			this._zooming = false;
			cancelAnimFrame(this._animRequest);

			off(document, 'touchmove', this._onTouchMove);
			off(document, 'touchend', this._onTouchEnd);

			// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
			if (this._map.options.zoomAnimation) {
				this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
			} else {
				this._map._resetView(this._center, this._map._limitZoom(this._zoom));
			}
		}
	});

	// @section Handlers
	// @property touchZoom: Handler
	// Touch zoom handler.
	Map.addInitHook('addHandler', 'touchZoom', TouchZoom);

	Map.BoxZoom = BoxZoom;
	Map.DoubleClickZoom = DoubleClickZoom;
	Map.Drag = Drag;
	Map.Keyboard = Keyboard;
	Map.ScrollWheelZoom = ScrollWheelZoom;
	Map.Tap = Tap;
	Map.TouchZoom = TouchZoom;

	// misc

	var oldL = window.L;
	function noConflict() {
		window.L = oldL;
		return this;
	}

	// Always export us to window global (see #2364)
	window.L = exports;

	Object.freeze = freeze;

	exports.version = version;
	exports.noConflict = noConflict;
	exports.Control = Control;
	exports.control = control;
	exports.Browser = Browser;
	exports.Evented = Evented;
	exports.Mixin = Mixin;
	exports.Util = Util;
	exports.Class = Class;
	exports.Handler = Handler;
	exports.extend = extend;
	exports.bind = bind;
	exports.stamp = stamp;
	exports.setOptions = setOptions;
	exports.DomEvent = DomEvent;
	exports.DomUtil = DomUtil;
	exports.PosAnimation = PosAnimation;
	exports.Draggable = Draggable;
	exports.LineUtil = LineUtil;
	exports.PolyUtil = PolyUtil;
	exports.Point = Point;
	exports.point = toPoint;
	exports.Bounds = Bounds;
	exports.bounds = toBounds;
	exports.Transformation = Transformation;
	exports.transformation = toTransformation;
	exports.Projection = index;
	exports.LatLng = LatLng;
	exports.latLng = toLatLng;
	exports.LatLngBounds = LatLngBounds;
	exports.latLngBounds = toLatLngBounds;
	exports.CRS = CRS;
	exports.GeoJSON = GeoJSON;
	exports.geoJSON = geoJSON;
	exports.geoJson = geoJson;
	exports.Layer = Layer;
	exports.LayerGroup = LayerGroup;
	exports.layerGroup = layerGroup;
	exports.FeatureGroup = FeatureGroup;
	exports.featureGroup = featureGroup;
	exports.ImageOverlay = ImageOverlay;
	exports.imageOverlay = imageOverlay;
	exports.VideoOverlay = VideoOverlay;
	exports.videoOverlay = videoOverlay;
	exports.DivOverlay = DivOverlay;
	exports.Popup = Popup;
	exports.popup = popup;
	exports.Tooltip = Tooltip;
	exports.tooltip = tooltip;
	exports.Icon = Icon;
	exports.icon = icon;
	exports.DivIcon = DivIcon;
	exports.divIcon = divIcon;
	exports.Marker = Marker;
	exports.marker = marker;
	exports.TileLayer = TileLayer;
	exports.tileLayer = tileLayer;
	exports.GridLayer = GridLayer;
	exports.gridLayer = gridLayer;
	exports.SVG = SVG;
	exports.svg = svg$1;
	exports.Renderer = Renderer;
	exports.Canvas = Canvas;
	exports.canvas = canvas$1;
	exports.Path = Path;
	exports.CircleMarker = CircleMarker;
	exports.circleMarker = circleMarker;
	exports.Circle = Circle;
	exports.circle = circle;
	exports.Polyline = Polyline;
	exports.polyline = polyline;
	exports.Polygon = Polygon;
	exports.polygon = polygon;
	exports.Rectangle = Rectangle;
	exports.rectangle = rectangle;
	exports.Map = Map;
	exports.map = createMap;

	})));
	//# sourceMappingURL=leaflet-src.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	/**
	 * Created by gongmin on 2017/9/6.
	 */
	/**
	 * 工具函数
	 * @Date 2017-04-05
	 */
	var util = {
	    /**
	     * [adapt 屏幕自适应]
	     * @param  {Number} designWidth [标准设计稿尺寸]
	     * @param  {Number} rem2px      [标准设计稿下1rem等于多少px]
	     * @return {[null]}             []
	     */
	    adapt: function adapt() {
	        var designWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 640;
	        var rem2px = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

	        var doc = window.document,
	            d = doc.createElement('div');
	        d.style.width = '1rem';
	        d.style.display = 'none';
	        var head = doc.getElementsByTagName('head')[0];
	        head.appendChild(d);
	        var defaultFontSize = parseFloat(window.getComputedStyle(d, null).getPropertyValue('width'));
	        d.remove();
	        doc.documentElement.style.fontSize = window.innerWidth / designWidth * rem2px / defaultFontSize * 100 + '%';
	        var st = doc.createElement('style');
	        var portrait = "@media screen and (min-width: " + window.innerWidth + "px) {html{font-size:" + window.innerWidth / (designWidth / rem2px) / defaultFontSize * 100 + "%;}}";
	        var landscape = "@media screen and (min-width: " + window.innerHeight + "px) {html{font-size:" + window.innerHeight / (designWidth / rem2px) / defaultFontSize * 100 + "%;}}";
	        st.innerHTML = portrait + landscape;
	        head.appendChild(st);
	    },

	    /**
	     * [debounce 防反跳]
	     * @param  {[Function]} func      [防反跳的函数]
	     * @param  {[Number]} threshold [时间间隔]
	     * @param  {[Boolean]} execAsap  [是否立即执行，true立即执行，默认为false]
	     * @param  {[Function]} fun       [如果存在，一定会执行的函数]
	     * @return {[null]}
	     */
	    debounce: function debounce(func) {
	        var threshold = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
	        var execAsap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	        var fun = arguments[3];

	        var timeout = void 0;
	        return function debounced() {
	            var self = this,
	                args = arguments;
	            function delayed() {
	                if (!execAsap) func.apply(self, args);
	                timeout = null;
	            }

	            if (timeout) {
	                clearTimeout(timeout);
	            } else if (execAsap) {
	                func.apply(self, args);
	            }
	            timeout = setTimeout(delayed, threshold);

	            if (fun) fun.apply(self, args);
	        };
	    },

	    /**
	     * [debounceAdapt 动态计算媒体查询]
	     * @param  {Number} designWidth [标准设计稿尺寸]
	     * @param  {Number} rem2px      [标准设计稿下1rem等于多少px]
	     */
	    debounceAdapt: function debounceAdapt() {
	        var _this = this;

	        var designWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 640;
	        var rem2px = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;

	        this.adapt(designWidth, rem2px); //屏幕自适应处理
	        window.onresize = this.debounce(function () {
	            _this.adapt(designWidth, rem2px);
	        }, 200, false);
	    },

	    /**
	     * [adaptHeight 高度自适应]
	     * @param  {[String]} domId       [控制dom高度的id]
	     * @param  {[Number]} otherHeight [除了domId其余部分高度]
	     * @param  {[Number]} threshold [时间间隔]
	     */
	    adaptHeight: function adaptHeight(domId, otherHeight) {
	        var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	        var mapDom = void 0,
	            bodyHeight = void 0;
	        otherHeight = parseFloat(otherHeight) || 0;
	        mapDom = document.getElementById(domId);
	        mapDom.style.height = getHeight() + "px";

	        window.onresize = this.debounce(function () {
	            mapDom.style.height = getHeight() + "px";
	        }, threshold);

	        function getHeight() {
	            var height = mapDom.parentNode.offsetHeight - otherHeight;
	            return height;
	        }
	    },

	    /**
	     * [getJSON 获取json文件]
	     * @param  {[String]} url [url地址]
	     * @return {[Promise]}     [promise]
	     */
	    getJson: function getJson(url) {
	        var promise = new Promise(function (resolve, reject) {
	            var client = new XMLHttpRequest();
	            client.open("GET", url);
	            client.onreadystatechange = handler;
	            client.responseType = "json";
	            client.setRequestHeader("Accept", "application/json");
	            client.send();

	            function handler() {
	                if (this.readyState !== 4) {
	                    return;
	                }
	                if (this.status === 200) {
	                    resolve(this.response);
	                } else {
	                    reject(new Error(this.statusText));
	                }
	            };
	        });

	        return promise;
	    },

	    /*showTipWin(text,time = 500,style={width:"100px",height:"100px"}){
	     let div = document.createElement('div');
	     div.style.display = "absolute";
	     div.style.width = style.width;
	     div.style.height = style.height;
	     div.style.
	     },*/
	    /**
	     * [cloneObj 深拷贝对象]
	     * @param  {[Object]} obj [被拷贝的对象]
	     * @return {[Object]}     [返回拷贝后的对象]
	     */
	    cloneObj: function cloneObj(obj) {
	        var newObj = void 0,
	            s = void 0;
	        if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') return;
	        newObj = obj.constructor === Object ? {} : [];
	        if (window.JSON) {
	            s = JSON.stringify(obj);
	            newObj = JSON.parse(s);
	        } else {
	            if (newObj.constructor === Array) {
	                newObj.concat(obj);
	            } else {
	                for (var o in obj) {
	                    newObj[i] = obj[i];
	                }
	            }
	        }

	        return newObj;
	    },
	    byClassName: function byClassName(className, index) {
	        if (index !== undefined) return document.getElementsByClassName(className)[index];
	        return document.getElementsByClassName(className);
	    },
	    ByIdName: function ByIdName(id) {
	        return document.getElementById(id);
	    },

	    /**
	     * [getScript 异步加载script]
	     * @param  {[String]} url [script地址]
	     * @return {[Promise]}     [promise]
	     */
	    getScript: function getScript(url) {
	        var _this2 = this;

	        var promise = new Promise(function (resolve, reject) {
	            var script = document.createElement('script');
	            script.type = 'text/javascript';

	            script.onreadystatechange = function () {
	                if (_this2.readyState == 'complete') {
	                    resolve();
	                }
	            };
	            script.onload = function () {
	                resolve();
	            };
	            script.onerror = function () {
	                reject();
	            };
	            script.src = url;
	            document.getElementsByTagName('head')[0].appendChild(script);
	        });

	        return promise;
	    }
	};

	exports.default = util;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.3.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2018-01-20T17:24Z
	 */
	( function( global, factory ) {

		"use strict";

		if ( typeof module === "object" && typeof module.exports === "object" ) {

			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}

	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";

	var arr = [];

	var document = window.document;

	var getProto = Object.getPrototypeOf;

	var slice = arr.slice;

	var concat = arr.concat;

	var push = arr.push;

	var indexOf = arr.indexOf;

	var class2type = {};

	var toString = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	var support = {};

	var isFunction = function isFunction( obj ) {

	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };


	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};




		var preservedScriptAttributes = {
			type: true,
			src: true,
			noModule: true
		};

		function DOMEval( code, doc, node ) {
			doc = doc || document;

			var i,
				script = doc.createElement( "script" );

			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
					if ( node[ i ] ) {
						script[ i ] = node[ i ];
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}


	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module



	var
		version = "3.3.1",

		// Define a local copy of jQuery
		jQuery = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		},

		// Support: Android <=4.0 only
		// Make sure we trim BOM and NBSP
		rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

	jQuery.fn = jQuery.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		},

		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};

	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					src = target[ name ];
					copy = options[ name ];

					// Prevent never-ending loop
					if ( target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {

						if ( copyIsArray ) {
							copyIsArray = false;
							clone = src && Array.isArray( src ) ? src : [];

						} else {
							clone = src && jQuery.isPlainObject( src ) ? src : {};
						}

						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {

			/* eslint-disable no-unused-vars */
			// See https://github.com/eslint/eslint/issues/6125
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a global context
		globalEval: function( code ) {
			DOMEval( code );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},

		// Support: Android <=4.0 only
		trim: function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},

		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return concat.apply( [], ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike( obj ) {

		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );

		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.3
	 * https://sizzlejs.com/
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 *
	 * Date: 2016-08-08
	 */
	(function( window ) {

	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,

		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,

		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},

		// Instance methods
		hasOwn = ({}).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		push_native = arr.push,
		push = arr.push,
		slice = arr.slice,
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[i] === elem ) {
					return i;
				}
			}
			return -1;
		},

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",

		// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
		identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
			"*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

		rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
				"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
				"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
				whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		rnative = /^[^{]+\{\s*\[native \w/,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
		funescape = function( _, escaped, escapedWhitespace ) {
			var high = "0x" + escaped - 0x10000;
			// NaN means non-codepoint
			// Support: Firefox<24
			// Workaround erroneous numeric interpretation of +"0x"
			return high !== high || escapedWhitespace ?
				escaped :
				high < 0 ?
					// BMP codepoint
					String.fromCharCode( high + 0x10000 ) :
					// Supplemental Plane codepoint (surrogate pair)
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {

				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}

				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}

			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},

		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},

		disabledAncestor = addCombinator(
			function( elem ) {
				return elem.disabled === true && ("form" in elem || "label" in elem);
			},
			{ dir: "parentNode", next: "legend" }
		);

	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			(arr = slice.call( preferredDoc.childNodes )),
			preferredDoc.childNodes
		);
		// Support: Android<4.0
		// Detect silently failing push.apply
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?

			// Leverage slice if possible
			function( target, els ) {
				push_native.apply( target, slice.call(els) );
			} :

			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
				// Can't trust NodeList.length
				while ( (target[j++] = els[i++]) ) {}
				target.length = j - 1;
			}
		};
	}

	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {

			if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
				setDocument( context );
			}
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

					// ID selector
					if ( (m = match[1]) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( (elem = context.getElementById( m )) ) {

								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}

						// Element context
						} else {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && (elem = newContext.getElementById( m )) &&
								contains( context, elem ) &&
								elem.id === m ) {

								results.push( elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[2] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( (m = match[3]) && support.getElementsByClassName &&
						context.getElementsByClassName ) {

						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!compilerCache[ selector + " " ] &&
					(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

					if ( nodeType !== 1 ) {
						newContext = context;
						newSelector = selector;

					// qSA looks outside Element context, which is not what we want
					// Thanks to Andrew Dupont for this workaround technique
					// Support: IE <=8
					// Exclude object elements
					} else if ( context.nodeName.toLowerCase() !== "object" ) {

						// Capture the context ID, setting it first if necessary
						if ( (nid = context.getAttribute( "id" )) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", (nid = expando) );
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[i] = "#" + nid + " " + toSelector( groups[i] );
						}
						newSelector = groups.join( "," );

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
					}

					if ( newSelector ) {
						try {
							push.apply( results,
								newContext.querySelectorAll( newSelector )
							);
							return results;
						} catch ( qsaError ) {
						} finally {
							if ( nid === expando ) {
								context.removeAttribute( "id" );
							}
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return (cache[ key + " " ] = value);
		}
		return cache;
	}

	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement("fieldset");

		try {
			return !!fn( el );
		} catch (e) {
			return false;
		} finally {
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
			// release memory in IE
			el = null;
		}
	}

	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split("|"),
			i = arr.length;

		while ( i-- ) {
			Expr.attrHandle[ arr[i] ] = handler;
		}
	}

	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;

		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}

		// Check if b follows a
		if ( cur ) {
			while ( (cur = cur.nextSibling) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}

		return a ? 1 : -1;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							disabledAncestor( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction(function( argument ) {
			argument = +argument;
			return markFunction(function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ (j = matchIndexes[i]) ] ) {
						seed[j] = !(matches[j] = seed[j]);
					}
				}
			});
		});
	}

	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	// Expose support vars for convenience
	support = Sizzle.support = {};

	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		// documentElement is verified for cases where it doesn't yet exist
		// (such as loading iframes in IE - #4833)
		var documentElement = elem && (elem.ownerDocument || elem).documentElement;
		return documentElement ? documentElement.nodeName !== "HTML" : false;
	};

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}

		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );

		// Support: IE 9-11, Edge
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		if ( preferredDoc !== document &&
			(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );

			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}

		/* Attributes
		---------------------------------------------------------------------- */

		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert(function( el ) {
			el.className = "i";
			return !el.getAttribute("className");
		});

		/* getElement(s)By*
		---------------------------------------------------------------------- */

		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert(function( el ) {
			el.appendChild( document.createComment("") );
			return !el.getElementsByTagName("*").length;
		});

		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );

		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert(function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		});

		// ID filter and find
		if ( support.getById ) {
			Expr.filter["ID"] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute("id") === attrId;
				};
			};
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter["ID"] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode("id");
					return node && node.value === attrId;
				};
			};

			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find["ID"] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );

					if ( elem ) {

						// Verify the id attribute
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}

						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( (elem = elems[i++]) ) {
							node = elem.getAttributeNode("id");
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}

					return [];
				}
			};
		}

		// Tag
		Expr.find["TAG"] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :

			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					while ( (elem = results[i++]) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			};

		// Class
		Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};

		/* QSA/matchesSelector
		---------------------------------------------------------------------- */

		// QSA and matchesSelector support

		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];

		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];

		if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert(function( el ) {
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";

				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll("[msallowcapture^='']").length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}

				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll("[selected]").length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}

				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push("~=");
				}

				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll(":checked").length ) {
					rbuggyQSA.push(":checked");
				}

				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push(".#.+[+~]");
				}
			});

			assert(function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";

				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement("input");
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );

				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll("[name=d]").length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}

				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll(":enabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll(":disabled").length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}

				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll("*,:x");
				rbuggyQSA.push(",.*:");
			});
		}

		if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector) )) ) {

			assert(function( el ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			});
		}

		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );

		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				));
			} :
			function( a, b ) {
				if ( b ) {
					while ( (b = b.parentNode) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};

		/* Sorting
		---------------------------------------------------------------------- */

		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {

			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}

			// Calculate position if both inputs belong to the same document
			compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :

				// Otherwise we know they are disconnected
				1;

			// Disconnected nodes
			if ( compare & 1 ||
				(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

				// Choose the first element that is related to our preferred document
				if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
					return -1;
				}
				if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
					return 1;
				}

				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}

			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];

			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
				return a === document ? -1 :
					b === document ? 1 :
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;

			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}

			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( (cur = cur.parentNode) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( (cur = cur.parentNode) ) {
				bp.unshift( cur );
			}

			// Walk down the tree looking for a discrepancy
			while ( ap[i] === bp[i] ) {
				i++;
			}

			return i ?
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[i], bp[i] ) :

				// Otherwise nodes in our document sort first
				ap[i] === preferredDoc ? -1 :
				bp[i] === preferredDoc ? 1 :
				0;
		};

		return document;
	};

	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};

	Sizzle.matchesSelector = function( elem, expr ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		// Make sure that attribute selectors are quoted
		expr = expr.replace( rattributeQuotes, "='$1']" );

		if ( support.matchesSelector && documentIsHTML &&
			!compilerCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

			try {
				var ret = matches.call( elem, expr );

				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
						// As well, disconnected nodes are said to be in a document
						// fragment in IE 9
						elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch (e) {}
		}

		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};

	Sizzle.contains = function( context, elem ) {
		// Set document vars if needed
		if ( ( context.ownerDocument || context ) !== document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};

	Sizzle.attr = function( elem, name ) {
		// Set document vars if needed
		if ( ( elem.ownerDocument || elem ) !== document ) {
			setDocument( elem );
		}

		var fn = Expr.attrHandle[ name.toLowerCase() ],
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;

		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				(val = elem.getAttributeNode(name)) && val.specified ?
					val.value :
					null;
	};

	Sizzle.escape = function( sel ) {
		return (sel + "").replace( rcssescape, fcssescape );
	};

	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			while ( (elem = results[i++]) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;

		return results;
	};

	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;

		if ( !nodeType ) {
			// If no nodeType, this is expected to be an array
			while ( (node = elem[i++]) ) {
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes

		return ret;
	};

	Expr = Sizzle.selectors = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		attrHandle: {},

		find: {},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			"ATTR": function( match ) {
				match[1] = match[1].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

				if ( match[2] === "~=" ) {
					match[3] = " " + match[3] + " ";
				}

				return match.slice( 0, 4 );
			},

			"CHILD": function( match ) {
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[1] = match[1].toLowerCase();

				if ( match[1].slice( 0, 3 ) === "nth" ) {
					// nth-* requires argument
					if ( !match[3] ) {
						Sizzle.error( match[0] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
					match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

				// other types prohibit arguments
				} else if ( match[3] ) {
					Sizzle.error( match[0] );
				}

				return match;
			},

			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[6] && match[2];

				if ( matchExpr["CHILD"].test( match[0] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[3] ) {
					match[2] = match[4] || match[5] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					match[0] = match[0].slice( 0, excess );
					match[2] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {

			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() { return true; } :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},

			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
					classCache( className, function( elem ) {
						return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
					});
			},

			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
				};
			},

			"CHILD": function( type, what, argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( (node = node[ dir ]) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {

											return false;
										}
									}
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index

								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( (node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									(diff = nodeIndex = 0) || start.pop()) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {
								// Use previously-cached element index if available
								if ( useCache ) {
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || (node[ expando ] = {});

									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										(outerCache[ node.uniqueID ] = {});

									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
									// Use the same loop as above to seek `elem` from the start
									while ( (node = ++nodeIndex && node && node[ dir ] ||
										(diff = nodeIndex = 0) || start.pop()) ) {

										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] || (node[ expando ] = {});

												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													(outerCache[ node.uniqueID ] = {});

												uniqueCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			"PSEUDO": function( pseudo, argument ) {
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction(function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[i] );
								seed[ idx ] = !( matches[ idx ] = matched[i] );
							}
						}) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {
			// Potentially complex pseudos
			"not": markFunction(function( selector ) {
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction(function( seed, matches, context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( (elem = unmatched[i]) ) {
								seed[i] = !(matches[i] = elem);
							}
						}
					}) :
					function( elem, context, xml ) {
						input[0] = elem;
						matcher( input, null, xml, results );
						// Don't keep the element (issue #299)
						input[0] = null;
						return !results.pop();
					};
			}),

			"has": markFunction(function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			}),

			"contains": markFunction(function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
				};
			}),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
				// lang value must be a valid identifier
				if ( !ridentifier.test(lang || "") ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( (elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
					return false;
				};
			}),

			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			"root": function( elem ) {
				return elem === docElem;
			},

			"focus": function( elem ) {
				return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
			},

			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),

			"checked": function( elem ) {
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
			},

			"selected": function( elem ) {
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			"empty": function( elem ) {
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			"parent": function( elem ) {
				return !Expr.pseudos["empty"]( elem );
			},

			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},

			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},

			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&

					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
			},

			// Position-in-collection
			"first": createPositionalPseudo(function() {
				return [ 0 ];
			}),

			"last": createPositionalPseudo(function( matchIndexes, length ) {
				return [ length - 1 ];
			}),

			"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			}),

			"even": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"odd": createPositionalPseudo(function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			}),

			"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			})
		}
	};

	Expr.pseudos["nth"] = Expr.pseudos["eq"];

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || (match = rcomma.exec( soFar )) ) {
				if ( match ) {
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[0].length ) || soFar;
				}
				groups.push( (tokens = []) );
			}

			matched = false;

			// Combinators
			if ( (match = rcombinators.exec( soFar )) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					// Cast descendant combinators to space
					type: match[0].replace( rtrim, " " )
				});
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
					(match = preFilters[ type ]( match ))) ) {
					matched = match.shift();
					tokens.push({
						value: matched,
						type: type,
						matches: match
					});
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[i].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( (elem = elem[ dir ]) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || (elem[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( (oldCache = uniqueCache[ key ]) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return (newCache[ 2 ] = oldCache[ 2 ]);
							} else {
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[i]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[0];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[i], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( (elem = unmatched[i]) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction(function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,

				matcherOut = matcher ?
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

						// ...intermediate processing is necessary
						[] :

						// ...otherwise use results directly
						results :
					matcherIn;

			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( (elem = temp[i]) ) {
						matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( (elem = matcherOut[i]) ) {
								// Restore matcherIn since elem is not yet a final match
								temp.push( (matcherIn[i] = elem) );
							}
						}
						postFinder( null, (matcherOut = []), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) &&
							(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

							seed[temp] = !(results[temp] = elem);
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		});
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[0].type ],
			implicitRelative = leadingRelative || Expr.relative[" "],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					(checkContext = context).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
				matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
			} else {
				matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[j].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
					len = elems.length;

				if ( outermost ) {
					outermostContext = context === document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
						if ( !context && elem.ownerDocument !== document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( (matcher = elementMatchers[j++]) ) {
							if ( matcher( elem, context || document, xml) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {
						// They will have gone through all possible matchers
						if ( (elem = !matcher && elem) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( (matcher = setMatchers[j++]) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !(unmatched[i] || setMatched[i]) ) {
									setMatched[i] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						Sizzle.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[i] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};

	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( (selector = compiled.selector || selector) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

				context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( runescape, funescape ),
						rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};

	// One-time assignments

	// Sort stability
	support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;

	// Initialize against the default document
	setDocument();

	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert(function( el ) {
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
	});

	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert(function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute("href") === "#" ;
	}) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		});
	}

	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert(function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	}) ) {
		addHandle( "value", function( elem, name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		});
	}

	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert(function( el ) {
		return el.getAttribute("disabled") == null;
	}) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
						(val = elem.getAttributeNode( name )) && val.specified ?
						val.value :
					null;
			}
		});
	}

	return Sizzle;

	})( window );



	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;

	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;




	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};


	var siblings = function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	};


	var rneedsContext = jQuery.expr.match.needsContext;



	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}

	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );


	// Initialize a jQuery object


	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery );
			}

			return jQuery.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;

	// Initialize central reference
	rootjQuery = jQuery( document );


	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
	        if ( nodeName( elem, "iframe" ) ) {
	            return elem.contentDocument;
	        }

	        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
	        // Treat the template element as a regular one in browsers that
	        // don't support it.
	        if ( nodeName( elem, "template" ) ) {
	            elem = elem.content || elem;
	        }

	        return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};


	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}

	jQuery.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( isFunction( then ) ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),

				// the master Deferred
				master = jQuery.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );


	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery.Deferred.exceptionHook = function( error, stack ) {

		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};




	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};




	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();

	jQuery.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );

		return this;
	};

	jQuery.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );

	jQuery.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );

	} else {

		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}




	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( !isFunction( value ) ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};


	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};




	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = {};

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();

	var dataUser = new Data();



	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );


	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	var isHiddenWithinTree = function( elem, el ) {

			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;

			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&

				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				jQuery.contains( elem.ownerDocument, elem ) &&

				jQuery.css( elem, "display" ) === "none";
		};

	var swap = function( elem, options, callback, args ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.apply( elem, args || [] );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	};




	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}


	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Support: IE <=9 only
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	// Support: IE <=9 only
	wrapMap.optgroup = wrapMap.option;

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;


	function getAll( context, tag ) {

		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}

		return ret;
	}


	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}


	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}


	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );

		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );

		div.appendChild( input );

		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	} )();
	var documentElement = document.documentElement;



	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 only
	// See #13393 for more info
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {

		global: {},

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Don't attach events to noData or text/comment nodes (but allow plain objects)
			if ( !elemData ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = {};
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}

				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			// Make a writable jQuery.Event from the native event object
			var event = jQuery.event.fix( nativeEvent );

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
				handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// Triggered event must either 1) have no namespace, or 2) have namespace(s)
					// a subset or equal to those in the bound event (both can have no namespace).
					if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&

				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			focus: {

				// Fire native event if possible so blur/focus sequence is correct
				trigger: function() {
					if ( this !== safeActiveElement() && this.focus ) {
						this.focus();
						return false;
					}
				},
				delegateType: "focusin"
			},
			blur: {
				trigger: function() {
					if ( this === safeActiveElement() && this.blur ) {
						this.blur();
						return false;
					}
				},
				delegateType: "focusout"
			},
			click: {

				// For checkbox, fire native event so checked state will be right
				trigger: function() {
					if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
						this.click();
						return false;
					}
				},

				// For cross-browser consistency, don't fire native .click() on links
				_default: function( event ) {
					return nodeName( event.target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	jQuery.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&

					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;

			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;

			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery.event.addProp );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );


	var

		/* eslint-disable max-len */

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		/* eslint-enable */

		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.access( src );
			pdataCur = dataPriv.set( dest, pdataOld );
			events = pdataOld.events;

			if ( events ) {
				delete pdataCur.handle;
				pdataCur.events = {};

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();

		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;

		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {

							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = jQuery.contains( elem.ownerDocument, elem );

			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {

				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},

		remove: function( selector ) {
			return remove( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );

				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	var getStyles = function( elem ) {

			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;

			if ( !view || !view.opener ) {
				view = window;
			}

			return view.getComputedStyle( elem );
		};

	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



	( function() {

		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {

			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}

			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );

			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";

			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			div.style.position = "absolute";
			scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

			documentElement.removeChild( container );

			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}

		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}

		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );

		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}

		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";

		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			}
		} );
	} )();


	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,

			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}


	function addGetHookIf( conditionFn, hookFn ) {

		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {

					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}

				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}


	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		},

		cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style;

	// Return a css property mapped to a potentially vendor prefixed property
	function vendorPropName( name ) {

		// Shortcut for names that are not vendor prefixed
		if ( name in emptyStyle ) {
			return name;
		}

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a property mapped along what jQuery.cssProps suggests or to
	// a vendor prefixed property.
	function finalPropName( name ) {
		var ret = jQuery.cssProps[ name ];
		if ( !ret ) {
			ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
		}
		return ret;
	}

	function setPositiveNumber( elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
			) );
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),
			val = curCSS( elem, dimension, styles ),
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox;

		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = valueIsBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ dimension ] );

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		if ( val === "auto" ||
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

			val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

			// offsetWidth/offsetHeight provide border-box values
			valueIsBorderBox = true;
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {

						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},

		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},

		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If a number was passed in, add the unit (except for certain CSS properties)
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}

				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery.each( [ "height", "width" ], function( i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
					isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra && boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					);

				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && support.scrollboxSize() === styles.position ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);

	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );


	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 &&
					( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
						jQuery.cssHooks[ tween.prop ] ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};

	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery.fx.step = {};




	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}

			jQuery.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				/* eslint-disable no-loop-func */

				anim.done( function() {

				/* eslint-enable no-loop-func */

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery.map( props, createTween, animation );

		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery.Animation = jQuery.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};

		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue && type !== false ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};

	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery.fx.stop = function() {
		inProgress = null;
	};

	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};


	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};


	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );

		input.type = "checkbox";

		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";

		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;

		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();


	var boolHook,
		attrHandle = jQuery.expr.attrHandle;

	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );

	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {

				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};

	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;

		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();

			if ( !isXML ) {

				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );




	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {

				/* eslint no-unused-expressions: "off" */

				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;

					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );




		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}


	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );




	var rreturn = /\r/g;

	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = isFunction( value );

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {

					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :

						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						/* eslint-disable no-cond-assign */

						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}

						/* eslint-enable no-cond-assign */
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );




	// Return jQuery for attributes-only inclusion


	support.focusin = "onfocusin" in window;


	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery.extend( jQuery.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery.event.trigger( e, null, elem );
		}

	} );

	jQuery.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );


	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};

			jQuery.event.special[ fix ] = {
				setup: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix );

					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this,
						attaches = dataPriv.access( doc, fix ) - 1;

					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );

					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;

	var nonce = Date.now();

	var rquery = ( /\?/ );



	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};


	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( i, elem ) {
				var val = jQuery( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );


	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( isFunction( func ) ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,

				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
								}
							}
							match = responseHeaders[ key.toLowerCase() ];
						}
						return match == null ? null : match;
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );

				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );

	jQuery.each( [ "get", "post" ], function( i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );


	jQuery._evalUrl = function( url ) {
		return jQuery.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
			"throws": true
		} );
	};


	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );

			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );


	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};




	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200,

			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();

	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;

	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;

		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();

					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}

					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;

								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {

									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(

											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,

										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};

					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {

							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {

								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}

					// Create the abort callback
					callback = callback( "abort" );

					try {

						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {

						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},

				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain requests
		if ( s.crossDomain ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" ).prop( {
						charset: s.scriptCharset,
						src: s.url
					} ).on(
						"load error",
						callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						}
					);

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );




	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );




	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();


	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );

				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}

		return jQuery.merge( [], parsed.childNodes );
	};


	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( isFunction( params ) ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};




	// Attach a bunch of functions for handling common AJAX events
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );




	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};




	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( isFunction( options ) ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );

					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );


	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );


	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );

	jQuery.fn.extend( {
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );




	jQuery.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		}
	} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	};

	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;

	jQuery.now = Date.now;

	jQuery.isNumeric = function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};




	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.

	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}




	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( !noGlobal ) {
		window.jQuery = window.$ = jQuery;
	}




	return jQuery;
	} );


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(L) {// Following https://github.com/Leaflet/Leaflet/blob/master/PLUGIN-GUIDE.md
	(function (factory, window) {

	    // define an AMD module that relies on 'leaflet'
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	        // define a Common JS module that relies on 'leaflet'
	    } else if (typeof exports === 'object') {
	        module.exports = factory(require('leaflet'));
	    }

	    // attach your plugin to the global 'L' variable
	    if (typeof window !== 'undefined' && window.L) {
	        window.L.Control.MiniMap = factory(L);
	        window.L.control.minimap = function (layer, options) {
	            return new window.L.Control.MiniMap(layer, options);
	        };
	    }
	}(function (L) {

	    var MiniMap = L.Control.extend({

	        includes: L.Mixin.Events,

	        options: {
	            position: 'bottomright',
	            toggleDisplay: false,
	            zoomLevelOffset: -5,
	            zoomLevelFixed: false,
	            centerFixed: false,
	            zoomAnimation: false,
	            autoToggleDisplay: false,
	            minimized: false,
	            width: 150,
	            height: 150,
	            collapsedWidth: 19,
	            collapsedHeight: 19,
	            aimingRectOptions: {color: '#19ac9e', weight: 1, clickable: false},
	            shadowRectOptions: {color: '#000000', weight: 1, clickable: false, opacity: 0, fillOpacity: 0},
	            strings: {hideText: 'Hide MiniMap', showText: 'Show MiniMap'},
	            mapOptions: {}  // Allows definition / override of Leaflet map options.
	        },

	        // layer is the map layer to be shown in the minimap
	        initialize: function (layer, options) {
	            L.Util.setOptions(this, options);
	            // Make sure the aiming rects are non-clickable even if the user tries to set them clickable (most likely by forgetting to specify them false)
	            this.options.aimingRectOptions.clickable = false;
	            this.options.shadowRectOptions.clickable = false;
	            this._layer = layer;
	        },

	        onAdd: function (map) {

	            this._mainMap = map;

	            // Creating the container and stopping events from spilling through to the main map.
	            this._container = L.DomUtil.create('div', 'leaflet-control-minimap');
	            this._container.style.width = this.options.width + 'px';
	            this._container.style.height = this.options.height + 'px';
	            L.DomEvent.disableClickPropagation(this._container);
	            L.DomEvent.on(this._container, 'mousewheel', L.DomEvent.stopPropagation);

	            var mapOptions = {
	                attributionControl: false,
	                dragging: !this.options.centerFixed,
	                zoomControl: false,
	                zoomAnimation: this.options.zoomAnimation,
	                autoToggleDisplay: this.options.autoToggleDisplay,
	                touchZoom: this.options.centerFixed ? 'center' : !this._isZoomLevelFixed(),
	                scrollWheelZoom: this.options.centerFixed ? 'center' : !this._isZoomLevelFixed(),
	                doubleClickZoom: this.options.centerFixed ? 'center' : !this._isZoomLevelFixed(),
	                boxZoom: !this._isZoomLevelFixed(),
	                crs: map.options.crs
	            };
	            mapOptions = L.Util.extend(this.options.mapOptions, mapOptions);  // merge with priority of the local mapOptions object.

	            this._miniMap = new L.Map(this._container, mapOptions);

	            this._miniMap.addLayer(this._layer);

	            // These bools are used to prevent infinite loops of the two maps notifying each other that they've moved.
	            this._mainMapMoving = false;
	            this._miniMapMoving = false;

	            // Keep a record of this to prevent auto toggling when the user explicitly doesn't want it.
	            this._userToggledDisplay = false;
	            this._minimized = false;

	            if (this.options.toggleDisplay) {
	                this._addToggleButton();
	            }

	            this._addCloseButton();

	            this._miniMap.whenReady(L.Util.bind(function () {
	                this._aimingRect = L.rectangle(this._mainMap.getBounds(), this.options.aimingRectOptions).addTo(this._miniMap);
	                this._shadowRect = L.rectangle(this._mainMap.getBounds(), this.options.shadowRectOptions).addTo(this._miniMap);
	                this._mainMap.on('moveend', this._onMainMapMoved, this);
	                this._mainMap.on('move', this._onMainMapMoving, this);
	                this._miniMap.on('movestart', this._onMiniMapMoveStarted, this);
	                this._miniMap.on('move', this._onMiniMapMoving, this);
	                this._miniMap.on('moveend', this._onMiniMapMoved, this);
	            }, this));

	            return this._container;
	        },

	        addTo: function (map) {
	            L.Control.prototype.addTo.call(this, map);

	            var center = this.options.centerFixed || this._mainMap.getCenter();
	            this._miniMap.setView(center, this._decideZoom(true));
	            this._setDisplay(this.options.minimized);
	            return this;
	        },

	        onRemove: function (map) {
	            this._mainMap.off('moveend', this._onMainMapMoved, this);
	            this._mainMap.off('move', this._onMainMapMoving, this);
	            this._miniMap.off('moveend', this._onMiniMapMoved, this);

	            this._miniMap.removeLayer(this._layer);
	        },

	        changeLayer: function (layer) {
	            this._miniMap.removeLayer(this._layer);
	            this._layer = layer;
	            this._miniMap.addLayer(this._layer);
	        },

	        _addToggleButton: function () {
	            this._toggleDisplayButton = this.options.toggleDisplay ? this._createButton(
	                '', this._toggleButtonInitialTitleText(), ('leaflet-control-minimap-toggle-display leaflet-control-minimap-toggle-display-' +
	                this.options.position), this._container, this._toggleDisplayButtonClicked, this) : undefined;

	            this._toggleDisplayButton.style.width = this.options.collapsedWidth + 'px';
	            this._toggleDisplayButton.style.height = this.options.collapsedHeight + 'px';
	        },

	        _addCloseButton: function () {
	            this._closeDisplayButton = this._createButton(
	                '', 'close', ('leaflet-control-minimap-close-display leaflet-control-minimap-toggle-display-topright'), this._container, this._closeDisplayButtonClicked, this);

	            this._closeDisplayButton.style.width = '14px';
	            this._closeDisplayButton.style.height = '14px';
	        },

	        _toggleButtonInitialTitleText: function () {
	            if (this.options.minimized) {
	                return this.options.strings.showText;
	            } else {
	                return this.options.strings.hideText;
	            }
	        },

	        _createButton: function (html, title, className, container, fn, context) {
	            var link = L.DomUtil.create('a', className, container);
	            link.innerHTML = html;
	            link.href = '#';
	            link.title = title;

	            var stop = L.DomEvent.stopPropagation;

	            L.DomEvent
	                .on(link, 'click', stop)
	                .on(link, 'mousedown', stop)
	                .on(link, 'dblclick', stop)
	                .on(link, 'click', L.DomEvent.preventDefault)
	                .on(link, 'click', fn, context);

	            return link;
	        },

	        _toggleDisplayButtonClicked: function () {
	            this._userToggledDisplay = true;
	            if (!this._minimized) {
	                this._minimize();
	            } else {
	                this._restore();
	            }
	        },

	        _closeDisplayButtonClicked: function () {
	            this._container.style.display = "none";
	        },

	        _setDisplay: function (minimize) {
	            if (minimize !== this._minimized) {
	                if (!this._minimized) {
	                    this._minimize();
	                } else {
	                    this._restore();
	                }
	            }
	        },

	        _minimize: function () {
	            // hide the minimap
	            if (this.options.toggleDisplay) {
	                this._container.style.width = this.options.collapsedWidth + 'px';
	                this._container.style.height = this.options.collapsedHeight + 'px';
	                this._toggleDisplayButton.className += (' minimized-' + this.options.position);
	                this._toggleDisplayButton.title = this.options.strings.showText;
	            } else {
	                this._container.style.display = 'none';
	            }
	            this._minimized = true;
	            this._onToggle();
	        },

	        _restore: function () {
	            if (this.options.toggleDisplay) {
	                this._container.style.width = this.options.width + 'px';
	                this._container.style.height = this.options.height + 'px';
	                this._toggleDisplayButton.className = this._toggleDisplayButton.className
	                    .replace('minimized-'	+ this.options.position, '');
	                this._toggleDisplayButton.title = this.options.strings.hideText;
	            } else {
	                this._container.style.display = 'block';
	            }
	            this._minimized = false;
	            this._onToggle();
	        },

	        _onMainMapMoved: function (e) {
	            if (!this._miniMapMoving) {
	                var center = this.options.centerFixed || this._mainMap.getCenter();

	                this._mainMapMoving = true;
	                this._miniMap.setView(center, this._decideZoom(true));
	                this._setDisplay(this._decideMinimized());
	            } else {
	                this._miniMapMoving = false;
	            }
	            this._aimingRect.setBounds(this._mainMap.getBounds());
	        },

	        _onMainMapMoving: function (e) {
	            this._aimingRect.setBounds(this._mainMap.getBounds());
	        },

	        _onMiniMapMoveStarted: function (e) {
	            if (!this.options.centerFixed) {
	                var lastAimingRect = this._aimingRect.getBounds();
	                var sw = this._miniMap.latLngToContainerPoint(lastAimingRect.getSouthWest());
	                var ne = this._miniMap.latLngToContainerPoint(lastAimingRect.getNorthEast());
	                this._lastAimingRectPosition = {sw: sw, ne: ne};
	            }
	        },

	        _onMiniMapMoving: function (e) {
	            if (!this.options.centerFixed) {
	                if (!this._mainMapMoving && this._lastAimingRectPosition) {
	                    this._shadowRect.setBounds(new L.LatLngBounds(this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.sw), this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.ne)));
	                    this._shadowRect.setStyle({opacity: 1, fillOpacity: 0.3});
	                }
	            }
	        },

	        _onMiniMapMoved: function (e) {
	            if (!this._mainMapMoving) {
	                this._miniMapMoving = true;
	                this._mainMap.setView(this._miniMap.getCenter(), this._decideZoom(false));
	                this._shadowRect.setStyle({opacity: 0, fillOpacity: 0});
	            } else {
	                this._mainMapMoving = false;
	            }
	        },

	        _isZoomLevelFixed: function () {
	            var zoomLevelFixed = this.options.zoomLevelFixed;
	            return this._isDefined(zoomLevelFixed) && this._isInteger(zoomLevelFixed);
	        },

	        _decideZoom: function (fromMaintoMini) {
	            if (!this._isZoomLevelFixed()) {
	                if (fromMaintoMini) {
	                    return this._mainMap.getZoom() + this.options.zoomLevelOffset;
	                } else {
	                    var currentDiff = this._miniMap.getZoom() - this._mainMap.getZoom();
	                    var proposedZoom = this._miniMap.getZoom() - this.options.zoomLevelOffset;
	                    var toRet;

	                    if (currentDiff > this.options.zoomLevelOffset && this._mainMap.getZoom() < this._miniMap.getMinZoom() - this.options.zoomLevelOffset) {
	                        // This means the miniMap is zoomed out to the minimum zoom level and can't zoom any more.
	                        if (this._miniMap.getZoom() > this._lastMiniMapZoom) {
	                            // This means the user is trying to zoom in by using the minimap, zoom the main map.
	                            toRet = this._mainMap.getZoom() + 1;
	                            // Also we cheat and zoom the minimap out again to keep it visually consistent.
	                            this._miniMap.setZoom(this._miniMap.getZoom() - 1);
	                        } else {
	                            // Either the user is trying to zoom out past the mini map's min zoom or has just panned using it, we can't tell the difference.
	                            // Therefore, we ignore it!
	                            toRet = this._mainMap.getZoom();
	                        }
	                    } else {
	                        // This is what happens in the majority of cases, and always if you configure the min levels + offset in a sane fashion.
	                        toRet = proposedZoom;
	                    }
	                    this._lastMiniMapZoom = this._miniMap.getZoom();
	                    return toRet;
	                }
	            } else {
	                if (fromMaintoMini) {
	                    return this.options.zoomLevelFixed;
	                } else {
	                    return this._mainMap.getZoom();
	                }
	            }
	        },

	        _decideMinimized: function () {
	            if (this._userToggledDisplay) {
	                return this._minimized;
	            }

	            if (this.options.autoToggleDisplay) {
	                if (this._mainMap.getBounds().contains(this._miniMap.getBounds())) {
	                    return true;
	                }
	                return false;
	            }

	            return this._minimized;
	        },

	        _isInteger: function (value) {
	            return typeof value === 'number';
	        },

	        _isDefined: function (value) {
	            return typeof value !== 'undefined';
	        },

	        _onToggle: function () {
	            L.Util.requestAnimFrame(function () {
	                L.DomEvent.on(this._container, 'transitionend', this._fireToggleEvents, this);
	                if (!L.Browser.any3d) {
	                    L.Util.requestAnimFrame(this._fireToggleEvents, this);
	                }
	            }, this);
	        },

	        _fireToggleEvents: function () {
	            L.DomEvent.off(this._container, 'transitionend', this._fireToggleEvents, this);
	            var data = { minimized: this._minimized };
	            this.fire(this._minimized ? 'minimize' : 'restore', data);
	            this.fire('toggle', data);
	        }
	    });

	    L.Map.mergeOptions({
	        miniMapControl: false
	    });

	    L.Map.addInitHook(function () {
	        if (this.options.miniMapControl) {
	            this.miniMapControl = (new MiniMap()).addTo(this);
	        }
	    });

	    return MiniMap;

	}, window));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.Location = undefined;

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Created by gongmin on 2017/9/6.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var Location = function () {
	    function Location() {
	        _classCallCheck(this, Location);
	    }

	    _createClass(Location, [{
	        key: 'init',
	        value: function init(type, LatLng) {
	            var $this = this;
	            var location = '';
	            //script.id = this._callbackId;
	            switch (type) {
	                case 'OpenStreetMap':
	                    break;
	                case 'Google地图':
	                    break;
	                case 'Google卫星':
	                    break;
	                case '天地图':
	                    break;
	                case '天地图影像':
	                    break;
	                case '高德地图':
	                    location = $this.initGaode(LatLng);break;
	            }
	            return location;
	        }
	    }, {
	        key: 'initGaode',
	        value: function initGaode(LatLng) {
	            var location = '';
	            var url = 'https://restapi.amap.com/v3/geocode/regeo?output=xml&location=' + LatLng.lng + ',' + LatLng.lat + '&key=3ee09e2462ad937d972b825e3624a89a&radius=1000&extensions=all';
	            _jquery2.default.ajax({
	                url: url,
	                async: false,
	                success: function success(data) {
	                    location = (0, _jquery2.default)(data).find('formatted_address').eq(0).text();
	                }
	            });
	            return location;
	        }
	    }, {
	        key: 'getAddress',
	        value: function getAddress(LatLng, type) {
	            var location = '';
	            var url = 'https://restapi.amap.com/v3/geocode/regeo?output=xml&location=' + LatLng.lng + ',' + LatLng.lat + '&key=3ee09e2462ad937d972b825e3624a89a&radius=1000&extensions=all';
	            _jquery2.default.ajax({
	                url: url,
	                success: function success(data) {
	                    var dataJson = eval('(' + data + ')');
	                    location = dataJson.addressComponent[type];
	                }
	            });
	            return location;
	        }
	    }, {
	        key: 'getInputtips',
	        value: function getInputtips(keywords, city, LatLng) {
	            var tips = '';
	            var url = 'https://restapi.amap.com/v3/assistant/inputtips?keywords=' + keywords + '&key=9a7983cc299b135b084ca6b8eff28012&datatype=all';
	            if (city) {
	                url = url + '&city=' + city;
	            }
	            if (LatLng) {
	                url = url + '&location=' + LatLng.lng + ',' + LatLng.lat;
	            }
	            _jquery2.default.ajax({
	                url: url,
	                async: false,
	                success: function success(data) {
	                    tips = data.tips;
	                }
	            });
	            return tips;
	        }
	    }, {
	        key: 'getSearch',
	        value: function getSearch(keywords, city) {
	            var search = '';
	            var url = 'https://restapi.amap.com/v3/place/text?keywords=' + keywords + '&key=9a7983cc299b135b084ca6b8eff28012&offset=10&page=1&extensions=all&children=1';
	            if (city) {
	                url = url + '&city=' + city;
	            }
	            _jquery2.default.ajax({
	                url: url,
	                async: false,
	                success: function success(data) {
	                    search = data;
	                }
	            });
	            return search;
	        }
	    }, {
	        key: 'getLatlng',
	        value: function getLatlng(address) {
	            var latlng = '';
	            var url = 'https://restapi.amap.com/v3/config/district?keywords=' + address + '&key=9a7983cc299b135b084ca6b8eff28012&subdistrict=0';
	            _jquery2.default.ajax({
	                url: url,
	                async: false,
	                success: function success(data) {
	                    latlng = data.districts[0].center;
	                }
	            });
	            return latlng;
	        }
	    }, {
	        key: 'getSubdistrict',
	        value: function getSubdistrict(address) {
	            var subdistrict = {};
	            var url = 'https://restapi.amap.com/v3/config/district?keywords=' + address + '&key=9a7983cc299b135b084ca6b8eff28012&subdistrict=1';
	            _jquery2.default.ajax({
	                url: url,
	                async: false,
	                success: function success(data) {
	                    subdistrict = data;
	                }
	            });
	            return subdistrict;
	        }
	    }]);

	    return Location;
	}();

	exports.Location = Location;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Created by gongmin on 2017/9/6.
	 */
	(function (factory) {
	    if (typeof module !== 'undefined' && module.exports) {
	        module.exports = factory(__webpack_require__(1));
	    } else {
	        window.providers = factory(window.L);
	    }
	})(function (L) {
	    var providers = {};

	    return providers;
	});

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {"use strict";

	L.TileLayer.ChinaProvider = L.TileLayer.extend({

	    initialize: function initialize(type, options) {
	        // (type, Object)
	        var providers = L.TileLayer.ChinaProvider.providers;

	        var parts = type.split('.');

	        var providerName = parts[0];
	        var mapName = parts[1];
	        var mapType = parts[2];

	        var url = providers[providerName][mapName][mapType];
	        options.subdomains = providers[providerName].Subdomains;

	        L.TileLayer.prototype.initialize.call(this, url, options);
	    }
	});

	L.TileLayer.ChinaProvider.providers = {
	    TianDiTu: {
	        Normal: {
	            Map: "http://t{s}.tianditu.cn/DataServer?T=vec_w&X={x}&Y={y}&L={z}",
	            Annotion: "http://t{s}.tianditu.cn/DataServer?T=cva_w&X={x}&Y={y}&L={z}"
	        },
	        Satellite: {
	            Map: "http://t{s}.tianditu.cn/DataServer?T=img_w&X={x}&Y={y}&L={z}",
	            Annotion: "http://t{s}.tianditu.cn/DataServer?T=cia_w&X={x}&Y={y}&L={z}"
	        },
	        Terrain: {
	            Map: "http://t{s}.tianditu.cn/DataServer?T=ter_w&X={x}&Y={y}&L={z}",
	            Annotion: "http://t{s}.tianditu.cn/DataServer?T=cta_w&X={x}&Y={y}&L={z}"
	        },
	        Subdomains: ['0', '1', '2', '3', '4', '5', '6', '7']
	    },

	    GaoDe: {
	        Normal: {
	            Map: 'http://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=8&x={x}&y={y}&z={z}'
	        },
	        Satellite: {
	            Map: 'http://webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}',
	            Annotion: 'http://webst0{s}.is.autonavi.com/appmaptile?style=8&x={x}&y={y}&z={z}'
	        },
	        Road: {
	            Map: 'http://tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&;t=1&x={x}&y={y}&z={z}&t=1519971161036'
	        },
	        Subdomains: ["1", "2", "3", "4"]
	    },

	    Google: {
	        Normal: {
	            Map: "http://www.google.cn/maps/vt?lyrs=m@189&gl=cn&x={x}&y={y}&z={z}"
	        },
	        Satellite: {
	            Map: "http://www.google.cn/maps/vt?lyrs=s@189&gl=cn&x={x}&y={y}&z={z}"
	        },
	        Subdomains: []
	    },

	    Geoq: {
	        Normal: {
	            Map: "http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}",
	            Color: "http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetColor/MapServer/tile/{z}/{y}/{x}",
	            PurplishBlue: "http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/{z}/{y}/{x}",
	            Gray: "http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetGray/MapServer/tile/{z}/{y}/{x}",
	            Warm: "http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetWarm/MapServer/tile/{z}/{y}/{x}",
	            Cold: "http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetCold/MapServer/tile/{z}/{y}/{x}"
	        },
	        Subdomains: []

	    }
	};

	L.tileLayer.chinaProvider = function (type, options) {
	    return new L.TileLayer.ChinaProvider(type, options);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	(function (factory) {
	    // Packaging/modules magic dance
	    var L;
	    if (true) {
	        // AMD
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof module !== 'undefined') {
	        // Node/CommonJS
	        L = require('leaflet');
	        module.exports = factory(L);
	    } else {
	        // Browser globals
	        if (typeof window.L === 'undefined') {
	            throw new Error('Leaflet must be loaded first');
	        }
	        factory(window.L);
	    }
	})(function (L) {
	    'use strict';

	    L.Control.Zoomslider = function () {

	        var Knob = L.Draggable.extend({
	            initialize: function initialize(element, stepHeight, knobHeight) {
	                L.Draggable.prototype.initialize.call(this, element, element);
	                this._element = element;

	                this._stepHeight = stepHeight;
	                this._knobHeight = knobHeight;

	                this.on('predrag', function () {
	                    this._newPos.x = 0;
	                    this._newPos.y = this._adjust(this._newPos.y);
	                }, this);
	            },

	            _adjust: function _adjust(y) {
	                var value = Math.round(this._toValue(y));
	                value = Math.max(0, Math.min(this._maxValue, value));
	                return this._toY(value);
	            },

	            // y = k*v + m
	            _toY: function _toY(value) {
	                return this._k * value + this._m;
	            },
	            // v = (y - m) / k
	            _toValue: function _toValue(y) {
	                return (y - this._m) / this._k;
	            },

	            setSteps: function setSteps(steps) {
	                var sliderHeight = steps * this._stepHeight;
	                this._maxValue = steps - 1;

	                // conversion parameters
	                // the conversion is just a common linear function.
	                this._k = -this._stepHeight;
	                this._m = sliderHeight - (this._stepHeight + this._knobHeight) / 2;
	            },

	            setPosition: function setPosition(y) {
	                L.DomUtil.setPosition(this._element, L.point(0, this._adjust(y)));
	            },

	            setValue: function setValue(v) {
	                this.setPosition(this._toY(v));
	            },

	            getValue: function getValue() {
	                return this._toValue(L.DomUtil.getPosition(this._element).y);
	            }
	        });

	        var Zoomslider = L.Control.extend({
	            options: {
	                position: 'bottomright',
	                // Height of zoom-slider.png in px
	                stepHeight: 8,
	                // Height of the knob div in px (including border)
	                knobHeight: 6,
	                styleNS: 'leaflet-control-zoomslider'
	            },

	            onAdd: function onAdd(map) {
	                this._map = map;
	                this._ui = this._createUI();
	                this._knob = new Knob(this._ui.knob, this.options.stepHeight, this.options.knobHeight);

	                map.whenReady(this._initKnob, this).whenReady(this._initEvents, this).whenReady(this._updateSize, this).whenReady(this._updateKnobValue, this).whenReady(this._initScale, this).whenReady(this._updateDisabled, this);
	                return this._ui.bar;
	            },

	            onRemove: function onRemove(map) {
	                map.off('zoomlevelschange', this._updateSize, this).off('zoomend zoomlevelschange', this._updateKnobValue, this).off('zoomend zoomlevelschange', this._updateDisabled, this);
	            },

	            _createUI: function _createUI() {
	                var ui = {},
	                    ns = this.options.styleNS;

	                ui.bar = L.DomUtil.create('div', ns + ' leaflet-bar');
	                ui.zoomIn = this._createZoomBtn('in', 'top', ui.bar);
	                ui.wrap = L.DomUtil.create('div', ns + '-wrap leaflet-bar-part', ui.bar);
	                ui.zoomOut = this._createZoomBtn('out', 'bottom', ui.bar);
	                ui.body = L.DomUtil.create('div', ns + '-body', ui.wrap);
	                ui.knob = L.DomUtil.create('div', ns + '-knob');
	                ui.scale = L.DomUtil.create('div', ns + '-scale');
	                ui.province = L.DomUtil.create('div', ns + '-province');

	                L.DomEvent.disableClickPropagation(ui.bar);
	                L.DomEvent.disableClickPropagation(ui.knob);

	                return ui;
	            },
	            _createZoomBtn: function _createZoomBtn(zoomDir, end, container) {
	                var classDef = this.options.styleNS + '-' + zoomDir + ' leaflet-bar-part' + ' leaflet-bar-part-' + end,
	                    link = L.DomUtil.create('a', classDef, container);

	                link.href = '#';
	                link.title = 'Zoom ' + zoomDir;

	                L.DomEvent.on(link, 'click', L.DomEvent.preventDefault);

	                return link;
	            },

	            _initKnob: function _initKnob() {
	                this._knob.enable();
	                this._ui.body.appendChild(this._ui.knob);
	            },
	            _initScale: function _initScale() {
	                var length = this._map.getMaxZoom() - this._map.getMinZoom();
	                var ns = this.options.styleNS;
	                var height = 1 - (this.options.stepHeight - 1) / 2;
	                for (var i = 0; i < length + 1; i++) {
	                    this._ui.body.appendChild(L.DomUtil.create('div', ns + '-scale')).style.transform = 'translate3d(0px, ' + height + 'px, 0px)';
	                    height = height + this.options.stepHeight - 1;
	                }
	                this._ui.body.appendChild(L.DomUtil.create('div', ns + '-province')).style.transform = 'translate3d(-58px, 79px, 0px)';
	                this._ui.body.appendChild(L.DomUtil.create('div', ns + '-city')).style.transform = 'translate3d(-58px, 39px, 0px)';
	                this._ui.body.appendChild(L.DomUtil.create('div', ns + '-street')).style.transform = 'translate3d(-58px, -25px, 0px)';
	            },
	            _initEvents: function _initEvents() {
	                this._map.on('zoomlevelschange', this._updateSize, this).on('zoomend zoomlevelschange', this._updateKnobValue, this).on('zoomend zoomlevelschange', this._updateDisabled, this);

	                L.DomEvent.on(this._ui.body, 'click', this._onSliderClick, this);
	                L.DomEvent.on(this._ui.zoomIn, 'click', this._zoomIn, this);
	                L.DomEvent.on(this._ui.zoomOut, 'click', this._zoomOut, this);

	                this._knob.on('dragend', this._updateMapZoom, this);
	            },

	            _onSliderClick: function _onSliderClick(e) {
	                var first = e.touches && e.touches.length === 1 ? e.touches[0] : e,
	                    y = L.DomEvent.getMousePosition(first, this._ui.body).y;

	                this._knob.setPosition(y);
	                this._updateMapZoom();
	            },

	            _zoomIn: function _zoomIn(e) {
	                this._map.zoomIn(e.shiftKey ? 3 : 1);
	            },
	            _zoomOut: function _zoomOut(e) {
	                this._map.zoomOut(e.shiftKey ? 3 : 1);
	            },

	            _zoomLevels: function _zoomLevels() {
	                var zoomLevels = this._map.getMaxZoom() - this._map.getMinZoom() + 1;
	                return zoomLevels < Infinity ? zoomLevels : 0;
	            },
	            _toZoomLevel: function _toZoomLevel(value) {
	                return value + this._map.getMinZoom();
	            },
	            _toValue: function _toValue(zoomLevel) {
	                return zoomLevel - this._map.getMinZoom();
	            },

	            _updateSize: function _updateSize() {
	                var steps = this._zoomLevels();

	                this._ui.body.style.height = this.options.stepHeight * steps + 'px';
	                this._knob.setSteps(steps);
	            },
	            _updateMapZoom: function _updateMapZoom() {
	                this._map.setZoom(this._toZoomLevel(this._knob.getValue()));
	            },
	            _updateKnobValue: function _updateKnobValue() {
	                this._knob.setValue(this._toValue(this._map.getZoom()));
	            },
	            _updateDisabled: function _updateDisabled() {
	                var zoomLevel = this._map.getZoom(),
	                    className = this.options.styleNS + '-disabled';

	                L.DomUtil.removeClass(this._ui.zoomIn, className);
	                L.DomUtil.removeClass(this._ui.zoomOut, className);

	                if (zoomLevel === this._map.getMinZoom()) {
	                    L.DomUtil.addClass(this._ui.zoomOut, className);
	                }
	                if (zoomLevel === this._map.getMaxZoom()) {
	                    L.DomUtil.addClass(this._ui.zoomIn, className);
	                }
	            }
	        });

	        return Zoomslider;
	    }();

	    L.Map.addInitHook(function () {
	        if (this.options.zoomsliderControl) {
	            this.zoomsliderControl = new L.Control.Zoomslider();
	            this.addControl(this.zoomsliderControl);
	        }
	    });

	    L.control.zoomslider = function (options) {
	        return new L.Control.Zoomslider(options);
	    };
	});

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	if (typeof console == "undefined") {
	    undefined.console = { log: function log(msg) {/* do nothing since it would otherwise break IE */} };
	}

	L.Control.OSMGeocoder = L.Control.extend({
	    options: {
	        collapsed: true,
	        position: 'topright',
	        text: 'Locate',
	        placeholder: '',
	        bounds: null, // L.LatLngBounds
	        email: null, // String
	        callback: function callback(results) {
	            if (results.length == 0) {
	                console.log("ERROR: didn't find a result");
	                return;
	            }
	            var bbox = results[0].boundingbox,
	                first = new L.LatLng(bbox[0], bbox[2]),
	                second = new L.LatLng(bbox[1], bbox[3]),
	                bounds = new L.LatLngBounds([first, second]);
	            this._map.fitBounds(bounds);
	        }
	    },

	    _callbackId: 0,

	    initialize: function initialize(options) {
	        L.Util.setOptions(this, options);
	    },

	    onAdd: function onAdd(map) {
	        this._map = map;

	        var className = 'leaflet-control-geocoder',
	            container = this._container = L.DomUtil.create('div', className);

	        L.DomEvent.disableClickPropagation(container);

	        var form = this._form = L.DomUtil.create('form', className + '-form');

	        var input = this._input = document.createElement('input');
	        input.type = "text";
	        input.placeholder = this.options.placeholder || '';

	        var submit = document.createElement('input');
	        submit.type = "submit";
	        submit.value = this.options.text;

	        form.appendChild(input);
	        form.appendChild(submit);

	        L.DomEvent.addListener(form, 'submit', this._geocode, this);

	        if (this.options.collapsed) {
	            L.DomEvent.addListener(container, 'mouseover', this._expand, this);
	            L.DomEvent.addListener(container, 'mouseout', this._collapse, this);

	            var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
	            link.href = '#';
	            link.title = 'Nominatim Geocoder';

	            L.DomEvent.addListener(link, L.Browser.touch ? 'click' : 'focus', this._expand, this);

	            this._map.on('movestart', this._collapse, this);
	        } else {
	            this._expand();
	        }

	        container.appendChild(form);

	        return container;
	    },

	    /* helper functions for cordinate extraction */
	    _createSearchResult: function _createSearchResult(lat, lon) {
	        //creates an position description similar to the result of a Nominatim search
	        var diff = 0.005;
	        var result = [];
	        result[0] = {};
	        result[0]["boundingbox"] = [parseFloat(lat) - diff, parseFloat(lat) + diff, parseFloat(lon) - diff, parseFloat(lon) + diff];
	        result[0]["class"] = "boundary";
	        result[0]["display_name"] = "Position: " + lat + " " + lon;
	        result[0]["lat"] = lat;
	        result[0]["lon"] = lon;
	        return result;
	    },
	    _isLatLon: function _isLatLon(q) {
	        //"lon lat" => xx.xxx x.xxxxx
	        var re = /(-?\d+\.\d+)\s(-?\d+\.\d+)/;
	        var m = re.exec(q);
	        if (m != undefined) return m;

	        //lat...xx.xxx...lon...x.xxxxx
	        re = /lat\D*(-?\d+\.\d+)\D*lon\D*(-?\d+\.\d+)/;
	        m = re.exec(q);
	        //showRegExpResult(m);
	        if (m != undefined) return m;else return null;
	    },
	    _isLatLon_decMin: function _isLatLon_decMin(q) {
	        console.log("is LatLon?: " + q);
	        //N 53° 13.785' E 010° 23.887'
	        //re = /[NS]\s*(\d+)\D*(\d+\.\d+).?\s*[EW]\s*(\d+)\D*(\d+\.\d+)\D*/;
	        var re = /([ns])\s*(\d+)\D*(\d+\.\d+).?\s*([ew])\s*(\d+)\D*(\d+\.\d+)/i;
	        var m = re.exec(q.toLowerCase());
	        //showRegExpResult(m);
	        if (m != undefined) return m;else return null;
	        // +- dec min +- dec min
	    },

	    _geocode: function _geocode(event) {
	        L.DomEvent.preventDefault(event);
	        var q = this._input.value;
	        //try to find corrdinates
	        if (this._isLatLon(q) != null) {
	            var m = this._isLatLon(q);
	            console.log("LatLon: " + m[1] + " " + m[2]);
	            //m = {lon, lat}
	            this.options.callback.call(this, this._createSearchResult(m[1], m[2]));
	            return;
	        } else if (this._isLatLon_decMin(q) != null) {
	            var m = this._isLatLon_decMin(q);
	            //m: [ns, lat dec, lat min, ew, lon dec, lon min]
	            var temp = new Array();
	            temp['n'] = 1;
	            temp['s'] = -1;
	            temp['e'] = 1;
	            temp['w'] = -1;
	            this.options.callback.call(this, this._createSearchResult(temp[m[1]] * (Number(m[2]) + m[3] / 60), temp[m[4]] * (Number(m[5]) + m[6] / 60)));
	            return;
	        }

	        //and now Nominatim
	        //http://wiki.openstreetmap.org/wiki/Nominatim
	        console.log(this._callbackId);
	        window["_l_osmgeocoder_" + this._callbackId] = L.Util.bind(this.options.callback, this);

	        /* Set up params to send to Nominatim */
	        var params = {
	            // Defaults
	            q: this._input.value,
	            json_callback: "_l_osmgeocoder_" + this._callbackId++,
	            format: 'json'
	        };

	        if (this.options.bounds && this.options.bounds != null) {
	            if (this.options.bounds instanceof L.LatLngBounds) {
	                params.viewbox = this.options.bounds.toBBoxString();
	                params.bounded = 1;
	            } else {
	                console.log('bounds must be of type L.LatLngBounds');
	                return;
	            }
	        }

	        if (this.options.email && this.options.email != null) {
	            if (typeof this.options.email == 'string') {
	                params.email = this.options.email;
	            } else {
	                console.log('email must be a string');
	            }
	        }

	        var protocol = location.protocol;
	        if (protocol == "file:") protocol = "https:";
	        var url = protocol + "//nominatim.openstreetmap.org/search" + L.Util.getParamString(params),
	            script = document.createElement("script");

	        script.type = "text/javascript";
	        script.src = url;
	        script.id = this._callbackId;
	        document.getElementsByTagName("head")[0].appendChild(script);
	    },

	    _expand: function _expand() {
	        L.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');
	    },

	    _collapse: function _collapse() {
	        this._container.className = this._container.className.replace(' leaflet-control-geocoder-expanded', '');
	    }
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	var _jquery = __webpack_require__(3);

	var _jquery2 = _interopRequireDefault(_jquery);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	(function () {

	    L.Control.LinearMeasurement = L.Control.extend({

	        options: {
	            position: 'topleft',
	            unitSystem: 'imperial', // imperial | metric
	            color: '#4D90FE',
	            contrastingColor: '#fff',
	            show_last_node: false,
	            show_azimut: false,
	            tool_className: false
	        },

	        clickSpeed: 200,

	        onAdd: function onAdd(map) {
	            var container = L.DomUtil.create('div', 'leaflet-control leaflet-bar'),
	                link = L.DomUtil.create('a', 'icon-ruler', container),
	                map_container = map.getContainer(),
	                me = this;
	            container.style.display = "none";

	            link.href = '#';
	            link.title = 'Toggle measurement tool';

	            L.DomEvent.on(link, 'click', L.DomEvent.stop).on(link, 'click', function () {
	                if (L.DomUtil.hasClass(link, 'icon-active')) {
	                    me.resetRuler(!!me.mainLayer);
	                    L.DomUtil.removeClass(link, 'icon-active');
	                    L.DomUtil.removeClass(map_container, 'ruler-map');
	                } else {
	                    me.initRuler();
	                    L.DomUtil.addClass(link, 'icon-active');
	                    L.DomUtil.addClass(map_container, 'ruler-map');
	                }
	            });

	            function contrastingColor(color) {
	                return luma(color) >= 165 ? '000' : 'fff';
	            }

	            function luma(color) {
	                var rgb = typeof color === 'string' ? hexToRGBArray(color) : color;
	                return 0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]; // SMPTE C, Rec. 709 weightings
	            }

	            function hexToRGBArray(color) {
	                if (color.length === 3) color = color.charAt(0) + color.charAt(0) + color.charAt(1) + color.charAt(1) + color.charAt(2) + color.charAt(2);else if (color.length !== 6) throw 'Invalid hex color: ' + color;
	                var rgb = [];
	                for (var i = 0; i <= 2; i++) {
	                    rgb[i] = parseInt(color.substr(i * 2, 2), 16);
	                }return rgb;
	            }

	            if (this.options.color && this.options.color.indexOf('#') === -1) {
	                this.options.color = '#' + this.options.color;
	            } else if (!this.options.color) {
	                this.options.color = '#4D90FE';
	            }

	            var originalColor = this.options.color.replace('#', '');

	            this.options.contrastingColor = '#' + contrastingColor(originalColor);

	            return container;
	        },

	        onRemove: function onRemove(map) {
	            this.resetRuler(!!this.mainLayer);
	        },

	        initRuler: function initRuler() {
	            var me = this,
	                map = this._map;

	            this.mainLayer = L.featureGroup();
	            this.mainLayer.addTo(this._map);

	            map.touchZoom.disable();
	            map.doubleClickZoom.disable();
	            map.boxZoom.disable();
	            map.keyboard.disable();

	            if (map.tap) {
	                map.tap.disable();
	            }

	            this.dblClickEventFn = function (e) {
	                me.getDblClickHandler(e);
	                L.DomEvent.stop(e);
	            };

	            this.clickEventFn = function (e) {
	                if (me.clickHandle) {
	                    clearTimeout(me.clickHandle);
	                    me.clickHandle = 0;

	                    if (me.options.show_last_node) {
	                        me.preClick(e);
	                        me.getMouseClickHandler(e);
	                    }

	                    me.getDblClickHandler(e);
	                } else {
	                    me.preClick(e);

	                    me.clickHandle = setTimeout(function () {
	                        me.getMouseClickHandler(e);
	                        me.clickHandle = 0;
	                    }, me.clickSpeed);
	                }
	            };

	            this.moveEventFn = function (e) {
	                if (!me.clickHandle) {
	                    me.getMouseMoveHandler(e);
	                }
	            };

	            this.contextEventFn = function (e) {
	                if (me.latlngsList.length == 0) {
	                    if (me.mainLayer) {
	                        me.mainLayer.removeLayer(me.layer);
	                    }
	                    me.resetRuler();
	                } else {
	                    me.getDblClickHandler(e);
	                }
	            };

	            map.on('click', this.clickEventFn, this);
	            map.on('mousemove', this.moveEventFn, this);
	            map.on('contextmenu', this.contextEventFn, this);

	            (0, _jquery2.default)(document).one("keyup", function (event) {
	                if (event.keyCode == 27) {
	                    if (me.latlngsList.length == 0) {
	                        if (me.mainLayer) {
	                            me.mainLayer.removeLayer(me.layer);
	                        }
	                    } else {
	                        /*
	                        map.off('click', this.clickEventFn, this);
	                        map.off('mousemove', this.moveEventFn, this);
	                        map.removeLayer(me.poly);
	                        map.removeLayer(me.total);
	                        me.total = me.workSpaceList[me.workSpaceList.length - 1];
	                        //map.removeLayer(me.workSpaceList[me.workSpaceList.length - 1]);
	                        me.latlngs[1] = me.total._latlng;
	                        me.latlngsList.pop();
	                        $(me.total._icon.lastChild.firstElementChild).removeClass('lineclose');
	                        $(me.total._icon.lastChild.firstElementChild).addClass('dlineclose');
	                        $(me.total._icon.lastChild.firstElementChild.firstElementChild).removeClass('lineclose');
	                        $(me.total._icon.lastChild.firstElementChild.firstElementChild).addClass('dlineclose');
	                        me.workSpaceList.pop();
	                        me.renderCircleList.pop();
	                        me.latlngs[0] = me.renderCircleList[me.renderCircleList.length - 1]._latlng;
	                          me._map.touchZoom.enable();
	                        me._map.boxZoom.enable();
	                        me._map.keyboard.enable();
	                          if(me._map.tap) {
	                            me._map.tap.enable();
	                        }
	                        */
	                    }
	                }
	            });

	            this.resetRuler();
	        },

	        initLayer: function initLayer() {
	            this.layer = L.featureGroup();
	            this.layer.addTo(this.mainLayer);
	            this.layer.on('selected', this.layerSelected);
	            this.layer.on('click', this.clickEventFn, this);
	        },

	        resetRuler: function resetRuler(resetLayer) {
	            var map = this._map;

	            if (resetLayer) {
	                map.off('click', this.clickEventFn, this);
	                map.off('mousemove', this.moveEventFn, this);
	                map.off('contextmenu', this.contextEventFn, this);

	                if (this.mainLayer) {
	                    this._map.removeLayer(this.mainLayer);
	                }

	                this.mainLayer = null;

	                this._map.touchZoom.enable();
	                this._map.boxZoom.enable();
	                this._map.keyboard.enable();

	                if (this._map.tap) {
	                    this._map.tap.enable();
	                }
	            }

	            this.layer = null;
	            this.prevLatlng = null;
	            this.poly = null;
	            this.multi = null;
	            this.latlngs = null;
	            this.latlngsList = [];
	            this.renderCircleList = [];
	            this.workSpaceList = [];
	            //this.lastWorkSpace = null;
	            this.sum = 0;
	            this.distance = 0;
	            this.separation = 1;
	            this.last = 0;
	            this.fixedLast = 0;
	            this.totalIcon = null;
	            this.total = null;
	            this.lastCircle = null;

	            /* Leaflet return distances in meters */
	            this.UNIT_CONV = 1000;
	            this.SUB_UNIT_CONV = 1000;
	            this.UNIT = 'km';
	            this.SUB_UNIT = 'm';

	            if (this.options.unitSystem === 'imperial') {
	                this.UNIT_CONV = 1609.344;
	                this.SUB_UNIT_CONV = 5280;
	                this.UNIT = 'mi';
	                this.SUB_UNIT = 'ft';
	            }

	            this.measure = {
	                scalar: 0,
	                unit: this.SUB_UNIT
	            };
	        },

	        cleanUpMarkers: function cleanUpMarkers(fixed) {
	            var layer = this.layer;

	            if (layer) {
	                layer.eachLayer(function (l) {
	                    if (l.options && l.options.type === 'tmp') {
	                        if (fixed) {
	                            l.options.type = 'fixed';
	                        } else {
	                            layer.removeLayer(l);
	                        }
	                    }
	                });
	            }
	        },

	        cleanUpFixed: function cleanUpFixed() {
	            var layer = this.layer;

	            if (layer) {
	                layer.eachLayer(function (l) {
	                    if (l.options && l.options.type === 'fixed') {
	                        layer.removeLayer(l);
	                    }
	                });
	            }
	        },

	        convertDots: function convertDots() {
	            var me = this,
	                layer = this.layer;

	            if (layer) {
	                layer.eachLayer(function (l) {
	                    if (l.options && l.options.type === 'dot') {

	                        var m = l.options.marker,
	                            i = m ? m.options.icon.options : null,
	                            il = i ? i.html : '';

	                        if (il && il.indexOf(me.measure.unit) === -1) {
	                            var str = l.options.label,
	                                s = str.split(' '),
	                                e = parseFloat(s[0]),
	                                u = s[1],
	                                label = '';

	                            if (l.options.label.indexOf(me.measure.unit) !== -1) {
	                                label = l.options.label;
	                            } else if (u === me.UNIT) {
	                                label = (e * me.SUB_UNIT_CONV).toFixed(2) + ' ' + me.SUB_UNIT;
	                            } else if (u === me.SUB_UNIT) {
	                                label = (e / me.SUB_UNIT_CONV).toFixed(2) + ' ' + me.UNIT;
	                            }

	                            var cicon = L.divIcon({
	                                className: 'total-popup-label',
	                                html: label
	                            });

	                            m.setIcon(cicon);
	                        }
	                    }
	                });
	            }
	        },

	        displayMarkers: function displayMarkers(latlngs, multi, sum) {
	            var x,
	                y,
	                label,
	                ratio,
	                p,
	                latlng = latlngs[latlngs.length - 1],
	                prevLatlng = latlngs[0],
	                original = prevLatlng.distanceTo(latlng) / this.UNIT_CONV,
	                dis = original;

	            var p2 = this._map.latLngToContainerPoint(latlng),
	                p1 = this._map.latLngToContainerPoint(prevLatlng),
	                unit = 1;

	            if (this.measure.unit === this.SUB_UNIT) {
	                unit = this.SUB_UNIT_CONV;
	                dis = dis * unit;
	            }

	            var t = sum * unit + dis,
	                qu = sum * unit;

	            for (var q = Math.floor(qu); q < t; q++) {
	                ratio = (t - q) / dis;

	                if (q % this.separation || q < qu) {
	                    continue;
	                }

	                x = p2.x - ratio * (p2.x - p1.x);
	                y = p2.y - ratio * (p2.y - p1.y);

	                p = L.point(x, y);

	                /* render a circle spaced by separation */

	                latlng = this._map.containerPointToLatLng(p);

	                label = q + ' ' + this.measure.unit;

	                this.renderCircle(latlng, 0, this.layer, multi ? 'fixed' : 'tmp', label);

	                this.last = t;
	            }

	            return original;
	        },

	        renderCircle: function renderCircle(latLng, radius, layer, type, label) {
	            var color = this.options.color,
	                lineColor = this.options.color,
	                azimut = '',
	                nodeCls = '';

	            type = type || 'circle';

	            var linesHTML = [];

	            var options = {
	                color: lineColor,
	                fillOpacity: 1,
	                opacity: 1,
	                fill: true,
	                type: type
	            };

	            var a = this.prevLatlng ? this._map.latLngToContainerPoint(this.prevLatlng) : null,
	                b = this._map.latLngToContainerPoint(latLng);

	            if (type === 'dot') {
	                nodeCls = 'node-label';

	                if (a && this.options.show_azimut) {
	                    azimut = ' <span class="azimut"> ' + this.lastAzimut + '&deg;</span>';
	                }
	            }

	            var p_latLng = this._map.containerPointToLatLng(b);

	            if (label) {
	                var cicon = L.divIcon({
	                    className: 'total-popup-label ' + nodeCls,
	                    html: '<span style="color: ' + color + ';">' + label + azimut + '</span>'
	                });

	                options.icon = cicon;
	                options.marker = L.marker(p_latLng, { icon: cicon, type: type }).addTo(layer);
	                options.label = label;
	            }

	            var circle = L.circleMarker(latLng, options);

	            circle.setRadius(3);
	            circle.addTo(layer);

	            return circle;
	        },

	        getAzimut: function getAzimut(a, b) {
	            var deg = 0;

	            if (a && b) {
	                deg = parseInt(Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);

	                if (deg > 0) {
	                    deg += 90;
	                } else if (deg < 0) {
	                    deg = Math.abs(deg);
	                    if (deg <= 90) {
	                        deg = 90 - deg;
	                    } else {
	                        deg = 360 - (deg - 90);
	                    }
	                }
	            }

	            this.lastAzimut = deg;

	            return deg;
	        },

	        renderPolyline: function renderPolyline(latLngs, dashArray, layer) {
	            var poly = L.polyline(latLngs, {
	                color: this.options.color,
	                weight: 2,
	                opacity: 1,
	                dashArray: dashArray
	            });

	            poly.addTo(layer);

	            return poly;
	        },

	        renderMultiPolyline: function renderMultiPolyline(latLngs, dashArray, layer) {
	            /* Leaflet version 1+ delegated the concept of multi-poly-line to the polyline */
	            var multi;

	            if (L.version.startsWith('0')) {
	                multi = L.multiPolyline(latLngs, {
	                    color: this.options.color,
	                    weight: 2,
	                    opacity: 1,
	                    dashArray: dashArray
	                });
	            } else {
	                multi = L.polyline(latLngs, {
	                    color: this.options.color,
	                    weight: 2,
	                    opacity: 1,
	                    dashArray: dashArray
	                });
	            }

	            multi.addTo(layer);

	            return multi;
	        },

	        formatDistance: function formatDistance(distance, precision) {
	            var s = L.Util.formatNum(distance < 1 ? distance * parseFloat(this.SUB_UNIT_CONV) : distance, precision),
	                u = distance < 1 ? this.SUB_UNIT : this.UNIT;

	            return { scalar: s, unit: u };
	        },

	        hasClass: function hasClass(target, classes) {
	            var fn = L.DomUtil.hasClass;

	            for (var i in classes) {
	                if (fn(target, classes[i])) {
	                    return true;
	                }
	            }

	            return false;
	        },

	        preClick: function preClick(e) {
	            var me = this,
	                target = e.originalEvent.target;

	            if (this.hasClass(target, ['leaflet-popup', 'total-popup-content'])) {
	                return;
	            }

	            if (!me.layer) {
	                me.initLayer();
	            }

	            me.cleanUpMarkers(true);

	            me.fixedLast = me.last;
	            me.prevLatlng = e.latlng;
	            me.sum = 0;
	        },

	        getMouseClickHandler: function getMouseClickHandler(e) {
	            var me = this,
	                map = this._map;
	            me.fixedLast = me.last;
	            me.sum = 0;

	            if (me.poly) {
	                me.latlngsList.push(me.latlngs);

	                if (!me.multi) {
	                    me.multi = me.renderMultiPolyline(me.latlngsList, '5 5', me.layer, 'dot');
	                } else {
	                    me.multi.setLatLngs(me.latlngsList);
	                }
	            }

	            var o, dis;
	            for (var l = 0; l < me.latlngsList.length; l++) {
	                o = me.latlngsList[l];
	                me.sum += o[0].distanceTo(o[1]) / me.UNIT_CONV;
	            }
	            if (me.measure.unit === this.SUB_UNIT) {
	                dis = me.sum * me.SUB_UNIT_CONV;
	            } else {
	                dis = me.sum;
	            }

	            var s = dis.toFixed(2);

	            me.renderCircleList.push(me.renderCircle(e.latlng, 0, me.layer, 'dot', parseInt(s) ? s + ' ' + me.measure.unit : ''));
	            me.prevLatlng = e.latlng;

	            if (dis == 0) {
	                var html = ['<div class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">起点', '<img src="../dist/images/dlineclose.svg" class="dlineclose" style="position: relative!important;top: -2px!important;left: 2px!important;"/>', '</div>'].join('');

	                var start = L.marker(e.latlng, {
	                    icon: L.divIcon({ className: 'total-popup', html: html }),
	                    clickable: false
	                }).addTo(this.layer);
	                me.workSpaceList.push(start);
	            } else {
	                var azimut = '';

	                if (!this.total) {
	                    return;
	                }

	                //this.layer.off('click');

	                //L.DomEvent.stop(e);

	                if (this.options.show_azimut) {
	                    var style = 'color: ' + this.options.contrastingColor + ';';
	                    azimut = ' <span class="azimut azimut-final" style="' + style + '"> &nbsp; ' + this.lastAzimut + '&deg;</span>';
	                }

	                var label = this.measure.scalar + ' ' + this.measure.unit + ' ',
	                    total_scalar = this.measure.unit === this.SUB_UNIT ? this.measure.scalar / this.UNIT_CONV : this.measure.scalar,
	                    total_latlng = this.total.getLatLng(),
	                    total_label = this.total,
	                    html = ['<div class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">' + label + azimut, '  <svg class="lineclose" viewbox="0 0 45 35">', '   <path style="stroke: ' + this.options.contrastingColor + '" class="lineclose" d="M 10,10 L 30,30 M 30,10 L 10,30" />', '  </svg>', '</div>'].join('');

	                var workspace = L.marker(e.latlng, {
	                    icon: L.divIcon({ className: 'total-popup', html: html }),
	                    clickable: true
	                }).addTo(this.layer);

	                me.workSpaceList.push(workspace);

	                //console.log(me.workSpaceList);

	                var data = {
	                    total: this.measure,
	                    total_label: total_label,
	                    unit: this.UNIT_CONV,
	                    sub_unit: this.SUB_UNIT_CONV
	                };

	                var fireSelected = function fireSelected(e) {
	                    var latlngs = [];
	                    if (L.DomUtil.hasClass(e.originalEvent.target, 'lineclose')) {
	                        map.removeLayer(workspace);
	                        for (var i = 0; i < me.latlngsList.length; i++) {
	                            if (me.latlngsList[i][1].equals(e.latlng)) {
	                                //me.latlngsList.splice(i, 1);
	                                var azimut = '';

	                                if (me.options.show_azimut) {
	                                    var style = 'color: ' + me.options.contrastingColor + ';';
	                                    azimut = ' <span class="azimut azimut-final" style="' + style + '"> &nbsp; ' + this.lastAzimut + '&deg;</span>';
	                                }
	                                //console.log(me);
	                                if (me.latlngsList[i + 1]) {
	                                    latlngs[0] = me.latlngsList[i][0];
	                                    latlngs[1] = me.latlngsList[i + 1][1];
	                                    me.latlngsList.splice(i, 1);
	                                    me.latlngsList.splice(i, 1, latlngs);
	                                    map.removeLayer(me.renderCircleList[i + 1]);
	                                    me.renderCircleList.splice(i + 1, 1);
	                                    //me.workSpaceList.splice(i, 1);
	                                    var dis = 0;
	                                    for (var j = 1; j < me.workSpaceList.length; j++) {
	                                        if (me.workSpaceList[j]._icon != null) {
	                                            var x = 1;
	                                            while (me.workSpaceList[j - x]._icon == null) {
	                                                x++;
	                                            }
	                                            dis = dis + me.workSpaceList[j - x].getLatLng().distanceTo(me.workSpaceList[j].getLatLng()) / me.UNIT_CONV;
	                                            var label = dis.toFixed(2) + ' ' + me.measure.unit + ' ',
	                                                html = ['<div class="total-popup-content" style="background-color:' + me.options.color + '; color: ' + me.options.contrastingColor + '">' + label + azimut, '  <svg class="lineclose" viewbox="0 0 45 35">', '   <path style="stroke: ' + me.options.contrastingColor + '" class="lineclose" d="M 10,10 L 30,30 M 30,10 L 10,30" />', '  </svg>', '</div>'].join('');
	                                            me.workSpaceList[j].setIcon(L.divIcon({ className: 'total-popup', html: html }));
	                                        }
	                                    }
	                                    var last_dis = 0;
	                                    for (var j = me.workSpaceList.length - 1; j >= 0; j--) {
	                                        if (me.workSpaceList[j]._icon != null) {
	                                            if (me.workSpaceList[j]._icon.innerText.split(" ")[0].indexOf('起点') >= 0) {
	                                                last_dis = me.latlngs[1].distanceTo(me.latlngs[0]) / me.UNIT_CONV;
	                                            } else {
	                                                last_dis = parseFloat(me.workSpaceList[j]._icon.innerText.split(" ")[0]) + me.latlngs[1].distanceTo(me.workSpaceList[j].getLatLng()) / me.UNIT_CONV;;
	                                            }
	                                            break;
	                                        }
	                                    }
	                                    var label = last_dis.toFixed(2) + ' ' + me.measure.unit + ' ',
	                                        html = ['<div class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">' + label + azimut, '   <img src="../dist/images/dlineclose.svg" class="dlineclose" style="position: relative!important;top: -2px!important;left: 2px!important;"/>', '</div>'].join('');
	                                    me.totalIcon = L.divIcon({ className: 'total-popup', html: html });
	                                    me.total.setIcon(me.totalIcon);
	                                } else {
	                                    me.poly.setLatLngs([me.latlngs[1], me.latlngsList[me.latlngsList.length - 1][0]]);
	                                    var dis = me.latlngs[1].distanceTo(me.latlngsList[me.latlngsList.length - 1][0]) / me.UNIT_CONV;
	                                    for (var j = me.workSpaceList.length - 1; j >= 0; j--) {
	                                        if (me.workSpaceList[j]._icon != null) {
	                                            if (me.workSpaceList[j]._icon.innerText.split(" ")[0].indexOf('起点') >= 0) {
	                                                dis = dis;
	                                            } else {
	                                                dis = parseFloat(me.workSpaceList[j]._icon.innerText.split(" ")[0]) + dis;
	                                            }
	                                            break;
	                                        }
	                                    }
	                                    me.latlngsList.splice(i, 1);
	                                    map.removeLayer(me.renderCircleList[i + 1]);
	                                    me.renderCircleList.splice(i + 1, 1);
	                                    //me.workSpaceList.splice(i + 1, 1);
	                                    me.poly.redraw();
	                                    var label = dis.toFixed(2) + ' ' + me.measure.unit + ' ',
	                                        html = ['<div class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">' + label + azimut, '   <img src="../dist/images/dlineclose.svg" class="dlineclose" style="position: relative!important;top: -2px!important;left: 2px!important;"/>', '</div>'].join('');
	                                    me.totalIcon = L.divIcon({ className: 'total-popup', html: html });
	                                    me.total.setIcon(me.totalIcon);
	                                }
	                            }
	                        }
	                        //console.log(e);
	                        //console.log(me);
	                        me.multi.setLatLngs(me.latlngsList);
	                        me.multi.redraw();
	                    } else {
	                        workspace.fireEvent('selected', data);
	                    }
	                };

	                workspace.on('click', fireSelected);
	                workspace.fireEvent('selected', data);
	            }
	        },

	        getMouseMoveHandler: function getMouseMoveHandler(e) {
	            var me = this;

	            if (!me.layer) {
	                me.initLayer();
	            }
	            var azimut = '';

	            if (this.prevLatlng) {
	                var latLng = e.latlng;

	                this.latlngs = [this.prevLatlng, e.latlng];

	                if (!this.poly) {
	                    this.poly = this.renderPolyline(this.latlngs, '5 5', this.layer);
	                } else {
	                    this.poly.setLatLngs(this.latlngs);
	                }

	                /* Distance in miles/meters */
	                this.distance = parseFloat(this.prevLatlng.distanceTo(e.latlng)) / this.UNIT_CONV;

	                /* scalar and unit */
	                this.measure = this.formatDistance(this.distance + this.sum, 2);

	                var a = this.prevLatlng ? this._map.latLngToContainerPoint(this.prevLatlng) : null,
	                    b = this._map.latLngToContainerPoint(latLng);

	                if (a && this.options.show_azimut) {
	                    var style = 'color: ' + this.options.contrastingColor + ';';
	                    azimut = ' <span class="azimut azimut-final" style="' + style + '"> &nbsp; ' + this.getAzimut(a, b) + '&deg;</span>';
	                }

	                /* tooltip with total distance */
	                var label = this.measure.scalar + ' ' + this.measure.unit,
	                    html = '<span class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">点击确定地点，双击或右键结束</span>';

	                if (!this.total) {
	                    this.totalIcon = L.divIcon({ className: 'total-popup', html: html });

	                    this.total = L.marker(e.latlng, {
	                        icon: this.totalIcon,
	                        clickable: true
	                    }).addTo(this.layer);
	                } else {
	                    this.totalIcon = L.divIcon({ className: 'total-popup', html: html });
	                    this.total.setLatLng(e.latlng);
	                    this.total.setIcon(this.totalIcon);
	                }

	                /* Rules for separation using only distance criteria */
	                var ds = this.measure.scalar,
	                    old_separation = this.separation,
	                    digits = parseInt(ds).toString().length,
	                    num = Math.pow(10, digits),
	                    real = ds > num / 2 ? num / 10 : num / 20,
	                    dimension = 0;

	                this.separation = real;

	                /* If there is a change in the segment length we want to re-space
	                   the dots on the multi line */
	                if (old_separation !== this.separation && this.fixedLast) {
	                    this.cleanUpMarkers();
	                    this.cleanUpFixed();

	                    var multi_latlngs = this.multi.getLatLngs();

	                    for (var s in multi_latlngs) {}
	                    //dimension += this.displayMarkers.apply(this, [multi_latlngs[s], true, dimension]);


	                    //this.displayMarkers.apply(this, [this.poly.getLatLngs(), false, this.sum]);

	                    /* Review that the dots are in correct units */
	                    //this.convertDots();
	                } else {
	                    this.cleanUpMarkers();
	                    //this.displayMarkers.apply(this, [this.poly.getLatLngs(), false, this.sum]);
	                }
	            } else {
	                var html = '<span class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">点击确定起点' + '</span>';
	                if (!this.total) {
	                    this.totalIcon = L.divIcon({ className: 'total-popup', html: html });

	                    this.total = L.marker(e.latlng, {
	                        icon: this.totalIcon,
	                        clickable: true
	                    }).addTo(this.layer);
	                } else {
	                    this.totalIcon = L.divIcon({ className: 'total-popup', html: html });
	                    this.total.setLatLng(e.latlng);
	                    this.total.setIcon(this.totalIcon);
	                }
	            }
	        },

	        getDblClickHandler: function getDblClickHandler(e) {
	            var azimut = '',
	                me = this;

	            if (!this.total) {
	                return;
	            }

	            this.layer.off('click');

	            L.DomEvent.stop(e);

	            if (this.options.show_azimut) {
	                var style = 'color: ' + this.options.contrastingColor + ';';
	                azimut = ' <span class="azimut azimut-final" style="' + style + '"> &nbsp; ' + this.lastAzimut + '&deg;</span>';
	            }

	            me.renderCircle(e.latlng, 0, me.layer, 'dot', label + azimut);

	            var workspace = this.layer,
	                label = this.measure.scalar + ' ' + this.measure.unit + ' ',
	                total_scalar = this.measure.unit === this.SUB_UNIT ? this.measure.scalar / this.UNIT_CONV : this.measure.scalar,
	                total_latlng = this.total.getLatLng(),
	                total_label = this.total,
	                html = ['<div class="total-popup-content" style="background-color:' + this.options.color + '; color: ' + this.options.contrastingColor + '">' + label + azimut, '   <img src="../dist/images/dlineclose.svg" class="dlineclose" style="position: relative!important;top: -2px!important;left: 2px!important;"/>', '</div>'].join('');

	            //me.lastWorkSpace = workspace;

	            this.totalIcon = L.divIcon({ className: 'total-popup', html: html });
	            this.total.setIcon(this.totalIcon);

	            var data = {
	                total: this.measure,
	                total_label: total_label,
	                unit: this.UNIT_CONV,
	                sub_unit: this.SUB_UNIT_CONV
	            };

	            var fireSelected = function fireSelected(e) {
	                if (L.DomUtil.hasClass(e.originalEvent.target, 'dlineclose')) {
	                    me.mainLayer.removeLayer(workspace);
	                } else {
	                    workspace.fireEvent('selected', data);
	                }
	            };

	            workspace.on('click', fireSelected);
	            workspace.fireEvent('selected', data);

	            var map = this._map;

	            map.off('click', this.clickEventFn, this);
	            map.off('mousemove', this.moveEventFn, this);
	            map.off('contextmenu', this.contextEventFn, this);

	            //this.mainLayer = null;

	            this._map.touchZoom.enable();
	            this._map.boxZoom.enable();
	            this._map.keyboard.enable();

	            if (this._map.tap) {
	                this._map.tap.enable();
	            }

	            (0, _jquery2.default)('.leaflet-pointer').addClass('leaflet-grab');
	            (0, _jquery2.default)('.leaflet-pointer').removeClass('leaflet-pointer');

	            (0, _jquery2.default)('.' + this.options.tool_className).find('i').removeClass('font-active');
	            (0, _jquery2.default)('.' + this.options.tool_className).attr('data-picture', 0);
	        },

	        purgeLayers: function purgeLayers(layers) {
	            for (var i in layers) {
	                if (layers[i]) {
	                    this.layer.removeLayer(layers[i]);
	                }
	            }
	        },

	        layerSelected: function layerSelected(e) {}
	    });
	})();
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {/*
	 Leaflet.draw 0.4.14, a plugin that adds drawing and editing tools to Leaflet powered maps.
	 (c) 2012-2017, Jacob Toye, Jon West, Smartrak, Leaflet

	 https://github.com/Leaflet/Leaflet.draw
	 http://leafletjs.com
	 */
	!function(t,e,i){function o(t,e){for(;(t=t.parentElement)&&!t.classList.contains(e););return t}L.drawVersion="0.4.14",L.Draw={},L.drawLocal={draw:{toolbar:{actions:{title:"Cancel drawing",text:"Cancel"},finish:{title:"Finish drawing",text:"Finish"},undo:{title:"Delete last point drawn",text:"Delete last point"},buttons:{polyline:"Draw a polyline",polygon:"Draw a polygon",rectangle:"Draw a rectangle",circle:"Draw a circle",marker:"Draw a marker",circlemarker:"Draw a circlemarker"}},handlers:{circle:{tooltip:{start:"Click and drag to draw circle."},radius:"Radius"},circlemarker:{tooltip:{start:"Click map to place circle marker."}},marker:{tooltip:{start:"Click map to place marker."}},polygon:{tooltip:{start:"Click to start drawing shape.",cont:"Click to continue drawing shape.",end:"Click first point to close this shape."}},polyline:{error:"<strong>Error:</strong> shape edges cannot cross!",tooltip:{start:"Click to start drawing line.",cont:"Click to continue drawing line.",end:"Click last point to finish line."}},rectangle:{tooltip:{start:"Click and drag to draw rectangle."}},simpleshape:{tooltip:{end:"Release mouse to finish drawing."}}}},edit:{toolbar:{actions:{save:{title:"Save changes",text:"Save"},cancel:{title:"Cancel editing, discards all changes",text:"Cancel"},clearAll:{title:"Clear all layers",text:"Clear All"}},buttons:{edit:"Edit layers",editDisabled:"No layers to edit",remove:"Delete layers",removeDisabled:"No layers to delete"}},handlers:{edit:{tooltip:{text:"Drag handles or markers to edit features.",subtext:"Click cancel to undo changes."}},remove:{tooltip:{text:"Click on a feature to remove."}}}}},L.Draw.Event={},L.Draw.Event.CREATED="draw:created",L.Draw.Event.EDITED="draw:edited",L.Draw.Event.DELETED="draw:deleted",L.Draw.Event.DRAWSTART="draw:drawstart",L.Draw.Event.DRAWSTOP="draw:drawstop",L.Draw.Event.DRAWVERTEX="draw:drawvertex",L.Draw.Event.EDITSTART="draw:editstart",L.Draw.Event.EDITMOVE="draw:editmove",L.Draw.Event.EDITRESIZE="draw:editresize",L.Draw.Event.EDITVERTEX="draw:editvertex",L.Draw.Event.EDITSTOP="draw:editstop",L.Draw.Event.DELETESTART="draw:deletestart",L.Draw.Event.DELETESTOP="draw:deletestop",L.Draw.Event.TOOLBAROPENED="draw:toolbaropened",L.Draw.Event.TOOLBARCLOSED="draw:toolbarclosed",L.Draw.Event.MARKERCONTEXT="draw:markercontext",L.Draw=L.Draw||{},L.Draw.Feature=L.Handler.extend({initialize:function(t,e){this._map=t,this._container=t._container,this._overlayPane=t._panes.overlayPane,this._popupPane=t._panes.popupPane,e&&e.shapeOptions&&(e.shapeOptions=L.Util.extend({},this.options.shapeOptions,e.shapeOptions)),L.setOptions(this,e);var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.Draw.Feature.include(L.Evented.prototype):L.Draw.Feature.include(L.Mixin.Events)},enable:function(){this._enabled||(L.Handler.prototype.enable.call(this),this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.DRAWSTART,{layerType:this.type}))},disable:function(){this._enabled&&(L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.DRAWSTOP,{layerType:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(L.DomUtil.disableTextSelection(),t.getContainer().focus(),this._tooltip=new L.Draw.Tooltip(this._map),L.DomEvent.on(this._container,"keyup",this._cancelDrawing,this))},removeHooks:function(){this._map&&(L.DomUtil.enableTextSelection(),this._tooltip.dispose(),this._tooltip=null,L.DomEvent.off(this._container,"keyup",this._cancelDrawing,this))},setOptions:function(t){L.setOptions(this,t)},_fireCreatedEvent:function(t){this._map.fire(L.Draw.Event.CREATED,{layer:t,layerType:this.type})},_cancelDrawing:function(t){27===t.keyCode&&(this._map.fire("draw:canceled",{layerType:this.type}),this.disable())}}),L.Draw.Polyline=L.Draw.Feature.extend({statics:{TYPE:"polyline"},Poly:L.Polyline,options:{allowIntersection:!0,repeatMode:!1,drawError:{color:"#b00b00",timeout:2500},icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),touchIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon"}),guidelineDistance:20,maxGuideLineLength:4e3,shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!1,clickable:!0},metric:!0,feet:!0,nautic:!1,showLength:!0,zIndexOffset:2e3,factor:1,maxPoints:0},initialize:function(t,e){L.Browser.touch&&(this.options.icon=this.options.touchIcon),this.options.drawError.message=L.drawLocal.draw.handlers.polyline.error,e&&e.drawError&&(e.drawError=L.Util.extend({},this.options.drawError,e.drawError)),this.type=L.Draw.Polyline.TYPE,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._markers=[],this._markerGroup=new L.LayerGroup,this._map.addLayer(this._markerGroup),this._poly=new L.Polyline([],this.options.shapeOptions),this._tooltip.updateContent(this._getTooltipText()),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("mouseout",this._onMouseOut,this).on("mousemove",this._onMouseMove,this).on("mousedown",this._onMouseDown,this).on("mouseup",this._onMouseUp,this).addTo(this._map),this._map.on("mouseup",this._onMouseUp,this).on("mousemove",this._onMouseMove,this).on("zoomlevelschange",this._onZoomEnd,this).on("touchstart",this._onTouch,this).on("zoomend",this._onZoomEnd,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._clearHideErrorTimeout(),this._cleanUpShape(),this._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers,this._map.removeLayer(this._poly),delete this._poly,this._mouseMarker.off("mousedown",this._onMouseDown,this).off("mouseout",this._onMouseOut,this).off("mouseup",this._onMouseUp,this).off("mousemove",this._onMouseMove,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._clearGuides(),this._map.off("mouseup",this._onMouseUp,this).off("mousemove",this._onMouseMove,this).off("zoomlevelschange",this._onZoomEnd,this).off("zoomend",this._onZoomEnd,this).off("touchstart",this._onTouch,this).off("click",this._onTouch,this)},deleteLastVertex:function(){if(!(this._markers.length<=1)){var t=this._markers.pop(),e=this._poly,i=e.getLatLngs(),o=i.splice(-1,1)[0];this._poly.setLatLngs(i),this._markerGroup.removeLayer(t),e.getLatLngs().length<2&&this._map.removeLayer(e),this._vertexChanged(o,!1)}},addVertex:function(t){if(this._markers.length>=2&&!this.options.allowIntersection&&this._poly.newLatLngIntersects(t))return void this._showErrorTooltip();this._errorShown&&this._hideErrorTooltip(),this._markers.push(this._createMarker(t)),this._poly.addLatLng(t),2===this._poly.getLatLngs().length&&this._map.addLayer(this._poly),this._vertexChanged(t,!0)},completeShape:function(){this._markers.length<=1||(this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable())},_finishShape:function(){var t=this._poly._defaultShape?this._poly._defaultShape():this._poly.getLatLngs(),e=this._poly.newLatLngIntersects(t[t.length-1]);if(!this.options.allowIntersection&&e||!this._shapeIsValid())return void this._showErrorTooltip();this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()},_shapeIsValid:function(){return!0},_onZoomEnd:function(){null!==this._markers&&this._updateGuide()},_onMouseMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent),i=this._map.layerPointToLatLng(e);this._currentLatLng=i,this._updateTooltip(i),this._updateGuide(e),this._mouseMarker.setLatLng(i),L.DomEvent.preventDefault(t.originalEvent)},_vertexChanged:function(t,e){this._map.fire(L.Draw.Event.DRAWVERTEX,{layers:this._markerGroup}),this._updateFinishHandler(),this._updateRunningMeasure(t,e),this._clearGuides(),this._updateTooltip()},_onMouseDown:function(t){if(!this._clickHandled&&!this._touchHandled&&!this._disableMarkers){this._onMouseMove(t),this._clickHandled=!0,this._disableNewMarkers();var e=t.originalEvent,i=e.clientX,o=e.clientY;this._startPoint.call(this,i,o)}},_startPoint:function(t,e){this._mouseDownOrigin=L.point(t,e)},_onMouseUp:function(t){var e=t.originalEvent,i=e.clientX,o=e.clientY;this._endPoint.call(this,i,o,t),this._clickHandled=null},_endPoint:function(e,i,o){if(this._mouseDownOrigin){var n=L.point(e,i).distanceTo(this._mouseDownOrigin),a=this._calculateFinishDistance(o.latlng);this.options.maxPoints>1&&this.options.maxPoints==this._markers.length+1?(this.addVertex(o.latlng),this._finishShape()):a<10&&L.Browser.touch?this._finishShape():Math.abs(n)<9*(t.devicePixelRatio||1)&&this.addVertex(o.latlng),this._enableNewMarkers()}this._mouseDownOrigin=null},_onTouch:function(t){var e,i,o=t.originalEvent;!o.touches||!o.touches[0]||this._clickHandled||this._touchHandled||this._disableMarkers||(e=o.touches[0].clientX,i=o.touches[0].clientY,this._disableNewMarkers(),this._touchHandled=!0,this._startPoint.call(this,e,i),this._endPoint.call(this,e,i,t),this._touchHandled=null),this._clickHandled=null},_onMouseOut:function(){this._tooltip&&this._tooltip._onMouseOut.call(this._tooltip)},_calculateFinishDistance:function(t){var e;if(this._markers.length>0){var i;if(this.type===L.Draw.Polyline.TYPE)i=this._markers[this._markers.length-1];else{if(this.type!==L.Draw.Polygon.TYPE)return 1/0;i=this._markers[0]}var o=this._map.latLngToContainerPoint(i.getLatLng()),n=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset}),a=this._map.latLngToContainerPoint(n.getLatLng());e=o.distanceTo(a)}else e=1/0;return e},_updateFinishHandler:function(){var t=this._markers.length;t>1&&this._markers[t-1].on("click",this._finishShape,this),t>2&&this._markers[t-2].off("click",this._finishShape,this)},_createMarker:function(t){var e=new L.Marker(t,{icon:this.options.icon,zIndexOffset:2*this.options.zIndexOffset});return this._markerGroup.addLayer(e),e},_updateGuide:function(t){var e=this._markers?this._markers.length:0;e>0&&(t=t||this._map.latLngToLayerPoint(this._currentLatLng),this._clearGuides(),this._drawGuide(this._map.latLngToLayerPoint(this._markers[e-1].getLatLng()),t))},_updateTooltip:function(t){var e=this._getTooltipText();t&&this._tooltip.updatePosition(t),this._errorShown||this._tooltip.updateContent(e)},_drawGuide:function(t,e){var i,o,n,a=Math.floor(Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))),s=this.options.guidelineDistance,r=this.options.maxGuideLineLength,l=a>r?a-r:s;for(this._guidesContainer||(this._guidesContainer=L.DomUtil.create("div","leaflet-draw-guides",this._overlayPane));l<a;l+=this.options.guidelineDistance)i=l/a,o={x:Math.floor(t.x*(1-i)+i*e.x),y:Math.floor(t.y*(1-i)+i*e.y)},n=L.DomUtil.create("div","leaflet-draw-guide-dash",this._guidesContainer),n.style.backgroundColor=this._errorShown?this.options.drawError.color:this.options.shapeOptions.color,L.DomUtil.setPosition(n,o)},_updateGuideColor:function(t){if(this._guidesContainer)for(var e=0,i=this._guidesContainer.childNodes.length;e<i;e++)this._guidesContainer.childNodes[e].style.backgroundColor=t},_clearGuides:function(){if(this._guidesContainer)for(;this._guidesContainer.firstChild;)this._guidesContainer.removeChild(this._guidesContainer.firstChild)},_getTooltipText:function(){var t,e,i=this.options.showLength;return 0===this._markers.length?t={text:L.drawLocal.draw.handlers.polyline.tooltip.start}:(e=i?this._getMeasurementString():"",t=1===this._markers.length?{text:L.drawLocal.draw.handlers.polyline.tooltip.cont,subtext:e}:{text:L.drawLocal.draw.handlers.polyline.tooltip.end,subtext:e}),t},_updateRunningMeasure:function(t,e){var i,o,n=this._markers.length;1===this._markers.length?this._measurementRunningTotal=0:(i=n-(e?2:1),o=L.GeometryUtil.isVersion07x()?t.distanceTo(this._markers[i].getLatLng())*(this.options.factor||1):this._map.distance(t,this._markers[i].getLatLng())*(this.options.factor||1),this._measurementRunningTotal+=o*(e?1:-1))},_getMeasurementString:function(){var t,e=this._currentLatLng,i=this._markers[this._markers.length-1].getLatLng();return t=L.GeometryUtil.isVersion07x()?i&&e&&e.distanceTo?this._measurementRunningTotal+e.distanceTo(i)*(this.options.factor||1):this._measurementRunningTotal||0:i&&e?this._measurementRunningTotal+this._map.distance(e,i)*(this.options.factor||1):this._measurementRunningTotal||0,L.GeometryUtil.readableDistance(t,this.options.metric,this.options.feet,this.options.nautic,this.options.precision)},_showErrorTooltip:function(){this._errorShown=!0,this._tooltip.showAsError().updateContent({text:this.options.drawError.message}),this._updateGuideColor(this.options.drawError.color),this._poly.setStyle({color:this.options.drawError.color}),this._clearHideErrorTimeout(),this._hideErrorTimeout=setTimeout(L.Util.bind(this._hideErrorTooltip,this),this.options.drawError.timeout)},_hideErrorTooltip:function(){this._errorShown=!1,this._clearHideErrorTimeout(),this._tooltip.removeError().updateContent(this._getTooltipText()),this._updateGuideColor(this.options.shapeOptions.color),this._poly.setStyle({color:this.options.shapeOptions.color})},_clearHideErrorTimeout:function(){this._hideErrorTimeout&&(clearTimeout(this._hideErrorTimeout),this._hideErrorTimeout=null)},_disableNewMarkers:function(){this._disableMarkers=!0},_enableNewMarkers:function(){setTimeout(function(){this._disableMarkers=!1}.bind(this),50)},_cleanUpShape:function(){this._markers.length>1&&this._markers[this._markers.length-1].off("click",this._finishShape,this)},_fireCreatedEvent:function(){var t=new this.Poly(this._poly.getLatLngs(),this.options.shapeOptions);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)}}),L.Draw.Polygon=L.Draw.Polyline.extend({statics:{TYPE:"polygon"},Poly:L.Polygon,options:{showArea:!1,showLength:!1,shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},metric:!0,feet:!0,nautic:!1,precision:{}},initialize:function(t,e){L.Draw.Polyline.prototype.initialize.call(this,t,e),this.type=L.Draw.Polygon.TYPE},_updateFinishHandler:function(){var t=this._markers.length;1===t&&this._markers[0].on("click",this._finishShape,this),t>2&&(this._markers[t-1].on("dblclick",this._finishShape,this),t>3&&this._markers[t-2].off("dblclick",this._finishShape,this))},_getTooltipText:function(){var t,e;return 0===this._markers.length?t=L.drawLocal.draw.handlers.polygon.tooltip.start:this._markers.length<3?(t=L.drawLocal.draw.handlers.polygon.tooltip.cont,e=this._getMeasurementString()):(t=L.drawLocal.draw.handlers.polygon.tooltip.end,e=this._getMeasurementString()),{text:t,subtext:e}},_getMeasurementString:function(){var t=this._area,e="";return t||this.options.showLength?(this.options.showLength&&(e=L.Draw.Polyline.prototype._getMeasurementString.call(this)),t&&(e+="<br>"+L.GeometryUtil.readableArea(t,this.options.metric,this.options.precision)),e):null},_shapeIsValid:function(){return this._markers.length>=3},_vertexChanged:function(t,e){var i;!this.options.allowIntersection&&this.options.showArea&&(i=this._poly.getLatLngs(),this._area=L.GeometryUtil.geodesicArea(i)),L.Draw.Polyline.prototype._vertexChanged.call(this,t,e)},_cleanUpShape:function(){var t=this._markers.length;t>0&&(this._markers[0].off("click",this._finishShape,this),t>2&&this._markers[t-1].off("dblclick",this._finishShape,this))}}),L.SimpleShape={},L.Draw.SimpleShape=L.Draw.Feature.extend({options:{repeatMode:!1},initialize:function(t,e){this._endLabelText=L.drawLocal.draw.handlers.simpleshape.tooltip.end,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._mapDraggable=this._map.dragging.enabled(),this._mapDraggable&&this._map.dragging.disable(),this._container.style.cursor="crosshair",this._tooltip.updateContent({text:this._initialLabelText}),this._map.on("mousedown",this._onMouseDown,this).on("mousemove",this._onMouseMove,this).on("touchstart",this._onMouseDown,this).on("touchmove",this._onMouseMove,this),e.addEventListener("touchstart",L.DomEvent.preventDefault,{passive:!1}))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._mapDraggable&&this._map.dragging.enable(),this._container.style.cursor="",this._map.off("mousedown",this._onMouseDown,this).off("mousemove",this._onMouseMove,this).off("touchstart",this._onMouseDown,this).off("touchmove",this._onMouseMove,this),L.DomEvent.off(e,"mouseup",this._onMouseUp,this),L.DomEvent.off(e,"touchend",this._onMouseUp,this),e.removeEventListener("touchstart",L.DomEvent.preventDefault),this._shape&&(this._map.removeLayer(this._shape),delete this._shape)),this._isDrawing=!1},_getTooltipText:function(){return{text:this._endLabelText}},_onMouseDown:function(t){this._isDrawing=!0,this._startLatLng=t.latlng,L.DomEvent.on(e,"mouseup",this._onMouseUp,this).on(e,"touchend",this._onMouseUp,this).preventDefault(t.originalEvent)},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._isDrawing&&(this._tooltip.updateContent(this._getTooltipText()),this._drawShape(e))},_onMouseUp:function(){this._shape&&this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()}}),L.Draw.Rectangle=L.Draw.SimpleShape.extend({statics:{TYPE:"rectangle"},options:{shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,showArea:!0,clickable:!0},metric:!0},initialize:function(t,e){this.type=L.Draw.Rectangle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.rectangle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e)},disable:function(){this._enabled&&(this._isCurrentlyTwoClickDrawing=!1,L.Draw.SimpleShape.prototype.disable.call(this))},_onMouseUp:function(t){if(!this._shape&&!this._isCurrentlyTwoClickDrawing)return void(this._isCurrentlyTwoClickDrawing=!0);this._isCurrentlyTwoClickDrawing&&!o(t.target,"leaflet-pane")||L.Draw.SimpleShape.prototype._onMouseUp.call(this)},_drawShape:function(t){this._shape?this._shape.setBounds(new L.LatLngBounds(this._startLatLng,t)):(this._shape=new L.Rectangle(new L.LatLngBounds(this._startLatLng,t),this.options.shapeOptions),this._map.addLayer(this._shape))},_fireCreatedEvent:function(){var t=new L.Rectangle(this._shape.getBounds(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t)},_getTooltipText:function(){var t,e,i,o=L.Draw.SimpleShape.prototype._getTooltipText.call(this),n=this._shape,a=this.options.showArea;return n&&(t=this._shape._defaultShape?this._shape._defaultShape():this._shape.getLatLngs(),e=L.GeometryUtil.geodesicArea(t),i=a?L.GeometryUtil.readableArea(e,this.options.metric):""),{text:o.text,subtext:i}}}),L.Draw.Marker=L.Draw.Feature.extend({statics:{TYPE:"marker"},options:{icon:new L.Icon.Default,repeatMode:!1,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.Marker.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.marker.tooltip.start,L.Draw.Feature.prototype.initialize.call(this,t,e)},addHooks:function(){L.Draw.Feature.prototype.addHooks.call(this),this._map&&(this._tooltip.updateContent({text:this._initialLabelText}),this._mouseMarker||(this._mouseMarker=L.marker(this._map.getCenter(),{icon:L.divIcon({className:"leaflet-mouse-marker",iconAnchor:[20,20],iconSize:[40,40]}),opacity:0,zIndexOffset:this.options.zIndexOffset})),this._mouseMarker.on("click",this._onClick,this).addTo(this._map),this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onTouch,this))},removeHooks:function(){L.Draw.Feature.prototype.removeHooks.call(this),this._map&&(this._map.off("click",this._onClick,this).off("click",this._onTouch,this),this._marker&&(this._marker.off("click",this._onClick,this),this._map.removeLayer(this._marker),delete this._marker),this._mouseMarker.off("click",this._onClick,this),this._map.removeLayer(this._mouseMarker),delete this._mouseMarker,this._map.off("mousemove",this._onMouseMove,this))},_onMouseMove:function(t){var e=t.latlng;this._tooltip.updatePosition(e),this._mouseMarker.setLatLng(e),this._marker?(e=this._mouseMarker.getLatLng(),this._marker.setLatLng(e)):(this._marker=this._createMarker(e),this._marker.on("click",this._onClick,this),this._map.on("click",this._onClick,this).addLayer(this._marker))},_createMarker:function(t){return new L.Marker(t,{icon:this.options.icon,zIndexOffset:this.options.zIndexOffset})},_onClick:function(){this._fireCreatedEvent(),this.disable(),this.options.repeatMode&&this.enable()},_onTouch:function(t){this._onMouseMove(t),this._onClick()},_fireCreatedEvent:function(){var t=new L.Marker.Touch(this._marker.getLatLng(),{icon:this.options.icon});L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)}}),L.Draw.CircleMarker=L.Draw.Marker.extend({statics:{TYPE:"circlemarker"},options:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0,zIndexOffset:2e3},initialize:function(t,e){this.type=L.Draw.CircleMarker.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circlemarker.tooltip.start,L.Draw.Feature.prototype.initialize.call(this,t,e)},_fireCreatedEvent:function(){var t=new L.CircleMarker(this._marker.getLatLng(),this.options);L.Draw.Feature.prototype._fireCreatedEvent.call(this,t)},_createMarker:function(t){return new L.CircleMarker(t,this.options)}}),L.Draw.Circle=L.Draw.SimpleShape.extend({statics:{TYPE:"circle"},options:{shapeOptions:{stroke:!0,color:"#3388ff",weight:4,opacity:.5,fill:!0,fillColor:null,fillOpacity:.2,clickable:!0},showRadius:!0,metric:!0,feet:!0,nautic:!1},initialize:function(t,e){this.type=L.Draw.Circle.TYPE,this._initialLabelText=L.drawLocal.draw.handlers.circle.tooltip.start,L.Draw.SimpleShape.prototype.initialize.call(this,t,e)},_drawShape:function(t){if(L.GeometryUtil.isVersion07x())var e=this._startLatLng.distanceTo(t);else var e=this._map.distance(this._startLatLng,t);this._shape?this._shape.setRadius(e):(this._shape=new L.Circle(this._startLatLng,e,this.options.shapeOptions),this._map.addLayer(this._shape))},_fireCreatedEvent:function(){var t=new L.Circle(this._startLatLng,this._shape.getRadius(),this.options.shapeOptions);L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this,t)},_onMouseMove:function(t){var e,i=t.latlng,o=this.options.showRadius,n=this.options.metric;if(this._tooltip.updatePosition(i),this._isDrawing){this._drawShape(i),e=this._shape.getRadius().toFixed(1);var a="";o&&(a=L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(e,n,this.options.feet,this.options.nautic)),this._tooltip.updateContent({text:this._endLabelText,subtext:a})}}}),L.Edit=L.Edit||{},L.Edit.Marker=L.Handler.extend({initialize:function(t,e){this._marker=t,L.setOptions(this,e)},addHooks:function(){var t=this._marker;t.dragging.enable(),t.on("dragend",this._onDragEnd,t),this._toggleMarkerHighlight()},removeHooks:function(){var t=this._marker;t.dragging.disable(),t.off("dragend",this._onDragEnd,t),this._toggleMarkerHighlight()},_onDragEnd:function(t){var e=t.target;e.edited=!0,this._map.fire(L.Draw.Event.EDITMOVE,{layer:e})},_toggleMarkerHighlight:function(){var t=this._marker._icon;t&&(t.style.display="none",L.DomUtil.hasClass(t,"leaflet-edit-marker-selected")?(L.DomUtil.removeClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,-4)):(L.DomUtil.addClass(t,"leaflet-edit-marker-selected"),this._offsetMarker(t,4)),t.style.display="")},_offsetMarker:function(t,e){var i=parseInt(t.style.marginTop,10)-e,o=parseInt(t.style.marginLeft,10)-e;t.style.marginTop=i+"px",t.style.marginLeft=o+"px"}}),L.Marker.addInitHook(function(){L.Edit.Marker&&(this.editing=new L.Edit.Marker(this),this.options.editable&&this.editing.enable())}),L.Edit=L.Edit||{},L.Edit.Poly=L.Handler.extend({initialize:function(t){this.latlngs=[t._latlngs],t._holes&&(this.latlngs=this.latlngs.concat(t._holes)),this._poly=t,this._poly.on("revert-edited",this._updateLatLngs,this)},_defaultShape:function(){return L.Polyline._flat?L.Polyline._flat(this._poly._latlngs)?this._poly._latlngs:this._poly._latlngs[0]:this._poly._latlngs},_eachVertexHandler:function(t){for(var e=0;e<this._verticesHandlers.length;e++)t(this._verticesHandlers[e])},addHooks:function(){this._initHandlers(),this._eachVertexHandler(function(t){t.addHooks()})},removeHooks:function(){this._eachVertexHandler(function(t){t.removeHooks()})},updateMarkers:function(){this._eachVertexHandler(function(t){t.updateMarkers()})},_initHandlers:function(){this._verticesHandlers=[];for(var t=0;t<this.latlngs.length;t++)this._verticesHandlers.push(new L.Edit.PolyVerticesEdit(this._poly,this.latlngs[t],this._poly.options.poly))},_updateLatLngs:function(t){this.latlngs=[t.layer._latlngs],t.layer._holes&&(this.latlngs=this.latlngs.concat(t.layer._holes))}}),L.Edit.PolyVerticesEdit=L.Handler.extend({options:{icon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon"}),touchIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-touch-icon"}),drawError:{color:"#b00b00",timeout:1e3}},initialize:function(t,e,i){L.Browser.touch&&(this.options.icon=this.options.touchIcon),this._poly=t,i&&i.drawError&&(i.drawError=L.Util.extend({},this.options.drawError,i.drawError)),this._latlngs=e,L.setOptions(this,i)},_defaultShape:function(){return L.Polyline._flat?L.Polyline._flat(this._latlngs)?this._latlngs:this._latlngs[0]:this._latlngs},addHooks:function(){var t=this._poly,e=t._path;t instanceof L.Polygon||(t.options.fill=!1,t.options.editing&&(t.options.editing.fill=!1)),e&&t.options.editing.className&&(t.options.original.className&&t.options.original.className.split(" ").forEach(function(t){L.DomUtil.removeClass(e,t)}),t.options.editing.className.split(" ").forEach(function(t){L.DomUtil.addClass(e,t)})),t.setStyle(t.options.editing),this._poly._map&&(this._map=this._poly._map,this._markerGroup||this._initMarkers(),this._poly._map.addLayer(this._markerGroup))},removeHooks:function(){var t=this._poly,e=t._path;e&&t.options.editing.className&&(t.options.editing.className.split(" ").forEach(function(t){L.DomUtil.removeClass(e,t)}),t.options.original.className&&t.options.original.className.split(" ").forEach(function(t){L.DomUtil.addClass(e,t)})),t.setStyle(t.options.original),t._map&&(t._map.removeLayer(this._markerGroup),delete this._markerGroup,delete this._markers)},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers()},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._markers=[];var t,e,i,o,n=this._defaultShape();for(t=0,i=n.length;t<i;t++)o=this._createMarker(n[t],t),o.on("click",this._onMarkerClick,this),o.on("contextmenu",this._onContextMenu,this),this._markers.push(o);var a,s;for(t=0,e=i-1;t<i;e=t++)(0!==t||L.Polygon&&this._poly instanceof L.Polygon)&&(a=this._markers[e],s=this._markers[t],this._createMiddleMarker(a,s),this._updatePrevNext(a,s))},_createMarker:function(t,e){var i=new L.Marker.Touch(t,{draggable:!0,icon:this.options.icon});return i._origLatLng=t,i._index=e,i.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._fireEdit,this).on("touchmove",this._onTouchMove,this).on("touchend",this._fireEdit,this).on("MSPointerMove",this._onTouchMove,this).on("MSPointerUp",this._fireEdit,this),this._markerGroup.addLayer(i),i},_onMarkerDragStart:function(){this._poly.fire("editstart")},_spliceLatLngs:function(){var t=this._defaultShape(),e=[].splice.apply(t,arguments);return this._poly._convertLatLngs(t,!0),this._poly.redraw(),e},_removeMarker:function(t){var e=t._index;this._markerGroup.removeLayer(t),this._markers.splice(e,1),this._spliceLatLngs(e,1),this._updateIndexes(e,-1),t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._fireEdit,this).off("touchmove",this._onMarkerDrag,this).off("touchend",this._fireEdit,this).off("click",this._onMarkerClick,this).off("MSPointerMove",this._onTouchMove,this).off("MSPointerUp",this._fireEdit,this)},_fireEdit:function(){this._poly.edited=!0,this._poly.fire("edit"),this._poly._map.fire(L.Draw.Event.EDITVERTEX,{layers:this._markerGroup,poly:this._poly})},_onMarkerDrag:function(t){var e=t.target,i=this._poly;if(L.extend(e._origLatLng,e._latlng),e._middleLeft&&e._middleLeft.setLatLng(this._getMiddleLatLng(e._prev,e)),e._middleRight&&e._middleRight.setLatLng(this._getMiddleLatLng(e,e._next)),i.options.poly){var o=i._map._editTooltip;if(!i.options.poly.allowIntersection&&i.intersects()){var n=i.options.color;i.setStyle({color:this.options.drawError.color}),0!==L.version.indexOf("0.7")&&e.dragging._draggable._onUp(t),this._onMarkerClick(t),o&&o.updateContent({text:L.drawLocal.draw.handlers.polyline.error}),setTimeout(function(){i.setStyle({color:n}),o&&o.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext})},1e3)}}this._poly._bounds._southWest=L.latLng(1/0,1/0),this._poly._bounds._northEast=L.latLng(-1/0,-1/0);var a=this._poly.getLatLngs();this._poly._convertLatLngs(a,!0),this._poly.redraw(),this._poly.fire("editdrag")},_onMarkerClick:function(t){var e=L.Polygon&&this._poly instanceof L.Polygon?4:3,i=t.target;this._defaultShape().length<e||(this._removeMarker(i),this._updatePrevNext(i._prev,i._next),i._middleLeft&&this._markerGroup.removeLayer(i._middleLeft),i._middleRight&&this._markerGroup.removeLayer(i._middleRight),i._prev&&i._next?this._createMiddleMarker(i._prev,i._next):i._prev?i._next||(i._prev._middleRight=null):i._next._middleLeft=null,this._fireEdit())},_onContextMenu:function(t){var e=t.target;this._poly;this._poly._map.fire(L.Draw.Event.MARKERCONTEXT,{marker:e,layers:this._markerGroup,poly:this._poly}),L.DomEvent.stopPropagation},_onTouchMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]),i=this._map.layerPointToLatLng(e),o=t.target;L.extend(o._origLatLng,i),o._middleLeft&&o._middleLeft.setLatLng(this._getMiddleLatLng(o._prev,o)),o._middleRight&&o._middleRight.setLatLng(this._getMiddleLatLng(o,o._next)),this._poly.redraw(),this.updateMarkers()},_updateIndexes:function(t,e){this._markerGroup.eachLayer(function(i){i._index>t&&(i._index+=e)})},_createMiddleMarker:function(t,e){var i,o,n,a=this._getMiddleLatLng(t,e),s=this._createMarker(a);s.setOpacity(.6),t._middleRight=e._middleLeft=s,o=function(){s.off("touchmove",o,this);var n=e._index;s._index=n,s.off("click",i,this).on("click",this._onMarkerClick,this),a.lat=s.getLatLng().lat,a.lng=s.getLatLng().lng,this._spliceLatLngs(n,0,a),this._markers.splice(n,0,s),s.setOpacity(1),this._updateIndexes(n,1),e._index++,this._updatePrevNext(t,s),this._updatePrevNext(s,e),this._poly.fire("editstart")},n=function(){s.off("dragstart",o,this),s.off("dragend",n,this),s.off("touchmove",o,this),this._createMiddleMarker(t,s),this._createMiddleMarker(s,e)},i=function(){o.call(this),n.call(this),this._fireEdit()},s.on("click",i,this).on("dragstart",o,this).on("dragend",n,this).on("touchmove",o,this),this._markerGroup.addLayer(s)},_updatePrevNext:function(t,e){t&&(t._next=e),e&&(e._prev=t)},_getMiddleLatLng:function(t,e){var i=this._poly._map,o=i.project(t.getLatLng()),n=i.project(e.getLatLng());return i.unproject(o._add(n)._divideBy(2))}}),L.Polyline.addInitHook(function(){this.editing||(L.Edit.Poly&&(this.editing=new L.Edit.Poly(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()}))}),L.Edit=L.Edit||{},L.Edit.SimpleShape=L.Handler.extend({options:{moveIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move"}),resizeIcon:new L.DivIcon({iconSize:new L.Point(8,8),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize"}),touchMoveIcon:new L.DivIcon({
	iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-move leaflet-touch-icon"}),touchResizeIcon:new L.DivIcon({iconSize:new L.Point(20,20),className:"leaflet-div-icon leaflet-editing-icon leaflet-edit-resize leaflet-touch-icon"})},initialize:function(t,e){L.Browser.touch&&(this.options.moveIcon=this.options.touchMoveIcon,this.options.resizeIcon=this.options.touchResizeIcon),this._shape=t,L.Util.setOptions(this,e)},addHooks:function(){var t=this._shape;this._shape._map&&(this._map=this._shape._map,t.setStyle(t.options.editing),t._map&&(this._map=t._map,this._markerGroup||this._initMarkers(),this._map.addLayer(this._markerGroup)))},removeHooks:function(){var t=this._shape;if(t.setStyle(t.options.original),t._map){this._unbindMarker(this._moveMarker);for(var e=0,i=this._resizeMarkers.length;e<i;e++)this._unbindMarker(this._resizeMarkers[e]);this._resizeMarkers=null,this._map.removeLayer(this._markerGroup),delete this._markerGroup}this._map=null},updateMarkers:function(){this._markerGroup.clearLayers(),this._initMarkers()},_initMarkers:function(){this._markerGroup||(this._markerGroup=new L.LayerGroup),this._createMoveMarker(),this._createResizeMarker()},_createMoveMarker:function(){},_createResizeMarker:function(){},_createMarker:function(t,e){var i=new L.Marker.Touch(t,{draggable:!0,icon:e,zIndexOffset:10});return this._bindMarker(i),this._markerGroup.addLayer(i),i},_bindMarker:function(t){t.on("dragstart",this._onMarkerDragStart,this).on("drag",this._onMarkerDrag,this).on("dragend",this._onMarkerDragEnd,this).on("touchstart",this._onTouchStart,this).on("touchmove",this._onTouchMove,this).on("MSPointerMove",this._onTouchMove,this).on("touchend",this._onTouchEnd,this).on("MSPointerUp",this._onTouchEnd,this)},_unbindMarker:function(t){t.off("dragstart",this._onMarkerDragStart,this).off("drag",this._onMarkerDrag,this).off("dragend",this._onMarkerDragEnd,this).off("touchstart",this._onTouchStart,this).off("touchmove",this._onTouchMove,this).off("MSPointerMove",this._onTouchMove,this).off("touchend",this._onTouchEnd,this).off("MSPointerUp",this._onTouchEnd,this)},_onMarkerDragStart:function(t){t.target.setOpacity(0),this._shape.fire("editstart")},_fireEdit:function(){this._shape.edited=!0,this._shape.fire("edit")},_onMarkerDrag:function(t){var e=t.target,i=e.getLatLng();e===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw(),this._shape.fire("editdrag")},_onMarkerDragEnd:function(t){t.target.setOpacity(1),this._fireEdit()},_onTouchStart:function(t){if(L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t),"function"==typeof this._getCorners){var e=this._getCorners(),i=t.target,o=i._cornerIndex;i.setOpacity(0),this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o)}this._shape.fire("editstart")},_onTouchMove:function(t){var e=this._map.mouseEventToLayerPoint(t.originalEvent.touches[0]),i=this._map.layerPointToLatLng(e);return t.target===this._moveMarker?this._move(i):this._resize(i),this._shape.redraw(),!1},_onTouchEnd:function(t){t.target.setOpacity(1),this.updateMarkers(),this._fireEdit()},_move:function(){},_resize:function(){}}),L.Edit=L.Edit||{},L.Edit.Rectangle=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getBounds(),e=t.getCenter();this._moveMarker=this._createMarker(e,this.options.moveIcon)},_createResizeMarker:function(){var t=this._getCorners();this._resizeMarkers=[];for(var e=0,i=t.length;e<i;e++)this._resizeMarkers.push(this._createMarker(t[e],this.options.resizeIcon)),this._resizeMarkers[e]._cornerIndex=e},_onMarkerDragStart:function(t){L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this,t);var e=this._getCorners(),i=t.target,o=i._cornerIndex;this._oppositeCorner=e[(o+2)%4],this._toggleCornerMarkers(0,o)},_onMarkerDragEnd:function(t){var e,i,o=t.target;o===this._moveMarker&&(e=this._shape.getBounds(),i=e.getCenter(),o.setLatLng(i)),this._toggleCornerMarkers(1),this._repositionCornerMarkers(),L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this,t)},_move:function(t){for(var e,i=this._shape._defaultShape?this._shape._defaultShape():this._shape.getLatLngs(),o=this._shape.getBounds(),n=o.getCenter(),a=[],s=0,r=i.length;s<r;s++)e=[i[s].lat-n.lat,i[s].lng-n.lng],a.push([t.lat+e[0],t.lng+e[1]]);this._shape.setLatLngs(a),this._repositionCornerMarkers(),this._map.fire(L.Draw.Event.EDITMOVE,{layer:this._shape})},_resize:function(t){var e;this._shape.setBounds(L.latLngBounds(t,this._oppositeCorner)),e=this._shape.getBounds(),this._moveMarker.setLatLng(e.getCenter()),this._map.fire(L.Draw.Event.EDITRESIZE,{layer:this._shape})},_getCorners:function(){var t=this._shape.getBounds();return[t.getNorthWest(),t.getNorthEast(),t.getSouthEast(),t.getSouthWest()]},_toggleCornerMarkers:function(t){for(var e=0,i=this._resizeMarkers.length;e<i;e++)this._resizeMarkers[e].setOpacity(t)},_repositionCornerMarkers:function(){for(var t=this._getCorners(),e=0,i=this._resizeMarkers.length;e<i;e++)this._resizeMarkers[e].setLatLng(t[e])}}),L.Rectangle.addInitHook(function(){L.Edit.Rectangle&&(this.editing=new L.Edit.Rectangle(this),this.options.editable&&this.editing.enable())}),L.Edit=L.Edit||{},L.Edit.CircleMarker=L.Edit.SimpleShape.extend({_createMoveMarker:function(){var t=this._shape.getLatLng();this._moveMarker=this._createMarker(t,this.options.moveIcon)},_createResizeMarker:function(){this._resizeMarkers=[]},_move:function(t){if(this._resizeMarkers.length){var e=this._getResizeMarkerPoint(t);this._resizeMarkers[0].setLatLng(e)}this._shape.setLatLng(t),this._map.fire(L.Draw.Event.EDITMOVE,{layer:this._shape})}}),L.CircleMarker.addInitHook(function(){L.Edit.CircleMarker&&(this.editing=new L.Edit.CircleMarker(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()})}),L.Edit=L.Edit||{},L.Edit.Circle=L.Edit.CircleMarker.extend({_createResizeMarker:function(){var t=this._shape.getLatLng(),e=this._getResizeMarkerPoint(t);this._resizeMarkers=[],this._resizeMarkers.push(this._createMarker(e,this.options.resizeIcon))},_getResizeMarkerPoint:function(t){var e=this._shape._radius*Math.cos(Math.PI/4),i=this._map.project(t);return this._map.unproject([i.x+e,i.y-e])},_resize:function(t){var e=this._moveMarker.getLatLng();L.GeometryUtil.isVersion07x()?radius=e.distanceTo(t):radius=this._map.distance(e,t),this._shape.setRadius(radius),this._map._editTooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.subtext+"<br />"+L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.draw.handlers.circle.radius+": "+L.GeometryUtil.readableDistance(radius,!0,this.options.feet,this.options.nautic)}),this._shape.setRadius(radius),this._map.fire(L.Draw.Event.EDITRESIZE,{layer:this._shape})}}),L.Circle.addInitHook(function(){L.Edit.Circle&&(this.editing=new L.Edit.Circle(this),this.options.editable&&this.editing.enable()),this.on("add",function(){this.editing&&this.editing.enabled()&&this.editing.addHooks()}),this.on("remove",function(){this.editing&&this.editing.enabled()&&this.editing.removeHooks()})}),L.Map.mergeOptions({touchExtend:!0}),L.Map.TouchExtend=L.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane},addHooks:function(){L.DomEvent.on(this._container,"touchstart",this._onTouchStart,this),L.DomEvent.on(this._container,"touchend",this._onTouchEnd,this),L.DomEvent.on(this._container,"touchmove",this._onTouchMove,this),this._detectIE()?(L.DomEvent.on(this._container,"MSPointerDown",this._onTouchStart,this),L.DomEvent.on(this._container,"MSPointerUp",this._onTouchEnd,this),L.DomEvent.on(this._container,"MSPointerMove",this._onTouchMove,this),L.DomEvent.on(this._container,"MSPointerCancel",this._onTouchCancel,this)):(L.DomEvent.on(this._container,"touchcancel",this._onTouchCancel,this),L.DomEvent.on(this._container,"touchleave",this._onTouchLeave,this))},removeHooks:function(){L.DomEvent.off(this._container,"touchstart",this._onTouchStart),L.DomEvent.off(this._container,"touchend",this._onTouchEnd),L.DomEvent.off(this._container,"touchmove",this._onTouchMove),this._detectIE()?(L.DomEvent.off(this._container,"MSPointerDowm",this._onTouchStart),L.DomEvent.off(this._container,"MSPointerUp",this._onTouchEnd),L.DomEvent.off(this._container,"MSPointerMove",this._onTouchMove),L.DomEvent.off(this._container,"MSPointerCancel",this._onTouchCancel)):(L.DomEvent.off(this._container,"touchcancel",this._onTouchCancel),L.DomEvent.off(this._container,"touchleave",this._onTouchLeave))},_touchEvent:function(t,e){var i={};if(void 0!==t.touches){if(!t.touches.length)return;i=t.touches[0]}else{if("touch"!==t.pointerType)return;if(i=t,!this._filterClick(t))return}var o=this._map.mouseEventToContainerPoint(i),n=this._map.mouseEventToLayerPoint(i),a=this._map.layerPointToLatLng(n);this._map.fire(e,{latlng:a,layerPoint:n,containerPoint:o,pageX:i.pageX,pageY:i.pageY,originalEvent:t})},_filterClick:function(t){var e=t.timeStamp||t.originalEvent.timeStamp,i=L.DomEvent._lastClick&&e-L.DomEvent._lastClick;return i&&i>100&&i<500||t.target._simulatedClick&&!t._simulated?(L.DomEvent.stop(t),!1):(L.DomEvent._lastClick=e,!0)},_onTouchStart:function(t){if(this._map._loaded){this._touchEvent(t,"touchstart")}},_onTouchEnd:function(t){if(this._map._loaded){this._touchEvent(t,"touchend")}},_onTouchCancel:function(t){if(this._map._loaded){var e="touchcancel";this._detectIE()&&(e="pointercancel"),this._touchEvent(t,e)}},_onTouchLeave:function(t){if(this._map._loaded){this._touchEvent(t,"touchleave")}},_onTouchMove:function(t){if(this._map._loaded){this._touchEvent(t,"touchmove")}},_detectIE:function(){var e=t.navigator.userAgent,i=e.indexOf("MSIE ");if(i>0)return parseInt(e.substring(i+5,e.indexOf(".",i)),10);if(e.indexOf("Trident/")>0){var o=e.indexOf("rv:");return parseInt(e.substring(o+3,e.indexOf(".",o)),10)}var n=e.indexOf("Edge/");return n>0&&parseInt(e.substring(n+5,e.indexOf(".",n)),10)}}),L.Map.addInitHook("addHandler","touchExtend",L.Map.TouchExtend),L.Marker.Touch=L.Marker.extend({_initInteraction:function(){return this.addInteractiveTarget?L.Marker.prototype._initInteraction.apply(this):this._initInteractionLegacy()},_initInteractionLegacy:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu","touchstart","touchend","touchmove"];this._detectIE?e.concat(["MSPointerDown","MSPointerUp","MSPointerMove","MSPointerCancel"]):e.concat(["touchcancel"]),L.DomUtil.addClass(t,"leaflet-clickable"),L.DomEvent.on(t,"click",this._onMouseClick,this),L.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)L.DomEvent.on(t,e[i],this._fireMouseEvent,this);L.Handler.MarkerDrag&&(this.dragging=new L.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_detectIE:function(){var e=t.navigator.userAgent,i=e.indexOf("MSIE ");if(i>0)return parseInt(e.substring(i+5,e.indexOf(".",i)),10);if(e.indexOf("Trident/")>0){var o=e.indexOf("rv:");return parseInt(e.substring(o+3,e.indexOf(".",o)),10)}var n=e.indexOf("Edge/");return n>0&&parseInt(e.substring(n+5,e.indexOf(".",n)),10)}}),L.LatLngUtil={cloneLatLngs:function(t){for(var e=[],i=0,o=t.length;i<o;i++)Array.isArray(t[i])?e.push(L.LatLngUtil.cloneLatLngs(t[i])):e.push(this.cloneLatLng(t[i]));return e},cloneLatLng:function(t){return L.latLng(t.lat,t.lng)}},function(){var t={km:2,ha:2,m:0,mi:2,ac:2,yd:0,ft:0,nm:2};L.GeometryUtil=L.extend(L.GeometryUtil||{},{geodesicArea:function(t){var e,i,o=t.length,n=0,a=Math.PI/180;if(o>2){for(var s=0;s<o;s++)e=t[s],i=t[(s+1)%o],n+=(i.lng-e.lng)*a*(2+Math.sin(e.lat*a)+Math.sin(i.lat*a));n=6378137*n*6378137/2}return Math.abs(n)},formattedNumber:function(t,e){var i=parseFloat(t).toFixed(e),o=L.drawLocal.format&&L.drawLocal.format.numeric,n=o&&o.delimiters,a=n&&n.thousands,s=n&&n.decimal;if(a||s){var r=i.split(".");i=a?r[0].replace(/(\d)(?=(\d{3})+(?!\d))/g,"$1"+a):r[0],s=s||".",r.length>1&&(i=i+s+r[1])}return i},readableArea:function(e,i,o){var n,a,o=L.Util.extend({},t,o);return i?(a=["ha","m"],type=typeof i,"string"===type?a=[i]:"boolean"!==type&&(a=i),n=e>=1e6&&-1!==a.indexOf("km")?L.GeometryUtil.formattedNumber(1e-6*e,o.km)+" km²":e>=1e4&&-1!==a.indexOf("ha")?L.GeometryUtil.formattedNumber(1e-4*e,o.ha)+" ha":L.GeometryUtil.formattedNumber(e,o.m)+" m²"):(e/=.836127,n=e>=3097600?L.GeometryUtil.formattedNumber(e/3097600,o.mi)+" mi²":e>=4840?L.GeometryUtil.formattedNumber(e/4840,o.ac)+" acres":L.GeometryUtil.formattedNumber(e,o.yd)+" yd²"),n},readableDistance:function(e,i,o,n,a){var s,a=L.Util.extend({},t,a);switch(i?"string"==typeof i?i:"metric":o?"feet":n?"nauticalMile":"yards"){case"metric":s=e>1e3?L.GeometryUtil.formattedNumber(e/1e3,a.km)+" km":L.GeometryUtil.formattedNumber(e,a.m)+" m";break;case"feet":e*=3.28083,s=L.GeometryUtil.formattedNumber(e,a.ft)+" ft";break;case"nauticalMile":e*=.53996,s=L.GeometryUtil.formattedNumber(e/1e3,a.nm)+" nm";break;case"yards":default:e*=1.09361,s=e>1760?L.GeometryUtil.formattedNumber(e/1760,a.mi)+" miles":L.GeometryUtil.formattedNumber(e,a.yd)+" yd"}return s},isVersion07x:function(){var t=L.version.split(".");return 0===parseInt(t[0],10)&&7===parseInt(t[1],10)}})}(),L.Util.extend(L.LineUtil,{segmentsIntersect:function(t,e,i,o){return this._checkCounterclockwise(t,i,o)!==this._checkCounterclockwise(e,i,o)&&this._checkCounterclockwise(t,e,i)!==this._checkCounterclockwise(t,e,o)},_checkCounterclockwise:function(t,e,i){return(i.y-t.y)*(e.x-t.x)>(e.y-t.y)*(i.x-t.x)}}),L.Polyline.include({intersects:function(){var t,e,i,o=this._getProjectedPoints(),n=o?o.length:0;if(this._tooFewPointsForIntersection())return!1;for(t=n-1;t>=3;t--)if(e=o[t-1],i=o[t],this._lineSegmentsIntersectsRange(e,i,t-2))return!0;return!1},newLatLngIntersects:function(t,e){return!!this._map&&this.newPointIntersects(this._map.latLngToLayerPoint(t),e)},newPointIntersects:function(t,e){var i=this._getProjectedPoints(),o=i?i.length:0,n=i?i[o-1]:null,a=o-2;return!this._tooFewPointsForIntersection(1)&&this._lineSegmentsIntersectsRange(n,t,a,e?1:0)},_tooFewPointsForIntersection:function(t){var e=this._getProjectedPoints(),i=e?e.length:0;return i+=t||0,!e||i<=3},_lineSegmentsIntersectsRange:function(t,e,i,o){var n,a,s=this._getProjectedPoints();o=o||0;for(var r=i;r>o;r--)if(n=s[r-1],a=s[r],L.LineUtil.segmentsIntersect(t,e,n,a))return!0;return!1},_getProjectedPoints:function(){if(!this._defaultShape)return this._originalPoints;for(var t=[],e=this._defaultShape(),i=0;i<e.length;i++)t.push(this._map.latLngToLayerPoint(e[i]));return t}}),L.Polygon.include({intersects:function(){var t,e,i,o,n=this._getProjectedPoints();return!this._tooFewPointsForIntersection()&&(!!L.Polyline.prototype.intersects.call(this)||(t=n.length,e=n[0],i=n[t-1],o=t-2,this._lineSegmentsIntersectsRange(i,e,o,1)))}}),L.Control.Draw=L.Control.extend({options:{position:"topleft",draw:{},edit:!1},initialize:function(t){if(L.version<"0.7")throw new Error("Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/");L.Control.prototype.initialize.call(this,t);var e;this._toolbars={},L.DrawToolbar&&this.options.draw&&(e=new L.DrawToolbar(this.options.draw),this._toolbars[L.DrawToolbar.TYPE]=e,this._toolbars[L.DrawToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.EditToolbar&&this.options.edit&&(e=new L.EditToolbar(this.options.edit),this._toolbars[L.EditToolbar.TYPE]=e,this._toolbars[L.EditToolbar.TYPE].on("enable",this._toolbarEnabled,this)),L.toolbar=this},onAdd:function(t){var e,i=L.DomUtil.create("div","leaflet-draw"),o=!1;for(var n in this._toolbars)this._toolbars.hasOwnProperty(n)&&(e=this._toolbars[n].addToolbar(t))&&(o||(L.DomUtil.hasClass(e,"leaflet-draw-toolbar-top")||L.DomUtil.addClass(e.childNodes[0],"leaflet-draw-toolbar-top"),o=!0),i.appendChild(e));return i},onRemove:function(){for(var t in this._toolbars)this._toolbars.hasOwnProperty(t)&&this._toolbars[t].removeToolbar()},setDrawingOptions:function(t){for(var e in this._toolbars)this._toolbars[e]instanceof L.DrawToolbar&&this._toolbars[e].setOptions(t)},_toolbarEnabled:function(t){var e=t.target;for(var i in this._toolbars)this._toolbars[i]!==e&&this._toolbars[i].disable()}}),L.Map.mergeOptions({drawControlTooltips:!0,drawControl:!1}),L.Map.addInitHook(function(){this.options.drawControl&&(this.drawControl=new L.Control.Draw,this.addControl(this.drawControl))}),L.Toolbar=L.Class.extend({initialize:function(t){L.setOptions(this,t),this._modes={},this._actionButtons=[],this._activeMode=null;var e=L.version.split(".");1===parseInt(e[0],10)&&parseInt(e[1],10)>=2?L.Toolbar.include(L.Evented.prototype):L.Toolbar.include(L.Mixin.Events)},enabled:function(){return null!==this._activeMode},disable:function(){this.enabled()&&this._activeMode.handler.disable()},addToolbar:function(t){var e,i=L.DomUtil.create("div","leaflet-draw-section"),o=0,n=this._toolbarClass||"",a=this.getModeHandlers(t);for(this._toolbarContainer=L.DomUtil.create("div","leaflet-draw-toolbar leaflet-bar"),this._map=t,e=0;e<a.length;e++)a[e].enabled&&this._initModeHandler(a[e].handler,this._toolbarContainer,o++,n,a[e].title);if(o)return this._lastButtonIndex=--o,this._actionsContainer=L.DomUtil.create("ul","leaflet-draw-actions"),i.appendChild(this._toolbarContainer),i.appendChild(this._actionsContainer),i},removeToolbar:function(){for(var t in this._modes)this._modes.hasOwnProperty(t)&&(this._disposeButton(this._modes[t].button,this._modes[t].handler.enable,this._modes[t].handler),this._modes[t].handler.disable(),this._modes[t].handler.off("enabled",this._handlerActivated,this).off("disabled",this._handlerDeactivated,this));this._modes={};for(var e=0,i=this._actionButtons.length;e<i;e++)this._disposeButton(this._actionButtons[e].button,this._actionButtons[e].callback,this);this._actionButtons=[],this._actionsContainer=null},_initModeHandler:function(t,e,i,o,n){var a=t.type;this._modes[a]={},this._modes[a].handler=t,this._modes[a].button=this._createButton({type:a,title:n,className:o+"-"+a,container:e,callback:this._modes[a].handler.enable,context:this._modes[a].handler}),this._modes[a].buttonIndex=i,this._modes[a].handler.on("enabled",this._handlerActivated,this).on("disabled",this._handlerDeactivated,this)},_detectIOS:function(){return/iPad|iPhone|iPod/.test(navigator.userAgent)&&!t.MSStream},_createButton:function(t){var e=L.DomUtil.create("a",t.className||"",t.container),i=L.DomUtil.create("span","sr-only",t.container);e.href="#",e.appendChild(i),t.title&&(e.title=t.title,i.innerHTML=t.title),t.text&&(e.innerHTML=t.text,i.innerHTML=t.text);var o=this._detectIOS()?"touchstart":"click";return L.DomEvent.on(e,"click",L.DomEvent.stopPropagation).on(e,"mousedown",L.DomEvent.stopPropagation).on(e,"dblclick",L.DomEvent.stopPropagation).on(e,"touchstart",L.DomEvent.stopPropagation).on(e,"click",L.DomEvent.preventDefault).on(e,o,t.callback,t.context),e},_disposeButton:function(t,e){var i=this._detectIOS()?"touchstart":"click";L.DomEvent.off(t,"click",L.DomEvent.stopPropagation).off(t,"mousedown",L.DomEvent.stopPropagation).off(t,"dblclick",L.DomEvent.stopPropagation).off(t,"touchstart",L.DomEvent.stopPropagation).off(t,"click",L.DomEvent.preventDefault).off(t,i,e)},_handlerActivated:function(t){this.disable(),this._activeMode=this._modes[t.handler],L.DomUtil.addClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._showActionsToolbar(),this.fire("enable")},_handlerDeactivated:function(){this._hideActionsToolbar(),L.DomUtil.removeClass(this._activeMode.button,"leaflet-draw-toolbar-button-enabled"),this._activeMode=null,this.fire("disable")},_createActions:function(t){var e,i,o,n,a=this._actionsContainer,s=this.getActions(t),r=s.length;for(i=0,o=this._actionButtons.length;i<o;i++)this._disposeButton(this._actionButtons[i].button,this._actionButtons[i].callback);for(this._actionButtons=[];a.firstChild;)a.removeChild(a.firstChild);for(var l=0;l<r;l++)"enabled"in s[l]&&!s[l].enabled||(e=L.DomUtil.create("li","",a),n=this._createButton({title:s[l].title,text:s[l].text,container:e,callback:s[l].callback,context:s[l].context}),this._actionButtons.push({button:n,callback:s[l].callback}))},_showActionsToolbar:function(){var t=this._activeMode.buttonIndex,e=this._lastButtonIndex,i=this._activeMode.button.offsetTop-1;this._createActions(this._activeMode.handler),this._actionsContainer.style.top=i+"px",0===t&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-top")),t===e&&(L.DomUtil.addClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.addClass(this._actionsContainer,"leaflet-draw-actions-bottom")),this._actionsContainer.style.display="block",this._map.fire(L.Draw.Event.TOOLBAROPENED)},_hideActionsToolbar:function(){this._actionsContainer.style.display="none",L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-notop"),L.DomUtil.removeClass(this._toolbarContainer,"leaflet-draw-toolbar-nobottom"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-top"),L.DomUtil.removeClass(this._actionsContainer,"leaflet-draw-actions-bottom"),this._map.fire(L.Draw.Event.TOOLBARCLOSED)}}),L.Draw=L.Draw||{},L.Draw.Tooltip=L.Class.extend({initialize:function(t){this._map=t,this._popupPane=t._panes.popupPane,this._visible=!1,this._container=t.options.drawControlTooltips?L.DomUtil.create("div","leaflet-draw-tooltip",this._popupPane):null,this._singleLineLabel=!1,this._map.on("mouseout",this._onMouseOut,this)},dispose:function(){this._map.off("mouseout",this._onMouseOut,this),this._container&&(this._popupPane.removeChild(this._container),this._container=null)},updateContent:function(t){return this._container?(t.subtext=t.subtext||"",0!==t.subtext.length||this._singleLineLabel?t.subtext.length>0&&this._singleLineLabel&&(L.DomUtil.removeClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!1):(L.DomUtil.addClass(this._container,"leaflet-draw-tooltip-single"),this._singleLineLabel=!0),this._container.innerHTML=(t.subtext.length>0?'<span class="leaflet-draw-tooltip-subtext">'+t.subtext+"</span><br />":"")+"<span>"+t.text+"</span>",t.text||t.subtext?(this._visible=!0,this._container.style.visibility="inherit"):(this._visible=!1,this._container.style.visibility="hidden"),this):this},updatePosition:function(t){var e=this._map.latLngToLayerPoint(t),i=this._container;return this._container&&(this._visible&&(i.style.visibility="inherit"),L.DomUtil.setPosition(i,e)),this},showAsError:function(){return this._container&&L.DomUtil.addClass(this._container,"leaflet-error-draw-tooltip"),this},removeError:function(){return this._container&&L.DomUtil.removeClass(this._container,"leaflet-error-draw-tooltip"),this},_onMouseOut:function(){this._container&&(this._container.style.visibility="hidden")}}),L.DrawToolbar=L.Toolbar.extend({statics:{TYPE:"draw"},options:{polyline:{},polygon:{},rectangle:{},circle:{},marker:{},circlemarker:{}},initialize:function(t){for(var e in this.options)this.options.hasOwnProperty(e)&&t[e]&&(t[e]=L.extend({},this.options[e],t[e]));this._toolbarClass="leaflet-draw-draw",L.Toolbar.prototype.initialize.call(this,t)},getModeHandlers:function(t){return[{enabled:this.options.polyline,handler:new L.Draw.Polyline(t,this.options.polyline),title:L.drawLocal.draw.toolbar.buttons.polyline},{enabled:this.options.polygon,handler:new L.Draw.Polygon(t,this.options.polygon),title:L.drawLocal.draw.toolbar.buttons.polygon},{enabled:this.options.rectangle,handler:new L.Draw.Rectangle(t,this.options.rectangle),title:L.drawLocal.draw.toolbar.buttons.rectangle},{enabled:this.options.circle,handler:new L.Draw.Circle(t,this.options.circle),title:L.drawLocal.draw.toolbar.buttons.circle},{enabled:this.options.marker,handler:new L.Draw.Marker(t,this.options.marker),title:L.drawLocal.draw.toolbar.buttons.marker},{enabled:this.options.circlemarker,handler:new L.Draw.CircleMarker(t,this.options.circlemarker),title:L.drawLocal.draw.toolbar.buttons.circlemarker}]},getActions:function(t){return[{enabled:t.completeShape,title:L.drawLocal.draw.toolbar.finish.title,text:L.drawLocal.draw.toolbar.finish.text,callback:t.completeShape,context:t},{enabled:t.deleteLastVertex,title:L.drawLocal.draw.toolbar.undo.title,text:L.drawLocal.draw.toolbar.undo.text,callback:t.deleteLastVertex,context:t},{title:L.drawLocal.draw.toolbar.actions.title,text:L.drawLocal.draw.toolbar.actions.text,callback:this.disable,context:this}]},setOptions:function(t){L.setOptions(this,t);for(var e in this._modes)this._modes.hasOwnProperty(e)&&t.hasOwnProperty(e)&&this._modes[e].handler.setOptions(t[e])}}),L.EditToolbar=L.Toolbar.extend({statics:{TYPE:"edit"},options:{edit:{selectedPathOptions:{dashArray:"10, 10",fill:!0,fillColor:"#fe57a1",fillOpacity:.1,maintainColor:!1}},remove:{},poly:null,featureGroup:null},initialize:function(t){t.edit&&(void 0===t.edit.selectedPathOptions&&(t.edit.selectedPathOptions=this.options.edit.selectedPathOptions),t.edit.selectedPathOptions=L.extend({},this.options.edit.selectedPathOptions,t.edit.selectedPathOptions)),t.remove&&(t.remove=L.extend({},this.options.remove,t.remove)),t.poly&&(t.poly=L.extend({},this.options.poly,t.poly)),this._toolbarClass="leaflet-draw-edit",L.Toolbar.prototype.initialize.call(this,t),this._selectedFeatureCount=0},getModeHandlers:function(t){var e=this.options.featureGroup;return[{enabled:this.options.edit,handler:new L.EditToolbar.Edit(t,{featureGroup:e,selectedPathOptions:this.options.edit.selectedPathOptions,poly:this.options.poly}),title:L.drawLocal.edit.toolbar.buttons.edit},{enabled:this.options.remove,handler:new L.EditToolbar.Delete(t,{featureGroup:e}),title:L.drawLocal.edit.toolbar.buttons.remove}]},getActions:function(t){var e=[{title:L.drawLocal.edit.toolbar.actions.save.title,text:L.drawLocal.edit.toolbar.actions.save.text,callback:this._save,context:this},{title:L.drawLocal.edit.toolbar.actions.cancel.title,text:L.drawLocal.edit.toolbar.actions.cancel.text,callback:this.disable,context:this}];return t.removeAllLayers&&e.push({title:L.drawLocal.edit.toolbar.actions.clearAll.title,text:L.drawLocal.edit.toolbar.actions.clearAll.text,callback:this._clearAllLayers,context:this}),e},addToolbar:function(t){var e=L.Toolbar.prototype.addToolbar.call(this,t);return this._checkDisabled(),this.options.featureGroup.on("layeradd layerremove",this._checkDisabled,this),e},removeToolbar:function(){this.options.featureGroup.off("layeradd layerremove",this._checkDisabled,this),L.Toolbar.prototype.removeToolbar.call(this)},disable:function(){this.enabled()&&(this._activeMode.handler.revertLayers(),L.Toolbar.prototype.disable.call(this))},_save:function(){this._activeMode.handler.save(),this._activeMode&&this._activeMode.handler.disable()},_clearAllLayers:function(){this._activeMode.handler.removeAllLayers(),this._activeMode&&this._activeMode.handler.disable()},_checkDisabled:function(){var t,e=this.options.featureGroup,i=0!==e.getLayers().length;this.options.edit&&(t=this._modes[L.EditToolbar.Edit.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.edit:L.drawLocal.edit.toolbar.buttons.editDisabled)),this.options.remove&&(t=this._modes[L.EditToolbar.Delete.TYPE].button,i?L.DomUtil.removeClass(t,"leaflet-disabled"):L.DomUtil.addClass(t,"leaflet-disabled"),t.setAttribute("title",i?L.drawLocal.edit.toolbar.buttons.remove:L.drawLocal.edit.toolbar.buttons.removeDisabled))}}),L.EditToolbar.Edit=L.Handler.extend({statics:{TYPE:"edit"},initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.setOptions(this,e),this._featureGroup=e.featureGroup,!(this._featureGroup instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this._uneditedLayerProps={},this.type=L.EditToolbar.Edit.TYPE;var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.EditToolbar.Edit.include(L.Evented.prototype):L.EditToolbar.Edit.include(L.Mixin.Events)},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.EDITSTART,{handler:this.type}),L.Handler.prototype.enable.call(this),this._featureGroup.on("layeradd",this._enableLayerEdit,this).on("layerremove",this._disableLayerEdit,this))},disable:function(){this._enabled&&(this._featureGroup.off("layeradd",this._enableLayerEdit,this).off("layerremove",this._disableLayerEdit,this),L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.EDITSTOP,{handler:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._featureGroup.eachLayer(this._enableLayerEdit,this),this._tooltip=new L.Draw.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}),t._editTooltip=this._tooltip,this._updateTooltip(),this._map.on("mousemove",this._onMouseMove,this).on("touchmove",this._onMouseMove,this).on("MSPointerMove",this._onMouseMove,this).on(L.Draw.Event.EDITVERTEX,this._updateTooltip,this))},removeHooks:function(){this._map&&(this._featureGroup.eachLayer(this._disableLayerEdit,this),this._uneditedLayerProps={},this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this).off("touchmove",this._onMouseMove,this).off("MSPointerMove",this._onMouseMove,this).off(L.Draw.Event.EDITVERTEX,this._updateTooltip,this))},revertLayers:function(){this._featureGroup.eachLayer(function(t){this._revertLayer(t)},this)},save:function(){var t=new L.LayerGroup;this._featureGroup.eachLayer(function(e){e.edited&&(t.addLayer(e),e.edited=!1)}),this._map.fire(L.Draw.Event.EDITED,{layers:t})},_backupLayer:function(t){var e=L.Util.stamp(t);this._uneditedLayerProps[e]||(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?this._uneditedLayerProps[e]={latlngs:L.LatLngUtil.cloneLatLngs(t.getLatLngs())}:t instanceof L.Circle?this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng()),radius:t.getRadius()}:(t instanceof L.Marker||t instanceof L.CircleMarker)&&(this._uneditedLayerProps[e]={latlng:L.LatLngUtil.cloneLatLng(t.getLatLng())}))},_getTooltipText:function(){return{text:L.drawLocal.edit.handlers.edit.tooltip.text,subtext:L.drawLocal.edit.handlers.edit.tooltip.subtext}},_updateTooltip:function(){this._tooltip.updateContent(this._getTooltipText())},_revertLayer:function(t){var e=L.Util.stamp(t);t.edited=!1,this._uneditedLayerProps.hasOwnProperty(e)&&(t instanceof L.Polyline||t instanceof L.Polygon||t instanceof L.Rectangle?t.setLatLngs(this._uneditedLayerProps[e].latlngs):t instanceof L.Circle?(t.setLatLng(this._uneditedLayerProps[e].latlng),t.setRadius(this._uneditedLayerProps[e].radius)):(t instanceof L.Marker||t instanceof L.CircleMarker)&&t.setLatLng(this._uneditedLayerProps[e].latlng),t.fire("revert-edited",{layer:t}))},_enableLayerEdit:function(t){var e,i,o=t.layer||t.target||t;this._backupLayer(o),this.options.poly&&(i=L.Util.extend({},this.options.poly),o.options.poly=i),this.options.selectedPathOptions&&(e=L.Util.extend({},this.options.selectedPathOptions),e.maintainColor&&(e.color=o.options.color,e.fillColor=o.options.fillColor),o.options.original=L.extend({},o.options),o.options.editing=e),o instanceof L.Marker?(o.editing&&o.editing.enable(),o.dragging.enable(),o.on("dragend",this._onMarkerDragEnd).on("touchmove",this._onTouchMove,this).on("MSPointerMove",this._onTouchMove,this).on("touchend",this._onMarkerDragEnd,this).on("MSPointerUp",this._onMarkerDragEnd,this)):o.editing.enable()},_disableLayerEdit:function(t){var e=t.layer||t.target||t;e.edited=!1,e.editing&&e.editing.disable(),delete e.options.editing,delete e.options.original,
	this._selectedPathOptions&&(e instanceof L.Marker?this._toggleMarkerHighlight(e):(e.setStyle(e.options.previousOptions),delete e.options.previousOptions)),e instanceof L.Marker?(e.dragging.disable(),e.off("dragend",this._onMarkerDragEnd,this).off("touchmove",this._onTouchMove,this).off("MSPointerMove",this._onTouchMove,this).off("touchend",this._onMarkerDragEnd,this).off("MSPointerUp",this._onMarkerDragEnd,this)):e.editing.disable()},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng)},_onMarkerDragEnd:function(t){var e=t.target;e.edited=!0,this._map.fire(L.Draw.Event.EDITMOVE,{layer:e})},_onTouchMove:function(t){var e=t.originalEvent.changedTouches[0],i=this._map.mouseEventToLayerPoint(e),o=this._map.layerPointToLatLng(i);t.target.setLatLng(o)},_hasAvailableLayers:function(){return 0!==this._featureGroup.getLayers().length}}),L.EditToolbar.Delete=L.Handler.extend({statics:{TYPE:"remove"},initialize:function(t,e){if(L.Handler.prototype.initialize.call(this,t),L.Util.setOptions(this,e),this._deletableLayers=this.options.featureGroup,!(this._deletableLayers instanceof L.FeatureGroup))throw new Error("options.featureGroup must be a L.FeatureGroup");this.type=L.EditToolbar.Delete.TYPE;var i=L.version.split(".");1===parseInt(i[0],10)&&parseInt(i[1],10)>=2?L.EditToolbar.Delete.include(L.Evented.prototype):L.EditToolbar.Delete.include(L.Mixin.Events)},enable:function(){!this._enabled&&this._hasAvailableLayers()&&(this.fire("enabled",{handler:this.type}),this._map.fire(L.Draw.Event.DELETESTART,{handler:this.type}),L.Handler.prototype.enable.call(this),this._deletableLayers.on("layeradd",this._enableLayerDelete,this).on("layerremove",this._disableLayerDelete,this))},disable:function(){this._enabled&&(this._deletableLayers.off("layeradd",this._enableLayerDelete,this).off("layerremove",this._disableLayerDelete,this),L.Handler.prototype.disable.call(this),this._map.fire(L.Draw.Event.DELETESTOP,{handler:this.type}),this.fire("disabled",{handler:this.type}))},addHooks:function(){var t=this._map;t&&(t.getContainer().focus(),this._deletableLayers.eachLayer(this._enableLayerDelete,this),this._deletedLayers=new L.LayerGroup,this._tooltip=new L.Draw.Tooltip(this._map),this._tooltip.updateContent({text:L.drawLocal.edit.handlers.remove.tooltip.text}),this._map.on("mousemove",this._onMouseMove,this))},removeHooks:function(){this._map&&(this._deletableLayers.eachLayer(this._disableLayerDelete,this),this._deletedLayers=null,this._tooltip.dispose(),this._tooltip=null,this._map.off("mousemove",this._onMouseMove,this))},revertLayers:function(){this._deletedLayers.eachLayer(function(t){this._deletableLayers.addLayer(t),t.fire("revert-deleted",{layer:t})},this)},save:function(){this._map.fire(L.Draw.Event.DELETED,{layers:this._deletedLayers})},removeAllLayers:function(){this._deletableLayers.eachLayer(function(t){this._removeLayer({layer:t})},this),this.save()},_enableLayerDelete:function(t){(t.layer||t.target||t).on("click",this._removeLayer,this)},_disableLayerDelete:function(t){var e=t.layer||t.target||t;e.off("click",this._removeLayer,this),this._deletedLayers.removeLayer(e)},_removeLayer:function(t){var e=t.layer||t.target||t;this._deletableLayers.removeLayer(e),this._deletedLayers.addLayer(e),e.fire("deleted")},_onMouseMove:function(t){this._tooltip.updatePosition(t.latlng)},_hasAvailableLayers:function(){return 0!==this._deletableLayers.getLayers().length}})}(window,document);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	///// FIXME: Use path._rings instead of path._latlngs???
	///// FIXME: Panic if this._map doesn't exist when called.
	///// FIXME: Implement snakeOut()
	///// FIXME: Implement layerGroup.snakeIn() / Out()


	L.Polyline.include({

		// Hi-res timestamp indicating when the last calculations for vertices and
		// distance took place.
		_snakingTimestamp: 0,

		// How many rings and vertices we've already visited
		// Yeah, yeah, "rings" semantically only apply to polygons, but L.Polyline
		// internally uses that nomenclature.
		_snakingRings: 0,
		_snakingVertices: 0,

		// Distance to draw (in screen pixels) since the last vertex
		_snakingDistance: 0,

		// Flag
		_snaking: false,

		/// TODO: accept a 'map' parameter, fall back to addTo() in case
		/// performance.now is not available.
		snakeIn: function snakeIn() {

			if (this._snaking) {
				return;
			}

			if (!('performance' in window) || !('now' in window.performance) || !this._map) {
				return;
			}

			this._snaking = true;
			this._snakingTime = performance.now();
			this._snakingVertices = this._snakingRings = this._snakingDistance = 0;

			if (!this._snakeLatLngs) {
				this._snakeLatLngs = L.LineUtil._flat(this._latlngs) ? [this._latlngs] : this._latlngs;
			}

			// Init with just the first (0th) vertex in a new ring
			// Twice because the first thing that this._snake is is chop the head.
			this._latlngs = [[this._snakeLatLngs[0][0], this._snakeLatLngs[0][0]]];

			this._update();
			this._snake();
			this.fire('snakestart');
			return this;
		},

		_snake: function _snake() {

			var now = performance.now();
			var diff = now - this._snakingTime; // In milliseconds
			var forward = diff * this.options.snakingSpeed / 1000; // In pixels
			this._snakingTime = now;

			// Chop the head from the previous frame
			this._latlngs[this._snakingRings].pop();

			return this._snakeForward(forward);
		},

		_snakeForward: function _snakeForward(forward) {

			// Calculate distance from current vertex to next vertex
			var currPoint = this._map.latLngToContainerPoint(this._snakeLatLngs[this._snakingRings][this._snakingVertices]);
			var nextPoint = this._map.latLngToContainerPoint(this._snakeLatLngs[this._snakingRings][this._snakingVertices + 1]);

			var distance = currPoint.distanceTo(nextPoint);

			// 		console.log('Distance to next point:', distance, '; Now at: ', this._snakingDistance, '; Must travel forward:', forward);
			// 		console.log('Vertices: ', this._latlngs);

			if (this._snakingDistance + forward > distance) {
				// Jump to next vertex
				this._snakingVertices++;
				this._latlngs[this._snakingRings].push(this._snakeLatLngs[this._snakingRings][this._snakingVertices]);

				if (this._snakingVertices >= this._snakeLatLngs[this._snakingRings].length - 1) {
					if (this._snakingRings >= this._snakeLatLngs.length - 1) {
						return this._snakeEnd();
					} else {
						this._snakingVertices = 0;
						this._snakingRings++;
						this._latlngs[this._snakingRings] = [this._snakeLatLngs[this._snakingRings][this._snakingVertices]];
					}
				}

				this._snakingDistance -= distance;
				return this._snakeForward(forward);
			}

			this._snakingDistance += forward;

			var percent = this._snakingDistance / distance;

			var headPoint = nextPoint.multiplyBy(percent).add(currPoint.multiplyBy(1 - percent));

			// Put a new head in place.
			var headLatLng = this._map.containerPointToLatLng(headPoint);
			this._latlngs[this._snakingRings].push(headLatLng);

			this.setLatLngs(this._latlngs);
			this.fire('snake');
			L.Util.requestAnimFrame(this._snake, this);
		},

		_snakeEnd: function _snakeEnd() {

			this.setLatLngs(this._snakeLatLngs);
			this._snaking = false;
			this.fire('snakeend');
		}

	});

	L.Polyline.mergeOptions({
		snakingSpeed: 200 // In pixels/sec
	});

	L.LayerGroup.include({

		_snakingLayers: [],
		_snakingLayersDone: 0,

		snakeIn: function snakeIn() {

			if (!('performance' in window) || !('now' in window.performance) || !this._map || this._snaking) {
				return;
			}

			this._snaking = true;
			this._snakingLayers = [];
			this._snakingLayersDone = 0;
			var keys = Object.keys(this._layers);
			for (var i in keys) {
				var key = keys[i];
				this._snakingLayers.push(this._layers[key]);
			}
			this.clearLayers();

			this.fire('snakestart');
			return this._snakeNext();
		},

		_snakeNext: function _snakeNext() {

			if (this._snakingLayersDone >= this._snakingLayers.length) {
				this.fire('snakeend');
				this._snaking = false;
				return;
			}

			var currentLayer = this._snakingLayers[this._snakingLayersDone];

			this._snakingLayersDone++;

			this.addLayer(currentLayer);
			if ('snakeIn' in currentLayer) {
				currentLayer.once('snakeend', function () {
					setTimeout(this._snakeNext.bind(this), this.options.snakingPause);
				}, this);
				currentLayer.snakeIn();
			} else {
				setTimeout(this._snakeNext.bind(this), this.options.snakingPause);
			}

			this.fire('snake');
			return this;
		}

	});

	L.LayerGroup.mergeOptions({
		snakingPause: 200
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	L.interpolatePosition = function (p1, p2, duration, t) {
	    var k = t / duration;
	    k = k > 0 ? k : 0;
	    k = k > 1 ? 1 : k;
	    return L.latLng(p1.lat + k * (p2.lat - p1.lat), p1.lng + k * (p2.lng - p1.lng));
	};

	L.Marker.MovingMarker = L.Marker.extend({

	    //state constants
	    statics: {
	        notStartedState: 0,
	        endedState: 1,
	        pausedState: 2,
	        runState: 3
	    },

	    options: {
	        autostart: false,
	        loop: false
	    },

	    initialize: function initialize(latlngs, durations, options) {
	        L.Marker.prototype.initialize.call(this, latlngs[0], options);

	        this._latlngs = latlngs.map(function (e, index) {
	            return L.latLng(e);
	        });

	        if (durations instanceof Array) {
	            this._durations = durations;
	        } else {
	            this._durations = this._createDurations(this._latlngs, durations);
	        }

	        this._currentDuration = 0;
	        this._currentIndex = 0;

	        this._state = L.Marker.MovingMarker.notStartedState;
	        this._startTime = 0;
	        this._startTimeStamp = 0; // timestamp given by requestAnimFrame
	        this._pauseStartTime = 0;
	        this._animId = 0;
	        this._animRequested = false;
	        this._currentLine = [];
	        this._stations = {};
	        this.run_status = false;
	    },

	    isRunning: function isRunning() {
	        return this._state === L.Marker.MovingMarker.runState;
	    },

	    isEnded: function isEnded() {
	        return this._state === L.Marker.MovingMarker.endedState;
	    },

	    isStarted: function isStarted() {
	        return this._state !== L.Marker.MovingMarker.notStartedState;
	    },

	    isPaused: function isPaused() {
	        return this._state === L.Marker.MovingMarker.pausedState;
	    },
	    startPlay: function startPlay() {
	        this.run_status = true;
	        this.start();
	    },
	    start: function start() {
	        if (this.isRunning()) {
	            return;
	        }

	        if (this.isPaused()) {
	            this.resume();
	        } else {
	            this._loadLine(0);
	            this._startAnimation();
	            this.fire('start');
	        }
	    },

	    resume: function resume() {
	        if (!this.isPaused()) {
	            return;
	        }
	        // update the current line
	        this._currentLine[0] = this.getLatLng();
	        this._currentDuration -= this._pauseStartTime - this._startTime;
	        this._startAnimation();
	    },

	    pause: function pause() {
	        if (!this.isRunning()) {
	            return;
	        }
	        this.run_status = false;
	        this._pauseStartTime = Date.now();
	        this._state = L.Marker.MovingMarker.pausedState;
	        this._stopAnimation();
	        this._updatePosition();
	    },
	    stopPlay: function stopPlay() {
	        this.run_status = false;
	    },

	    stop: function stop(elapsedTime) {

	        if (this.isEnded()) {
	            return;
	        }

	        this._stopAnimation();

	        if (typeof elapsedTime === 'undefined') {
	            // user call
	            elapsedTime = 0;
	            this._updatePosition();
	        }

	        this._state = L.Marker.MovingMarker.endedState;
	        this.fire('end', { elapsedTime: elapsedTime });
	    },

	    addLatLng: function addLatLng(latlng, duration) {
	        this._latlngs.push(L.latLng(latlng));
	        this._durations.push(duration);
	    },

	    moveTo: function moveTo(latlng, duration) {
	        this._stopAnimation();
	        this._latlngs = [this.getLatLng(), L.latLng(latlng)];
	        this._durations = [duration];
	        this._state = L.Marker.MovingMarker.notStartedState;
	        this.start('1');
	        this.options.loop = false;
	    },

	    addStation: function addStation(pointIndex, duration) {
	        if (pointIndex > this._latlngs.length - 2 || pointIndex < 1) {
	            return;
	        }
	        this._stations[pointIndex] = duration;
	    },

	    onAdd: function onAdd(map) {
	        L.Marker.prototype.onAdd.call(this, map);

	        if (this.options.autostart && !this.isStarted()) {
	            this.start();
	            return;
	        }

	        if (this.isRunning()) {
	            this._resumeAnimation();
	        }
	    },

	    onRemove: function onRemove(map) {
	        L.Marker.prototype.onRemove.call(this, map);
	        this._stopAnimation();
	    },

	    _createDurations: function _createDurations(latlngs, duration) {
	        var lastIndex = latlngs.length - 1;
	        var distances = [];
	        var totalDistance = 0;
	        var distance = 0;

	        // compute array of distances between points
	        for (var i = 0; i < lastIndex; i++) {
	            distance = latlngs[i + 1].distanceTo(latlngs[i]);
	            distances.push(distance);
	            totalDistance += distance;
	        }

	        var ratioDuration = duration / totalDistance;

	        var durations = [];
	        for (i = 0; i < distances.length; i++) {
	            durations.push(distances[i] * ratioDuration);
	        }

	        return durations;
	    },

	    _startAnimation: function _startAnimation() {
	        this._state = L.Marker.MovingMarker.runState;
	        this._animId = L.Util.requestAnimFrame(function (timestamp) {
	            this._startTime = Date.now();
	            this._startTimeStamp = timestamp;
	            this._animate(timestamp);
	        }, this, true);
	        this._animRequested = true;
	    },

	    _resumeAnimation: function _resumeAnimation() {
	        if (!this._animRequested) {
	            this._animRequested = true;
	            this._animId = L.Util.requestAnimFrame(function (timestamp) {
	                this._animate(timestamp);
	            }, this, true);
	        }
	    },

	    _stopAnimation: function _stopAnimation() {
	        if (this._animRequested) {
	            L.Util.cancelAnimFrame(this._animId);
	            this._animRequested = false;
	        }
	    },

	    _updatePosition: function _updatePosition() {
	        var elapsedTime = Date.now() - this._startTime;
	        this._animate(this._startTimeStamp + elapsedTime, true);
	    },

	    _loadLine: function _loadLine(index) {
	        this._currentIndex = index;
	        this._currentDuration = this._durations[index];
	        this._currentLine = this._latlngs.slice(index, index + 2);
	    },

	    /**
	     * Load the line where the marker is
	     * @param  {Number} timestamp
	     * @return {Number} elapsed time on the current line or null if
	     * we reached the end or marker is at a station
	     */
	    _updateLine: function _updateLine(timestamp) {
	        // time elapsed since the last latlng
	        var elapsedTime = timestamp - this._startTimeStamp;

	        // not enough time to update the line
	        if (elapsedTime <= this._currentDuration) {
	            return elapsedTime;
	        }

	        var lineIndex = this._currentIndex;
	        var lineDuration = this._currentDuration;
	        var stationDuration;

	        while (elapsedTime > lineDuration) {
	            // substract time of the current line
	            elapsedTime -= lineDuration;
	            stationDuration = this._stations[lineIndex + 1];

	            // test if there is a station at the end of the line
	            if (stationDuration !== undefined) {
	                if (elapsedTime < stationDuration) {
	                    this.setLatLng(this._latlngs[lineIndex + 1]);
	                    return null;
	                }
	                elapsedTime -= stationDuration;
	            }

	            lineIndex++;

	            // test if we have reached the end of the polyline
	            if (lineIndex >= this._latlngs.length - 1) {

	                if (this.options.loop) {
	                    lineIndex = 0;
	                    this.fire('loop', { elapsedTime: elapsedTime });
	                } else {
	                    // place the marker at the end, else it would be at
	                    // the last position
	                    this.setLatLng(this._latlngs[this._latlngs.length - 1]);
	                    this.stop(elapsedTime);
	                    return null;
	                }
	            }
	            lineDuration = this._durations[lineIndex];
	        }

	        this._loadLine(lineIndex);
	        this._startTimeStamp = timestamp - elapsedTime;
	        this._startTime = Date.now() - elapsedTime;
	        return elapsedTime;
	    },

	    initPlayer: function initPlayer(latlngs, time, callback) {
	        this.l = latlngs.length - 1;
	        this.i = 1;
	        this.latlngs = latlngs;
	        this.time = time;
	        this.callback = callback;
	    },

	    play: function play() {
	        if (this.callback != null) {
	            this.callback(this);
	        }

	        if (this.i < this.l) {
	            this.i++;
	            this.moveTo(this.latlngs[this.i], this.time);
	        } else {
	            return this;
	        }
	    },

	    _animate: function _animate(timestamp, noRequestAnim) {
	        this._animRequested = false;

	        // find the next line and compute the new elapsedTime
	        var elapsedTime = this._updateLine(timestamp);

	        if (this.isEnded()) {
	            // no need to animate
	            if (this.run_status) {
	                this.play();
	            }
	            return;
	        }

	        if (elapsedTime != null) {
	            // compute the position
	            var p = L.interpolatePosition(this._currentLine[0], this._currentLine[1], this._currentDuration, elapsedTime);
	            this.setLatLng(p);
	        }

	        if (!noRequestAnim) {
	            this._animId = L.Util.requestAnimFrame(this._animate, this, false);
	            this._animRequested = true;
	        }
	    }
	});

	L.Marker.movingMarker = function (latlngs, duration, options) {
	    return new L.Marker.MovingMarker(latlngs, duration, options);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	L.Icon.Glyph = L.Icon.extend({
		options: {
			iconSize: [25, 41],
			iconAnchor: [12, 41],
			popupAnchor: [1, -34],
			shadowSize: [41, 41],
			// 		iconUrl: 'glyph-marker-icon.png',
			// 		iconSize: [35, 45],
			// 		iconAnchor:   [17, 42],
			// 		popupAnchor: [1, -32],
			// 		shadowAnchor: [10, 12],
			// 		shadowSize: [36, 16],
			// 		bgPos: (Point)
			className: '',
			prefix: '',
			glyph: 'home',
			glyphColor: 'white',
			glyphSize: '11px', // in CSS units
			glyphAnchor: [0, -7] // In pixels, counting from the center of the image.
		},

		createIcon: function createIcon() {
			var div = document.createElement('div'),
			    options = this.options;

			if (options.glyph) {
				div.appendChild(this._createGlyph());
			}

			this._setIconStyles(div, options.className);
			return div;
		},

		_createGlyph: function _createGlyph() {
			var glyphClass,
			    textContent,
			    options = this.options;

			if (!options.prefix) {
				glyphClass = '';
				textContent = options.glyph;
			} else if (options.glyph.slice(0, options.prefix.length + 1) === options.prefix + "-") {
				glyphClass = options.glyph;
			} else {
				glyphClass = options.prefix + "-" + options.glyph;
			}

			var span = L.DomUtil.create('span', options.prefix + ' ' + glyphClass);
			span.style.fontSize = options.glyphSize;
			span.style.color = options.glyphColor;
			span.style.width = options.iconSize[0] + 'px';
			span.style.lineHeight = options.iconSize[1] + 'px';
			span.style.textAlign = 'center';
			span.style.marginLeft = options.glyphAnchor[0] + 'px';
			span.style.marginTop = options.glyphAnchor[1] + 'px';
			span.style.pointerEvents = 'none';

			if (textContent) {
				span.innerHTML = textContent;
				span.style.display = 'inline-block';
			}

			return span;
		},

		_setIconStyles: function _setIconStyles(div, name) {
			if (name === 'shadow') {
				return L.Icon.prototype._setIconStyles.call(this, div, name);
			}

			var options = this.options,
			    size = L.point(options['iconSize']),
			    anchor = L.point(options.iconAnchor);

			if (!anchor && size) {
				anchor = size.divideBy(2, true);
			}

			div.className = 'leaflet-marker-icon leaflet-glyph-icon ' + name;
			var src = this._getIconUrl('icon');
			if (src) {
				div.style.backgroundImage = "url('" + src + "')";
				div.style.backgroundRepeat = "no-repeat";
			}

			if (options.bgPos) {
				div.style.backgroundPosition = -options.bgPos.x + 'px ' + -options.bgPos.y + 'px';
			}
			if (options.bgSize) {
				div.style.backgroundSize = options.bgSize.x + 'px ' + options.bgSize.y + 'px';
			}

			if (anchor) {
				div.style.marginLeft = -anchor.x + 'px';
				div.style.marginTop = -anchor.y + 'px';
			}

			if (size) {
				div.style.width = size.x + 'px';
				div.style.height = size.y + 'px';
			}
		}
	});

	L.icon.glyph = function (options) {
		return new L.Icon.Glyph(options);
	};

	// Base64-encoded version of glyph-marker-icon.png
	L.Icon.Glyph.prototype.options.iconUrl = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAN1wAADdcBQiibeAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAUlSURBVFjDrZdLiBxVFIb/e289uqt6kkx6zIiIoKgLRReKuMhCcaOIAUEIiCCE4CIPggZ8kBjooPgM0TiYEUUjqBGchZqAQlyYRTA+kJiJQiJGMjN5zYzT3dP1rrr3HBeTjDGTSfc8Dvyruud89Z9z6kIJdBj31763MivsJXKuZYF6dak5++2mh7NOcsXVHq6sHbhOK/24kOJJMO4AE1vKygwZhxlKSHGKiD+RSu09vOXB43OCrHz96y6T2lsh+OmKXzFdlbLne2UopSAupBhjECcZgjDMgiiSxPhcK/nCr1sfOtcWcm/tq9uEsL4rl0vdK67pKVu2jUwTMk0wBBAzpBCQAnAtiZIlwWQwPlHPglZQAFj1Y23VwVkh92zbd59U+Kanp+p2L12mooKQ5AbcpuclS6LiKoRhxOfHzhXMcs3PtVV7Z0DufXH/LSzpSG9vr1/p6kIz0dDUrvx/IYXAsrJCkWc4e/Z0Zpgf+KX26A/TkNtrXziesY9Xq8tvWNZdVfVYg7hzwKVv3O3ZiKMWj46OTrq5fdOh1x5pSADwjdzo2nbv0u6qqkca2jCIMGcZAuqRhu8vEX7ZK2V2WgMAcXdtvyeKbPS662+osCohzMycHVweniNREoShoZO5KYobpciSh23bFq7rIUgNiLFghRkBlg2v7GlpiccsCHrcryzxUk3zmsNskeYGvt/lxVH4hMWEu9xSWaQFYQ7L1B6iGZ5bBoy+zWKiHiltFHpqeIsVhWaosg1iqlgg4wAAEYEXsV3EmNppJmExMFYUxfVSuIs6E0sI5FkBBhLJzH9laQxLSjBj0WQJgSJPweDTkknvS4JGbCuxKOt7UY4lEQfNnAu9TzLxN2nUdAQTLAEw8YIlAVgAkmDCSBL75eCutSeY+GTUqqNkqUVxUbIl4qgJo4vWzecrhyQAMJldYf1MXLLl1EIsYBZgoGwpRI2zMTPtGBhYbSQAlJF9lieRzNMIriVBzPOWawvoIkYaNC0u9IcAIAHgp75NLQl8ENbPZJ6jgAU48RyFqHEuZyE+Pda/vjENAQBD5s209Y+kPJlyM4+r3lUS0AWSyVEhpHnjYu1pyO+7N4ywwPvhxHDiuwo8j1b5rkQwMZIziYHBXetPzIAAgIV8exZOSMoieI6aU5vKtgR0jqw1JtiYbZfW/R/kSN+mcWbxdtwYjn1XTd9B7cQAfNdCWB/OhBR7jvWv/3tWCAAoO3ktjyZZJ0HHbsq2AooERVQXzPKly2vOgPz29jNNBr+e1IcSz5YAM4hmFzPDtyWS+lDK4N2DfU+dbgsBAFHyd+oszE3agt/GjWcrUBEjj5sQBb96pXpXhAzueDJi4u1p41TsuQpCiFln4bkKeXMoJeadg++tG+sYAgBBXOo3RRrruAnfkWDmGfIdCeQhiiQgQbxjtlqzQk59vCZlNluL5lDiORLyMjcA4DsKeXM4AfDKxa97ThAAqPaMfaR1Nq6jOiqOAhOm5TsKJg1QZGGRedY7V6tzVcjBWk1D0JZ8cigt2RJSimkXnqOgW8MxQLUTb6wN5g0BgGPV0c9BekTH41xx5YXrQ8FkTRgdpxU7ea9djbYQ1GokmJ43wUhWtgRcS04tQjAcw9CWw29tThYOAXD03XVfMps/TTTOy30blDZgiqxFK6p7OsnvCDJ1UD9LyUjORoPDkUQyPfdHbXW+qJCjfRsOwOAoNY4z6Xz01rHq3k5zO4ZMHTabYSIhJD87MLB64f8Ys8WdG/tfBljMJedfwY+s/2P4Pv8AAAAASUVORK5CYII=';
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {(function (global, factory) {
		 true ? factory(__webpack_require__(1)) :
		typeof define === 'function' && define.amd ? define(['leaflet'], factory) :
		(factory(global.L));
	}(this, (function (L$1) { 'use strict';

	L$1 = L$1 && L$1.hasOwnProperty('default') ? L$1['default'] : L$1;

	// functional re-impl of L.Point.distanceTo,
	// with no dependency on Leaflet for easier testing
	function pointDistance(ptA, ptB) {
	    var x = ptB.x - ptA.x;
	    var y = ptB.y - ptA.y;
	    return Math.sqrt(x * x + y * y);
	}

	var computeSegmentHeading = function computeSegmentHeading(a, b) {
	    return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI + 90 + 360) % 360;
	};

	var asRatioToPathLength = function asRatioToPathLength(_ref, totalPathLength) {
	    var value = _ref.value,
	        isInPixels = _ref.isInPixels;
	    return isInPixels ? value / totalPathLength : value;
	};

	function parseRelativeOrAbsoluteValue(value) {
	    if (typeof value === 'string' && value.indexOf('%') !== -1) {
	        return {
	            value: parseFloat(value) / 100,
	            isInPixels: false
	        };
	    }
	    var parsedValue = value ? parseFloat(value) : 0;
	    return {
	        value: parsedValue,
	        isInPixels: parsedValue > 0
	    };
	}

	var pointsEqual = function pointsEqual(a, b) {
	    return a.x === b.x && a.y === b.y;
	};

	function pointsToSegments(pts) {
	    return pts.reduce(function (segments, b, idx, points) {
	        // this test skips same adjacent points
	        if (idx > 0 && !pointsEqual(b, points[idx - 1])) {
	            var a = points[idx - 1];
	            var distA = segments.length > 0 ? segments[segments.length - 1].distB : 0;
	            var distAB = pointDistance(a, b);
	            segments.push({
	                a: a,
	                b: b,
	                distA: distA,
	                distB: distA + distAB,
	                heading: computeSegmentHeading(a, b)
	            });
	        }
	        return segments;
	    }, []);
	}

	function projectPatternOnPointPath(pts, pattern) {
	    // 1. split the path into segment infos
	    var segments = pointsToSegments(pts);
	    var nbSegments = segments.length;
	    if (nbSegments === 0) {
	        return [];
	    }

	    var totalPathLength = segments[nbSegments - 1].distB;

	    var offset = asRatioToPathLength(pattern.offset, totalPathLength);
	    var endOffset = asRatioToPathLength(pattern.endOffset, totalPathLength);
	    var repeat = asRatioToPathLength(pattern.repeat, totalPathLength);

	    var repeatIntervalPixels = totalPathLength * repeat;
	    var startOffsetPixels = offset > 0 ? totalPathLength * offset : 0;
	    var endOffsetPixels = endOffset > 0 ? totalPathLength * endOffset : 0;

	    // 2. generate the positions of the pattern as offsets from the path start
	    var positionOffsets = [];
	    var positionOffset = startOffsetPixels;
	    do {
	        positionOffsets.push(positionOffset);
	        positionOffset += repeatIntervalPixels;
	    } while (repeatIntervalPixels > 0 && positionOffset < totalPathLength - endOffsetPixels);

	    // 3. projects offsets to segments
	    var segmentIndex = 0;
	    var segment = segments[0];
	    return positionOffsets.map(function (positionOffset) {
	        // find the segment matching the offset,
	        // starting from the previous one as offsets are ordered
	        while (positionOffset > segment.distB && segmentIndex < nbSegments - 1) {
	            segmentIndex++;
	            segment = segments[segmentIndex];
	        }

	        var segmentRatio = (positionOffset - segment.distA) / (segment.distB - segment.distA);
	        return {
	            pt: interpolateBetweenPoints(segment.a, segment.b, segmentRatio),
	            heading: segment.heading
	        };
	    });
	}

	/**
	* Finds the point which lies on the segment defined by points A and B,
	* at the given ratio of the distance from A to B, by linear interpolation.
	*/
	function interpolateBetweenPoints(ptA, ptB, ratio) {
	    if (ptB.x !== ptA.x) {
	        return {
	            x: ptA.x + ratio * (ptB.x - ptA.x),
	            y: ptA.y + ratio * (ptB.y - ptA.y)
	        };
	    }
	    // special case where points lie on the same vertical axis
	    return {
	        x: ptA.x,
	        y: ptA.y + (ptB.y - ptA.y) * ratio
	    };
	}

	(function() {
	    // save these original methods before they are overwritten
	    var proto_initIcon = L.Marker.prototype._initIcon;
	    var proto_setPos = L.Marker.prototype._setPos;

	    var oldIE = (L.DomUtil.TRANSFORM === 'msTransform');

	    L.Marker.addInitHook(function () {
	        var iconOptions = this.options.icon && this.options.icon.options;
	        var iconAnchor = iconOptions && this.options.icon.options.iconAnchor;
	        if (iconAnchor) {
	            iconAnchor = (iconAnchor[0] + 'px ' + iconAnchor[1] + 'px');
	        }
	        this.options.rotationOrigin = this.options.rotationOrigin || iconAnchor || 'center bottom' ;
	        this.options.rotationAngle = this.options.rotationAngle || 0;

	        // Ensure marker keeps rotated during dragging
	        this.on('drag', function(e) { e.target._applyRotation(); });
	    });

	    L.Marker.include({
	        _initIcon: function() {
	            proto_initIcon.call(this);
	        },

	        _setPos: function (pos) {
	            proto_setPos.call(this, pos);
	            this._applyRotation();
	        },

	        _applyRotation: function () {
	            if(this.options.rotationAngle) {
	                this._icon.style[L.DomUtil.TRANSFORM+'Origin'] = this.options.rotationOrigin;

	                if(oldIE) {
	                    // for IE 9, use the 2D rotation
	                    this._icon.style[L.DomUtil.TRANSFORM] = 'rotate(' + this.options.rotationAngle + 'deg)';
	                } else {
	                    // for modern browsers, prefer the 3D accelerated version
	                    this._icon.style[L.DomUtil.TRANSFORM] += ' rotateZ(' + this.options.rotationAngle + 'deg)';
	                }
	            }
	        },

	        setRotationAngle: function(angle) {
	            this.options.rotationAngle = angle;
	            this.update();
	            return this;
	        },

	        setRotationOrigin: function(origin) {
	            this.options.rotationOrigin = origin;
	            this.update();
	            return this;
	        }
	    });
	})();

	L$1.Symbol = L$1.Symbol || {};

	/**
	* A simple dash symbol, drawn as a Polyline.
	* Can also be used for dots, if 'pixelSize' option is given the 0 value.
	*/
	L$1.Symbol.Dash = L$1.Class.extend({
	    options: {
	        pixelSize: 10,
	        pathOptions: {}
	    },

	    initialize: function initialize(options) {
	        L$1.Util.setOptions(this, options);
	        this.options.pathOptions.clickable = false;
	    },

	    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {
	        var opts = this.options;
	        var d2r = Math.PI / 180;

	        // for a dot, nothing more to compute
	        if (opts.pixelSize <= 1) {
	            return L$1.polyline([dirPoint.latLng, dirPoint.latLng], opts.pathOptions);
	        }

	        var midPoint = map.project(dirPoint.latLng);
	        var angle = -(dirPoint.heading - 90) * d2r;
	        var a = L$1.point(midPoint.x + opts.pixelSize * Math.cos(angle + Math.PI) / 2, midPoint.y + opts.pixelSize * Math.sin(angle) / 2);
	        // compute second point by central symmetry to avoid unecessary cos/sin
	        var b = midPoint.add(midPoint.subtract(a));
	        return L$1.polyline([map.unproject(a), map.unproject(b)], opts.pathOptions);
	    }
	});

	L$1.Symbol.dash = function (options) {
	    return new L$1.Symbol.Dash(options);
	};

	L$1.Symbol.ArrowHead = L$1.Class.extend({
	    options: {
	        polygon: true,
	        pixelSize: 10,
	        headAngle: 60,
	        pathOptions: {
	            stroke: false,
	            weight: 2
	        }
	    },

	    initialize: function initialize(options) {
	        L$1.Util.setOptions(this, options);
	        this.options.pathOptions.clickable = false;
	    },

	    buildSymbol: function buildSymbol(dirPoint, latLngs, map, index, total) {
	        return this.options.polygon ? L$1.polygon(this._buildArrowPath(dirPoint, map), this.options.pathOptions) : L$1.polyline(this._buildArrowPath(dirPoint, map), this.options.pathOptions);
	    },

	    _buildArrowPath: function _buildArrowPath(dirPoint, map) {
	        var d2r = Math.PI / 180;
	        var tipPoint = map.project(dirPoint.latLng);
	        var direction = -(dirPoint.heading - 90) * d2r;
	        var radianArrowAngle = this.options.headAngle / 2 * d2r;

	        var headAngle1 = direction + radianArrowAngle;
	        var headAngle2 = direction - radianArrowAngle;
	        var arrowHead1 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle1), tipPoint.y + this.options.pixelSize * Math.sin(headAngle1));
	        var arrowHead2 = L$1.point(tipPoint.x - this.options.pixelSize * Math.cos(headAngle2), tipPoint.y + this.options.pixelSize * Math.sin(headAngle2));

	        return [map.unproject(arrowHead1), dirPoint.latLng, map.unproject(arrowHead2)];
	    }
	});

	L$1.Symbol.arrowHead = function (options) {
	    return new L$1.Symbol.ArrowHead(options);
	};

	L$1.Symbol.Marker = L$1.Class.extend({
	    options: {
	        markerOptions: {},
	        rotate: false
	    },

	    initialize: function initialize(options) {
	        L$1.Util.setOptions(this, options);
	        this.options.markerOptions.clickable = false;
	        this.options.markerOptions.draggable = false;
	    },

	    buildSymbol: function buildSymbol(directionPoint, latLngs, map, index, total) {
	        if (this.options.rotate) {
	            this.options.markerOptions.rotationAngle = directionPoint.heading + (this.options.angleCorrection || 0);
	        }
	        return L$1.marker(directionPoint.latLng, this.options.markerOptions);
	    }
	});

	L$1.Symbol.marker = function (options) {
	    return new L$1.Symbol.Marker(options);
	};

	var isCoord = function isCoord(c) {
	    return c instanceof L$1.LatLng || Array.isArray(c) && c.length === 2 && typeof c[0] === 'number';
	};

	var isCoordArray = function isCoordArray(ll) {
	    return Array.isArray(ll) && isCoord(ll[0]);
	};

	L$1.PolylineDecorator = L$1.FeatureGroup.extend({
	    options: {
	        patterns: []
	    },

	    initialize: function initialize(paths, options) {
	        L$1.FeatureGroup.prototype.initialize.call(this);
	        L$1.Util.setOptions(this, options);
	        this._map = null;
	        this._paths = this._initPaths(paths);
	        this._bounds = this._initBounds();
	        this._patterns = this._initPatterns(this.options.patterns);
	    },

	    /**
	    * Deals with all the different cases. input can be one of these types:
	    * array of LatLng, array of 2-number arrays, Polyline, Polygon,
	    * array of one of the previous.
	    */
	    _initPaths: function _initPaths(input, isPolygon) {
	        var _this = this;

	        if (isCoordArray(input)) {
	            // Leaflet Polygons don't need the first point to be repeated, but we do
	            var coords = isPolygon ? input.concat([input[0]]) : input;
	            return [coords];
	        }
	        if (input instanceof L$1.Polyline) {
	            // we need some recursivity to support multi-poly*
	            return this._initPaths(input.getLatLngs(), input instanceof L$1.Polygon);
	        }
	        if (Array.isArray(input)) {
	            // flatten everything, we just need coordinate lists to apply patterns
	            return input.reduce(function (flatArray, p) {
	                return flatArray.concat(_this._initPaths(p, isPolygon));
	            }, []);
	        }
	        return [];
	    },

	    // parse pattern definitions and precompute some values
	    _initPatterns: function _initPatterns(patternDefs) {
	        return patternDefs.map(this._parsePatternDef);
	    },

	    /**
	    * Changes the patterns used by this decorator
	    * and redraws the new one.
	    */
	    setPatterns: function setPatterns(patterns) {
	        this.options.patterns = patterns;
	        this._patterns = this._initPatterns(this.options.patterns);
	        this.redraw();
	    },

	    /**
	    * Changes the patterns used by this decorator
	    * and redraws the new one.
	    */
	    setPaths: function setPaths(paths) {
	        this._paths = this._initPaths(paths);
	        this._bounds = this._initBounds();
	        this.redraw();
	    },

	    /**
	    * Parse the pattern definition
	    */
	    _parsePatternDef: function _parsePatternDef(patternDef, latLngs) {
	        return {
	            symbolFactory: patternDef.symbol,
	            // Parse offset and repeat values, managing the two cases:
	            // absolute (in pixels) or relative (in percentage of the polyline length)
	            offset: parseRelativeOrAbsoluteValue(patternDef.offset),
	            endOffset: parseRelativeOrAbsoluteValue(patternDef.endOffset),
	            repeat: parseRelativeOrAbsoluteValue(patternDef.repeat)
	        };
	    },

	    onAdd: function onAdd(map) {
	        this._map = map;
	        this._draw();
	        this._map.on('moveend', this.redraw, this);
	    },

	    onRemove: function onRemove(map) {
	        this._map.off('moveend', this.redraw, this);
	        this._map = null;
	        L$1.FeatureGroup.prototype.onRemove.call(this, map);
	    },

	    /**
	    * As real pattern bounds depends on map zoom and bounds,
	    * we just compute the total bounds of all paths decorated by this instance.
	    */
	    _initBounds: function _initBounds() {
	        var allPathCoords = this._paths.reduce(function (acc, path) {
	            return acc.concat(path);
	        }, []);
	        return L$1.latLngBounds(allPathCoords);
	    },

	    getBounds: function getBounds() {
	        return this._bounds;
	    },

	    /**
	    * Returns an array of ILayers object
	    */
	    _buildSymbols: function _buildSymbols(latLngs, symbolFactory, directionPoints) {
	        var _this2 = this;

	        return directionPoints.map(function (directionPoint, i) {
	            return symbolFactory.buildSymbol(directionPoint, latLngs, _this2._map, i, directionPoints.length);
	        });
	    },

	    /**
	    * Compute pairs of LatLng and heading angle,
	    * that define positions and directions of the symbols on the path
	    */
	    _getDirectionPoints: function _getDirectionPoints(latLngs, pattern) {
	        var _this3 = this;

	        if (latLngs.length < 2) {
	            return [];
	        }
	        var pathAsPoints = latLngs.map(function (latLng) {
	            return _this3._map.project(latLng);
	        });
	        return projectPatternOnPointPath(pathAsPoints, pattern).map(function (point) {
	            return {
	                latLng: _this3._map.unproject(L$1.point(point.pt)),
	                heading: point.heading
	            };
	        });
	    },

	    redraw: function redraw() {
	        if (!this._map) {
	            return;
	        }
	        this.clearLayers();
	        this._draw();
	    },

	    /**
	    * Returns all symbols for a given pattern as an array of FeatureGroup
	    */
	    _getPatternLayers: function _getPatternLayers(pattern) {
	        var _this4 = this;

	        var mapBounds = this._map.getBounds().pad(0.1);
	        return this._paths.map(function (path) {
	            var directionPoints = _this4._getDirectionPoints(path, pattern)
	            // filter out invisible points
	            .filter(function (point) {
	                return mapBounds.contains(point.latLng);
	            });
	            return L$1.featureGroup(_this4._buildSymbols(path, pattern.symbolFactory, directionPoints));
	        });
	    },

	    /**
	    * Draw all patterns
	    */
	    _draw: function _draw() {
	        var _this5 = this;

	        this._patterns.map(function (pattern) {
	            return _this5._getPatternLayers(pattern);
	        }).forEach(function (layers) {
	            _this5.addLayer(L$1.featureGroup(layers));
	        });
	    }
	});
	/*
	 * Allows compact syntax to be used
	 */
	L$1.polylineDecorator = function (paths, options) {
	    return new L$1.PolylineDecorator(paths, options);
	};

	})));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {/*
	 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
	 https://github.com/Leaflet/Leaflet.markercluster
	 (c) 2012-2017, Dave Leaver
	*/
	!function(e,t,i){L.MarkerClusterGroup=L.FeatureGroup.extend({options:{maxClusterRadius:80,iconCreateFunction:null,clusterPane:L.Marker.prototype.options.pane,spiderfyOnMaxZoom:!0,showCoverageOnHover:!0,zoomToBoundsOnClick:!0,singleMarkerMode:!1,disableClusteringAtZoom:null,removeOutsideVisibleBounds:!0,animate:!0,animateAddingMarkers:!1,spiderfyDistanceMultiplier:1,spiderLegPolylineOptions:{weight:1.5,color:"#222",opacity:.5},chunkedLoading:!1,chunkInterval:200,chunkDelay:50,chunkProgress:null,polygonOptions:{}},initialize:function(e){L.Util.setOptions(this,e),this.options.iconCreateFunction||(this.options.iconCreateFunction=this._defaultIconCreateFunction),this._featureGroup=L.featureGroup(),this._featureGroup.addEventParent(this),this._nonPointGroup=L.featureGroup(),this._nonPointGroup.addEventParent(this),this._inZoomAnimation=0,this._needsClustering=[],this._needsRemoving=[],this._currentShownBounds=null,this._queue=[],this._childMarkerEventHandlers={dragstart:this._childMarkerDragStart,move:this._childMarkerMoved,dragend:this._childMarkerDragEnd};var t=L.DomUtil.TRANSITION&&this.options.animate;L.extend(this,t?this._withAnimation:this._noAnimation),this._markerCluster=t?L.MarkerCluster:L.MarkerClusterNonAnimated},addLayer:function(e){if(e instanceof L.LayerGroup)return this.addLayers([e]);if(!e.getLatLng)return this._nonPointGroup.addLayer(e),this.fire("layeradd",{layer:e}),this;if(!this._map)return this._needsClustering.push(e),this.fire("layeradd",{layer:e}),this;if(this.hasLayer(e))return this;this._unspiderfy&&this._unspiderfy(),this._addLayer(e,this._maxZoom),this.fire("layeradd",{layer:e}),this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons();var t=e,i=this._zoom;if(e.__parent)for(;t.__parent._zoom>=i;)t=t.__parent;return this._currentShownBounds.contains(t.getLatLng())&&(this.options.animateAddingMarkers?this._animationAddLayer(e,t):this._animationAddLayerNonAnimated(e,t)),this},removeLayer:function(e){return e instanceof L.LayerGroup?this.removeLayers([e]):e.getLatLng?this._map?e.__parent?(this._unspiderfy&&(this._unspiderfy(),this._unspiderfyLayer(e)),this._removeLayer(e,!0),this.fire("layerremove",{layer:e}),this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons(),e.off(this._childMarkerEventHandlers,this),this._featureGroup.hasLayer(e)&&(this._featureGroup.removeLayer(e),e.clusterShow&&e.clusterShow()),this):this:(!this._arraySplice(this._needsClustering,e)&&this.hasLayer(e)&&this._needsRemoving.push({layer:e,latlng:e._latlng}),this.fire("layerremove",{layer:e}),this):(this._nonPointGroup.removeLayer(e),this.fire("layerremove",{layer:e}),this)},addLayers:function(e,t){if(!L.Util.isArray(e))return this.addLayer(e);var i,n=this._featureGroup,r=this._nonPointGroup,s=this.options.chunkedLoading,o=this.options.chunkInterval,a=this.options.chunkProgress,h=e.length,l=0,u=!0;if(this._map){var _=(new Date).getTime(),d=L.bind(function(){for(var c=(new Date).getTime();h>l;l++){if(s&&0===l%200){var p=(new Date).getTime()-c;if(p>o)break}if(i=e[l],i instanceof L.LayerGroup)u&&(e=e.slice(),u=!1),this._extractNonGroupLayers(i,e),h=e.length;else if(i.getLatLng){if(!this.hasLayer(i)&&(this._addLayer(i,this._maxZoom),t||this.fire("layeradd",{layer:i}),i.__parent&&2===i.__parent.getChildCount())){var f=i.__parent.getAllChildMarkers(),m=f[0]===i?f[1]:f[0];n.removeLayer(m)}}else r.addLayer(i),t||this.fire("layeradd",{layer:i})}a&&a(l,h,(new Date).getTime()-_),l===h?(this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons(),this._topClusterLevel._recursivelyAddChildrenToMap(null,this._zoom,this._currentShownBounds)):setTimeout(d,this.options.chunkDelay)},this);d()}else for(var c=this._needsClustering;h>l;l++)i=e[l],i instanceof L.LayerGroup?(u&&(e=e.slice(),u=!1),this._extractNonGroupLayers(i,e),h=e.length):i.getLatLng?this.hasLayer(i)||c.push(i):r.addLayer(i);return this},removeLayers:function(e){var t,i,n=e.length,r=this._featureGroup,s=this._nonPointGroup,o=!0;if(!this._map){for(t=0;n>t;t++)i=e[t],i instanceof L.LayerGroup?(o&&(e=e.slice(),o=!1),this._extractNonGroupLayers(i,e),n=e.length):(this._arraySplice(this._needsClustering,i),s.removeLayer(i),this.hasLayer(i)&&this._needsRemoving.push({layer:i,latlng:i._latlng}),this.fire("layerremove",{layer:i}));return this}if(this._unspiderfy){this._unspiderfy();var a=e.slice(),h=n;for(t=0;h>t;t++)i=a[t],i instanceof L.LayerGroup?(this._extractNonGroupLayers(i,a),h=a.length):this._unspiderfyLayer(i)}for(t=0;n>t;t++)i=e[t],i instanceof L.LayerGroup?(o&&(e=e.slice(),o=!1),this._extractNonGroupLayers(i,e),n=e.length):i.__parent?(this._removeLayer(i,!0,!0),this.fire("layerremove",{layer:i}),r.hasLayer(i)&&(r.removeLayer(i),i.clusterShow&&i.clusterShow())):(s.removeLayer(i),this.fire("layerremove",{layer:i}));return this._topClusterLevel._recalculateBounds(),this._refreshClustersIcons(),this._topClusterLevel._recursivelyAddChildrenToMap(null,this._zoom,this._currentShownBounds),this},clearLayers:function(){return this._map||(this._needsClustering=[],delete this._gridClusters,delete this._gridUnclustered),this._noanimationUnspiderfy&&this._noanimationUnspiderfy(),this._featureGroup.clearLayers(),this._nonPointGroup.clearLayers(),this.eachLayer(function(e){e.off(this._childMarkerEventHandlers,this),delete e.__parent},this),this._map&&this._generateInitialClusters(),this},getBounds:function(){var e=new L.LatLngBounds;this._topClusterLevel&&e.extend(this._topClusterLevel._bounds);for(var t=this._needsClustering.length-1;t>=0;t--)e.extend(this._needsClustering[t].getLatLng());return e.extend(this._nonPointGroup.getBounds()),e},eachLayer:function(e,t){var i,n,r,s=this._needsClustering.slice(),o=this._needsRemoving;for(this._topClusterLevel&&this._topClusterLevel.getAllChildMarkers(s),n=s.length-1;n>=0;n--){for(i=!0,r=o.length-1;r>=0;r--)if(o[r].layer===s[n]){i=!1;break}i&&e.call(t,s[n])}this._nonPointGroup.eachLayer(e,t)},getLayers:function(){var e=[];return this.eachLayer(function(t){e.push(t)}),e},getLayer:function(e){var t=null;return e=parseInt(e,10),this.eachLayer(function(i){L.stamp(i)===e&&(t=i)}),t},hasLayer:function(e){if(!e)return!1;var t,i=this._needsClustering;for(t=i.length-1;t>=0;t--)if(i[t]===e)return!0;for(i=this._needsRemoving,t=i.length-1;t>=0;t--)if(i[t].layer===e)return!1;return!(!e.__parent||e.__parent._group!==this)||this._nonPointGroup.hasLayer(e)},zoomToShowLayer:function(e,t){"function"!=typeof t&&(t=function(){});var i=function(){!e._icon&&!e.__parent._icon||this._inZoomAnimation||(this._map.off("moveend",i,this),this.off("animationend",i,this),e._icon?t():e.__parent._icon&&(this.once("spiderfied",t,this),e.__parent.spiderfy()))};e._icon&&this._map.getBounds().contains(e.getLatLng())?t():e.__parent._zoom<Math.round(this._map._zoom)?(this._map.on("moveend",i,this),this._map.panTo(e.getLatLng())):(this._map.on("moveend",i,this),this.on("animationend",i,this),e.__parent.zoomToBounds())},onAdd:function(e){this._map=e;var t,i,n;if(!isFinite(this._map.getMaxZoom()))throw"Map has no maxZoom specified";for(this._featureGroup.addTo(e),this._nonPointGroup.addTo(e),this._gridClusters||this._generateInitialClusters(),this._maxLat=e.options.crs.projection.MAX_LATITUDE,t=0,i=this._needsRemoving.length;i>t;t++)n=this._needsRemoving[t],n.newlatlng=n.layer._latlng,n.layer._latlng=n.latlng;for(t=0,i=this._needsRemoving.length;i>t;t++)n=this._needsRemoving[t],this._removeLayer(n.layer,!0),n.layer._latlng=n.newlatlng;this._needsRemoving=[],this._zoom=Math.round(this._map._zoom),this._currentShownBounds=this._getExpandedVisibleBounds(),this._map.on("zoomend",this._zoomEnd,this),this._map.on("moveend",this._moveEnd,this),this._spiderfierOnAdd&&this._spiderfierOnAdd(),this._bindEvents(),i=this._needsClustering,this._needsClustering=[],this.addLayers(i,!0)},onRemove:function(e){e.off("zoomend",this._zoomEnd,this),e.off("moveend",this._moveEnd,this),this._unbindEvents(),this._map._mapPane.className=this._map._mapPane.className.replace(" leaflet-cluster-anim",""),this._spiderfierOnRemove&&this._spiderfierOnRemove(),delete this._maxLat,this._hideCoverage(),this._featureGroup.remove(),this._nonPointGroup.remove(),this._featureGroup.clearLayers(),this._map=null},getVisibleParent:function(e){for(var t=e;t&&!t._icon;)t=t.__parent;return t||null},_arraySplice:function(e,t){for(var i=e.length-1;i>=0;i--)if(e[i]===t)return e.splice(i,1),!0},_removeFromGridUnclustered:function(e,t){for(var i=this._map,n=this._gridUnclustered,r=Math.floor(this._map.getMinZoom());t>=r&&n[t].removeObject(e,i.project(e.getLatLng(),t));t--);},_childMarkerDragStart:function(e){e.target.__dragStart=e.target._latlng},_childMarkerMoved:function(e){if(!this._ignoreMove&&!e.target.__dragStart){var t=e.target._popup&&e.target._popup.isOpen();this._moveChild(e.target,e.oldLatLng,e.latlng),t&&e.target.openPopup()}},_moveChild:function(e,t,i){e._latlng=t,this.removeLayer(e),e._latlng=i,this.addLayer(e)},_childMarkerDragEnd:function(e){e.target.__dragStart&&this._moveChild(e.target,e.target.__dragStart,e.target._latlng),delete e.target.__dragStart},_removeLayer:function(e,t,i){var n=this._gridClusters,r=this._gridUnclustered,s=this._featureGroup,o=this._map,a=Math.floor(this._map.getMinZoom());t&&this._removeFromGridUnclustered(e,this._maxZoom);var h,l=e.__parent,u=l._markers;for(this._arraySplice(u,e);l&&(l._childCount--,l._boundsNeedUpdate=!0,!(l._zoom<a));)t&&l._childCount<=1?(h=l._markers[0]===e?l._markers[1]:l._markers[0],n[l._zoom].removeObject(l,o.project(l._cLatLng,l._zoom)),r[l._zoom].addObject(h,o.project(h.getLatLng(),l._zoom)),this._arraySplice(l.__parent._childClusters,l),l.__parent._markers.push(h),h.__parent=l.__parent,l._icon&&(s.removeLayer(l),i||s.addLayer(h))):l._iconNeedsUpdate=!0,l=l.__parent;delete e.__parent},_isOrIsParent:function(e,t){for(;t;){if(e===t)return!0;t=t.parentNode}return!1},fire:function(e,t,i){if(t&&t.layer instanceof L.MarkerCluster){if(t.originalEvent&&this._isOrIsParent(t.layer._icon,t.originalEvent.relatedTarget))return;e="cluster"+e}L.FeatureGroup.prototype.fire.call(this,e,t,i)},listens:function(e,t){return L.FeatureGroup.prototype.listens.call(this,e,t)||L.FeatureGroup.prototype.listens.call(this,"cluster"+e,t)},_defaultIconCreateFunction:function(e){var t=e.getChildCount(),i=" marker-cluster-";return i+=10>t?"small":100>t?"medium":"large",new L.DivIcon({html:"<div><span>"+t+"</span></div>",className:"marker-cluster"+i,iconSize:new L.Point(40,40)})},_bindEvents:function(){var e=this._map,t=this.options.spiderfyOnMaxZoom,i=this.options.showCoverageOnHover,n=this.options.zoomToBoundsOnClick;(t||n)&&this.on("clusterclick",this._zoomOrSpiderfy,this),i&&(this.on("clustermouseover",this._showCoverage,this),this.on("clustermouseout",this._hideCoverage,this),e.on("zoomend",this._hideCoverage,this))},_zoomOrSpiderfy:function(e){for(var t=e.layer,i=t;1===i._childClusters.length;)i=i._childClusters[0];i._zoom===this._maxZoom&&i._childCount===t._childCount&&this.options.spiderfyOnMaxZoom?t.spiderfy():this.options.zoomToBoundsOnClick&&t.zoomToBounds(),e.originalEvent&&13===e.originalEvent.keyCode&&this._map._container.focus()},_showCoverage:function(e){var t=this._map;this._inZoomAnimation||(this._shownPolygon&&t.removeLayer(this._shownPolygon),e.layer.getChildCount()>2&&e.layer!==this._spiderfied&&(this._shownPolygon=new L.Polygon(e.layer.getConvexHull(),this.options.polygonOptions),t.addLayer(this._shownPolygon)))},_hideCoverage:function(){this._shownPolygon&&(this._map.removeLayer(this._shownPolygon),this._shownPolygon=null)},_unbindEvents:function(){var e=this.options.spiderfyOnMaxZoom,t=this.options.showCoverageOnHover,i=this.options.zoomToBoundsOnClick,n=this._map;(e||i)&&this.off("clusterclick",this._zoomOrSpiderfy,this),t&&(this.off("clustermouseover",this._showCoverage,this),this.off("clustermouseout",this._hideCoverage,this),n.off("zoomend",this._hideCoverage,this))},_zoomEnd:function(){this._map&&(this._mergeSplitClusters(),this._zoom=Math.round(this._map._zoom),this._currentShownBounds=this._getExpandedVisibleBounds())},_moveEnd:function(){if(!this._inZoomAnimation){var e=this._getExpandedVisibleBounds();this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),this._zoom,e),this._topClusterLevel._recursivelyAddChildrenToMap(null,Math.round(this._map._zoom),e),this._currentShownBounds=e}},_generateInitialClusters:function(){var e=Math.ceil(this._map.getMaxZoom()),t=Math.floor(this._map.getMinZoom()),i=this.options.maxClusterRadius,n=i;"function"!=typeof i&&(n=function(){return i}),null!==this.options.disableClusteringAtZoom&&(e=this.options.disableClusteringAtZoom-1),this._maxZoom=e,this._gridClusters={},this._gridUnclustered={};for(var r=e;r>=t;r--)this._gridClusters[r]=new L.DistanceGrid(n(r)),this._gridUnclustered[r]=new L.DistanceGrid(n(r));this._topClusterLevel=new this._markerCluster(this,t-1)},_addLayer:function(e,t){var i,n,r=this._gridClusters,s=this._gridUnclustered,o=Math.floor(this._map.getMinZoom());for(this.options.singleMarkerMode&&this._overrideMarkerIcon(e),e.on(this._childMarkerEventHandlers,this);t>=o;t--){i=this._map.project(e.getLatLng(),t);var a=r[t].getNearObject(i);if(a)return a._addChild(e),e.__parent=a,void 0;if(a=s[t].getNearObject(i)){var h=a.__parent;h&&this._removeLayer(a,!1);var l=new this._markerCluster(this,t,a,e);r[t].addObject(l,this._map.project(l._cLatLng,t)),a.__parent=l,e.__parent=l;var u=l;for(n=t-1;n>h._zoom;n--)u=new this._markerCluster(this,n,u),r[n].addObject(u,this._map.project(a.getLatLng(),n));return h._addChild(u),this._removeFromGridUnclustered(a,t),void 0}s[t].addObject(e,i)}this._topClusterLevel._addChild(e),e.__parent=this._topClusterLevel},_refreshClustersIcons:function(){this._featureGroup.eachLayer(function(e){e instanceof L.MarkerCluster&&e._iconNeedsUpdate&&e._updateIcon()})},_enqueue:function(e){this._queue.push(e),this._queueTimeout||(this._queueTimeout=setTimeout(L.bind(this._processQueue,this),300))},_processQueue:function(){for(var e=0;e<this._queue.length;e++)this._queue[e].call(this);this._queue.length=0,clearTimeout(this._queueTimeout),this._queueTimeout=null},_mergeSplitClusters:function(){var e=Math.round(this._map._zoom);this._processQueue(),this._zoom<e&&this._currentShownBounds.intersects(this._getExpandedVisibleBounds())?(this._animationStart(),this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),this._zoom,this._getExpandedVisibleBounds()),this._animationZoomIn(this._zoom,e)):this._zoom>e?(this._animationStart(),this._animationZoomOut(this._zoom,e)):this._moveEnd()},_getExpandedVisibleBounds:function(){return this.options.removeOutsideVisibleBounds?L.Browser.mobile?this._checkBoundsMaxLat(this._map.getBounds()):this._checkBoundsMaxLat(this._map.getBounds().pad(1)):this._mapBoundsInfinite},_checkBoundsMaxLat:function(e){var t=this._maxLat;return t!==i&&(e.getNorth()>=t&&(e._northEast.lat=1/0),e.getSouth()<=-t&&(e._southWest.lat=-1/0)),e},_animationAddLayerNonAnimated:function(e,t){if(t===e)this._featureGroup.addLayer(e);else if(2===t._childCount){t._addToMap();var i=t.getAllChildMarkers();this._featureGroup.removeLayer(i[0]),this._featureGroup.removeLayer(i[1])}else t._updateIcon()},_extractNonGroupLayers:function(e,t){var i,n=e.getLayers(),r=0;for(t=t||[];r<n.length;r++)i=n[r],i instanceof L.LayerGroup?this._extractNonGroupLayers(i,t):t.push(i);return t},_overrideMarkerIcon:function(e){var t=e.options.icon=this.options.iconCreateFunction({getChildCount:function(){return 1},getAllChildMarkers:function(){return[e]}});return t}}),L.MarkerClusterGroup.include({_mapBoundsInfinite:new L.LatLngBounds(new L.LatLng(-1/0,-1/0),new L.LatLng(1/0,1/0))}),L.MarkerClusterGroup.include({_noAnimation:{_animationStart:function(){},_animationZoomIn:function(e,t){this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),e),this._topClusterLevel._recursivelyAddChildrenToMap(null,t,this._getExpandedVisibleBounds()),this.fire("animationend")},_animationZoomOut:function(e,t){this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),e),this._topClusterLevel._recursivelyAddChildrenToMap(null,t,this._getExpandedVisibleBounds()),this.fire("animationend")},_animationAddLayer:function(e,t){this._animationAddLayerNonAnimated(e,t)}},_withAnimation:{_animationStart:function(){this._map._mapPane.className+=" leaflet-cluster-anim",this._inZoomAnimation++},_animationZoomIn:function(e,t){var i,n=this._getExpandedVisibleBounds(),r=this._featureGroup,s=Math.floor(this._map.getMinZoom());this._ignoreMove=!0,this._topClusterLevel._recursively(n,e,s,function(s){var o,a=s._latlng,h=s._markers;for(n.contains(a)||(a=null),s._isSingleParent()&&e+1===t?(r.removeLayer(s),s._recursivelyAddChildrenToMap(null,t,n)):(s.clusterHide(),s._recursivelyAddChildrenToMap(a,t,n)),i=h.length-1;i>=0;i--)o=h[i],n.contains(o._latlng)||r.removeLayer(o)}),this._forceLayout(),this._topClusterLevel._recursivelyBecomeVisible(n,t),r.eachLayer(function(e){e instanceof L.MarkerCluster||!e._icon||e.clusterShow()}),this._topClusterLevel._recursively(n,e,t,function(e){e._recursivelyRestoreChildPositions(t)}),this._ignoreMove=!1,this._enqueue(function(){this._topClusterLevel._recursively(n,e,s,function(e){r.removeLayer(e),e.clusterShow()}),this._animationEnd()})},_animationZoomOut:function(e,t){this._animationZoomOutSingle(this._topClusterLevel,e-1,t),this._topClusterLevel._recursivelyAddChildrenToMap(null,t,this._getExpandedVisibleBounds()),this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds,Math.floor(this._map.getMinZoom()),e,this._getExpandedVisibleBounds())},_animationAddLayer:function(e,t){var i=this,n=this._featureGroup;n.addLayer(e),t!==e&&(t._childCount>2?(t._updateIcon(),this._forceLayout(),this._animationStart(),e._setPos(this._map.latLngToLayerPoint(t.getLatLng())),e.clusterHide(),this._enqueue(function(){n.removeLayer(e),e.clusterShow(),i._animationEnd()})):(this._forceLayout(),i._animationStart(),i._animationZoomOutSingle(t,this._map.getMaxZoom(),this._zoom)))}},_animationZoomOutSingle:function(e,t,i){var n=this._getExpandedVisibleBounds(),r=Math.floor(this._map.getMinZoom());e._recursivelyAnimateChildrenInAndAddSelfToMap(n,r,t+1,i);var s=this;this._forceLayout(),e._recursivelyBecomeVisible(n,i),this._enqueue(function(){if(1===e._childCount){var o=e._markers[0];this._ignoreMove=!0,o.setLatLng(o.getLatLng()),this._ignoreMove=!1,o.clusterShow&&o.clusterShow()}else e._recursively(n,i,r,function(e){e._recursivelyRemoveChildrenFromMap(n,r,t+1)});s._animationEnd()})},_animationEnd:function(){this._map&&(this._map._mapPane.className=this._map._mapPane.className.replace(" leaflet-cluster-anim","")),this._inZoomAnimation--,this.fire("animationend")},_forceLayout:function(){L.Util.falseFn(t.body.offsetWidth)}}),L.markerClusterGroup=function(e){return new L.MarkerClusterGroup(e)},L.MarkerCluster=L.Marker.extend({initialize:function(e,t,i,n){L.Marker.prototype.initialize.call(this,i?i._cLatLng||i.getLatLng():new L.LatLng(0,0),{icon:this,pane:e.options.clusterPane}),this._group=e,this._zoom=t,this._markers=[],this._childClusters=[],this._childCount=0,this._iconNeedsUpdate=!0,this._boundsNeedUpdate=!0,this._bounds=new L.LatLngBounds,i&&this._addChild(i),n&&this._addChild(n)},getAllChildMarkers:function(e){e=e||[];for(var t=this._childClusters.length-1;t>=0;t--)this._childClusters[t].getAllChildMarkers(e);for(var i=this._markers.length-1;i>=0;i--)e.push(this._markers[i]);return e},getChildCount:function(){return this._childCount},zoomToBounds:function(e){for(var t,i=this._childClusters.slice(),n=this._group._map,r=n.getBoundsZoom(this._bounds),s=this._zoom+1,o=n.getZoom();i.length>0&&r>s;){s++;var a=[];for(t=0;t<i.length;t++)a=a.concat(i[t]._childClusters);i=a}r>s?this._group._map.setView(this._latlng,s):o>=r?this._group._map.setView(this._latlng,o+1):this._group._map.fitBounds(this._bounds,e)},getBounds:function(){var e=new L.LatLngBounds;return e.extend(this._bounds),e},_updateIcon:function(){this._iconNeedsUpdate=!0,this._icon&&this.setIcon(this)},createIcon:function(){return this._iconNeedsUpdate&&(this._iconObj=this._group.options.iconCreateFunction(this),this._iconNeedsUpdate=!1),this._iconObj.createIcon()},createShadow:function(){return this._iconObj.createShadow()},_addChild:function(e,t){this._iconNeedsUpdate=!0,this._boundsNeedUpdate=!0,this._setClusterCenter(e),e instanceof L.MarkerCluster?(t||(this._childClusters.push(e),e.__parent=this),this._childCount+=e._childCount):(t||this._markers.push(e),this._childCount++),this.__parent&&this.__parent._addChild(e,!0)},_setClusterCenter:function(e){this._cLatLng||(this._cLatLng=e._cLatLng||e._latlng)},_resetBounds:function(){var e=this._bounds;e._southWest&&(e._southWest.lat=1/0,e._southWest.lng=1/0),e._northEast&&(e._northEast.lat=-1/0,e._northEast.lng=-1/0)},_recalculateBounds:function(){var e,t,i,n,r=this._markers,s=this._childClusters,o=0,a=0,h=this._childCount;if(0!==h){for(this._resetBounds(),e=0;e<r.length;e++)i=r[e]._latlng,this._bounds.extend(i),o+=i.lat,a+=i.lng;for(e=0;e<s.length;e++)t=s[e],t._boundsNeedUpdate&&t._recalculateBounds(),this._bounds.extend(t._bounds),i=t._wLatLng,n=t._childCount,o+=i.lat*n,a+=i.lng*n;this._latlng=this._wLatLng=new L.LatLng(o/h,a/h),this._boundsNeedUpdate=!1}},_addToMap:function(e){e&&(this._backupLatlng=this._latlng,this.setLatLng(e)),this._group._featureGroup.addLayer(this)},_recursivelyAnimateChildrenIn:function(e,t,i){this._recursively(e,this._group._map.getMinZoom(),i-1,function(e){var i,n,r=e._markers;for(i=r.length-1;i>=0;i--)n=r[i],n._icon&&(n._setPos(t),n.clusterHide())},function(e){var i,n,r=e._childClusters;for(i=r.length-1;i>=0;i--)n=r[i],n._icon&&(n._setPos(t),n.clusterHide())})},_recursivelyAnimateChildrenInAndAddSelfToMap:function(e,t,i,n){this._recursively(e,n,t,function(r){r._recursivelyAnimateChildrenIn(e,r._group._map.latLngToLayerPoint(r.getLatLng()).round(),i),r._isSingleParent()&&i-1===n?(r.clusterShow(),r._recursivelyRemoveChildrenFromMap(e,t,i)):r.clusterHide(),r._addToMap()})},_recursivelyBecomeVisible:function(e,t){this._recursively(e,this._group._map.getMinZoom(),t,null,function(e){e.clusterShow()})},_recursivelyAddChildrenToMap:function(e,t,i){this._recursively(i,this._group._map.getMinZoom()-1,t,function(n){if(t!==n._zoom)for(var r=n._markers.length-1;r>=0;r--){var s=n._markers[r];i.contains(s._latlng)&&(e&&(s._backupLatlng=s.getLatLng(),s.setLatLng(e),s.clusterHide&&s.clusterHide()),n._group._featureGroup.addLayer(s))}},function(t){t._addToMap(e)})},_recursivelyRestoreChildPositions:function(e){for(var t=this._markers.length-1;t>=0;t--){var i=this._markers[t];i._backupLatlng&&(i.setLatLng(i._backupLatlng),delete i._backupLatlng)}if(e-1===this._zoom)for(var n=this._childClusters.length-1;n>=0;n--)this._childClusters[n]._restorePosition();else for(var r=this._childClusters.length-1;r>=0;r--)this._childClusters[r]._recursivelyRestoreChildPositions(e)},_restorePosition:function(){this._backupLatlng&&(this.setLatLng(this._backupLatlng),delete this._backupLatlng)},_recursivelyRemoveChildrenFromMap:function(e,t,i,n){var r,s;this._recursively(e,t-1,i-1,function(e){for(s=e._markers.length-1;s>=0;s--)r=e._markers[s],n&&n.contains(r._latlng)||(e._group._featureGroup.removeLayer(r),r.clusterShow&&r.clusterShow())},function(e){for(s=e._childClusters.length-1;s>=0;s--)r=e._childClusters[s],n&&n.contains(r._latlng)||(e._group._featureGroup.removeLayer(r),r.clusterShow&&r.clusterShow())})},_recursively:function(e,t,i,n,r){var s,o,a=this._childClusters,h=this._zoom;if(h>=t&&(n&&n(this),r&&h===i&&r(this)),t>h||i>h)for(s=a.length-1;s>=0;s--)o=a[s],e.intersects(o._bounds)&&o._recursively(e,t,i,n,r)},_isSingleParent:function(){return this._childClusters.length>0&&this._childClusters[0]._childCount===this._childCount}}),L.Marker.include({clusterHide:function(){return this.options.opacityWhenUnclustered=this.options.opacity||1,this.setOpacity(0)},clusterShow:function(){var e=this.setOpacity(this.options.opacity||this.options.opacityWhenUnclustered);return delete this.options.opacityWhenUnclustered,e}}),L.DistanceGrid=function(e){this._cellSize=e,this._sqCellSize=e*e,this._grid={},this._objectPoint={}},L.DistanceGrid.prototype={addObject:function(e,t){var i=this._getCoord(t.x),n=this._getCoord(t.y),r=this._grid,s=r[n]=r[n]||{},o=s[i]=s[i]||[],a=L.Util.stamp(e);this._objectPoint[a]=t,o.push(e)},updateObject:function(e,t){this.removeObject(e),this.addObject(e,t)},removeObject:function(e,t){var i,n,r=this._getCoord(t.x),s=this._getCoord(t.y),o=this._grid,a=o[s]=o[s]||{},h=a[r]=a[r]||[];for(delete this._objectPoint[L.Util.stamp(e)],i=0,n=h.length;n>i;i++)if(h[i]===e)return h.splice(i,1),1===n&&delete a[r],!0},eachObject:function(e,t){var i,n,r,s,o,a,h,l=this._grid;for(i in l){o=l[i];for(n in o)for(a=o[n],r=0,s=a.length;s>r;r++)h=e.call(t,a[r]),h&&(r--,s--)}},getNearObject:function(e){var t,i,n,r,s,o,a,h,l=this._getCoord(e.x),u=this._getCoord(e.y),_=this._objectPoint,d=this._sqCellSize,c=null;for(t=u-1;u+1>=t;t++)if(r=this._grid[t])for(i=l-1;l+1>=i;i++)if(s=r[i])for(n=0,o=s.length;o>n;n++)a=s[n],h=this._sqDist(_[L.Util.stamp(a)],e),(d>h||d>=h&&null===c)&&(d=h,c=a);return c},_getCoord:function(e){var t=Math.floor(e/this._cellSize);return isFinite(t)?t:e},_sqDist:function(e,t){var i=t.x-e.x,n=t.y-e.y;return i*i+n*n}},function(){L.QuickHull={getDistant:function(e,t){var i=t[1].lat-t[0].lat,n=t[0].lng-t[1].lng;return n*(e.lat-t[0].lat)+i*(e.lng-t[0].lng)},findMostDistantPointFromBaseLine:function(e,t){var i,n,r,s=0,o=null,a=[];for(i=t.length-1;i>=0;i--)n=t[i],r=this.getDistant(n,e),r>0&&(a.push(n),r>s&&(s=r,o=n));return{maxPoint:o,newPoints:a}},buildConvexHull:function(e,t){var i=[],n=this.findMostDistantPointFromBaseLine(e,t);return n.maxPoint?(i=i.concat(this.buildConvexHull([e[0],n.maxPoint],n.newPoints)),i=i.concat(this.buildConvexHull([n.maxPoint,e[1]],n.newPoints))):[e[0]]},getConvexHull:function(e){var t,i=!1,n=!1,r=!1,s=!1,o=null,a=null,h=null,l=null,u=null,_=null;for(t=e.length-1;t>=0;t--){var d=e[t];(i===!1||d.lat>i)&&(o=d,i=d.lat),(n===!1||d.lat<n)&&(a=d,n=d.lat),(r===!1||d.lng>r)&&(h=d,r=d.lng),(s===!1||d.lng<s)&&(l=d,s=d.lng)}n!==i?(_=a,u=o):(_=l,u=h);var c=[].concat(this.buildConvexHull([_,u],e),this.buildConvexHull([u,_],e));return c}}}(),L.MarkerCluster.include({getConvexHull:function(){var e,t,i=this.getAllChildMarkers(),n=[];for(t=i.length-1;t>=0;t--)e=i[t].getLatLng(),n.push(e);return L.QuickHull.getConvexHull(n)}}),L.MarkerCluster.include({_2PI:2*Math.PI,_circleFootSeparation:25,_circleStartAngle:Math.PI/6,_spiralFootSeparation:28,_spiralLengthStart:11,_spiralLengthFactor:5,_circleSpiralSwitchover:9,spiderfy:function(){if(this._group._spiderfied!==this&&!this._group._inZoomAnimation){var e,t=this.getAllChildMarkers(),i=this._group,n=i._map,r=n.latLngToLayerPoint(this._latlng);this._group._unspiderfy(),this._group._spiderfied=this,t.length>=this._circleSpiralSwitchover?e=this._generatePointsSpiral(t.length,r):(r.y+=10,e=this._generatePointsCircle(t.length,r)),this._animationSpiderfy(t,e)}},unspiderfy:function(e){this._group._inZoomAnimation||(this._animationUnspiderfy(e),this._group._spiderfied=null)},_generatePointsCircle:function(e,t){var i,n,r=this._group.options.spiderfyDistanceMultiplier*this._circleFootSeparation*(2+e),s=r/this._2PI,o=this._2PI/e,a=[];for(a.length=e,i=e-1;i>=0;i--)n=this._circleStartAngle+i*o,a[i]=new L.Point(t.x+s*Math.cos(n),t.y+s*Math.sin(n))._round();return a},_generatePointsSpiral:function(e,t){var i,n=this._group.options.spiderfyDistanceMultiplier,r=n*this._spiralLengthStart,s=n*this._spiralFootSeparation,o=n*this._spiralLengthFactor*this._2PI,a=0,h=[];for(h.length=e,i=e-1;i>=0;i--)a+=s/r+5e-4*i,h[i]=new L.Point(t.x+r*Math.cos(a),t.y+r*Math.sin(a))._round(),r+=o/a;return h},_noanimationUnspiderfy:function(){var e,t,i=this._group,n=i._map,r=i._featureGroup,s=this.getAllChildMarkers();for(i._ignoreMove=!0,this.setOpacity(1),t=s.length-1;t>=0;t--)e=s[t],r.removeLayer(e),e._preSpiderfyLatlng&&(e.setLatLng(e._preSpiderfyLatlng),delete e._preSpiderfyLatlng),e.setZIndexOffset&&e.setZIndexOffset(0),e._spiderLeg&&(n.removeLayer(e._spiderLeg),delete e._spiderLeg);i.fire("unspiderfied",{cluster:this,markers:s}),i._ignoreMove=!1,i._spiderfied=null}}),L.MarkerClusterNonAnimated=L.MarkerCluster.extend({_animationSpiderfy:function(e,t){var i,n,r,s,o=this._group,a=o._map,h=o._featureGroup,l=this._group.options.spiderLegPolylineOptions;for(o._ignoreMove=!0,i=0;i<e.length;i++)s=a.layerPointToLatLng(t[i]),n=e[i],r=new L.Polyline([this._latlng,s],l),a.addLayer(r),n._spiderLeg=r,n._preSpiderfyLatlng=n._latlng,n.setLatLng(s),n.setZIndexOffset&&n.setZIndexOffset(1e6),h.addLayer(n);this.setOpacity(.3),o._ignoreMove=!1,o.fire("spiderfied",{cluster:this,markers:e})},_animationUnspiderfy:function(){this._noanimationUnspiderfy()}}),L.MarkerCluster.include({_animationSpiderfy:function(e,t){var n,r,s,o,a,h,l=this,u=this._group,_=u._map,d=u._featureGroup,c=this._latlng,p=_.latLngToLayerPoint(c),f=L.Path.SVG,m=L.extend({},this._group.options.spiderLegPolylineOptions),g=m.opacity;for(g===i&&(g=L.MarkerClusterGroup.prototype.options.spiderLegPolylineOptions.opacity),f?(m.opacity=0,m.className=(m.className||"")+" leaflet-cluster-spider-leg"):m.opacity=g,u._ignoreMove=!0,n=0;n<e.length;n++)r=e[n],h=_.layerPointToLatLng(t[n]),s=new L.Polyline([c,h],m),_.addLayer(s),r._spiderLeg=s,f&&(o=s._path,a=o.getTotalLength()+.1,o.style.strokeDasharray=a,o.style.strokeDashoffset=a),r.setZIndexOffset&&r.setZIndexOffset(1e6),r.clusterHide&&r.clusterHide(),d.addLayer(r),r._setPos&&r._setPos(p);for(u._forceLayout(),u._animationStart(),n=e.length-1;n>=0;n--)h=_.layerPointToLatLng(t[n]),r=e[n],r._preSpiderfyLatlng=r._latlng,r.setLatLng(h),r.clusterShow&&r.clusterShow(),f&&(s=r._spiderLeg,o=s._path,o.style.strokeDashoffset=0,s.setStyle({opacity:g}));this.setOpacity(.3),u._ignoreMove=!1,setTimeout(function(){u._animationEnd(),u.fire("spiderfied",{cluster:l,markers:e})},200)},_animationUnspiderfy:function(e){var t,i,n,r,s,o,a=this,h=this._group,l=h._map,u=h._featureGroup,_=e?l._latLngToNewLayerPoint(this._latlng,e.zoom,e.center):l.latLngToLayerPoint(this._latlng),d=this.getAllChildMarkers(),c=L.Path.SVG;for(h._ignoreMove=!0,h._animationStart(),this.setOpacity(1),i=d.length-1;i>=0;i--)t=d[i],t._preSpiderfyLatlng&&(t.closePopup(),t.setLatLng(t._preSpiderfyLatlng),delete t._preSpiderfyLatlng,o=!0,t._setPos&&(t._setPos(_),o=!1),t.clusterHide&&(t.clusterHide(),o=!1),o&&u.removeLayer(t),c&&(n=t._spiderLeg,r=n._path,s=r.getTotalLength()+.1,r.style.strokeDashoffset=s,n.setStyle({opacity:0})));h._ignoreMove=!1,setTimeout(function(){var e=0;for(i=d.length-1;i>=0;i--)t=d[i],t._spiderLeg&&e++;for(i=d.length-1;i>=0;i--)t=d[i],t._spiderLeg&&(t.clusterShow&&t.clusterShow(),t.setZIndexOffset&&t.setZIndexOffset(0),e>1&&u.removeLayer(t),l.removeLayer(t._spiderLeg),delete t._spiderLeg);h._animationEnd(),h.fire("unspiderfied",{cluster:a,markers:d})},200)}}),L.MarkerClusterGroup.include({_spiderfied:null,unspiderfy:function(){this._unspiderfy.apply(this,arguments)},_spiderfierOnAdd:function(){this._map.on("click",this._unspiderfyWrapper,this),this._map.options.zoomAnimation&&this._map.on("zoomstart",this._unspiderfyZoomStart,this),this._map.on("zoomend",this._noanimationUnspiderfy,this),L.Browser.touch||this._map.getRenderer(this)},_spiderfierOnRemove:function(){this._map.off("click",this._unspiderfyWrapper,this),this._map.off("zoomstart",this._unspiderfyZoomStart,this),this._map.off("zoomanim",this._unspiderfyZoomAnim,this),this._map.off("zoomend",this._noanimationUnspiderfy,this),this._noanimationUnspiderfy()},_unspiderfyZoomStart:function(){this._map&&this._map.on("zoomanim",this._unspiderfyZoomAnim,this)},_unspiderfyZoomAnim:function(e){L.DomUtil.hasClass(this._map._mapPane,"leaflet-touching")||(this._map.off("zoomanim",this._unspiderfyZoomAnim,this),this._unspiderfy(e))},_unspiderfyWrapper:function(){this._unspiderfy()
	},_unspiderfy:function(e){this._spiderfied&&this._spiderfied.unspiderfy(e)},_noanimationUnspiderfy:function(){this._spiderfied&&this._spiderfied._noanimationUnspiderfy()},_unspiderfyLayer:function(e){e._spiderLeg&&(this._featureGroup.removeLayer(e),e.clusterShow&&e.clusterShow(),e.setZIndexOffset&&e.setZIndexOffset(0),this._map.removeLayer(e._spiderLeg),delete e._spiderLeg)}}),L.MarkerClusterGroup.include({refreshClusters:function(e){return e?e instanceof L.MarkerClusterGroup?e=e._topClusterLevel.getAllChildMarkers():e instanceof L.LayerGroup?e=e._layers:e instanceof L.MarkerCluster?e=e.getAllChildMarkers():e instanceof L.Marker&&(e=[e]):e=this._topClusterLevel.getAllChildMarkers(),this._flagParentsIconsNeedUpdate(e),this._refreshClustersIcons(),this.options.singleMarkerMode&&this._refreshSingleMarkerModeMarkers(e),this},_flagParentsIconsNeedUpdate:function(e){var t,i;for(t in e)for(i=e[t].__parent;i;)i._iconNeedsUpdate=!0,i=i.__parent},_refreshSingleMarkerModeMarkers:function(e){var t,i;for(t in e)i=e[t],this.hasLayer(i)&&i.setIcon(this._overrideMarkerIcon(i))}}),L.Marker.include({refreshIconOptions:function(e,t){var i=this.options.icon;return L.setOptions(i,e),this.setIcon(i),t&&this.__parent&&this.__parent._group.refreshClusters(this),this}})}(window,document);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {

	var isMSIE8 = !('getComputedStyle' in window && typeof window.getComputedStyle === 'function')

	function extensions(parentClass) { return {

	    initialize: function (options) {
	        parentClass.prototype.initialize.call(this, options);
	        this._originalLayers = [];
	        this._visibleLayers = [];
	        this._staticLayers = [];
	        this._rbush = [];
	        this._cachedRelativeBoxes = [];
	        this._margin = options.margin || 0;
	        this._rbush = null;
	    },

	    addLayer: function(layer) {
	        if ( !('options' in layer) || !('icon' in layer.options)) {
	            this._staticLayers.push(layer);
	            parentClass.prototype.addLayer.call(this, layer);
	            return;
	        }

	        this._originalLayers.push(layer);
	        if (this._map) {
	            this._maybeAddLayerToRBush( layer );
	        }
	    },

	    removeLayer: function(layer) {
	        this._rbush.remove(this._cachedRelativeBoxes[layer._leaflet_id]);
	        delete this._cachedRelativeBoxes[layer._leaflet_id];
	        parentClass.prototype.removeLayer.call(this,layer);
	        var i;

	        i = this._originalLayers.indexOf(layer);
	        if (i !== -1) { this._originalLayers.splice(i,1); }

	        i = this._visibleLayers.indexOf(layer);
	        if (i !== -1) { this._visibleLayers.splice(i,1); }

	        i = this._staticLayers.indexOf(layer);
	        if (i !== -1) { this._staticLayers.splice(i,1); }
	    },

	    clearLayers: function() {
	        this._rbush = rbush();
	        this._originalLayers = [];
	        this._visibleLayers  = [];
	        this._staticLayers   = [];
	        this._cachedRelativeBoxes = [];
	        parentClass.prototype.clearLayers.call(this);
	    },

	    onAdd: function (map) {
	        this._map = map;
	        for (var i  = 0; i < this._staticLayers.length; i++) {
	            map.addLayer(this._staticLayers[i]);
	        }

	        this._onMoveEnd();
	        map.on('zoomend', this._onZoomEnd, this);
	        map.on('moveend', this._onMoveEnd, this);
	    },

	    onRemove: function(map) {
	        for (var i in this._staticLayers) {
	            map.removeLayer(this._staticLayers[i]);
	        }
	        map.off('zoomend', this._onZoomEnd, this);
	        map.off('moveend', this._onMoveEnd, this);
	        parentClass.prototype.onRemove.call(this, map);
	    },

	    _maybeAddLayerToRBush: function(layer) {
	        var z    = this._map.getZoom();
	        var bush = this._rbush;
	        var boxes2 = [[-14,-14,14,14],[-35,-10,35,11]];
	        //var boxes = this._cachedRelativeBoxes[layer._leaflet_id];
	        var visible = false;
	        /*
	         if (!boxes) {
	         // Add the layer to the map so it's instantiated on the DOM,
	         //   in order to fetch its position and size.
	         parentClass.prototype.addLayer.call(this, layer);
	         var visible = true;
	         // 			var htmlElement = layer._icon;
	         var box = this._getIconBox(layer._icon);
	         boxes = this._getRelativeBoxes(layer._icon.children, box);
	         boxes.push(box);
	         this._cachedRelativeBoxes[layer._leaflet_id] = boxes;
	         }
	         */
	        var boxes = this._positionBoxes(this._map.latLngToLayerPoint(layer.getLatLng()),boxes2);

	        var collision = false;
	        for (var i=0; i<boxes.length && !collision; i++) {
	            collision = bush.search(boxes[i]).length > 0;
	        }

	        if (!collision) {
	            if (!visible) {
	                if(!this._map.getBounds().contains(layer.getLatLng())){
	                    parentClass.prototype.removeLayer.call(this, layer);
	                }else {
	                    parentClass.prototype.addLayer.call(this, layer);
	                }
	            }
	            this._visibleLayers.push(layer);
	            bush.load(boxes);
	        } else {
	            parentClass.prototype.removeLayer.call(this, layer);
	        }

	    },


	    // Returns a plain array with the relative dimensions of a L.Icon, based
	    //   on the computed values from iconSize and iconAnchor.
	    _getIconBox: function (el) {

	        if (isMSIE8) {
	            // Fallback for MSIE8, will most probably fail on edge cases
	            return [ 0, 0, el.offsetWidth, el.offsetHeight];
	        }

	        var styles = window.getComputedStyle(el);

	        // getComputedStyle() should return values already in pixels, so using parseInt()
	        //   is not as much as a hack as it seems to be.

	        return [
	            parseInt(styles.marginLeft),
	            parseInt(styles.marginTop),
	            parseInt(styles.marginLeft) + parseInt(styles.width),
	            parseInt(styles.marginTop)  + parseInt(styles.height)
	        ];
	    },


	    // Much like _getIconBox, but works for positioned HTML elements, based on offsetWidth/offsetHeight.
	    _getRelativeBoxes: function(els,baseBox) {
	        var boxes = [];
	        for (var i=0; i<els.length; i++) {
	            var el = els[i];
	            var box = [
	                el.offsetLeft,
	                el.offsetTop,
	                el.offsetLeft + el.offsetWidth,
	                el.offsetTop  + el.offsetHeight
	            ];
	            box = this._offsetBoxes(box, baseBox);
	            boxes.push( box );

	            if (el.children.length) {
	                var parentBox = baseBox;
	                if (!isMSIE8) {
	                    var positionStyle = window.getComputedStyle(el).position;
	                    if (positionStyle === 'absolute' || positionStyle === 'relative') {
	                        parentBox = box;
	                    }
	                }
	                boxes = boxes.concat( this._getRelativeBoxes(el.children, parentBox) );
	            }
	        }
	        return boxes;
	    },

	    _offsetBoxes: function(a,b){
	        return [
	            a[0] + b[0],
	            a[1] + b[1],
	            a[2] + b[0],
	            a[3] + b[1]
	        ];
	    },

	    // Adds the coordinate of the layer (in pixels / map canvas units) to each box coordinate.
	    _positionBoxes: function(offset, boxes) {
	        var newBoxes = [];	// Must be careful to not overwrite references to the original ones.
	        for (var i=0; i<boxes.length; i++) {
	            newBoxes.push( this._positionBox( offset, boxes[i] ) );
	        }
	        return newBoxes;
	    },

	    _positionBox: function(offset, box) {

	        return [
	            box[0] + offset.x - this._margin,
	            box[1] + offset.y - this._margin,
	            box[2] + offset.x + this._margin,
	            box[3] + offset.y + this._margin,
	        ]
	    },

	    _onZoomEnd: function() {
	        for (var i=0; i<this._visibleLayers.length; i++) {
	            parentClass.prototype.removeLayer.call(this, this._visibleLayers[i]);
	        }

	        this._rbush = rbush();

	        for (var i=0; i < this._originalLayers.length; i++) {
	            this._maybeAddLayerToRBush(this._originalLayers[i]);
	        }

	    },

	    _onMoveEnd: function() {
	        for (var i=0; i<this._visibleLayers.length; i++) {
	            parentClass.prototype.removeLayer.call(this, this._visibleLayers[i]);
	        }

	        this._rbush = rbush();

	        for (var i=0; i < this._originalLayers.length; i++) {
	            this._maybeAddLayerToRBush(this._originalLayers[i]);
	        }

	    }
	}};


	L.LayerGroup.Collision   = L.LayerGroup.extend(extensions( L.LayerGroup ));
	L.FeatureGroup.Collision = L.FeatureGroup.extend(extensions( L.FeatureGroup ));
	L.GeoJSON.Collision      = L.GeoJSON.extend(extensions( L.GeoJSON ));

	// Uppercase factories only for backwards compatibility:
	L.LayerGroup.collision = function (options) {
	    return new L.LayerGroup.Collision(options || {});
	};

	L.FeatureGroup.collision = function (options) {
	    return new L.FeatureGroup.Collision(options || {});
	};

	L.GeoJSON.collision = function (options) {
	    return new L.GeoJSON.Collision(options || {});
	};

	// Factories should always be lowercase, like this:
	L.layerGroup.collision = function (options) {
	    return new L.LayerGroup.Collision(options || {});
	};

	L.featureGroup.collision = function (options) {
	    return new L.FeatureGroup.Collision(options || {});
	};

	L.geoJson.collision = function (options) {
	    return new L.GeoJSON.Collision(options || {});
	};


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {L.MapboxGL = L.Layer.extend({
	    options: {
	      updateInterval: 32
	    },

	    initialize: function (options) {
	        L.setOptions(this, options);

	        if (options.accessToken) {
	            mapboxgl.accessToken = options.accessToken;
	        } else {
	            throw new Error('You should provide a Mapbox GL access token as a token option.');
	        }

	         /**
	         * Create a version of `fn` that only fires once every `time` millseconds.
	         *
	         * @param {Function} fn the function to be throttled
	         * @param {number} time millseconds required between function calls
	         * @param {*} context the value of `this` with which the function is called
	         * @returns {Function} debounced function
	         * @private
	         */
	        var throttle = function (fn, time, context) {
	            var lock, args, wrapperFn, later;

	            later = function () {
	                // reset lock and call if queued
	                lock = false;
	                if (args) {
	                    wrapperFn.apply(context, args);
	                    args = false;
	                }
	            };

	            wrapperFn = function () {
	                if (lock) {
	                    // called too soon, queue to call later
	                    args = arguments;

	                } else {
	                    // call and lock until later
	                    fn.apply(context, arguments);
	                    setTimeout(later, time);
	                    lock = true;
	                }
	            };

	            return wrapperFn;
	        };

	        // setup throttling the update event when panning
	        this._throttledUpdate = throttle(L.Util.bind(this._update, this), this.options.updateInterval);
	    },

	    onAdd: function (map) {
	        if (!this._glContainer) {
	            this._initContainer();
	        }

	        map._panes.tilePane.appendChild(this._glContainer);

	        this._initGL();

	        this._offset = this._map.containerPointToLayerPoint([0, 0]);

	        // work around https://github.com/mapbox/mapbox-gl-leaflet/issues/47
	        if (map.options.zoomAnimation) {
	            L.DomEvent.on(map._proxy, L.DomUtil.TRANSITION_END, this._transitionEnd, this);
	        }
	    },

	    onRemove: function (map) {
	        if (this._map.options.zoomAnimation) {
	            L.DomEvent.off(this._map._proxy, L.DomUtil.TRANSITION_END, this._transitionEnd, this);
	        }

	        map.getPanes().tilePane.removeChild(this._glContainer);
	        this._glMap.remove();
	        this._glMap = null;
	    },

	    getEvents: function () {
	        return {
	            move: this._throttledUpdate, // sensibly throttle updating while panning
	            zoomanim: this._animateZoom, // applys the zoom animation to the <canvas>
	            zoom: this._pinchZoom, // animate every zoom event for smoother pinch-zooming
	            zoomstart: this._zoomStart, // flag starting a zoom to disable panning
	            zoomend: this._zoomEnd
	        };
	    },

	    _initContainer: function () {
	        var container = this._glContainer = L.DomUtil.create('div', 'leaflet-gl-layer');

	        var size = this._map.getSize();
	        container.style.width  = size.x + 'px';
	        container.style.height = size.y + 'px';
	    },

	    _initGL: function () {
	        var center = this._map.getCenter();

	        var options = L.extend({}, this.options, {
	            container: this._glContainer,
	            interactive: false,
	            center: [center.lng, center.lat],
	            zoom: this._map.getZoom() - 1,
	            attributionControl: false
	        });

	        this._glMap = new mapboxgl.Map(options);

	        // allow GL base map to pan beyond min/max latitudes
	        this._glMap.transform.latRange = null;

	        if (this._glMap._canvas.canvas) {
	            // older versions of mapbox-gl surfaced the canvas differently
	            this._glMap._actualCanvas = this._glMap._canvas.canvas;
	        } else {
	            this._glMap._actualCanvas = this._glMap._canvas;
	        }

	        // treat child <canvas> element like L.ImageOverlay
	        L.DomUtil.addClass(this._glMap._actualCanvas, 'leaflet-image-layer');
	        L.DomUtil.addClass(this._glMap._actualCanvas, 'leaflet-zoom-animated');

	    },

	    _update: function (e) {
	        // update the offset so we can correct for it later when we zoom
	        this._offset = this._map.containerPointToLayerPoint([0, 0]);

	        if (this._zooming) {
	          return;
	        }

	        var size = this._map.getSize(),
	            container = this._glContainer,
	            gl = this._glMap,
	            topLeft = this._map.containerPointToLayerPoint([0, 0]);

	        L.DomUtil.setPosition(container, topLeft);

	        var center = this._map.getCenter();

	        // gl.setView([center.lat, center.lng], this._map.getZoom() - 1, 0);
	        // calling setView directly causes sync issues because it uses requestAnimFrame

	        var tr = gl.transform;
	        tr.center = mapboxgl.LngLat.convert([center.lng, center.lat]);
	        tr.zoom = this._map.getZoom() - 1;

	        if (gl.transform.width !== size.x || gl.transform.height !== size.y) {
	            container.style.width  = size.x + 'px';
	            container.style.height = size.y + 'px';
	            if (gl._resize !== null && gl._resize !== undefined){
	                gl._resize();
	            } else {
	                gl.resize();
	            }
	        } else {
	            // older versions of mapbox-gl surfaced update publicly
	            if (gl._update !== null && gl._update !== undefined){
	                gl._update();
	            } else {
	                gl.update();
	            }
	        }
	    },

	    // update the map constantly during a pinch zoom
	    _pinchZoom: function (e) {
	      this._glMap.jumpTo({
	        zoom: this._map.getZoom() - 1,
	        center: this._map.getCenter()
	      });
	    },

	    // borrowed from L.ImageOverlay https://github.com/Leaflet/Leaflet/blob/master/src/layer/ImageOverlay.js#L139-L144
	    _animateZoom: function (e) {
	      var scale = this._map.getZoomScale(e.zoom),
	          offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), e.zoom, e.center);

	      L.DomUtil.setTransform(this._glMap._actualCanvas, offset.subtract(this._offset), scale);
	    },

	    _zoomStart: function (e) {
	      this._zooming = true;
	    },

	    _zoomEnd: function () {
	      var scale = this._map.getZoomScale(this._map.getZoom()),
	          offset = this._map._latLngToNewLayerPoint(this._map.getBounds().getNorthWest(), this._map.getZoom(), this._map.getCenter());

	      L.DomUtil.setTransform(this._glMap._actualCanvas, offset.subtract(this._offset), scale);

	      this._zooming = false;
	    },

	    _transitionEnd: function (e) {
	      L.Util.requestAnimFrame(function () {
	          var zoom = this._map.getZoom(),
	          center = this._map.getCenter(),
	          offset = this._map.latLngToContainerPoint(this._map.getBounds().getNorthWest());

	          // reset the scale and offset
	          L.DomUtil.setTransform(this._glMap._actualCanvas, offset, 1);

	          // enable panning once the gl map is ready again
	          this._glMap.once('moveend', L.Util.bind(function () {
	              this._zoomEnd();
	          }, this));

	          // update the map position
	          this._glMap.jumpTo({
	              center: center,
	              zoom: zoom - 1
	          });
	      }, this);
	    }
	});

	L.mapboxGL = function (options) {
	    return new L.MapboxGL(options);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var gju = __webpack_require__(20);

	function isPoly(l) {
	    return l.feature &&
	        l.feature.geometry &&
	        l.feature.geometry.type &&
	        ['Polygon', 'MultiPolygon'].indexOf(l.feature.geometry.type) !== -1;
	}

	var leafletPip = {
	    bassackwards: false,
	    pointInLayer: function(p, layer, first) {
	        if (typeof p.lat === 'number') p = [p.lng, p.lat];
	        else if (leafletPip.bassackwards) p = p.concat().reverse();

	        var results = [];

	        layer.eachLayer(function(l) {
	            if (first && results.length) return;

	            if (isPoly(l) && gju.pointInPolygon({
	                type: 'Point',
	                coordinates: p
	            }, l.toGeoJSON().geometry)) {
	                results.push(l);
	            }
	        });
	        return results;
	    }
	};

	module.exports = leafletPip;


/***/ }),
/* 20 */
/***/ (function(module, exports) {

	(function () {
	  var gju = this.gju = {};

	  // Export the geojson object for **CommonJS**
	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = gju;
	  }

	  // adapted from http://www.kevlindev.com/gui/math/intersection/Intersection.js
	  gju.lineStringsIntersect = function (l1, l2) {
	    var intersects = [];
	    for (var i = 0; i <= l1.coordinates.length - 2; ++i) {
	      for (var j = 0; j <= l2.coordinates.length - 2; ++j) {
	        var a1 = {
	          x: l1.coordinates[i][1],
	          y: l1.coordinates[i][0]
	        },
	          a2 = {
	            x: l1.coordinates[i + 1][1],
	            y: l1.coordinates[i + 1][0]
	          },
	          b1 = {
	            x: l2.coordinates[j][1],
	            y: l2.coordinates[j][0]
	          },
	          b2 = {
	            x: l2.coordinates[j + 1][1],
	            y: l2.coordinates[j + 1][0]
	          },
	          ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
	          ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
	          u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
	        if (u_b != 0) {
	          var ua = ua_t / u_b,
	            ub = ub_t / u_b;
	          if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
	            intersects.push({
	              'type': 'Point',
	              'coordinates': [a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)]
	            });
	          }
	        }
	      }
	    }
	    if (intersects.length == 0) intersects = false;
	    return intersects;
	  }

	  // Bounding Box

	  function boundingBoxAroundPolyCoords (coords) {
	    var xAll = [], yAll = []

	    for (var i = 0; i < coords[0].length; i++) {
	      xAll.push(coords[0][i][1])
	      yAll.push(coords[0][i][0])
	    }

	    xAll = xAll.sort(function (a,b) { return a - b })
	    yAll = yAll.sort(function (a,b) { return a - b })

	    return [ [xAll[0], yAll[0]], [xAll[xAll.length - 1], yAll[yAll.length - 1]] ]
	  }

	  gju.pointInBoundingBox = function (point, bounds) {
	    return !(point.coordinates[1] < bounds[0][0] || point.coordinates[1] > bounds[1][0] || point.coordinates[0] < bounds[0][1] || point.coordinates[0] > bounds[1][1]) 
	  }

	  // Point in Polygon
	  // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html#Listing the Vertices

	  function pnpoly (x,y,coords) {
	    var vert = [ [0,0] ]

	    for (var i = 0; i < coords.length; i++) {
	      for (var j = 0; j < coords[i].length; j++) {
	        vert.push(coords[i][j])
	      }
		  vert.push(coords[i][0])
	      vert.push([0,0])
	    }

	    var inside = false
	    for (var i = 0, j = vert.length - 1; i < vert.length; j = i++) {
	      if (((vert[i][0] > y) != (vert[j][0] > y)) && (x < (vert[j][1] - vert[i][1]) * (y - vert[i][0]) / (vert[j][0] - vert[i][0]) + vert[i][1])) inside = !inside
	    }

	    return inside
	  }

	  gju.pointInPolygon = function (p, poly) {
	    var coords = (poly.type == "Polygon") ? [ poly.coordinates ] : poly.coordinates

	    var insideBox = false
	    for (var i = 0; i < coords.length; i++) {
	      if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[i]))) insideBox = true
	    }
	    if (!insideBox) return false

	    var insidePoly = false
	    for (var i = 0; i < coords.length; i++) {
	      if (pnpoly(p.coordinates[1], p.coordinates[0], coords[i])) insidePoly = true
	    }

	    return insidePoly
	  }

	  // support multi (but not donut) polygons
	  gju.pointInMultiPolygon = function (p, poly) {
	    var coords_array = (poly.type == "MultiPolygon") ? [ poly.coordinates ] : poly.coordinates

	    var insideBox = false
	    var insidePoly = false
	    for (var i = 0; i < coords_array.length; i++){
	      var coords = coords_array[i];
	      for (var j = 0; j < coords.length; j++) {
	        if (!insideBox){
	          if (gju.pointInBoundingBox(p, boundingBoxAroundPolyCoords(coords[j]))) {
	            insideBox = true
	          }
	        }
	      }
	      if (!insideBox) return false
	      for (var j = 0; j < coords.length; j++) {
	        if (!insidePoly){
	          if (pnpoly(p.coordinates[1], p.coordinates[0], coords[j])) {
	            insidePoly = true
	          }
	        }
	      }
	    }

	    return insidePoly
	  }

	  gju.numberToRadius = function (number) {
	    return number * Math.PI / 180;
	  }

	  gju.numberToDegree = function (number) {
	    return number * 180 / Math.PI;
	  }

	  // written with help from @tautologe
	  gju.drawCircle = function (radiusInMeters, centerPoint, steps) {
	    var center = [centerPoint.coordinates[1], centerPoint.coordinates[0]],
	      dist = (radiusInMeters / 1000) / 6371,
	      // convert meters to radiant
	      radCenter = [gju.numberToRadius(center[0]), gju.numberToRadius(center[1])],
	      steps = steps || 15,
	      // 15 sided circle
	      poly = [[center[0], center[1]]];
	    for (var i = 0; i < steps; i++) {
	      var brng = 2 * Math.PI * i / steps;
	      var lat = Math.asin(Math.sin(radCenter[0]) * Math.cos(dist)
	              + Math.cos(radCenter[0]) * Math.sin(dist) * Math.cos(brng));
	      var lng = radCenter[1] + Math.atan2(Math.sin(brng) * Math.sin(dist) * Math.cos(radCenter[0]),
	                                          Math.cos(dist) - Math.sin(radCenter[0]) * Math.sin(lat));
	      poly[i] = [];
	      poly[i][1] = gju.numberToDegree(lat);
	      poly[i][0] = gju.numberToDegree(lng);
	    }
	    return {
	      "type": "Polygon",
	      "coordinates": [poly]
	    };
	  }

	  // assumes rectangle starts at lower left point
	  gju.rectangleCentroid = function (rectangle) {
	    var bbox = rectangle.coordinates[0];
	    var xmin = bbox[0][0],
	      ymin = bbox[0][1],
	      xmax = bbox[2][0],
	      ymax = bbox[2][1];
	    var xwidth = xmax - xmin;
	    var ywidth = ymax - ymin;
	    return {
	      'type': 'Point',
	      'coordinates': [xmin + xwidth / 2, ymin + ywidth / 2]
	    };
	  }

	  // from http://www.movable-type.co.uk/scripts/latlong.html
	  gju.pointDistance = function (pt1, pt2) {
	    var lon1 = pt1.coordinates[0],
	      lat1 = pt1.coordinates[1],
	      lon2 = pt2.coordinates[0],
	      lat2 = pt2.coordinates[1],
	      dLat = gju.numberToRadius(lat2 - lat1),
	      dLon = gju.numberToRadius(lon2 - lon1),
	      a = Math.pow(Math.sin(dLat / 2), 2) + Math.cos(gju.numberToRadius(lat1))
	        * Math.cos(gju.numberToRadius(lat2)) * Math.pow(Math.sin(dLon / 2), 2),
	      c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	    return (6371 * c) * 1000; // returns meters
	  },

	  // checks if geometry lies entirely within a circle
	  // works with Point, LineString, Polygon
	  gju.geometryWithinRadius = function (geometry, center, radius) {
	    if (geometry.type == 'Point') {
	      return gju.pointDistance(geometry, center) <= radius;
	    } else if (geometry.type == 'LineString' || geometry.type == 'Polygon') {
	      var point = {};
	      var coordinates;
	      if (geometry.type == 'Polygon') {
	        // it's enough to check the exterior ring of the Polygon
	        coordinates = geometry.coordinates[0];
	      } else {
	        coordinates = geometry.coordinates;
	      }
	      for (var i in coordinates) {
	        point.coordinates = coordinates[i];
	        if (gju.pointDistance(point, center) > radius) {
	          return false;
	        }
	      }
	    }
	    return true;
	  }

	  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
	  gju.area = function (polygon) {
	    var area = 0;
	    // TODO: polygon holes at coordinates[1]
	    var points = polygon.coordinates[0];
	    var j = points.length - 1;
	    var p1, p2;

	    for (var i = 0; i < points.length; j = i++) {
	      var p1 = {
	        x: points[i][1],
	        y: points[i][0]
	      };
	      var p2 = {
	        x: points[j][1],
	        y: points[j][0]
	      };
	      area += p1.x * p2.y;
	      area -= p1.y * p2.x;
	    }

	    area /= 2;
	    return area;
	  },

	  // adapted from http://paulbourke.net/geometry/polyarea/javascript.txt
	  gju.centroid = function (polygon) {
	    var f, x = 0,
	      y = 0;
	    // TODO: polygon holes at coordinates[1]
	    var points = polygon.coordinates[0];
	    var j = points.length - 1;
	    var p1, p2;

	    for (var i = 0; i < points.length; j = i++) {
	      var p1 = {
	        x: points[i][1],
	        y: points[i][0]
	      };
	      var p2 = {
	        x: points[j][1],
	        y: points[j][0]
	      };
	      f = p1.x * p2.y - p2.x * p1.y;
	      x += (p1.x + p2.x) * f;
	      y += (p1.y + p2.y) * f;
	    }

	    f = gju.area(polygon) * 6;
	    return {
	      'type': 'Point',
	      'coordinates': [y / f, x / f]
	    };
	  },

	  gju.simplify = function (source, kink) { /* source[] array of geojson points */
	    /* kink	in metres, kinks above this depth kept  */
	    /* kink depth is the height of the triangle abc where a-b and b-c are two consecutive line segments */
	    kink = kink || 20;
	    source = source.map(function (o) {
	      return {
	        lng: o.coordinates[0],
	        lat: o.coordinates[1]
	      }
	    });

	    var n_source, n_stack, n_dest, start, end, i, sig;
	    var dev_sqr, max_dev_sqr, band_sqr;
	    var x12, y12, d12, x13, y13, d13, x23, y23, d23;
	    var F = (Math.PI / 180.0) * 0.5;
	    var index = new Array(); /* aray of indexes of source points to include in the reduced line */
	    var sig_start = new Array(); /* indices of start & end of working section */
	    var sig_end = new Array();

	    /* check for simple cases */

	    if (source.length < 3) return (source); /* one or two points */

	    /* more complex case. initialize stack */

	    n_source = source.length;
	    band_sqr = kink * 360.0 / (2.0 * Math.PI * 6378137.0); /* Now in degrees */
	    band_sqr *= band_sqr;
	    n_dest = 0;
	    sig_start[0] = 0;
	    sig_end[0] = n_source - 1;
	    n_stack = 1;

	    /* while the stack is not empty  ... */
	    while (n_stack > 0) {

	      /* ... pop the top-most entries off the stacks */

	      start = sig_start[n_stack - 1];
	      end = sig_end[n_stack - 1];
	      n_stack--;

	      if ((end - start) > 1) { /* any intermediate points ? */

	        /* ... yes, so find most deviant intermediate point to
	        either side of line joining start & end points */

	        x12 = (source[end].lng() - source[start].lng());
	        y12 = (source[end].lat() - source[start].lat());
	        if (Math.abs(x12) > 180.0) x12 = 360.0 - Math.abs(x12);
	        x12 *= Math.cos(F * (source[end].lat() + source[start].lat())); /* use avg lat to reduce lng */
	        d12 = (x12 * x12) + (y12 * y12);

	        for (i = start + 1, sig = start, max_dev_sqr = -1.0; i < end; i++) {

	          x13 = source[i].lng() - source[start].lng();
	          y13 = source[i].lat() - source[start].lat();
	          if (Math.abs(x13) > 180.0) x13 = 360.0 - Math.abs(x13);
	          x13 *= Math.cos(F * (source[i].lat() + source[start].lat()));
	          d13 = (x13 * x13) + (y13 * y13);

	          x23 = source[i].lng() - source[end].lng();
	          y23 = source[i].lat() - source[end].lat();
	          if (Math.abs(x23) > 180.0) x23 = 360.0 - Math.abs(x23);
	          x23 *= Math.cos(F * (source[i].lat() + source[end].lat()));
	          d23 = (x23 * x23) + (y23 * y23);

	          if (d13 >= (d12 + d23)) dev_sqr = d23;
	          else if (d23 >= (d12 + d13)) dev_sqr = d13;
	          else dev_sqr = (x13 * y12 - y13 * x12) * (x13 * y12 - y13 * x12) / d12; // solve triangle
	          if (dev_sqr > max_dev_sqr) {
	            sig = i;
	            max_dev_sqr = dev_sqr;
	          }
	        }

	        if (max_dev_sqr < band_sqr) { /* is there a sig. intermediate point ? */
	          /* ... no, so transfer current start point */
	          index[n_dest] = start;
	          n_dest++;
	        } else { /* ... yes, so push two sub-sections on stack for further processing */
	          n_stack++;
	          sig_start[n_stack - 1] = sig;
	          sig_end[n_stack - 1] = end;
	          n_stack++;
	          sig_start[n_stack - 1] = start;
	          sig_end[n_stack - 1] = sig;
	        }
	      } else { /* ... no intermediate points, so transfer current start point */
	        index[n_dest] = start;
	        n_dest++;
	      }
	    }

	    /* transfer last point */
	    index[n_dest] = n_source - 1;
	    n_dest++;

	    /* make return array */
	    var r = new Array();
	    for (var i = 0; i < n_dest; i++)
	      r.push(source[index[i]]);

	    return r.map(function (o) {
	      return {
	        type: "Point",
	        coordinates: [o.lng, o.lat]
	      }
	    });
	  }

	  // http://www.movable-type.co.uk/scripts/latlong.html#destPoint
	  gju.destinationPoint = function (pt, brng, dist) {
	    dist = dist/6371;  // convert dist to angular distance in radians
	    brng = gju.numberToRadius(brng);

	    var lon1 = gju.numberToRadius(pt.coordinates[0]);
	    var lat1 = gju.numberToRadius(pt.coordinates[1]);

	    var lat2 = Math.asin( Math.sin(lat1)*Math.cos(dist) +
	                          Math.cos(lat1)*Math.sin(dist)*Math.cos(brng) );
	    var lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(dist)*Math.cos(lat1),
	                                 Math.cos(dist)-Math.sin(lat1)*Math.sin(lat2));
	    lon2 = (lon2+3*Math.PI) % (2*Math.PI) - Math.PI;  // normalise to -180..+180º

	    return {
	      'type': 'Point',
	      'coordinates': [gju.numberToDegree(lon2), gju.numberToDegree(lat2)]
	    };
	  };

	})();


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery Mousewheel 3.1.13
	 *
	 * Copyright jQuery Foundation and other contributors
	 * Released under the MIT license
	 * http://jquery.org/license
	 */

	(function (factory) {
	    if ( true ) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports === 'object') {
	        // Node/CommonJS style for Browserify
	        module.exports = factory;
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	}(function ($) {

	    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
	        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
	                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
	        slice  = Array.prototype.slice,
	        nullLowestDeltaTimeout, lowestDelta;

	    if ( $.event.fixHooks ) {
	        for ( var i = toFix.length; i; ) {
	            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
	        }
	    }

	    var special = $.event.special.mousewheel = {
	        version: '3.1.12',

	        setup: function() {
	            if ( this.addEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.addEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = handler;
	            }
	            // Store the line height and page height for this particular element
	            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
	            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
	        },

	        teardown: function() {
	            if ( this.removeEventListener ) {
	                for ( var i = toBind.length; i; ) {
	                    this.removeEventListener( toBind[--i], handler, false );
	                }
	            } else {
	                this.onmousewheel = null;
	            }
	            // Clean up the data we added to the element
	            $.removeData(this, 'mousewheel-line-height');
	            $.removeData(this, 'mousewheel-page-height');
	        },

	        getLineHeight: function(elem) {
	            var $elem = $(elem),
	                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
	            if (!$parent.length) {
	                $parent = $('body');
	            }
	            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
	        },

	        getPageHeight: function(elem) {
	            return $(elem).height();
	        },

	        settings: {
	            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
	            normalizeOffset: true  // calls getBoundingClientRect for each event
	        }
	    };

	    $.fn.extend({
	        mousewheel: function(fn) {
	            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
	        },

	        unmousewheel: function(fn) {
	            return this.unbind('mousewheel', fn);
	        }
	    });


	    function handler(event) {
	        var orgEvent   = event || window.event,
	            args       = slice.call(arguments, 1),
	            delta      = 0,
	            deltaX     = 0,
	            deltaY     = 0,
	            absDelta   = 0,
	            offsetX    = 0,
	            offsetY    = 0;
	        event = $.event.fix(orgEvent);
	        event.type = 'mousewheel';

	        // Old school scrollwheel delta
	        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
	        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
	        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
	        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

	        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
	        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
	            deltaX = deltaY * -1;
	            deltaY = 0;
	        }

	        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
	        delta = deltaY === 0 ? deltaX : deltaY;

	        // New school wheel delta (wheel event)
	        if ( 'deltaY' in orgEvent ) {
	            deltaY = orgEvent.deltaY * -1;
	            delta  = deltaY;
	        }
	        if ( 'deltaX' in orgEvent ) {
	            deltaX = orgEvent.deltaX;
	            if ( deltaY === 0 ) { delta  = deltaX * -1; }
	        }

	        // No change actually happened, no reason to go any further
	        if ( deltaY === 0 && deltaX === 0 ) { return; }

	        // Need to convert lines and pages to pixels if we aren't already in pixels
	        // There are three delta modes:
	        //   * deltaMode 0 is by pixels, nothing to do
	        //   * deltaMode 1 is by lines
	        //   * deltaMode 2 is by pages
	        if ( orgEvent.deltaMode === 1 ) {
	            var lineHeight = $.data(this, 'mousewheel-line-height');
	            delta  *= lineHeight;
	            deltaY *= lineHeight;
	            deltaX *= lineHeight;
	        } else if ( orgEvent.deltaMode === 2 ) {
	            var pageHeight = $.data(this, 'mousewheel-page-height');
	            delta  *= pageHeight;
	            deltaY *= pageHeight;
	            deltaX *= pageHeight;
	        }

	        // Store lowest absolute delta to normalize the delta values
	        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

	        if ( !lowestDelta || absDelta < lowestDelta ) {
	            lowestDelta = absDelta;

	            // Adjust older deltas if necessary
	            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	                lowestDelta /= 40;
	            }
	        }

	        // Adjust older deltas if necessary
	        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
	            // Divide all the things by 40!
	            delta  /= 40;
	            deltaX /= 40;
	            deltaY /= 40;
	        }

	        // Get a whole, normalized value for the deltas
	        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
	        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
	        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

	        // Normalise offsetX and offsetY properties
	        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
	            var boundingRect = this.getBoundingClientRect();
	            offsetX = event.clientX - boundingRect.left;
	            offsetY = event.clientY - boundingRect.top;
	        }

	        // Add information to the event object
	        event.deltaX = deltaX;
	        event.deltaY = deltaY;
	        event.deltaFactor = lowestDelta;
	        event.offsetX = offsetX;
	        event.offsetY = offsetY;
	        // Go ahead and set deltaMode to 0 since we converted to pixels
	        // Although this is a little odd since we overwrite the deltaX/Y
	        // properties with normalized deltas.
	        event.deltaMode = 0;

	        // Add event and delta to the front of the arguments
	        args.unshift(event, delta, deltaX, deltaY);

	        // Clearout lowestDelta after sometime to better
	        // handle multiple device types that give different
	        // a different lowestDelta
	        // Ex: trackpad = 3 and mouse wheel = 120
	        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
	        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

	        return ($.event.dispatch || $.event.handle).apply(this, args);
	    }

	    function nullLowestDelta() {
	        lowestDelta = null;
	    }

	    function shouldAdjustOldDeltas(orgEvent, absDelta) {
	        // If this is an older event and the delta is divisable by 120,
	        // then we are assuming that the browser is treating this as an
	        // older mouse wheel event and that we should divide the deltas
	        // by 40 to try and get a more usable deltaFactor.
	        // Side note, this actually impacts the reported scroll distance
	        // in older browsers and can cause scrolling to be slower than native.
	        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
	        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
	    }

	}));


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.proj4 = factory());
	}(this, (function () { 'use strict';

		var globals = function(defs) {
		  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
		  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
		  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

		  defs.WGS84 = defs['EPSG:4326'];
		  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
		  defs.GOOGLE = defs['EPSG:3857'];
		  defs['EPSG:900913'] = defs['EPSG:3857'];
		  defs['EPSG:102113'] = defs['EPSG:3857'];
		};

		var PJD_3PARAM = 1;
		var PJD_7PARAM = 2;
		var PJD_WGS84 = 4; // WGS84 or equivalent
		var PJD_NODATUM = 5; // WGS84 or equivalent
		var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
		var HALF_PI = Math.PI/2;
		// ellipoid pj_set_ell.c
		var SIXTH = 0.1666666666666666667;
		/* 1/6 */
		var RA4 = 0.04722222222222222222;
		/* 17/360 */
		var RA6 = 0.02215608465608465608;
		var EPSLN = 1.0e-10;
		// you'd think you could use Number.EPSILON above but that makes
		// Mollweide get into an infinate loop.

		var D2R = 0.01745329251994329577;
		var R2D = 57.29577951308232088;
		var FORTPI = Math.PI/4;
		var TWO_PI = Math.PI * 2;
		// SPI is slightly greater than Math.PI, so values that exceed the -180..180
		// degree range by a tiny amount don't get wrapped. This prevents points that
		// have drifted from their original location along the 180th meridian (due to
		// floating point error) from changing their sign.
		var SPI = 3.14159265359;

		var exports$1 = {};
		exports$1.greenwich = 0.0; //"0dE",
		exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
		exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
		exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
		exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
		exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
		exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
		exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
		exports$1.ferro = -17.666666666667; //"17d40'W",
		exports$1.brussels = 4.367975; //"4d22'4.71\"E",
		exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
		exports$1.athens = 23.7163375; //"23d42'58.815\"E",
		exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

		var units = {
		  ft: {to_meter: 0.3048},
		  'us-ft': {to_meter: 1200 / 3937}
		};

		var ignoredChar = /[\s_\-\/\(\)]/g;
		function match(obj, key) {
		  if (obj[key]) {
		    return obj[key];
		  }
		  var keys = Object.keys(obj);
		  var lkey = key.toLowerCase().replace(ignoredChar, '');
		  var i = -1;
		  var testkey, processedKey;
		  while (++i < keys.length) {
		    testkey = keys[i];
		    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
		    if (processedKey === lkey) {
		      return obj[testkey];
		    }
		  }
		}

		var parseProj = function(defData) {
		  var self = {};
		  var paramObj = defData.split('+').map(function(v) {
		    return v.trim();
		  }).filter(function(a) {
		    return a;
		  }).reduce(function(p, a) {
		    var split = a.split('=');
		    split.push(true);
		    p[split[0].toLowerCase()] = split[1];
		    return p;
		  }, {});
		  var paramName, paramVal, paramOutname;
		  var params = {
		    proj: 'projName',
		    datum: 'datumCode',
		    rf: function(v) {
		      self.rf = parseFloat(v);
		    },
		    lat_0: function(v) {
		      self.lat0 = v * D2R;
		    },
		    lat_1: function(v) {
		      self.lat1 = v * D2R;
		    },
		    lat_2: function(v) {
		      self.lat2 = v * D2R;
		    },
		    lat_ts: function(v) {
		      self.lat_ts = v * D2R;
		    },
		    lon_0: function(v) {
		      self.long0 = v * D2R;
		    },
		    lon_1: function(v) {
		      self.long1 = v * D2R;
		    },
		    lon_2: function(v) {
		      self.long2 = v * D2R;
		    },
		    alpha: function(v) {
		      self.alpha = parseFloat(v) * D2R;
		    },
		    lonc: function(v) {
		      self.longc = v * D2R;
		    },
		    x_0: function(v) {
		      self.x0 = parseFloat(v);
		    },
		    y_0: function(v) {
		      self.y0 = parseFloat(v);
		    },
		    k_0: function(v) {
		      self.k0 = parseFloat(v);
		    },
		    k: function(v) {
		      self.k0 = parseFloat(v);
		    },
		    a: function(v) {
		      self.a = parseFloat(v);
		    },
		    b: function(v) {
		      self.b = parseFloat(v);
		    },
		    r_a: function() {
		      self.R_A = true;
		    },
		    zone: function(v) {
		      self.zone = parseInt(v, 10);
		    },
		    south: function() {
		      self.utmSouth = true;
		    },
		    towgs84: function(v) {
		      self.datum_params = v.split(",").map(function(a) {
		        return parseFloat(a);
		      });
		    },
		    to_meter: function(v) {
		      self.to_meter = parseFloat(v);
		    },
		    units: function(v) {
		      self.units = v;
		      var unit = match(units, v);
		      if (unit) {
		        self.to_meter = unit.to_meter;
		      }
		    },
		    from_greenwich: function(v) {
		      self.from_greenwich = v * D2R;
		    },
		    pm: function(v) {
		      var pm = match(exports$1, v);
		      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
		    },
		    nadgrids: function(v) {
		      if (v === '@null') {
		        self.datumCode = 'none';
		      }
		      else {
		        self.nadgrids = v;
		      }
		    },
		    axis: function(v) {
		      var legalAxis = "ewnsud";
		      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
		        self.axis = v;
		      }
		    }
		  };
		  for (paramName in paramObj) {
		    paramVal = paramObj[paramName];
		    if (paramName in params) {
		      paramOutname = params[paramName];
		      if (typeof paramOutname === 'function') {
		        paramOutname(paramVal);
		      }
		      else {
		        self[paramOutname] = paramVal;
		      }
		    }
		    else {
		      self[paramName] = paramVal;
		    }
		  }
		  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
		    self.datumCode = self.datumCode.toLowerCase();
		  }
		  return self;
		};

		var NEUTRAL = 1;
		var KEYWORD = 2;
		var NUMBER = 3;
		var QUOTED = 4;
		var AFTERQUOTE = 5;
		var ENDED = -1;
		var whitespace = /\s/;
		var latin = /[A-Za-z]/;
		var keyword = /[A-Za-z84]/;
		var endThings = /[,\]]/;
		var digets = /[\d\.E\-\+]/;
		// const ignoredChar = /[\s_\-\/\(\)]/g;
		function Parser(text) {
		  if (typeof text !== 'string') {
		    throw new Error('not a string');
		  }
		  this.text = text.trim();
		  this.level = 0;
		  this.place = 0;
		  this.root = null;
		  this.stack = [];
		  this.currentObject = null;
		  this.state = NEUTRAL;
		}
		Parser.prototype.readCharicter = function() {
		  var char = this.text[this.place++];
		  if (this.state !== QUOTED) {
		    while (whitespace.test(char)) {
		      if (this.place >= this.text.length) {
		        return;
		      }
		      char = this.text[this.place++];
		    }
		  }
		  switch (this.state) {
		    case NEUTRAL:
		      return this.neutral(char);
		    case KEYWORD:
		      return this.keyword(char)
		    case QUOTED:
		      return this.quoted(char);
		    case AFTERQUOTE:
		      return this.afterquote(char);
		    case NUMBER:
		      return this.number(char);
		    case ENDED:
		      return;
		  }
		};
		Parser.prototype.afterquote = function(char) {
		  if (char === '"') {
		    this.word += '"';
		    this.state = QUOTED;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.word = this.word.trim();
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
		};
		Parser.prototype.afterItem = function(char) {
		  if (char === ',') {
		    if (this.word !== null) {
		      this.currentObject.push(this.word);
		    }
		    this.word = null;
		    this.state = NEUTRAL;
		    return;
		  }
		  if (char === ']') {
		    this.level--;
		    if (this.word !== null) {
		      this.currentObject.push(this.word);
		      this.word = null;
		    }
		    this.state = NEUTRAL;
		    this.currentObject = this.stack.pop();
		    if (!this.currentObject) {
		      this.state = ENDED;
		    }

		    return;
		  }
		};
		Parser.prototype.number = function(char) {
		  if (digets.test(char)) {
		    this.word += char;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.word = parseFloat(this.word);
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
		};
		Parser.prototype.quoted = function(char) {
		  if (char === '"') {
		    this.state = AFTERQUOTE;
		    return;
		  }
		  this.word += char;
		  return;
		};
		Parser.prototype.keyword = function(char) {
		  if (keyword.test(char)) {
		    this.word += char;
		    return;
		  }
		  if (char === '[') {
		    var newObjects = [];
		    newObjects.push(this.word);
		    this.level++;
		    if (this.root === null) {
		      this.root = newObjects;
		    } else {
		      this.currentObject.push(newObjects);
		    }
		    this.stack.push(this.currentObject);
		    this.currentObject = newObjects;
		    this.state = NEUTRAL;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
		};
		Parser.prototype.neutral = function(char) {
		  if (latin.test(char)) {
		    this.word = char;
		    this.state = KEYWORD;
		    return;
		  }
		  if (char === '"') {
		    this.word = '';
		    this.state = QUOTED;
		    return;
		  }
		  if (digets.test(char)) {
		    this.word = char;
		    this.state = NUMBER;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
		};
		Parser.prototype.output = function() {
		  while (this.place < this.text.length) {
		    this.readCharicter();
		  }
		  if (this.state === ENDED) {
		    return this.root;
		  }
		  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
		};

		function parseString(txt) {
		  var parser = new Parser(txt);
		  return parser.output();
		}

		function mapit(obj, key, value) {
		  if (Array.isArray(key)) {
		    value.unshift(key);
		    key = null;
		  }
		  var thing = key ? {} : obj;

		  var out = value.reduce(function(newObj, item) {
		    sExpr(item, newObj);
		    return newObj
		  }, thing);
		  if (key) {
		    obj[key] = out;
		  }
		}

		function sExpr(v, obj) {
		  if (!Array.isArray(v)) {
		    obj[v] = true;
		    return;
		  }
		  var key = v.shift();
		  if (key === 'PARAMETER') {
		    key = v.shift();
		  }
		  if (v.length === 1) {
		    if (Array.isArray(v[0])) {
		      obj[key] = {};
		      sExpr(v[0], obj[key]);
		      return;
		    }
		    obj[key] = v[0];
		    return;
		  }
		  if (!v.length) {
		    obj[key] = true;
		    return;
		  }
		  if (key === 'TOWGS84') {
		    obj[key] = v;
		    return;
		  }
		  if (!Array.isArray(key)) {
		    obj[key] = {};
		  }

		  var i;
		  switch (key) {
		    case 'UNIT':
		    case 'PRIMEM':
		    case 'VERT_DATUM':
		      obj[key] = {
		        name: v[0].toLowerCase(),
		        convert: v[1]
		      };
		      if (v.length === 3) {
		        sExpr(v[2], obj[key]);
		      }
		      return;
		    case 'SPHEROID':
		    case 'ELLIPSOID':
		      obj[key] = {
		        name: v[0],
		        a: v[1],
		        rf: v[2]
		      };
		      if (v.length === 4) {
		        sExpr(v[3], obj[key]);
		      }
		      return;
		    case 'PROJECTEDCRS':
		    case 'PROJCRS':
		    case 'GEOGCS':
		    case 'GEOCCS':
		    case 'PROJCS':
		    case 'LOCAL_CS':
		    case 'GEODCRS':
		    case 'GEODETICCRS':
		    case 'GEODETICDATUM':
		    case 'EDATUM':
		    case 'ENGINEERINGDATUM':
		    case 'VERT_CS':
		    case 'VERTCRS':
		    case 'VERTICALCRS':
		    case 'COMPD_CS':
		    case 'COMPOUNDCRS':
		    case 'ENGINEERINGCRS':
		    case 'ENGCRS':
		    case 'FITTED_CS':
		    case 'LOCAL_DATUM':
		    case 'DATUM':
		      v[0] = ['name', v[0]];
		      mapit(obj, key, v);
		      return;
		    default:
		      i = -1;
		      while (++i < v.length) {
		        if (!Array.isArray(v[i])) {
		          return sExpr(v, obj[key]);
		        }
		      }
		      return mapit(obj, key, v);
		  }
		}

		var D2R$1 = 0.01745329251994329577;
		function rename(obj, params) {
		  var outName = params[0];
		  var inName = params[1];
		  if (!(outName in obj) && (inName in obj)) {
		    obj[outName] = obj[inName];
		    if (params.length === 3) {
		      obj[outName] = params[2](obj[outName]);
		    }
		  }
		}

		function d2r(input) {
		  return input * D2R$1;
		}

		function cleanWKT(wkt) {
		  if (wkt.type === 'GEOGCS') {
		    wkt.projName = 'longlat';
		  } else if (wkt.type === 'LOCAL_CS') {
		    wkt.projName = 'identity';
		    wkt.local = true;
		  } else {
		    if (typeof wkt.PROJECTION === 'object') {
		      wkt.projName = Object.keys(wkt.PROJECTION)[0];
		    } else {
		      wkt.projName = wkt.PROJECTION;
		    }
		  }
		  if (wkt.UNIT) {
		    wkt.units = wkt.UNIT.name.toLowerCase();
		    if (wkt.units === 'metre') {
		      wkt.units = 'meter';
		    }
		    if (wkt.UNIT.convert) {
		      if (wkt.type === 'GEOGCS') {
		        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
		          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
		        }
		      } else {
		        wkt.to_meter = wkt.UNIT.convert, 10;
		      }
		    }
		  }
		  var geogcs = wkt.GEOGCS;
		  if (wkt.type === 'GEOGCS') {
		    geogcs = wkt;
		  }
		  if (geogcs) {
		    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
		    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
		    //}
		    if (geogcs.DATUM) {
		      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
		    } else {
		      wkt.datumCode = geogcs.name.toLowerCase();
		    }
		    if (wkt.datumCode.slice(0, 2) === 'd_') {
		      wkt.datumCode = wkt.datumCode.slice(2);
		    }
		    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
		      wkt.datumCode = 'nzgd49';
		    }
		    if (wkt.datumCode === 'wgs_1984') {
		      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
		        wkt.sphere = true;
		      }
		      wkt.datumCode = 'wgs84';
		    }
		    if (wkt.datumCode.slice(-6) === '_ferro') {
		      wkt.datumCode = wkt.datumCode.slice(0, - 6);
		    }
		    if (wkt.datumCode.slice(-8) === '_jakarta') {
		      wkt.datumCode = wkt.datumCode.slice(0, - 8);
		    }
		    if (~wkt.datumCode.indexOf('belge')) {
		      wkt.datumCode = 'rnb72';
		    }
		    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
		      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
		      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
		        wkt.ellps = 'intl';
		      }

		      wkt.a = geogcs.DATUM.SPHEROID.a;
		      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
		    }
		    if (~wkt.datumCode.indexOf('osgb_1936')) {
		      wkt.datumCode = 'osgb36';
		    }
		    if (~wkt.datumCode.indexOf('osni_1952')) {
		      wkt.datumCode = 'osni52';
		    }
		    if (~wkt.datumCode.indexOf('tm65')
		      || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
		      wkt.datumCode = 'ire65';
		    }
		  }
		  if (wkt.b && !isFinite(wkt.b)) {
		    wkt.b = wkt.a;
		  }

		  function toMeter(input) {
		    var ratio = wkt.to_meter || 1;
		    return input * ratio;
		  }
		  var renamer = function(a) {
		    return rename(wkt, a);
		  };
		  var list = [
		    ['standard_parallel_1', 'Standard_Parallel_1'],
		    ['standard_parallel_2', 'Standard_Parallel_2'],
		    ['false_easting', 'False_Easting'],
		    ['false_northing', 'False_Northing'],
		    ['central_meridian', 'Central_Meridian'],
		    ['latitude_of_origin', 'Latitude_Of_Origin'],
		    ['latitude_of_origin', 'Central_Parallel'],
		    ['scale_factor', 'Scale_Factor'],
		    ['k0', 'scale_factor'],
		    ['latitude_of_center', 'Latitude_of_center'],
		    ['lat0', 'latitude_of_center', d2r],
		    ['longitude_of_center', 'Longitude_Of_Center'],
		    ['longc', 'longitude_of_center', d2r],
		    ['x0', 'false_easting', toMeter],
		    ['y0', 'false_northing', toMeter],
		    ['long0', 'central_meridian', d2r],
		    ['lat0', 'latitude_of_origin', d2r],
		    ['lat0', 'standard_parallel_1', d2r],
		    ['lat1', 'standard_parallel_1', d2r],
		    ['lat2', 'standard_parallel_2', d2r],
		    ['alpha', 'azimuth', d2r],
		    ['srsCode', 'name']
		  ];
		  list.forEach(renamer);
		  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
		    wkt.long0 = wkt.longc;
		  }
		  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
		    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
		    wkt.lat_ts = wkt.lat1;
		  }
		}
		var wkt = function(wkt) {
		  var lisp = parseString(wkt);
		  var type = lisp.shift();
		  var name = lisp.shift();
		  lisp.unshift(['name', name]);
		  lisp.unshift(['type', type]);
		  var obj = {};
		  sExpr(lisp, obj);
		  cleanWKT(obj);
		  return obj;
		};

		function defs(name) {
		  /*global console*/
		  var that = this;
		  if (arguments.length === 2) {
		    var def = arguments[1];
		    if (typeof def === 'string') {
		      if (def.charAt(0) === '+') {
		        defs[name] = parseProj(arguments[1]);
		      }
		      else {
		        defs[name] = wkt(arguments[1]);
		      }
		    } else {
		      defs[name] = def;
		    }
		  }
		  else if (arguments.length === 1) {
		    if (Array.isArray(name)) {
		      return name.map(function(v) {
		        if (Array.isArray(v)) {
		          defs.apply(that, v);
		        }
		        else {
		          defs(v);
		        }
		      });
		    }
		    else if (typeof name === 'string') {
		      if (name in defs) {
		        return defs[name];
		      }
		    }
		    else if ('EPSG' in name) {
		      defs['EPSG:' + name.EPSG] = name;
		    }
		    else if ('ESRI' in name) {
		      defs['ESRI:' + name.ESRI] = name;
		    }
		    else if ('IAU2000' in name) {
		      defs['IAU2000:' + name.IAU2000] = name;
		    }
		    else {
		      console.log(name);
		    }
		    return;
		  }


		}
		globals(defs);

		function testObj(code){
		  return typeof code === 'string';
		}
		function testDef(code){
		  return code in defs;
		}
		 var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; 
		function testWKT(code){
		  return codeWords.some(function (word) {
		    return code.indexOf(word) > -1;
		  });
		}
		function testProj(code){
		  return code[0] === '+';
		}
		function parse(code){
		  if (testObj(code)) {
		    //check to see if this is a WKT string
		    if (testDef(code)) {
		      return defs[code];
		    }
		    if (testWKT(code)) {
		      return wkt(code);
		    }
		    if (testProj(code)) {
		      return parseProj(code);
		    }
		  }else{
		    return code;
		  }
		}

		var extend = function(destination, source) {
		  destination = destination || {};
		  var value, property;
		  if (!source) {
		    return destination;
		  }
		  for (property in source) {
		    value = source[property];
		    if (value !== undefined) {
		      destination[property] = value;
		    }
		  }
		  return destination;
		};

		var msfnz = function(eccent, sinphi, cosphi) {
		  var con = eccent * sinphi;
		  return cosphi / (Math.sqrt(1 - con * con));
		};

		var sign = function(x) {
		  return x<0 ? -1 : 1;
		};

		var adjust_lon = function(x) {
		  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
		};

		var tsfnz = function(eccent, phi, sinphi) {
		  var con = eccent * sinphi;
		  var com = 0.5 * eccent;
		  con = Math.pow(((1 - con) / (1 + con)), com);
		  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
		};

		var phi2z = function(eccent, ts) {
		  var eccnth = 0.5 * eccent;
		  var con, dphi;
		  var phi = HALF_PI - 2 * Math.atan(ts);
		  for (var i = 0; i <= 15; i++) {
		    con = eccent * Math.sin(phi);
		    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
		  //console.log("phi2z has NoConvergence");
		  return -9999;
		};

		function init() {
		  var con = this.b / this.a;
		  this.es = 1 - con * con;
		  if(!('x0' in this)){
		    this.x0 = 0;
		  }
		  if(!('y0' in this)){
		    this.y0 = 0;
		  }
		  this.e = Math.sqrt(this.es);
		  if (this.lat_ts) {
		    if (this.sphere) {
		      this.k0 = Math.cos(this.lat_ts);
		    }
		    else {
		      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
		    }
		  }
		  else {
		    if (!this.k0) {
		      if (this.k) {
		        this.k0 = this.k;
		      }
		      else {
		        this.k0 = 1;
		      }
		    }
		  }
		}

		/* Mercator forward equations--mapping lat,long to x,y
		  --------------------------------------------------*/

		function forward(p) {
		  var lon = p.x;
		  var lat = p.y;
		  // convert to radians
		  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
		    return null;
		  }

		  var x, y;
		  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
		    return null;
		  }
		  else {
		    if (this.sphere) {
		      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
		      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
		    }
		    else {
		      var sinphi = Math.sin(lat);
		      var ts = tsfnz(this.e, lat, sinphi);
		      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
		      y = this.y0 - this.a * this.k0 * Math.log(ts);
		    }
		    p.x = x;
		    p.y = y;
		    return p;
		  }
		}

		/* Mercator inverse equations--mapping x,y to lat/long
		  --------------------------------------------------*/
		function inverse(p) {

		  var x = p.x - this.x0;
		  var y = p.y - this.y0;
		  var lon, lat;

		  if (this.sphere) {
		    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
		  }
		  else {
		    var ts = Math.exp(-y / (this.a * this.k0));
		    lat = phi2z(this.e, ts);
		    if (lat === -9999) {
		      return null;
		    }
		  }
		  lon = adjust_lon(this.long0 + x / (this.a * this.k0));

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
		var merc = {
		  init: init,
		  forward: forward,
		  inverse: inverse,
		  names: names$1
		};

		function init$1() {
		  //no-op for longlat
		}

		function identity(pt) {
		  return pt;
		}
		var names$2 = ["longlat", "identity"];
		var longlat = {
		  init: init$1,
		  forward: identity,
		  inverse: identity,
		  names: names$2
		};

		var projs = [merc, longlat];
		var names$$1 = {};
		var projStore = [];

		function add(proj, i) {
		  var len = projStore.length;
		  if (!proj.names) {
		    console.log(i);
		    return true;
		  }
		  projStore[len] = proj;
		  proj.names.forEach(function(n) {
		    names$$1[n.toLowerCase()] = len;
		  });
		  return this;
		}

		function get(name) {
		  if (!name) {
		    return false;
		  }
		  var n = name.toLowerCase();
		  if (typeof names$$1[n] !== 'undefined' && projStore[names$$1[n]]) {
		    return projStore[names$$1[n]];
		  }
		}

		function start() {
		  projs.forEach(add);
		}
		var projections = {
		  start: start,
		  add: add,
		  get: get
		};

		var exports$2 = {};
		exports$2.MERIT = {
		  a: 6378137.0,
		  rf: 298.257,
		  ellipseName: "MERIT 1983"
		};

		exports$2.SGS85 = {
		  a: 6378136.0,
		  rf: 298.257,
		  ellipseName: "Soviet Geodetic System 85"
		};

		exports$2.GRS80 = {
		  a: 6378137.0,
		  rf: 298.257222101,
		  ellipseName: "GRS 1980(IUGG, 1980)"
		};

		exports$2.IAU76 = {
		  a: 6378140.0,
		  rf: 298.257,
		  ellipseName: "IAU 1976"
		};

		exports$2.airy = {
		  a: 6377563.396,
		  b: 6356256.910,
		  ellipseName: "Airy 1830"
		};

		exports$2.APL4 = {
		  a: 6378137,
		  rf: 298.25,
		  ellipseName: "Appl. Physics. 1965"
		};

		exports$2.NWL9D = {
		  a: 6378145.0,
		  rf: 298.25,
		  ellipseName: "Naval Weapons Lab., 1965"
		};

		exports$2.mod_airy = {
		  a: 6377340.189,
		  b: 6356034.446,
		  ellipseName: "Modified Airy"
		};

		exports$2.andrae = {
		  a: 6377104.43,
		  rf: 300.0,
		  ellipseName: "Andrae 1876 (Den., Iclnd.)"
		};

		exports$2.aust_SA = {
		  a: 6378160.0,
		  rf: 298.25,
		  ellipseName: "Australian Natl & S. Amer. 1969"
		};

		exports$2.GRS67 = {
		  a: 6378160.0,
		  rf: 298.2471674270,
		  ellipseName: "GRS 67(IUGG 1967)"
		};

		exports$2.bessel = {
		  a: 6377397.155,
		  rf: 299.1528128,
		  ellipseName: "Bessel 1841"
		};

		exports$2.bess_nam = {
		  a: 6377483.865,
		  rf: 299.1528128,
		  ellipseName: "Bessel 1841 (Namibia)"
		};

		exports$2.clrk66 = {
		  a: 6378206.4,
		  b: 6356583.8,
		  ellipseName: "Clarke 1866"
		};

		exports$2.clrk80 = {
		  a: 6378249.145,
		  rf: 293.4663,
		  ellipseName: "Clarke 1880 mod."
		};

		exports$2.clrk58 = {
		  a: 6378293.645208759,
		  rf: 294.2606763692654,
		  ellipseName: "Clarke 1858"
		};

		exports$2.CPM = {
		  a: 6375738.7,
		  rf: 334.29,
		  ellipseName: "Comm. des Poids et Mesures 1799"
		};

		exports$2.delmbr = {
		  a: 6376428.0,
		  rf: 311.5,
		  ellipseName: "Delambre 1810 (Belgium)"
		};

		exports$2.engelis = {
		  a: 6378136.05,
		  rf: 298.2566,
		  ellipseName: "Engelis 1985"
		};

		exports$2.evrst30 = {
		  a: 6377276.345,
		  rf: 300.8017,
		  ellipseName: "Everest 1830"
		};

		exports$2.evrst48 = {
		  a: 6377304.063,
		  rf: 300.8017,
		  ellipseName: "Everest 1948"
		};

		exports$2.evrst56 = {
		  a: 6377301.243,
		  rf: 300.8017,
		  ellipseName: "Everest 1956"
		};

		exports$2.evrst69 = {
		  a: 6377295.664,
		  rf: 300.8017,
		  ellipseName: "Everest 1969"
		};

		exports$2.evrstSS = {
		  a: 6377298.556,
		  rf: 300.8017,
		  ellipseName: "Everest (Sabah & Sarawak)"
		};

		exports$2.fschr60 = {
		  a: 6378166.0,
		  rf: 298.3,
		  ellipseName: "Fischer (Mercury Datum) 1960"
		};

		exports$2.fschr60m = {
		  a: 6378155.0,
		  rf: 298.3,
		  ellipseName: "Fischer 1960"
		};

		exports$2.fschr68 = {
		  a: 6378150.0,
		  rf: 298.3,
		  ellipseName: "Fischer 1968"
		};

		exports$2.helmert = {
		  a: 6378200.0,
		  rf: 298.3,
		  ellipseName: "Helmert 1906"
		};

		exports$2.hough = {
		  a: 6378270.0,
		  rf: 297.0,
		  ellipseName: "Hough"
		};

		exports$2.intl = {
		  a: 6378388.0,
		  rf: 297.0,
		  ellipseName: "International 1909 (Hayford)"
		};

		exports$2.kaula = {
		  a: 6378163.0,
		  rf: 298.24,
		  ellipseName: "Kaula 1961"
		};

		exports$2.lerch = {
		  a: 6378139.0,
		  rf: 298.257,
		  ellipseName: "Lerch 1979"
		};

		exports$2.mprts = {
		  a: 6397300.0,
		  rf: 191.0,
		  ellipseName: "Maupertius 1738"
		};

		exports$2.new_intl = {
		  a: 6378157.5,
		  b: 6356772.2,
		  ellipseName: "New International 1967"
		};

		exports$2.plessis = {
		  a: 6376523.0,
		  rf: 6355863.0,
		  ellipseName: "Plessis 1817 (France)"
		};

		exports$2.krass = {
		  a: 6378245.0,
		  rf: 298.3,
		  ellipseName: "Krassovsky, 1942"
		};

		exports$2.SEasia = {
		  a: 6378155.0,
		  b: 6356773.3205,
		  ellipseName: "Southeast Asia"
		};

		exports$2.walbeck = {
		  a: 6376896.0,
		  b: 6355834.8467,
		  ellipseName: "Walbeck"
		};

		exports$2.WGS60 = {
		  a: 6378165.0,
		  rf: 298.3,
		  ellipseName: "WGS 60"
		};

		exports$2.WGS66 = {
		  a: 6378145.0,
		  rf: 298.25,
		  ellipseName: "WGS 66"
		};

		exports$2.WGS7 = {
		  a: 6378135.0,
		  rf: 298.26,
		  ellipseName: "WGS 72"
		};

		var WGS84 = exports$2.WGS84 = {
		  a: 6378137.0,
		  rf: 298.257223563,
		  ellipseName: "WGS 84"
		};

		exports$2.sphere = {
		  a: 6370997.0,
		  b: 6370997.0,
		  ellipseName: "Normal Sphere (r=6370997)"
		};

		function eccentricity(a, b, rf, R_A) {
		  var a2 = a * a; // used in geocentric
		  var b2 = b * b; // used in geocentric
		  var es = (a2 - b2) / a2; // e ^ 2
		  var e = 0;
		  if (R_A) {
		    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
		    a2 = a * a;
		    es = 0;
		  } else {
		    e = Math.sqrt(es); // eccentricity
		  }
		  var ep2 = (a2 - b2) / b2; // used in geocentric
		  return {
		    es: es,
		    e: e,
		    ep2: ep2
		  };
		}
		function sphere(a, b, rf, ellps, sphere) {
		  if (!a) { // do we have an ellipsoid?
		    var ellipse = match(exports$2, ellps);
		    if (!ellipse) {
		      ellipse = WGS84;
		    }
		    a = ellipse.a;
		    b = ellipse.b;
		    rf = ellipse.rf;
		  }

		  if (rf && !b) {
		    b = (1.0 - 1.0 / rf) * a;
		  }
		  if (rf === 0 || Math.abs(a - b) < EPSLN) {
		    sphere = true;
		    b = a;
		  }
		  return {
		    a: a,
		    b: b,
		    rf: rf,
		    sphere: sphere
		  };
		}

		var exports$3 = {};
		exports$3.wgs84 = {
		  towgs84: "0,0,0",
		  ellipse: "WGS84",
		  datumName: "WGS84"
		};

		exports$3.ch1903 = {
		  towgs84: "674.374,15.056,405.346",
		  ellipse: "bessel",
		  datumName: "swiss"
		};

		exports$3.ggrs87 = {
		  towgs84: "-199.87,74.79,246.62",
		  ellipse: "GRS80",
		  datumName: "Greek_Geodetic_Reference_System_1987"
		};

		exports$3.nad83 = {
		  towgs84: "0,0,0",
		  ellipse: "GRS80",
		  datumName: "North_American_Datum_1983"
		};

		exports$3.nad27 = {
		  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
		  ellipse: "clrk66",
		  datumName: "North_American_Datum_1927"
		};

		exports$3.potsdam = {
		  towgs84: "606.0,23.0,413.0",
		  ellipse: "bessel",
		  datumName: "Potsdam Rauenberg 1950 DHDN"
		};

		exports$3.carthage = {
		  towgs84: "-263.0,6.0,431.0",
		  ellipse: "clark80",
		  datumName: "Carthage 1934 Tunisia"
		};

		exports$3.hermannskogel = {
		  towgs84: "653.0,-212.0,449.0",
		  ellipse: "bessel",
		  datumName: "Hermannskogel"
		};

		exports$3.osni52 = {
		  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
		  ellipse: "airy",
		  datumName: "Irish National"
		};

		exports$3.ire65 = {
		  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
		  ellipse: "mod_airy",
		  datumName: "Ireland 1965"
		};

		exports$3.rassadiran = {
		  towgs84: "-133.63,-157.5,-158.62",
		  ellipse: "intl",
		  datumName: "Rassadiran"
		};

		exports$3.nzgd49 = {
		  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
		  ellipse: "intl",
		  datumName: "New Zealand Geodetic Datum 1949"
		};

		exports$3.osgb36 = {
		  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
		  ellipse: "airy",
		  datumName: "Airy 1830"
		};

		exports$3.s_jtsk = {
		  towgs84: "589,76,480",
		  ellipse: 'bessel',
		  datumName: 'S-JTSK (Ferro)'
		};

		exports$3.beduaram = {
		  towgs84: '-106,-87,188',
		  ellipse: 'clrk80',
		  datumName: 'Beduaram'
		};

		exports$3.gunung_segara = {
		  towgs84: '-403,684,41',
		  ellipse: 'bessel',
		  datumName: 'Gunung Segara Jakarta'
		};

		exports$3.rnb72 = {
		  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
		  ellipse: "intl",
		  datumName: "Reseau National Belge 1972"
		};

		function datum(datumCode, datum_params, a, b, es, ep2) {
		  var out = {};

		  if (datumCode === undefined || datumCode === 'none') {
		    out.datum_type = PJD_NODATUM;
		  } else {
		    out.datum_type = PJD_WGS84;
		  }

		  if (datum_params) {
		    out.datum_params = datum_params.map(parseFloat);
		    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
		      out.datum_type = PJD_3PARAM;
		    }
		    if (out.datum_params.length > 3) {
		      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
		        out.datum_type = PJD_7PARAM;
		        out.datum_params[3] *= SEC_TO_RAD;
		        out.datum_params[4] *= SEC_TO_RAD;
		        out.datum_params[5] *= SEC_TO_RAD;
		        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
		      }
		    }
		  }

		  out.a = a; //datum object also uses these values
		  out.b = b;
		  out.es = es;
		  out.ep2 = ep2;
		  return out;
		}

		function Projection$1(srsCode,callback) {
		  if (!(this instanceof Projection$1)) {
		    return new Projection$1(srsCode);
		  }
		  callback = callback || function(error){
		    if(error){
		      throw error;
		    }
		  };
		  var json = parse(srsCode);
		  if(typeof json !== 'object'){
		    callback(srsCode);
		    return;
		  }
		  var ourProj = Projection$1.projections.get(json.projName);
		  if(!ourProj){
		    callback(srsCode);
		    return;
		  }
		  if (json.datumCode && json.datumCode !== 'none') {
		    var datumDef = match(exports$3, json.datumCode);
		    if (datumDef) {
		      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
		      json.ellps = datumDef.ellipse;
		      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
		    }
		  }
		  json.k0 = json.k0 || 1.0;
		  json.axis = json.axis || 'enu';
		  json.ellps = json.ellps || 'wgs84';
		  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
		  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
		  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);

		  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
		  extend(this, ourProj); // transfer all the methods from the projection

		  // copy the 4 things over we calulated in deriveConstants.sphere
		  this.a = sphere_.a;
		  this.b = sphere_.b;
		  this.rf = sphere_.rf;
		  this.sphere = sphere_.sphere;

		  // copy the 3 things we calculated in deriveConstants.eccentricity
		  this.es = ecc.es;
		  this.e = ecc.e;
		  this.ep2 = ecc.ep2;

		  // add in the datum object
		  this.datum = datumObj;

		  // init the projection
		  this.init();

		  // legecy callback from back in the day when it went to spatialreference.org
		  callback(null, this);

		}
		Projection$1.projections = projections;
		Projection$1.projections.start();

		function compareDatums(source, dest) {
		  if (source.datum_type !== dest.datum_type) {
		    return false; // false, datums are not equal
		  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
		    // the tolerance for es is to ensure that GRS80 and WGS84
		    // are considered identical
		    return false;
		  } else if (source.datum_type === PJD_3PARAM) {
		    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
		  } else if (source.datum_type === PJD_7PARAM) {
		    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
		  } else {
		    return true; // datums are equal
		  }
		} // cs_compare_datums()

		/*
		 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
		 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
		 * according to the current ellipsoid parameters.
		 *
		 *    Latitude  : Geodetic latitude in radians                     (input)
		 *    Longitude : Geodetic longitude in radians                    (input)
		 *    Height    : Geodetic height, in meters                       (input)
		 *    X         : Calculated Geocentric X coordinate, in meters    (output)
		 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
		 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
		 *
		 */
		function geodeticToGeocentric(p, es, a) {
		  var Longitude = p.x;
		  var Latitude = p.y;
		  var Height = p.z ? p.z : 0; //Z value not always supplied

		  var Rn; /*  Earth radius at location  */
		  var Sin_Lat; /*  Math.sin(Latitude)  */
		  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
		  var Cos_Lat; /*  Math.cos(Latitude)  */

		  /*
		   ** Don't blow up if Latitude is just a little out of the value
		   ** range as it may just be a rounding issue.  Also removed longitude
		   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
		   */
		  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
		    Latitude = -HALF_PI;
		  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
		    Latitude = HALF_PI;
		  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
		    /* Latitude out of range */
		    //..reportError('geocent:lat out of range:' + Latitude);
		    return null;
		  }

		  if (Longitude > Math.PI) {
		    Longitude -= (2 * Math.PI);
		  }
		  Sin_Lat = Math.sin(Latitude);
		  Cos_Lat = Math.cos(Latitude);
		  Sin2_Lat = Sin_Lat * Sin_Lat;
		  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
		  return {
		    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
		    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
		    z: ((Rn * (1 - es)) + Height) * Sin_Lat
		  };
		} // cs_geodetic_to_geocentric()

		function geocentricToGeodetic(p, es, a, b) {
		  /* local defintions and variables */
		  /* end-criterium of loop, accuracy of sin(Latitude) */
		  var genau = 1e-12;
		  var genau2 = (genau * genau);
		  var maxiter = 30;

		  var P; /* distance between semi-minor axis and location */
		  var RR; /* distance between center and location */
		  var CT; /* sin of geocentric latitude */
		  var ST; /* cos of geocentric latitude */
		  var RX;
		  var RK;
		  var RN; /* Earth radius at location */
		  var CPHI0; /* cos of start or old geodetic latitude in iterations */
		  var SPHI0; /* sin of start or old geodetic latitude in iterations */
		  var CPHI; /* cos of searched geodetic latitude */
		  var SPHI; /* sin of searched geodetic latitude */
		  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
		  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

		  var X = p.x;
		  var Y = p.y;
		  var Z = p.z ? p.z : 0.0; //Z value not always supplied
		  var Longitude;
		  var Latitude;
		  var Height;

		  P = Math.sqrt(X * X + Y * Y);
		  RR = Math.sqrt(X * X + Y * Y + Z * Z);

		  /*      special cases for latitude and longitude */
		  if (P / a < genau) {

		    /*  special case, if P=0. (X=0., Y=0.) */
		    Longitude = 0.0;

		    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
		     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
		    if (RR / a < genau) {
		      Latitude = HALF_PI;
		      Height = -b;
		      return {
		        x: p.x,
		        y: p.y,
		        z: p.z
		      };
		    }
		  } else {
		    /*  ellipsoidal (geodetic) longitude
		     *  interval: -PI < Longitude <= +PI */
		    Longitude = Math.atan2(Y, X);
		  }

		  /* --------------------------------------------------------------
		   * Following iterative algorithm was developped by
		   * "Institut for Erdmessung", University of Hannover, July 1988.
		   * Internet: www.ife.uni-hannover.de
		   * Iterative computation of CPHI,SPHI and Height.
		   * Iteration of CPHI and SPHI to 10**-12 radian resp.
		   * 2*10**-7 arcsec.
		   * --------------------------------------------------------------
		   */
		  CT = Z / RR;
		  ST = P / RR;
		  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
		  CPHI0 = ST * (1.0 - es) * RX;
		  SPHI0 = CT * RX;
		  iter = 0;

		  /* loop to find sin(Latitude) resp. Latitude
		   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
		  do {
		    iter++;
		    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

		    /*  ellipsoidal (geodetic) height */
		    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

		    RK = es * RN / (RN + Height);
		    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
		    CPHI = ST * (1.0 - RK) * RX;
		    SPHI = CT * RX;
		    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
		    CPHI0 = CPHI;
		    SPHI0 = SPHI;
		  }
		  while (SDPHI * SDPHI > genau2 && iter < maxiter);

		  /*      ellipsoidal (geodetic) latitude */
		  Latitude = Math.atan(SPHI / Math.abs(CPHI));
		  return {
		    x: Longitude,
		    y: Latitude,
		    z: Height
		  };
		} // cs_geocentric_to_geodetic()

		/****************************************************************/
		// pj_geocentic_to_wgs84( p )
		//  p = point to transform in geocentric coordinates (x,y,z)


		/** point object, nothing fancy, just allows values to be
		    passed back and forth by reference rather than by value.
		    Other point classes may be used as long as they have
		    x and y properties, which will get modified in the transform method.
		*/
		function geocentricToWgs84(p, datum_type, datum_params) {

		  if (datum_type === PJD_3PARAM) {
		    // if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: p.x + datum_params[0],
		      y: p.y + datum_params[1],
		      z: p.z + datum_params[2],
		    };
		  } else if (datum_type === PJD_7PARAM) {
		    var Dx_BF = datum_params[0];
		    var Dy_BF = datum_params[1];
		    var Dz_BF = datum_params[2];
		    var Rx_BF = datum_params[3];
		    var Ry_BF = datum_params[4];
		    var Rz_BF = datum_params[5];
		    var M_BF = datum_params[6];
		    // if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
		      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
		      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
		    };
		  }
		} // cs_geocentric_to_wgs84

		/****************************************************************/
		// pj_geocentic_from_wgs84()
		//  coordinate system definition,
		//  point to transform in geocentric coordinates (x,y,z)
		function geocentricFromWgs84(p, datum_type, datum_params) {

		  if (datum_type === PJD_3PARAM) {
		    //if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: p.x - datum_params[0],
		      y: p.y - datum_params[1],
		      z: p.z - datum_params[2],
		    };

		  } else if (datum_type === PJD_7PARAM) {
		    var Dx_BF = datum_params[0];
		    var Dy_BF = datum_params[1];
		    var Dz_BF = datum_params[2];
		    var Rx_BF = datum_params[3];
		    var Ry_BF = datum_params[4];
		    var Rz_BF = datum_params[5];
		    var M_BF = datum_params[6];
		    var x_tmp = (p.x - Dx_BF) / M_BF;
		    var y_tmp = (p.y - Dy_BF) / M_BF;
		    var z_tmp = (p.z - Dz_BF) / M_BF;
		    //if( x[io] === HUGE_VAL )
		    //    continue;

		    return {
		      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
		      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
		      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
		    };
		  } //cs_geocentric_from_wgs84()
		}

		function checkParams(type) {
		  return (type === PJD_3PARAM || type === PJD_7PARAM);
		}

		var datum_transform = function(source, dest, point) {
		  // Short cut if the datums are identical.
		  if (compareDatums(source, dest)) {
		    return point; // in this case, zero is sucess,
		    // whereas cs_compare_datums returns 1 to indicate TRUE
		    // confusing, should fix this
		  }

		  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
		  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
		    return point;
		  }

		  // If this datum requires grid shifts, then apply it to geodetic coordinates.

		  // Do we need to go through geocentric coordinates?
		  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
		    return point;
		  }

		  // Convert to geocentric coordinates.
		  point = geodeticToGeocentric(point, source.es, source.a);
		  // Convert between datums
		  if (checkParams(source.datum_type)) {
		    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
		  }
		  if (checkParams(dest.datum_type)) {
		    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
		  }
		  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);

		};

		var adjust_axis = function(crs, denorm, point) {
		  var xin = point.x,
		    yin = point.y,
		    zin = point.z || 0.0;
		  var v, t, i;
		  var out = {};
		  for (i = 0; i < 3; i++) {
		    if (denorm && i === 2 && point.z === undefined) {
		      continue;
		    }
		    if (i === 0) {
		      v = xin;
		      t = 'x';
		    }
		    else if (i === 1) {
		      v = yin;
		      t = 'y';
		    }
		    else {
		      v = zin;
		      t = 'z';
		    }
		    switch (crs.axis[i]) {
		    case 'e':
		      out[t] = v;
		      break;
		    case 'w':
		      out[t] = -v;
		      break;
		    case 'n':
		      out[t] = v;
		      break;
		    case 's':
		      out[t] = -v;
		      break;
		    case 'u':
		      if (point[t] !== undefined) {
		        out.z = v;
		      }
		      break;
		    case 'd':
		      if (point[t] !== undefined) {
		        out.z = -v;
		      }
		      break;
		    default:
		      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
		      return null;
		    }
		  }
		  return out;
		};

		var toPoint = function (array){
		  var out = {
		    x: array[0],
		    y: array[1]
		  };
		  if (array.length>2) {
		    out.z = array[2];
		  }
		  if (array.length>3) {
		    out.m = array[3];
		  }
		  return out;
		};

		var checkSanity = function (point) {
		  checkCoord(point.x);
		  checkCoord(point.y);
		};
		function checkCoord(num) {
		  if (typeof Number.isFinite === 'function') {
		    if (Number.isFinite(num)) {
		      return;
		    }
		    throw new TypeError('coordinates must be finite numbers');
		  }
		  if (typeof num !== 'number' || num !== num || !isFinite(num)) {
		    throw new TypeError('coordinates must be finite numbers');
		  }
		}

		function checkNotWGS(source, dest) {
		  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
		}

		function transform(source, dest, point) {
		  var wgs84;
		  if (Array.isArray(point)) {
		    point = toPoint(point);
		  }
		  checkSanity(point);
		  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
		  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
		    wgs84 = new Projection$1('WGS84');
		    point = transform(source, wgs84, point);
		    source = wgs84;
		  }
		  // DGR, 2010/11/12
		  if (source.axis !== 'enu') {
		    point = adjust_axis(source, false, point);
		  }
		  // Transform source points to long/lat, if they aren't already.
		  if (source.projName === 'longlat') {
		    point = {
		      x: point.x * D2R,
		      y: point.y * D2R
		    };
		  }
		  else {
		    if (source.to_meter) {
		      point = {
		        x: point.x * source.to_meter,
		        y: point.y * source.to_meter
		      };
		    }
		    point = source.inverse(point); // Convert Cartesian to longlat
		  }
		  // Adjust for the prime meridian if necessary
		  if (source.from_greenwich) {
		    point.x += source.from_greenwich;
		  }

		  // Convert datums if needed, and if possible.
		  point = datum_transform(source.datum, dest.datum, point);

		  // Adjust for the prime meridian if necessary
		  if (dest.from_greenwich) {
		    point = {
		      x: point.x - dest.from_greenwich,
		      y: point.y
		    };
		  }

		  if (dest.projName === 'longlat') {
		    // convert radians to decimal degrees
		    point = {
		      x: point.x * R2D,
		      y: point.y * R2D
		    };
		  } else { // else project
		    point = dest.forward(point);
		    if (dest.to_meter) {
		      point = {
		        x: point.x / dest.to_meter,
		        y: point.y / dest.to_meter
		      };
		    }
		  }

		  // DGR, 2010/11/12
		  if (dest.axis !== 'enu') {
		    return adjust_axis(dest, true, point);
		  }

		  return point;
		}

		var wgs84 = Projection$1('WGS84');

		function transformer(from, to, coords) {
		  var transformedArray, out, keys;
		  if (Array.isArray(coords)) {
		    transformedArray = transform(from, to, coords);
		    if (coords.length === 3) {
		      return [transformedArray.x, transformedArray.y, transformedArray.z];
		    }
		    else {
		      return [transformedArray.x, transformedArray.y];
		    }
		  }
		  else {
		    out = transform(from, to, coords);
		    keys = Object.keys(coords);
		    if (keys.length === 2) {
		      return out;
		    }
		    keys.forEach(function (key) {
		      if (key === 'x' || key === 'y') {
		        return;
		      }
		      out[key] = coords[key];
		    });
		    return out;
		  }
		}

		function checkProj(item) {
		  if (item instanceof Projection$1) {
		    return item;
		  }
		  if (item.oProj) {
		    return item.oProj;
		  }
		  return Projection$1(item);
		}
		function proj4$1(fromProj, toProj, coord) {
		  fromProj = checkProj(fromProj);
		  var single = false;
		  var obj;
		  if (typeof toProj === 'undefined') {
		    toProj = fromProj;
		    fromProj = wgs84;
		    single = true;
		  }
		  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
		    coord = toProj;
		    toProj = fromProj;
		    fromProj = wgs84;
		    single = true;
		  }
		  toProj = checkProj(toProj);
		  if (coord) {
		    return transformer(fromProj, toProj, coord);
		  }
		  else {
		    obj = {
		      forward: function(coords) {
		        return transformer(fromProj, toProj, coords);
		      },
		      inverse: function(coords) {
		        return transformer(toProj, fromProj, coords);
		      }
		    };
		    if (single) {
		      obj.oProj = toProj;
		    }
		    return obj;
		  }
		}

		/**
		 * UTM zones are grouped, and assigned to one of a group of 6
		 * sets.
		 *
		 * {int} @private
		 */
		var NUM_100K_SETS = 6;

		/**
		 * The column letters (for easting) of the lower left value, per
		 * set.
		 *
		 * {string} @private
		 */
		var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

		/**
		 * The row letters (for northing) of the lower left value, per
		 * set.
		 *
		 * {string} @private
		 */
		var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

		var A = 65; // A
		var I = 73; // I
		var O = 79; // O
		var V = 86; // V
		var Z = 90; // Z
		var mgrs = {
		  forward: forward$1,
		  inverse: inverse$1,
		  toPoint: toPoint$1
		};
		/**
		 * Conversion of lat/lon to MGRS.
		 *
		 * @param {object} ll Object literal with lat and lon properties on a
		 *     WGS84 ellipsoid.
		 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
		 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
		 * @return {string} the MGRS string for the given location and accuracy.
		 */
		function forward$1(ll, accuracy) {
		  accuracy = accuracy || 5; // default accuracy 1m
		  return encode(LLtoUTM({
		    lat: ll[1],
		    lon: ll[0]
		  }), accuracy);
		}

		/**
		 * Conversion of MGRS to lat/lon.
		 *
		 * @param {string} mgrs MGRS string.
		 * @return {array} An array with left (longitude), bottom (latitude), right
		 *     (longitude) and top (latitude) values in WGS84, representing the
		 *     bounding box for the provided MGRS reference.
		 */
		function inverse$1(mgrs) {
		  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
		  if (bbox.lat && bbox.lon) {
		    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
		  }
		  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
		}

		function toPoint$1(mgrs) {
		  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
		  if (bbox.lat && bbox.lon) {
		    return [bbox.lon, bbox.lat];
		  }
		  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
		}
		/**
		 * Conversion from degrees to radians.
		 *
		 * @private
		 * @param {number} deg the angle in degrees.
		 * @return {number} the angle in radians.
		 */
		function degToRad(deg) {
		  return (deg * (Math.PI / 180.0));
		}

		/**
		 * Conversion from radians to degrees.
		 *
		 * @private
		 * @param {number} rad the angle in radians.
		 * @return {number} the angle in degrees.
		 */
		function radToDeg(rad) {
		  return (180.0 * (rad / Math.PI));
		}

		/**
		 * Converts a set of Longitude and Latitude co-ordinates to UTM
		 * using the WGS84 ellipsoid.
		 *
		 * @private
		 * @param {object} ll Object literal with lat and lon properties
		 *     representing the WGS84 coordinate to be converted.
		 * @return {object} Object literal containing the UTM value with easting,
		 *     northing, zoneNumber and zoneLetter properties, and an optional
		 *     accuracy property in digits. Returns null if the conversion failed.
		 */
		function LLtoUTM(ll) {
		  var Lat = ll.lat;
		  var Long = ll.lon;
		  var a = 6378137.0; //ellip.radius;
		  var eccSquared = 0.00669438; //ellip.eccsq;
		  var k0 = 0.9996;
		  var LongOrigin;
		  var eccPrimeSquared;
		  var N, T, C, A, M;
		  var LatRad = degToRad(Lat);
		  var LongRad = degToRad(Long);
		  var LongOriginRad;
		  var ZoneNumber;
		  // (int)
		  ZoneNumber = Math.floor((Long + 180) / 6) + 1;

		  //Make sure the longitude 180.00 is in Zone 60
		  if (Long === 180) {
		    ZoneNumber = 60;
		  }

		  // Special zone for Norway
		  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
		    ZoneNumber = 32;
		  }

		  // Special zones for Svalbard
		  if (Lat >= 72.0 && Lat < 84.0) {
		    if (Long >= 0.0 && Long < 9.0) {
		      ZoneNumber = 31;
		    }
		    else if (Long >= 9.0 && Long < 21.0) {
		      ZoneNumber = 33;
		    }
		    else if (Long >= 21.0 && Long < 33.0) {
		      ZoneNumber = 35;
		    }
		    else if (Long >= 33.0 && Long < 42.0) {
		      ZoneNumber = 37;
		    }
		  }

		  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
		  // in middle of
		  // zone
		  LongOriginRad = degToRad(LongOrigin);

		  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

		  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
		  T = Math.tan(LatRad) * Math.tan(LatRad);
		  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
		  A = Math.cos(LatRad) * (LongRad - LongOriginRad);

		  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

		  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

		  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
		  if (Lat < 0.0) {
		    UTMNorthing += 10000000.0; //10000000 meter offset for
		    // southern hemisphere
		  }

		  return {
		    northing: Math.round(UTMNorthing),
		    easting: Math.round(UTMEasting),
		    zoneNumber: ZoneNumber,
		    zoneLetter: getLetterDesignator(Lat)
		  };
		}

		/**
		 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
		 * class where the Zone can be specified as a single string eg."60N" which
		 * is then broken down into the ZoneNumber and ZoneLetter.
		 *
		 * @private
		 * @param {object} utm An object literal with northing, easting, zoneNumber
		 *     and zoneLetter properties. If an optional accuracy property is
		 *     provided (in meters), a bounding box will be returned instead of
		 *     latitude and longitude.
		 * @return {object} An object literal containing either lat and lon values
		 *     (if no accuracy was provided), or top, right, bottom and left values
		 *     for the bounding box calculated according to the provided accuracy.
		 *     Returns null if the conversion failed.
		 */
		function UTMtoLL(utm) {

		  var UTMNorthing = utm.northing;
		  var UTMEasting = utm.easting;
		  var zoneLetter = utm.zoneLetter;
		  var zoneNumber = utm.zoneNumber;
		  // check the ZoneNummber is valid
		  if (zoneNumber < 0 || zoneNumber > 60) {
		    return null;
		  }

		  var k0 = 0.9996;
		  var a = 6378137.0; //ellip.radius;
		  var eccSquared = 0.00669438; //ellip.eccsq;
		  var eccPrimeSquared;
		  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
		  var N1, T1, C1, R1, D, M;
		  var LongOrigin;
		  var mu, phi1Rad;

		  // remove 500,000 meter offset for longitude
		  var x = UTMEasting - 500000.0;
		  var y = UTMNorthing;

		  // We must know somehow if we are in the Northern or Southern
		  // hemisphere, this is the only time we use the letter So even
		  // if the Zone letter isn't exactly correct it should indicate
		  // the hemisphere correctly
		  if (zoneLetter < 'N') {
		    y -= 10000000.0; // remove 10,000,000 meter offset used
		    // for southern hemisphere
		  }

		  // There are 60 zones with zone 1 being at West -180 to -174
		  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
		  // in middle of
		  // zone

		  eccPrimeSquared = (eccSquared) / (1 - eccSquared);

		  M = y / k0;
		  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

		  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
		  // double phi1 = ProjMath.radToDeg(phi1Rad);

		  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
		  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
		  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
		  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
		  D = x / (N1 * k0);

		  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
		  lat = radToDeg(lat);

		  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
		  lon = LongOrigin + radToDeg(lon);

		  var result;
		  if (utm.accuracy) {
		    var topRight = UTMtoLL({
		      northing: utm.northing + utm.accuracy,
		      easting: utm.easting + utm.accuracy,
		      zoneLetter: utm.zoneLetter,
		      zoneNumber: utm.zoneNumber
		    });
		    result = {
		      top: topRight.lat,
		      right: topRight.lon,
		      bottom: lat,
		      left: lon
		    };
		  }
		  else {
		    result = {
		      lat: lat,
		      lon: lon
		    };
		  }
		  return result;
		}

		/**
		 * Calculates the MGRS letter designator for the given latitude.
		 *
		 * @private
		 * @param {number} lat The latitude in WGS84 to get the letter designator
		 *     for.
		 * @return {char} The letter designator.
		 */
		function getLetterDesignator(lat) {
		  //This is here as an error flag to show that the Latitude is
		  //outside MGRS limits
		  var LetterDesignator = 'Z';

		  if ((84 >= lat) && (lat >= 72)) {
		    LetterDesignator = 'X';
		  }
		  else if ((72 > lat) && (lat >= 64)) {
		    LetterDesignator = 'W';
		  }
		  else if ((64 > lat) && (lat >= 56)) {
		    LetterDesignator = 'V';
		  }
		  else if ((56 > lat) && (lat >= 48)) {
		    LetterDesignator = 'U';
		  }
		  else if ((48 > lat) && (lat >= 40)) {
		    LetterDesignator = 'T';
		  }
		  else if ((40 > lat) && (lat >= 32)) {
		    LetterDesignator = 'S';
		  }
		  else if ((32 > lat) && (lat >= 24)) {
		    LetterDesignator = 'R';
		  }
		  else if ((24 > lat) && (lat >= 16)) {
		    LetterDesignator = 'Q';
		  }
		  else if ((16 > lat) && (lat >= 8)) {
		    LetterDesignator = 'P';
		  }
		  else if ((8 > lat) && (lat >= 0)) {
		    LetterDesignator = 'N';
		  }
		  else if ((0 > lat) && (lat >= -8)) {
		    LetterDesignator = 'M';
		  }
		  else if ((-8 > lat) && (lat >= -16)) {
		    LetterDesignator = 'L';
		  }
		  else if ((-16 > lat) && (lat >= -24)) {
		    LetterDesignator = 'K';
		  }
		  else if ((-24 > lat) && (lat >= -32)) {
		    LetterDesignator = 'J';
		  }
		  else if ((-32 > lat) && (lat >= -40)) {
		    LetterDesignator = 'H';
		  }
		  else if ((-40 > lat) && (lat >= -48)) {
		    LetterDesignator = 'G';
		  }
		  else if ((-48 > lat) && (lat >= -56)) {
		    LetterDesignator = 'F';
		  }
		  else if ((-56 > lat) && (lat >= -64)) {
		    LetterDesignator = 'E';
		  }
		  else if ((-64 > lat) && (lat >= -72)) {
		    LetterDesignator = 'D';
		  }
		  else if ((-72 > lat) && (lat >= -80)) {
		    LetterDesignator = 'C';
		  }
		  return LetterDesignator;
		}

		/**
		 * Encodes a UTM location as MGRS string.
		 *
		 * @private
		 * @param {object} utm An object literal with easting, northing,
		 *     zoneLetter, zoneNumber
		 * @param {number} accuracy Accuracy in digits (1-5).
		 * @return {string} MGRS string for the given UTM location.
		 */
		function encode(utm, accuracy) {
		  // prepend with leading zeroes
		  var seasting = "00000" + utm.easting,
		    snorthing = "00000" + utm.northing;

		  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
		}

		/**
		 * Get the two letter 100k designator for a given UTM easting,
		 * northing and zone number value.
		 *
		 * @private
		 * @param {number} easting
		 * @param {number} northing
		 * @param {number} zoneNumber
		 * @return the two letter 100k designator for the given UTM location.
		 */
		function get100kID(easting, northing, zoneNumber) {
		  var setParm = get100kSetForZone(zoneNumber);
		  var setColumn = Math.floor(easting / 100000);
		  var setRow = Math.floor(northing / 100000) % 20;
		  return getLetter100kID(setColumn, setRow, setParm);
		}

		/**
		 * Given a UTM zone number, figure out the MGRS 100K set it is in.
		 *
		 * @private
		 * @param {number} i An UTM zone number.
		 * @return {number} the 100k set the UTM zone is in.
		 */
		function get100kSetForZone(i) {
		  var setParm = i % NUM_100K_SETS;
		  if (setParm === 0) {
		    setParm = NUM_100K_SETS;
		  }

		  return setParm;
		}

		/**
		 * Get the two-letter MGRS 100k designator given information
		 * translated from the UTM northing, easting and zone number.
		 *
		 * @private
		 * @param {number} column the column index as it relates to the MGRS
		 *        100k set spreadsheet, created from the UTM easting.
		 *        Values are 1-8.
		 * @param {number} row the row index as it relates to the MGRS 100k set
		 *        spreadsheet, created from the UTM northing value. Values
		 *        are from 0-19.
		 * @param {number} parm the set block, as it relates to the MGRS 100k set
		 *        spreadsheet, created from the UTM zone. Values are from
		 *        1-60.
		 * @return two letter MGRS 100k code.
		 */
		function getLetter100kID(column, row, parm) {
		  // colOrigin and rowOrigin are the letters at the origin of the set
		  var index = parm - 1;
		  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
		  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

		  // colInt and rowInt are the letters to build to return
		  var colInt = colOrigin + column - 1;
		  var rowInt = rowOrigin + row;
		  var rollover = false;

		  if (colInt > Z) {
		    colInt = colInt - Z + A - 1;
		    rollover = true;
		  }

		  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
		    colInt++;
		  }

		  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
		    colInt++;

		    if (colInt === I) {
		      colInt++;
		    }
		  }

		  if (colInt > Z) {
		    colInt = colInt - Z + A - 1;
		  }

		  if (rowInt > V) {
		    rowInt = rowInt - V + A - 1;
		    rollover = true;
		  }
		  else {
		    rollover = false;
		  }

		  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
		    rowInt++;
		  }

		  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
		    rowInt++;

		    if (rowInt === I) {
		      rowInt++;
		    }
		  }

		  if (rowInt > V) {
		    rowInt = rowInt - V + A - 1;
		  }

		  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
		  return twoLetter;
		}

		/**
		 * Decode the UTM parameters from a MGRS string.
		 *
		 * @private
		 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
		 * @return {object} An object literal with easting, northing, zoneLetter,
		 *     zoneNumber and accuracy (in meters) properties.
		 */
		function decode(mgrsString) {

		  if (mgrsString && mgrsString.length === 0) {
		    throw ("MGRSPoint coverting from nothing");
		  }

		  var length = mgrsString.length;

		  var hunK = null;
		  var sb = "";
		  var testChar;
		  var i = 0;

		  // get Zone number
		  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
		    if (i >= 2) {
		      throw ("MGRSPoint bad conversion from: " + mgrsString);
		    }
		    sb += testChar;
		    i++;
		  }

		  var zoneNumber = parseInt(sb, 10);

		  if (i === 0 || i + 3 > length) {
		    // A good MGRS string has to be 4-5 digits long,
		    // ##AAA/#AAA at least.
		    throw ("MGRSPoint bad conversion from: " + mgrsString);
		  }

		  var zoneLetter = mgrsString.charAt(i++);

		  // Should we check the zone letter here? Why not.
		  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
		    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
		  }

		  hunK = mgrsString.substring(i, i += 2);

		  var set = get100kSetForZone(zoneNumber);

		  var east100k = getEastingFromChar(hunK.charAt(0), set);
		  var north100k = getNorthingFromChar(hunK.charAt(1), set);

		  // We have a bug where the northing may be 2000000 too low.
		  // How
		  // do we know when to roll over?

		  while (north100k < getMinNorthing(zoneLetter)) {
		    north100k += 2000000;
		  }

		  // calculate the char index for easting/northing separator
		  var remainder = length - i;

		  if (remainder % 2 !== 0) {
		    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
		  }

		  var sep = remainder / 2;

		  var sepEasting = 0.0;
		  var sepNorthing = 0.0;
		  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
		  if (sep > 0) {
		    accuracyBonus = 100000.0 / Math.pow(10, sep);
		    sepEastingString = mgrsString.substring(i, i + sep);
		    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
		    sepNorthingString = mgrsString.substring(i + sep);
		    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
		  }

		  easting = sepEasting + east100k;
		  northing = sepNorthing + north100k;

		  return {
		    easting: easting,
		    northing: northing,
		    zoneLetter: zoneLetter,
		    zoneNumber: zoneNumber,
		    accuracy: accuracyBonus
		  };
		}

		/**
		 * Given the first letter from a two-letter MGRS 100k zone, and given the
		 * MGRS table set for the zone number, figure out the easting value that
		 * should be added to the other, secondary easting value.
		 *
		 * @private
		 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
		 * @param {number} set The MGRS table set for the zone number.
		 * @return {number} The easting value for the given letter and set.
		 */
		function getEastingFromChar(e, set) {
		  // colOrigin is the letter at the origin of the set for the
		  // column
		  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
		  var eastingValue = 100000.0;
		  var rewindMarker = false;

		  while (curCol !== e.charCodeAt(0)) {
		    curCol++;
		    if (curCol === I) {
		      curCol++;
		    }
		    if (curCol === O) {
		      curCol++;
		    }
		    if (curCol > Z) {
		      if (rewindMarker) {
		        throw ("Bad character: " + e);
		      }
		      curCol = A;
		      rewindMarker = true;
		    }
		    eastingValue += 100000.0;
		  }

		  return eastingValue;
		}

		/**
		 * Given the second letter from a two-letter MGRS 100k zone, and given the
		 * MGRS table set for the zone number, figure out the northing value that
		 * should be added to the other, secondary northing value. You have to
		 * remember that Northings are determined from the equator, and the vertical
		 * cycle of letters mean a 2000000 additional northing meters. This happens
		 * approx. every 18 degrees of latitude. This method does *NOT* count any
		 * additional northings. You have to figure out how many 2000000 meters need
		 * to be added for the zone letter of the MGRS coordinate.
		 *
		 * @private
		 * @param {char} n Second letter of the MGRS 100k zone
		 * @param {number} set The MGRS table set number, which is dependent on the
		 *     UTM zone number.
		 * @return {number} The northing value for the given letter and set.
		 */
		function getNorthingFromChar(n, set) {

		  if (n > 'V') {
		    throw ("MGRSPoint given invalid Northing " + n);
		  }

		  // rowOrigin is the letter at the origin of the set for the
		  // column
		  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
		  var northingValue = 0.0;
		  var rewindMarker = false;

		  while (curRow !== n.charCodeAt(0)) {
		    curRow++;
		    if (curRow === I) {
		      curRow++;
		    }
		    if (curRow === O) {
		      curRow++;
		    }
		    // fixing a bug making whole application hang in this loop
		    // when 'n' is a wrong character
		    if (curRow > V) {
		      if (rewindMarker) { // making sure that this loop ends
		        throw ("Bad character: " + n);
		      }
		      curRow = A;
		      rewindMarker = true;
		    }
		    northingValue += 100000.0;
		  }

		  return northingValue;
		}

		/**
		 * The function getMinNorthing returns the minimum northing value of a MGRS
		 * zone.
		 *
		 * Ported from Geotrans' c Lattitude_Band_Value structure table.
		 *
		 * @private
		 * @param {char} zoneLetter The MGRS zone to get the min northing for.
		 * @return {number}
		 */
		function getMinNorthing(zoneLetter) {
		  var northing;
		  switch (zoneLetter) {
		  case 'C':
		    northing = 1100000.0;
		    break;
		  case 'D':
		    northing = 2000000.0;
		    break;
		  case 'E':
		    northing = 2800000.0;
		    break;
		  case 'F':
		    northing = 3700000.0;
		    break;
		  case 'G':
		    northing = 4600000.0;
		    break;
		  case 'H':
		    northing = 5500000.0;
		    break;
		  case 'J':
		    northing = 6400000.0;
		    break;
		  case 'K':
		    northing = 7300000.0;
		    break;
		  case 'L':
		    northing = 8200000.0;
		    break;
		  case 'M':
		    northing = 9100000.0;
		    break;
		  case 'N':
		    northing = 0.0;
		    break;
		  case 'P':
		    northing = 800000.0;
		    break;
		  case 'Q':
		    northing = 1700000.0;
		    break;
		  case 'R':
		    northing = 2600000.0;
		    break;
		  case 'S':
		    northing = 3500000.0;
		    break;
		  case 'T':
		    northing = 4400000.0;
		    break;
		  case 'U':
		    northing = 5300000.0;
		    break;
		  case 'V':
		    northing = 6200000.0;
		    break;
		  case 'W':
		    northing = 7000000.0;
		    break;
		  case 'X':
		    northing = 7900000.0;
		    break;
		  default:
		    northing = -1.0;
		  }
		  if (northing >= 0.0) {
		    return northing;
		  }
		  else {
		    throw ("Invalid zone letter: " + zoneLetter);
		  }

		}

		function Point(x, y, z) {
		  if (!(this instanceof Point)) {
		    return new Point(x, y, z);
		  }
		  if (Array.isArray(x)) {
		    this.x = x[0];
		    this.y = x[1];
		    this.z = x[2] || 0.0;
		  } else if(typeof x === 'object') {
		    this.x = x.x;
		    this.y = x.y;
		    this.z = x.z || 0.0;
		  } else if (typeof x === 'string' && typeof y === 'undefined') {
		    var coords = x.split(',');
		    this.x = parseFloat(coords[0], 10);
		    this.y = parseFloat(coords[1], 10);
		    this.z = parseFloat(coords[2], 10) || 0.0;
		  } else {
		    this.x = x;
		    this.y = y;
		    this.z = z || 0.0;
		  }
		  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
		}

		Point.fromMGRS = function(mgrsStr) {
		  return new Point(toPoint$1(mgrsStr));
		};
		Point.prototype.toMGRS = function(accuracy) {
		  return forward$1([this.x, this.y], accuracy);
		};

		var version = "2.4.4";

		var C00 = 1;
		var C02 = 0.25;
		var C04 = 0.046875;
		var C06 = 0.01953125;
		var C08 = 0.01068115234375;
		var C22 = 0.75;
		var C44 = 0.46875;
		var C46 = 0.01302083333333333333;
		var C48 = 0.00712076822916666666;
		var C66 = 0.36458333333333333333;
		var C68 = 0.00569661458333333333;
		var C88 = 0.3076171875;

		var pj_enfn = function(es) {
		  var en = [];
		  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
		  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
		  var t = es * es;
		  en[2] = t * (C44 - es * (C46 + es * C48));
		  t *= es;
		  en[3] = t * (C66 - es * C68);
		  en[4] = t * es * C88;
		  return en;
		};

		var pj_mlfn = function(phi, sphi, cphi, en) {
		  cphi *= sphi;
		  sphi *= sphi;
		  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
		};

		var MAX_ITER = 20;

		var pj_inv_mlfn = function(arg, es, en) {
		  var k = 1 / (1 - es);
		  var phi = arg;
		  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
		    var s = Math.sin(phi);
		    var t = 1 - es * s * s;
		    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
		    //phi -= t * (t * Math.sqrt(t)) * k;
		    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
		    phi -= t;
		    if (Math.abs(t) < EPSLN) {
		      return phi;
		    }
		  }
		  //..reportError("cass:pj_inv_mlfn: Convergence error");
		  return phi;
		};

		// Heavily based on this tmerc projection implementation
		// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js

		function init$2() {
		  this.x0 = this.x0 !== undefined ? this.x0 : 0;
		  this.y0 = this.y0 !== undefined ? this.y0 : 0;
		  this.long0 = this.long0 !== undefined ? this.long0 : 0;
		  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

		  if (this.es) {
		    this.en = pj_enfn(this.es);
		    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
		  }
		}

		/**
		    Transverse Mercator Forward  - long/lat to x/y
		    long/lat in radians
		  */
		function forward$2(p) {
		  var lon = p.x;
		  var lat = p.y;

		  var delta_lon = adjust_lon(lon - this.long0);
		  var con;
		  var x, y;
		  var sin_phi = Math.sin(lat);
		  var cos_phi = Math.cos(lat);

		  if (!this.es) {
		    var b = cos_phi * Math.sin(delta_lon);

		    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
		      return (93);
		    }
		    else {
		      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
		      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
		      b = Math.abs(y);

		      if (b >= 1) {
		        if ((b - 1) > EPSLN) {
		          return (93);
		        }
		        else {
		          y = 0;
		        }
		      }
		      else {
		        y = Math.acos(y);
		      }

		      if (lat < 0) {
		        y = -y;
		      }

		      y = this.a * this.k0 * (y - this.lat0) + this.y0;
		    }
		  }
		  else {
		    var al = cos_phi * delta_lon;
		    var als = Math.pow(al, 2);
		    var c = this.ep2 * Math.pow(cos_phi, 2);
		    var cs = Math.pow(c, 2);
		    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
		    var t = Math.pow(tq, 2);
		    var ts = Math.pow(t, 2);
		    con = 1 - this.es * Math.pow(sin_phi, 2);
		    al = al / Math.sqrt(con);
		    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

		    x = this.a * (this.k0 * al * (1 +
		      als / 6 * (1 - t + c +
		      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
		      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
		      this.x0;

		    y = this.a * (this.k0 * (ml - this.ml0 +
		      sin_phi * delta_lon * al / 2 * (1 +
		      als / 12 * (5 - t + 9 * c + 4 * cs +
		      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
		      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
		      this.y0;
		  }

		  p.x = x;
		  p.y = y;

		  return p;
		}

		/**
		    Transverse Mercator Inverse  -  x/y to long/lat
		  */
		function inverse$2(p) {
		  var con, phi;
		  var lat, lon;
		  var x = (p.x - this.x0) * (1 / this.a);
		  var y = (p.y - this.y0) * (1 / this.a);

		  if (!this.es) {
		    var f = Math.exp(x / this.k0);
		    var g = 0.5 * (f - 1 / f);
		    var temp = this.lat0 + y / this.k0;
		    var h = Math.cos(temp);
		    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
		    lat = Math.asin(con);

		    if (y < 0) {
		      lat = -lat;
		    }

		    if ((g === 0) && (h === 0)) {
		      lon = 0;
		    }
		    else {
		      lon = adjust_lon(Math.atan2(g, h) + this.long0);
		    }
		  }
		  else { // ellipsoidal form
		    con = this.ml0 + y / this.k0;
		    phi = pj_inv_mlfn(con, this.es, this.en);

		    if (Math.abs(phi) < HALF_PI) {
		      var sin_phi = Math.sin(phi);
		      var cos_phi = Math.cos(phi);
		      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
		      var c = this.ep2 * Math.pow(cos_phi, 2);
		      var cs = Math.pow(c, 2);
		      var t = Math.pow(tan_phi, 2);
		      var ts = Math.pow(t, 2);
		      con = 1 - this.es * Math.pow(sin_phi, 2);
		      var d = x * Math.sqrt(con) / this.k0;
		      var ds = Math.pow(d, 2);
		      con = con * tan_phi;

		      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
		        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
		        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
		        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

		      lon = adjust_lon(this.long0 + (d * (1 -
		        ds / 6 * (1 + 2 * t + c -
		        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
		        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
		    }
		    else {
		      lat = HALF_PI * sign(y);
		      lon = 0;
		    }
		  }

		  p.x = lon;
		  p.y = lat;

		  return p;
		}

		var names$3 = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
		var tmerc = {
		  init: init$2,
		  forward: forward$2,
		  inverse: inverse$2,
		  names: names$3
		};

		var sinh = function(x) {
		  var r = Math.exp(x);
		  r = (r - 1 / r) / 2;
		  return r;
		};

		var hypot = function(x, y) {
		  x = Math.abs(x);
		  y = Math.abs(y);
		  var a = Math.max(x, y);
		  var b = Math.min(x, y) / (a ? a : 1);

		  return a * Math.sqrt(1 + Math.pow(b, 2));
		};

		var log1py = function(x) {
		  var y = 1 + x;
		  var z = y - 1;

		  return z === 0 ? x : x * Math.log(y) / z;
		};

		var asinhy = function(x) {
		  var y = Math.abs(x);
		  y = log1py(y * (1 + y / (hypot(1, y) + 1)));

		  return x < 0 ? -y : y;
		};

		var gatg = function(pp, B) {
		  var cos_2B = 2 * Math.cos(2 * B);
		  var i = pp.length - 1;
		  var h1 = pp[i];
		  var h2 = 0;
		  var h;

		  while (--i >= 0) {
		    h = -h2 + cos_2B * h1 + pp[i];
		    h2 = h1;
		    h1 = h;
		  }

		  return (B + h * Math.sin(2 * B));
		};

		var clens = function(pp, arg_r) {
		  var r = 2 * Math.cos(arg_r);
		  var i = pp.length - 1;
		  var hr1 = pp[i];
		  var hr2 = 0;
		  var hr;

		  while (--i >= 0) {
		    hr = -hr2 + r * hr1 + pp[i];
		    hr2 = hr1;
		    hr1 = hr;
		  }

		  return Math.sin(arg_r) * hr;
		};

		var cosh = function(x) {
		  var r = Math.exp(x);
		  r = (r + 1 / r) / 2;
		  return r;
		};

		var clens_cmplx = function(pp, arg_r, arg_i) {
		  var sin_arg_r = Math.sin(arg_r);
		  var cos_arg_r = Math.cos(arg_r);
		  var sinh_arg_i = sinh(arg_i);
		  var cosh_arg_i = cosh(arg_i);
		  var r = 2 * cos_arg_r * cosh_arg_i;
		  var i = -2 * sin_arg_r * sinh_arg_i;
		  var j = pp.length - 1;
		  var hr = pp[j];
		  var hi1 = 0;
		  var hr1 = 0;
		  var hi = 0;
		  var hr2;
		  var hi2;

		  while (--j >= 0) {
		    hr2 = hr1;
		    hi2 = hi1;
		    hr1 = hr;
		    hi1 = hi;
		    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
		    hi = -hi2 + i * hr1 + r * hi1;
		  }

		  r = sin_arg_r * cosh_arg_i;
		  i = cos_arg_r * sinh_arg_i;

		  return [r * hr - i * hi, r * hi + i * hr];
		};

		// Heavily based on this etmerc projection implementation
		// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js

		function init$3() {
		  if (this.es === undefined || this.es <= 0) {
		    throw new Error('incorrect elliptical usage');
		  }

		  this.x0 = this.x0 !== undefined ? this.x0 : 0;
		  this.y0 = this.y0 !== undefined ? this.y0 : 0;
		  this.long0 = this.long0 !== undefined ? this.long0 : 0;
		  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

		  this.cgb = [];
		  this.cbg = [];
		  this.utg = [];
		  this.gtu = [];

		  var f = this.es / (1 + Math.sqrt(1 - this.es));
		  var n = f / (2 - f);
		  var np = n;

		  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
		  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

		  np = np * n;
		  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
		  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

		  np = np * n;
		  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
		  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

		  np = np * n;
		  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
		  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

		  np = np * n;
		  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
		  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

		  np = np * n;
		  this.cgb[5] = np * (601676 / 22275);
		  this.cbg[5] = np * (444337 / 155925);

		  np = Math.pow(n, 2);
		  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

		  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
		  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

		  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
		  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

		  np = np * n;
		  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
		  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

		  np = np * n;
		  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
		  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

		  np = np * n;
		  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
		  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

		  np = np * n;
		  this.utg[5] = np * (-20648693 / 638668800);
		  this.gtu[5] = np * (212378941 / 319334400);

		  var Z = gatg(this.cbg, this.lat0);
		  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
		}

		function forward$3(p) {
		  var Ce = adjust_lon(p.x - this.long0);
		  var Cn = p.y;

		  Cn = gatg(this.cbg, Cn);
		  var sin_Cn = Math.sin(Cn);
		  var cos_Cn = Math.cos(Cn);
		  var sin_Ce = Math.sin(Ce);
		  var cos_Ce = Math.cos(Ce);

		  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
		  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
		  Ce = asinhy(Math.tan(Ce));

		  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

		  Cn = Cn + tmp[0];
		  Ce = Ce + tmp[1];

		  var x;
		  var y;

		  if (Math.abs(Ce) <= 2.623395162778) {
		    x = this.a * (this.Qn * Ce) + this.x0;
		    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
		  }
		  else {
		    x = Infinity;
		    y = Infinity;
		  }

		  p.x = x;
		  p.y = y;

		  return p;
		}

		function inverse$3(p) {
		  var Ce = (p.x - this.x0) * (1 / this.a);
		  var Cn = (p.y - this.y0) * (1 / this.a);

		  Cn = (Cn - this.Zb) / this.Qn;
		  Ce = Ce / this.Qn;

		  var lon;
		  var lat;

		  if (Math.abs(Ce) <= 2.623395162778) {
		    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

		    Cn = Cn + tmp[0];
		    Ce = Ce + tmp[1];
		    Ce = Math.atan(sinh(Ce));

		    var sin_Cn = Math.sin(Cn);
		    var cos_Cn = Math.cos(Cn);
		    var sin_Ce = Math.sin(Ce);
		    var cos_Ce = Math.cos(Ce);

		    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
		    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

		    lon = adjust_lon(Ce + this.long0);
		    lat = gatg(this.cgb, Cn);
		  }
		  else {
		    lon = Infinity;
		    lat = Infinity;
		  }

		  p.x = lon;
		  p.y = lat;

		  return p;
		}

		var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
		var etmerc = {
		  init: init$3,
		  forward: forward$3,
		  inverse: inverse$3,
		  names: names$4
		};

		var adjust_zone = function(zone, lon) {
		  if (zone === undefined) {
		    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

		    if (zone < 0) {
		      return 0;
		    } else if (zone > 60) {
		      return 60;
		    }
		  }
		  return zone;
		};

		var dependsOn = 'etmerc';
		function init$4() {
		  var zone = adjust_zone(this.zone, this.long0);
		  if (zone === undefined) {
		    throw new Error('unknown utm zone');
		  }
		  this.lat0 = 0;
		  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
		  this.x0 = 500000;
		  this.y0 = this.utmSouth ? 10000000 : 0;
		  this.k0 = 0.9996;

		  etmerc.init.apply(this);
		  this.forward = etmerc.forward;
		  this.inverse = etmerc.inverse;
		}

		var names$5 = ["Universal Transverse Mercator System", "utm"];
		var utm = {
		  init: init$4,
		  names: names$5,
		  dependsOn: dependsOn
		};

		var srat = function(esinp, exp) {
		  return (Math.pow((1 - esinp) / (1 + esinp), exp));
		};

		var MAX_ITER$1 = 20;
		function init$6() {
		  var sphi = Math.sin(this.lat0);
		  var cphi = Math.cos(this.lat0);
		  cphi *= cphi;
		  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
		  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
		  this.phic0 = Math.asin(sphi / this.C);
		  this.ratexp = 0.5 * this.C * this.e;
		  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
		}

		function forward$5(p) {
		  var lon = p.x;
		  var lat = p.y;

		  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
		  p.x = this.C * lon;
		  return p;
		}

		function inverse$5(p) {
		  var DEL_TOL = 1e-14;
		  var lon = p.x / this.C;
		  var lat = p.y;
		  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
		  for (var i = MAX_ITER$1; i > 0; --i) {
		    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
		    if (Math.abs(lat - p.y) < DEL_TOL) {
		      break;
		    }
		    p.y = lat;
		  }
		  /* convergence failed */
		  if (!i) {
		    return null;
		  }
		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$7 = ["gauss"];
		var gauss = {
		  init: init$6,
		  forward: forward$5,
		  inverse: inverse$5,
		  names: names$7
		};

		function init$5() {
		  gauss.init.apply(this);
		  if (!this.rc) {
		    return;
		  }
		  this.sinc0 = Math.sin(this.phic0);
		  this.cosc0 = Math.cos(this.phic0);
		  this.R2 = 2 * this.rc;
		  if (!this.title) {
		    this.title = "Oblique Stereographic Alternative";
		  }
		}

		function forward$4(p) {
		  var sinc, cosc, cosl, k;
		  p.x = adjust_lon(p.x - this.long0);
		  gauss.forward.apply(this, [p]);
		  sinc = Math.sin(p.y);
		  cosc = Math.cos(p.y);
		  cosl = Math.cos(p.x);
		  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
		  p.x = k * cosc * Math.sin(p.x);
		  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
		  p.x = this.a * p.x + this.x0;
		  p.y = this.a * p.y + this.y0;
		  return p;
		}

		function inverse$4(p) {
		  var sinc, cosc, lon, lat, rho;
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;

		  p.x /= this.k0;
		  p.y /= this.k0;
		  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
		    var c = 2 * Math.atan2(rho, this.R2);
		    sinc = Math.sin(c);
		    cosc = Math.cos(c);
		    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
		    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
		  }
		  else {
		    lat = this.phic0;
		    lon = 0;
		  }

		  p.x = lon;
		  p.y = lat;
		  gauss.inverse.apply(this, [p]);
		  p.x = adjust_lon(p.x + this.long0);
		  return p;
		}

		var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];
		var sterea = {
		  init: init$5,
		  forward: forward$4,
		  inverse: inverse$4,
		  names: names$6
		};

		function ssfn_(phit, sinphi, eccen) {
		  sinphi *= eccen;
		  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
		}

		function init$7() {
		  this.coslat0 = Math.cos(this.lat0);
		  this.sinlat0 = Math.sin(this.lat0);
		  if (this.sphere) {
		    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
		      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
		    }
		  }
		  else {
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      if (this.lat0 > 0) {
		        //North pole
		        //trace('stere:north pole');
		        this.con = 1;
		      }
		      else {
		        //South pole
		        //trace('stere:south pole');
		        this.con = -1;
		      }
		    }
		    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
		    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
		      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
		    }
		    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
		    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
		    this.cosX0 = Math.cos(this.X0);
		    this.sinX0 = Math.sin(this.X0);
		  }
		}

		// Stereographic forward equations--mapping lat,long to x,y
		function forward$6(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var sinlat = Math.sin(lat);
		  var coslat = Math.cos(lat);
		  var A, X, sinX, cosX, ts, rh;
		  var dlon = adjust_lon(lon - this.long0);

		  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
		    //case of the origine point
		    //trace('stere:this is the origin point');
		    p.x = NaN;
		    p.y = NaN;
		    return p;
		  }
		  if (this.sphere) {
		    //trace('stere:sphere case');
		    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
		    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
		    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
		    return p;
		  }
		  else {
		    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
		    cosX = Math.cos(X);
		    sinX = Math.sin(X);
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
		      rh = 2 * this.a * this.k0 * ts / this.cons;
		      p.x = this.x0 + rh * Math.sin(lon - this.long0);
		      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
		      //trace(p.toString());
		      return p;
		    }
		    else if (Math.abs(this.sinlat0) < EPSLN) {
		      //Eq
		      //trace('stere:equateur');
		      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
		      p.y = A * sinX;
		    }
		    else {
		      //other case
		      //trace('stere:normal case');
		      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
		      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
		    }
		    p.x = A * cosX * Math.sin(dlon) + this.x0;
		  }
		  //trace(p.toString());
		  return p;
		}

		//* Stereographic inverse equations--mapping x,y to lat/long
		function inverse$6(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var lon, lat, ts, ce, Chi;
		  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
		  if (this.sphere) {
		    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
		    lon = this.long0;
		    lat = this.lat0;
		    if (rh <= EPSLN) {
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
		    if (Math.abs(this.coslat0) < EPSLN) {
		      if (this.lat0 > 0) {
		        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
		      }
		      else {
		        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
		      }
		    }
		    else {
		      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
		    }
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      if (rh <= EPSLN) {
		        lat = this.lat0;
		        lon = this.long0;
		        p.x = lon;
		        p.y = lat;
		        //trace(p.toString());
		        return p;
		      }
		      p.x *= this.con;
		      p.y *= this.con;
		      ts = rh * this.cons / (2 * this.a * this.k0);
		      lat = this.con * phi2z(this.e, ts);
		      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
		    }
		    else {
		      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
		      lon = this.long0;
		      if (rh <= EPSLN) {
		        Chi = this.X0;
		      }
		      else {
		        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
		        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
		      }
		      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
		    }
		  }
		  p.x = lon;
		  p.y = lat;

		  //trace(p.toString());
		  return p;

		}

		var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
		var stere = {
		  init: init$7,
		  forward: forward$6,
		  inverse: inverse$6,
		  names: names$8,
		  ssfn_: ssfn_
		};

		/*
		  references:
		    Formules et constantes pour le Calcul pour la
		    projection cylindrique conforme à axe oblique et pour la transformation entre
		    des systèmes de référence.
		    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
		  */

		function init$8() {
		  var phy0 = this.lat0;
		  this.lambda0 = this.long0;
		  var sinPhy0 = Math.sin(phy0);
		  var semiMajorAxis = this.a;
		  var invF = this.rf;
		  var flattening = 1 / invF;
		  var e2 = 2 * flattening - Math.pow(flattening, 2);
		  var e = this.e = Math.sqrt(e2);
		  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
		  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
		  this.b0 = Math.asin(sinPhy0 / this.alpha);
		  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
		  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
		  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
		  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
		}

		function forward$7(p) {
		  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
		  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
		  var S = -this.alpha * (Sa1 + Sa2) + this.K;

		  // spheric latitude
		  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

		  // spheric longitude
		  var I = this.alpha * (p.x - this.lambda0);

		  // psoeudo equatorial rotation
		  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

		  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

		  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
		  p.x = this.R * rotI + this.x0;
		  return p;
		}

		function inverse$7(p) {
		  var Y = p.x - this.x0;
		  var X = p.y - this.y0;

		  var rotI = Y / this.R;
		  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

		  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
		  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

		  var lambda = this.lambda0 + I / this.alpha;

		  var S = 0;
		  var phy = b;
		  var prevPhy = -1000;
		  var iteration = 0;
		  while (Math.abs(phy - prevPhy) > 0.0000001) {
		    if (++iteration > 20) {
		      //...reportError("omercFwdInfinity");
		      return;
		    }
		    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
		    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
		    prevPhy = phy;
		    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
		  }

		  p.x = lambda;
		  p.y = phy;
		  return p;
		}

		var names$9 = ["somerc"];
		var somerc = {
		  init: init$8,
		  forward: forward$7,
		  inverse: inverse$7,
		  names: names$9
		};

		/* Initialize the Oblique Mercator  projection
		    ------------------------------------------*/
		function init$9() {
		  this.no_off = this.no_off || false;
		  this.no_rot = this.no_rot || false;

		  if (isNaN(this.k0)) {
		    this.k0 = 1;
		  }
		  var sinlat = Math.sin(this.lat0);
		  var coslat = Math.cos(this.lat0);
		  var con = this.e * sinlat;

		  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
		  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
		  var t0 = tsfnz(this.e, this.lat0, sinlat);
		  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
		  if (dl * dl < 1) {
		    dl = 1;
		  }
		  var fl;
		  var gl;
		  if (!isNaN(this.longc)) {
		    //Central point and azimuth method

		    if (this.lat0 >= 0) {
		      fl = dl + Math.sqrt(dl * dl - 1);
		    }
		    else {
		      fl = dl - Math.sqrt(dl * dl - 1);
		    }
		    this.el = fl * Math.pow(t0, this.bl);
		    gl = 0.5 * (fl - 1 / fl);
		    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
		    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

		  }
		  else {
		    //2 points method
		    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
		    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
		    if (this.lat0 >= 0) {
		      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
		    }
		    else {
		      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
		    }
		    var hl = Math.pow(t1, this.bl);
		    var ll = Math.pow(t2, this.bl);
		    fl = this.el / hl;
		    gl = 0.5 * (fl - 1 / fl);
		    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
		    var pl = (ll - hl) / (ll + hl);
		    var dlon12 = adjust_lon(this.long1 - this.long2);
		    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
		    this.long0 = adjust_lon(this.long0);
		    var dlon10 = adjust_lon(this.long1 - this.long0);
		    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
		    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
		  }

		  if (this.no_off) {
		    this.uc = 0;
		  }
		  else {
		    if (this.lat0 >= 0) {
		      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
		    }
		    else {
		      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
		    }
		  }

		}

		/* Oblique Mercator forward equations--mapping lat,long to x,y
		    ----------------------------------------------------------*/
		function forward$8(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var dlon = adjust_lon(lon - this.long0);
		  var us, vs;
		  var con;
		  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
		    if (lat > 0) {
		      con = -1;
		    }
		    else {
		      con = 1;
		    }
		    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
		    us = -1 * con * HALF_PI * this.al / this.bl;
		  }
		  else {
		    var t = tsfnz(this.e, lat, Math.sin(lat));
		    var ql = this.el / Math.pow(t, this.bl);
		    var sl = 0.5 * (ql - 1 / ql);
		    var tl = 0.5 * (ql + 1 / ql);
		    var vl = Math.sin(this.bl * (dlon));
		    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
		    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
		      vs = Number.POSITIVE_INFINITY;
		    }
		    else {
		      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
		    }
		    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
		      us = this.al * this.bl * (dlon);
		    }
		    else {
		      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
		    }
		  }

		  if (this.no_rot) {
		    p.x = this.x0 + us;
		    p.y = this.y0 + vs;
		  }
		  else {

		    us -= this.uc;
		    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
		    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
		  }
		  return p;
		}

		function inverse$8(p) {
		  var us, vs;
		  if (this.no_rot) {
		    vs = p.y - this.y0;
		    us = p.x - this.x0;
		  }
		  else {
		    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
		    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
		    us += this.uc;
		  }
		  var qp = Math.exp(-1 * this.bl * vs / this.al);
		  var sp = 0.5 * (qp - 1 / qp);
		  var tp = 0.5 * (qp + 1 / qp);
		  var vp = Math.sin(this.bl * us / this.al);
		  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
		  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
		  if (Math.abs(up - 1) < EPSLN) {
		    p.x = this.long0;
		    p.y = HALF_PI;
		  }
		  else if (Math.abs(up + 1) < EPSLN) {
		    p.x = this.long0;
		    p.y = -1 * HALF_PI;
		  }
		  else {
		    p.y = phi2z(this.e, ts);
		    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
		  }
		  return p;
		}

		var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
		var omerc = {
		  init: init$9,
		  forward: forward$8,
		  inverse: inverse$8,
		  names: names$10
		};

		function init$10() {

		  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
		  //double c_lat;                   /* center latitude                      */
		  //double c_lon;                   /* center longitude                     */
		  //double lat1;                    /* first standard parallel              */
		  //double lat2;                    /* second standard parallel             */
		  //double r_maj;                   /* major axis                           */
		  //double r_min;                   /* minor axis                           */
		  //double false_east;              /* x offset in meters                   */
		  //double false_north;             /* y offset in meters                   */

		  if (!this.lat2) {
		    this.lat2 = this.lat1;
		  } //if lat2 is not defined
		  if (!this.k0) {
		    this.k0 = 1;
		  }
		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  // Standard Parallels cannot be equal and on opposite sides of the equator
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }

		  var temp = this.b / this.a;
		  this.e = Math.sqrt(1 - temp * temp);

		  var sin1 = Math.sin(this.lat1);
		  var cos1 = Math.cos(this.lat1);
		  var ms1 = msfnz(this.e, sin1, cos1);
		  var ts1 = tsfnz(this.e, this.lat1, sin1);

		  var sin2 = Math.sin(this.lat2);
		  var cos2 = Math.cos(this.lat2);
		  var ms2 = msfnz(this.e, sin2, cos2);
		  var ts2 = tsfnz(this.e, this.lat2, sin2);

		  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

		  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
		    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
		  }
		  else {
		    this.ns = sin1;
		  }
		  if (isNaN(this.ns)) {
		    this.ns = sin1;
		  }
		  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
		  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
		  if (!this.title) {
		    this.title = "Lambert Conformal Conic";
		  }
		}

		// Lambert Conformal conic forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$9(p) {

		  var lon = p.x;
		  var lat = p.y;

		  // singular cases :
		  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
		    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
		  }

		  var con = Math.abs(Math.abs(lat) - HALF_PI);
		  var ts, rh1;
		  if (con > EPSLN) {
		    ts = tsfnz(this.e, lat, Math.sin(lat));
		    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
		  }
		  else {
		    con = lat * this.ns;
		    if (con <= 0) {
		      return null;
		    }
		    rh1 = 0;
		  }
		  var theta = this.ns * adjust_lon(lon - this.long0);
		  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
		  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

		  return p;
		}

		// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$9(p) {

		  var rh1, con, ts;
		  var lat, lon;
		  var x = (p.x - this.x0) / this.k0;
		  var y = (this.rh - (p.y - this.y0) / this.k0);
		  if (this.ns > 0) {
		    rh1 = Math.sqrt(x * x + y * y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(x * x + y * y);
		    con = -1;
		  }
		  var theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2((con * x), (con * y));
		  }
		  if ((rh1 !== 0) || (this.ns > 0)) {
		    con = 1 / this.ns;
		    ts = Math.pow((rh1 / (this.a * this.f0)), con);
		    lat = phi2z(this.e, ts);
		    if (lat === -9999) {
		      return null;
		    }
		  }
		  else {
		    lat = -HALF_PI;
		  }
		  lon = adjust_lon(theta / this.ns + this.long0);

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$11 = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
		var lcc = {
		  init: init$10,
		  forward: forward$9,
		  inverse: inverse$9,
		  names: names$11
		};

		function init$11() {
		  this.a = 6377397.155;
		  this.es = 0.006674372230614;
		  this.e = Math.sqrt(this.es);
		  if (!this.lat0) {
		    this.lat0 = 0.863937979737193;
		  }
		  if (!this.long0) {
		    this.long0 = 0.7417649320975901 - 0.308341501185665;
		  }
		  /* if scale not set default to 0.9999 */
		  if (!this.k0) {
		    this.k0 = 0.9999;
		  }
		  this.s45 = 0.785398163397448; /* 45 */
		  this.s90 = 2 * this.s45;
		  this.fi0 = this.lat0;
		  this.e2 = this.es;
		  this.e = Math.sqrt(this.e2);
		  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
		  this.uq = 1.04216856380474;
		  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
		  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
		  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
		  this.k1 = this.k0;
		  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
		  this.s0 = 1.37008346281555;
		  this.n = Math.sin(this.s0);
		  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
		  this.ad = this.s90 - this.uq;
		}

		/* ellipsoid */
		/* calculate xy from lat/lon */
		/* Constants, identical to inverse transform function */
		function forward$10(p) {
		  var gfi, u, deltav, s, d, eps, ro;
		  var lon = p.x;
		  var lat = p.y;
		  var delta_lon = adjust_lon(lon - this.long0);
		  /* Transformation */
		  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
		  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
		  deltav = -delta_lon * this.alfa;
		  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
		  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
		  eps = this.n * d;
		  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
		  p.y = ro * Math.cos(eps) / 1;
		  p.x = ro * Math.sin(eps) / 1;

		  if (!this.czech) {
		    p.y *= -1;
		    p.x *= -1;
		  }
		  return (p);
		}

		/* calculate lat/lon from xy */
		function inverse$10(p) {
		  var u, deltav, s, d, eps, ro, fi1;
		  var ok;

		  /* Transformation */
		  /* revert y, x*/
		  var tmp = p.x;
		  p.x = p.y;
		  p.y = tmp;
		  if (!this.czech) {
		    p.y *= -1;
		    p.x *= -1;
		  }
		  ro = Math.sqrt(p.x * p.x + p.y * p.y);
		  eps = Math.atan2(p.y, p.x);
		  d = eps / Math.sin(this.s0);
		  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
		  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
		  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
		  p.x = this.long0 - deltav / this.alfa;
		  fi1 = u;
		  ok = 0;
		  var iter = 0;
		  do {
		    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
		    if (Math.abs(fi1 - p.y) < 0.0000000001) {
		      ok = 1;
		    }
		    fi1 = p.y;
		    iter += 1;
		  } while (ok === 0 && iter < 15);
		  if (iter >= 15) {
		    return null;
		  }

		  return (p);
		}

		var names$12 = ["Krovak", "krovak"];
		var krovak = {
		  init: init$11,
		  forward: forward$10,
		  inverse: inverse$10,
		  names: names$12
		};

		var mlfn = function(e0, e1, e2, e3, phi) {
		  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
		};

		var e0fn = function(x) {
		  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
		};

		var e1fn = function(x) {
		  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
		};

		var e2fn = function(x) {
		  return (0.05859375 * x * x * (1 + 0.75 * x));
		};

		var e3fn = function(x) {
		  return (x * x * x * (35 / 3072));
		};

		var gN = function(a, e, sinphi) {
		  var temp = e * sinphi;
		  return a / Math.sqrt(1 - temp * temp);
		};

		var adjust_lat = function(x) {
		  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
		};

		var imlfn = function(ml, e0, e1, e2, e3) {
		  var phi;
		  var dphi;

		  phi = ml / e0;
		  for (var i = 0; i < 15; i++) {
		    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }

		  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
		  return NaN;
		};

		function init$12() {
		  if (!this.sphere) {
		    this.e0 = e0fn(this.es);
		    this.e1 = e1fn(this.es);
		    this.e2 = e2fn(this.es);
		    this.e3 = e3fn(this.es);
		    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
		  }
		}

		/* Cassini forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------------------*/
		function forward$11(p) {

		  /* Forward equations
		      -----------------*/
		  var x, y;
		  var lam = p.x;
		  var phi = p.y;
		  lam = adjust_lon(lam - this.long0);

		  if (this.sphere) {
		    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
		    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
		  }
		  else {
		    //ellipsoid
		    var sinphi = Math.sin(phi);
		    var cosphi = Math.cos(phi);
		    var nl = gN(this.a, this.e, sinphi);
		    var tl = Math.tan(phi) * Math.tan(phi);
		    var al = lam * Math.cos(phi);
		    var asq = al * al;
		    var cl = this.es * cosphi * cosphi / (1 - this.es);
		    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

		    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
		    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


		  }

		  p.x = x + this.x0;
		  p.y = y + this.y0;
		  return p;
		}

		/* Inverse equations
		  -----------------*/
		function inverse$11(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var x = p.x / this.a;
		  var y = p.y / this.a;
		  var phi, lam;

		  if (this.sphere) {
		    var dd = y + this.lat0;
		    phi = Math.asin(Math.sin(dd) * Math.cos(x));
		    lam = Math.atan2(Math.tan(x), Math.cos(dd));
		  }
		  else {
		    /* ellipsoid */
		    var ml1 = this.ml0 / this.a + y;
		    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
		    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
		      p.x = this.long0;
		      p.y = HALF_PI;
		      if (y < 0) {
		        p.y *= -1;
		      }
		      return p;
		    }
		    var nl1 = gN(this.a, this.e, Math.sin(phi1));

		    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
		    var tl1 = Math.pow(Math.tan(phi1), 2);
		    var dl = x * this.a / nl1;
		    var dsq = dl * dl;
		    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
		    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

		  }

		  p.x = adjust_lon(lam + this.long0);
		  p.y = adjust_lat(phi);
		  return p;

		}

		var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
		var cass = {
		  init: init$12,
		  forward: forward$11,
		  inverse: inverse$11,
		  names: names$13
		};

		var qsfnz = function(eccent, sinphi) {
		  var con;
		  if (eccent > 1.0e-7) {
		    con = eccent * sinphi;
		    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
		  }
		  else {
		    return (2 * sinphi);
		  }
		};

		/*
		  reference
		    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
		    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
		  */

		var S_POLE = 1;

		var N_POLE = 2;
		var EQUIT = 3;
		var OBLIQ = 4;

		/* Initialize the Lambert Azimuthal Equal Area projection
		  ------------------------------------------------------*/
		function init$13() {
		  var t = Math.abs(this.lat0);
		  if (Math.abs(t - HALF_PI) < EPSLN) {
		    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
		  }
		  else if (Math.abs(t) < EPSLN) {
		    this.mode = this.EQUIT;
		  }
		  else {
		    this.mode = this.OBLIQ;
		  }
		  if (this.es > 0) {
		    var sinphi;

		    this.qp = qsfnz(this.e, 1);
		    this.mmf = 0.5 / (1 - this.es);
		    this.apa = authset(this.es);
		    switch (this.mode) {
		    case this.N_POLE:
		      this.dd = 1;
		      break;
		    case this.S_POLE:
		      this.dd = 1;
		      break;
		    case this.EQUIT:
		      this.rq = Math.sqrt(0.5 * this.qp);
		      this.dd = 1 / this.rq;
		      this.xmf = 1;
		      this.ymf = 0.5 * this.qp;
		      break;
		    case this.OBLIQ:
		      this.rq = Math.sqrt(0.5 * this.qp);
		      sinphi = Math.sin(this.lat0);
		      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
		      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
		      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
		      this.ymf = (this.xmf = this.rq) / this.dd;
		      this.xmf *= this.dd;
		      break;
		    }
		  }
		  else {
		    if (this.mode === this.OBLIQ) {
		      this.sinph0 = Math.sin(this.lat0);
		      this.cosph0 = Math.cos(this.lat0);
		    }
		  }
		}

		/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------------------*/
		function forward$12(p) {

		  /* Forward equations
		      -----------------*/
		  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
		  var lam = p.x;
		  var phi = p.y;

		  lam = adjust_lon(lam - this.long0);
		  if (this.sphere) {
		    sinphi = Math.sin(phi);
		    cosphi = Math.cos(phi);
		    coslam = Math.cos(lam);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
		      if (y <= EPSLN) {
		        return null;
		      }
		      y = Math.sqrt(2 / y);
		      x = y * cosphi * Math.sin(lam);
		      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
		    }
		    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
		      if (this.mode === this.N_POLE) {
		        coslam = -coslam;
		      }
		      if (Math.abs(phi + this.phi0) < EPSLN) {
		        return null;
		      }
		      y = FORTPI - phi * 0.5;
		      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
		      x = y * Math.sin(lam);
		      y *= coslam;
		    }
		  }
		  else {
		    sinb = 0;
		    cosb = 0;
		    b = 0;
		    coslam = Math.cos(lam);
		    sinlam = Math.sin(lam);
		    sinphi = Math.sin(phi);
		    q = qsfnz(this.e, sinphi);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      sinb = q / this.qp;
		      cosb = Math.sqrt(1 - sinb * sinb);
		    }
		    switch (this.mode) {
		    case this.OBLIQ:
		      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
		      break;
		    case this.EQUIT:
		      b = 1 + cosb * coslam;
		      break;
		    case this.N_POLE:
		      b = HALF_PI + phi;
		      q = this.qp - q;
		      break;
		    case this.S_POLE:
		      b = phi - HALF_PI;
		      q = this.qp + q;
		      break;
		    }
		    if (Math.abs(b) < EPSLN) {
		      return null;
		    }
		    switch (this.mode) {
		    case this.OBLIQ:
		    case this.EQUIT:
		      b = Math.sqrt(2 / b);
		      if (this.mode === this.OBLIQ) {
		        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
		      }
		      else {
		        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
		      }
		      x = this.xmf * b * cosb * sinlam;
		      break;
		    case this.N_POLE:
		    case this.S_POLE:
		      if (q >= 0) {
		        x = (b = Math.sqrt(q)) * sinlam;
		        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
		      }
		      else {
		        x = y = 0;
		      }
		      break;
		    }
		  }

		  p.x = this.a * x + this.x0;
		  p.y = this.a * y + this.y0;
		  return p;
		}

		/* Inverse equations
		  -----------------*/
		function inverse$12(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var x = p.x / this.a;
		  var y = p.y / this.a;
		  var lam, phi, cCe, sCe, q, rho, ab;
		  if (this.sphere) {
		    var cosz = 0,
		      rh, sinz = 0;

		    rh = Math.sqrt(x * x + y * y);
		    phi = rh * 0.5;
		    if (phi > 1) {
		      return null;
		    }
		    phi = 2 * Math.asin(phi);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      sinz = Math.sin(phi);
		      cosz = Math.cos(phi);
		    }
		    switch (this.mode) {
		    case this.EQUIT:
		      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
		      x *= sinz;
		      y = cosz * rh;
		      break;
		    case this.OBLIQ:
		      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
		      x *= sinz * this.cosph0;
		      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
		      break;
		    case this.N_POLE:
		      y = -y;
		      phi = HALF_PI - phi;
		      break;
		    case this.S_POLE:
		      phi -= HALF_PI;
		      break;
		    }
		    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
		  }
		  else {
		    ab = 0;
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      x /= this.dd;
		      y *= this.dd;
		      rho = Math.sqrt(x * x + y * y);
		      if (rho < EPSLN) {
		        p.x = 0;
		        p.y = this.phi0;
		        return p;
		      }
		      sCe = 2 * Math.asin(0.5 * rho / this.rq);
		      cCe = Math.cos(sCe);
		      x *= (sCe = Math.sin(sCe));
		      if (this.mode === this.OBLIQ) {
		        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
		        q = this.qp * ab;
		        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
		      }
		      else {
		        ab = y * sCe / rho;
		        q = this.qp * ab;
		        y = rho * cCe;
		      }
		    }
		    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
		      if (this.mode === this.N_POLE) {
		        y = -y;
		      }
		      q = (x * x + y * y);
		      if (!q) {
		        p.x = 0;
		        p.y = this.phi0;
		        return p;
		      }
		      ab = 1 - q / this.qp;
		      if (this.mode === this.S_POLE) {
		        ab = -ab;
		      }
		    }
		    lam = Math.atan2(x, y);
		    phi = authlat(Math.asin(ab), this.apa);
		  }

		  p.x = adjust_lon(this.long0 + lam);
		  p.y = phi;
		  return p;
		}

		/* determine latitude from authalic latitude */
		var P00 = 0.33333333333333333333;

		var P01 = 0.17222222222222222222;
		var P02 = 0.10257936507936507936;
		var P10 = 0.06388888888888888888;
		var P11 = 0.06640211640211640211;
		var P20 = 0.01641501294219154443;

		function authset(es) {
		  var t;
		  var APA = [];
		  APA[0] = es * P00;
		  t = es * es;
		  APA[0] += t * P01;
		  APA[1] = t * P10;
		  t *= es;
		  APA[0] += t * P02;
		  APA[1] += t * P11;
		  APA[2] = t * P20;
		  return APA;
		}

		function authlat(beta, APA) {
		  var t = beta + beta;
		  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
		}

		var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
		var laea = {
		  init: init$13,
		  forward: forward$12,
		  inverse: inverse$12,
		  names: names$14,
		  S_POLE: S_POLE,
		  N_POLE: N_POLE,
		  EQUIT: EQUIT,
		  OBLIQ: OBLIQ
		};

		var asinz = function(x) {
		  if (Math.abs(x) > 1) {
		    x = (x > 1) ? 1 : -1;
		  }
		  return Math.asin(x);
		};

		function init$14() {

		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2);
		  this.e3 = Math.sqrt(this.es);

		  this.sin_po = Math.sin(this.lat1);
		  this.cos_po = Math.cos(this.lat1);
		  this.t1 = this.sin_po;
		  this.con = this.sin_po;
		  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
		  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

		  this.sin_po = Math.sin(this.lat2);
		  this.cos_po = Math.cos(this.lat2);
		  this.t2 = this.sin_po;
		  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
		  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

		  this.sin_po = Math.sin(this.lat0);
		  this.cos_po = Math.cos(this.lat0);
		  this.t3 = this.sin_po;
		  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

		  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
		    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
		  }
		  else {
		    this.ns0 = this.con;
		  }
		  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
		  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
		}

		/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
		  -------------------------------------------------------------------*/
		function forward$13(p) {

		  var lon = p.x;
		  var lat = p.y;

		  this.sin_phi = Math.sin(lat);
		  this.cos_phi = Math.cos(lat);

		  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
		  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
		  var theta = this.ns0 * adjust_lon(lon - this.long0);
		  var x = rh1 * Math.sin(theta) + this.x0;
		  var y = this.rh - rh1 * Math.cos(theta) + this.y0;

		  p.x = x;
		  p.y = y;
		  return p;
		}

		function inverse$13(p) {
		  var rh1, qs, con, theta, lon, lat;

		  p.x -= this.x0;
		  p.y = this.rh - p.y + this.y0;
		  if (this.ns0 >= 0) {
		    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
		    con = -1;
		  }
		  theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2(con * p.x, con * p.y);
		  }
		  con = rh1 * this.ns0 / this.a;
		  if (this.sphere) {
		    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
		  }
		  else {
		    qs = (this.c - con * con) / this.ns0;
		    lat = this.phi1z(this.e3, qs);
		  }

		  lon = adjust_lon(theta / this.ns0 + this.long0);
		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		/* Function to compute phi1, the latitude for the inverse of the
		   Albers Conical Equal-Area projection.
		-------------------------------------------*/
		function phi1z(eccent, qs) {
		  var sinphi, cosphi, con, com, dphi;
		  var phi = asinz(0.5 * qs);
		  if (eccent < EPSLN) {
		    return phi;
		  }

		  var eccnts = eccent * eccent;
		  for (var i = 1; i <= 25; i++) {
		    sinphi = Math.sin(phi);
		    cosphi = Math.cos(phi);
		    con = eccent * sinphi;
		    com = 1 - con * con;
		    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
		    phi = phi + dphi;
		    if (Math.abs(dphi) <= 1e-7) {
		      return phi;
		    }
		  }
		  return null;
		}

		var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
		var aea = {
		  init: init$14,
		  forward: forward$13,
		  inverse: inverse$13,
		  names: names$15,
		  phi1z: phi1z
		};

		/*
		  reference:
		    Wolfram Mathworld "Gnomonic Projection"
		    http://mathworld.wolfram.com/GnomonicProjection.html
		    Accessed: 12th November 2009
		  */
		function init$15() {

		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.sin_p14 = Math.sin(this.lat0);
		  this.cos_p14 = Math.cos(this.lat0);
		  // Approximation for projecting points to the horizon (infinity)
		  this.infinity_dist = 1000 * this.a;
		  this.rc = 1;
		}

		/* Gnomonic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$14(p) {
		  var sinphi, cosphi; /* sin and cos value        */
		  var dlon; /* delta longitude value      */
		  var coslon; /* cos of longitude        */
		  var ksp; /* scale factor          */
		  var g;
		  var x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  dlon = adjust_lon(lon - this.long0);

		  sinphi = Math.sin(lat);
		  cosphi = Math.cos(lat);

		  coslon = Math.cos(dlon);
		  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
		  ksp = 1;
		  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
		    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
		    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
		  }
		  else {

		    // Point is in the opposing hemisphere and is unprojectable
		    // We still need to return a reasonable point, so we project
		    // to infinity, on a bearing
		    // equivalent to the northern hemisphere equivalent
		    // This is a reasonable approximation for short shapes and lines that
		    // straddle the horizon.

		    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
		    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}

		function inverse$14(p) {
		  var rh; /* Rho */
		  var sinc, cosc;
		  var c;
		  var lon, lat;

		  /* Inverse equations
		      -----------------*/
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;

		  p.x /= this.k0;
		  p.y /= this.k0;

		  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
		    c = Math.atan2(rh, this.rc);
		    sinc = Math.sin(c);
		    cosc = Math.cos(c);

		    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
		    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
		    lon = adjust_lon(this.long0 + lon);
		  }
		  else {
		    lat = this.phic0;
		    lon = 0;
		  }

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$16 = ["gnom"];
		var gnom = {
		  init: init$15,
		  forward: forward$14,
		  inverse: inverse$14,
		  names: names$16
		};

		var iqsfnz = function(eccent, q) {
		  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
		  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
		    if (q < 0) {
		      return (-1 * HALF_PI);
		    }
		    else {
		      return HALF_PI;
		    }
		  }
		  //var phi = 0.5* q/(1-eccent*eccent);
		  var phi = Math.asin(0.5 * q);
		  var dphi;
		  var sin_phi;
		  var cos_phi;
		  var con;
		  for (var i = 0; i < 30; i++) {
		    sin_phi = Math.sin(phi);
		    cos_phi = Math.cos(phi);
		    con = eccent * sin_phi;
		    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }

		  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
		  return NaN;
		};

		/*
		  reference:
		    "Cartographic Projection Procedures for the UNIX Environment-
		    A User's Manual" by Gerald I. Evenden,
		    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
		*/
		function init$16() {
		  //no-op
		  if (!this.sphere) {
		    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
		  }
		}

		/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
		    ------------------------------------------------------------*/
		function forward$15(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var x, y;
		  /* Forward equations
		      -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  if (this.sphere) {
		    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
		    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
		  }
		  else {
		    var qs = qsfnz(this.e, Math.sin(lat));
		    x = this.x0 + this.a * this.k0 * dlon;
		    y = this.y0 + this.a * qs * 0.5 / this.k0;
		  }

		  p.x = x;
		  p.y = y;
		  return p;
		}

		/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
		    ------------------------------------------------------------*/
		function inverse$15(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var lon, lat;

		  if (this.sphere) {
		    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
		    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
		  }
		  else {
		    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
		    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
		  }

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$17 = ["cea"];
		var cea = {
		  init: init$16,
		  forward: forward$15,
		  inverse: inverse$15,
		  names: names$17
		};

		function init$17() {

		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  this.lat0 = this.lat0 || 0;
		  this.long0 = this.long0 || 0;
		  this.lat_ts = this.lat_ts || 0;
		  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

		  this.rc = Math.cos(this.lat_ts);
		}

		// forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$16(p) {

		  var lon = p.x;
		  var lat = p.y;

		  var dlon = adjust_lon(lon - this.long0);
		  var dlat = adjust_lat(lat - this.lat0);
		  p.x = this.x0 + (this.a * dlon * this.rc);
		  p.y = this.y0 + (this.a * dlat);
		  return p;
		}

		// inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$16(p) {

		  var x = p.x;
		  var y = p.y;

		  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
		  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
		  return p;
		}

		var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
		var eqc = {
		  init: init$17,
		  forward: forward$16,
		  inverse: inverse$16,
		  names: names$18
		};

		var MAX_ITER$2 = 20;

		function init$18() {
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
		  this.e = Math.sqrt(this.es);
		  this.e0 = e0fn(this.es);
		  this.e1 = e1fn(this.es);
		  this.e2 = e2fn(this.es);
		  this.e3 = e3fn(this.es);
		  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
		}

		/* Polyconic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$17(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var x, y, el;
		  var dlon = adjust_lon(lon - this.long0);
		  el = dlon * Math.sin(lat);
		  if (this.sphere) {
		    if (Math.abs(lat) <= EPSLN) {
		      x = this.a * dlon;
		      y = -1 * this.a * this.lat0;
		    }
		    else {
		      x = this.a * Math.sin(el) / Math.tan(lat);
		      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
		    }
		  }
		  else {
		    if (Math.abs(lat) <= EPSLN) {
		      x = this.a * dlon;
		      y = -1 * this.ml0;
		    }
		    else {
		      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
		      x = nl * Math.sin(el);
		      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
		    }

		  }
		  p.x = x + this.x0;
		  p.y = y + this.y0;
		  return p;
		}

		/* Inverse equations
		  -----------------*/
		function inverse$17(p) {
		  var lon, lat, x, y, i;
		  var al, bl;
		  var phi, dphi;
		  x = p.x - this.x0;
		  y = p.y - this.y0;

		  if (this.sphere) {
		    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
		      lon = adjust_lon(x / this.a + this.long0);
		      lat = 0;
		    }
		    else {
		      al = this.lat0 + y / this.a;
		      bl = x * x / this.a / this.a + al * al;
		      phi = al;
		      var tanphi;
		      for (i = MAX_ITER$2; i; --i) {
		        tanphi = Math.tan(phi);
		        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
		        phi += dphi;
		        if (Math.abs(dphi) <= EPSLN) {
		          lat = phi;
		          break;
		        }
		      }
		      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
		    }
		  }
		  else {
		    if (Math.abs(y + this.ml0) <= EPSLN) {
		      lat = 0;
		      lon = adjust_lon(this.long0 + x / this.a);
		    }
		    else {

		      al = (this.ml0 + y) / this.a;
		      bl = x * x / this.a / this.a + al * al;
		      phi = al;
		      var cl, mln, mlnp, ma;
		      var con;
		      for (i = MAX_ITER$2; i; --i) {
		        con = this.e * Math.sin(phi);
		        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
		        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
		        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
		        ma = mln / this.a;
		        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
		        phi -= dphi;
		        if (Math.abs(dphi) <= EPSLN) {
		          lat = phi;
		          break;
		        }
		      }

		      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
		      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
		      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
		    }
		  }

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$19 = ["Polyconic", "poly"];
		var poly = {
		  init: init$18,
		  forward: forward$17,
		  inverse: inverse$17,
		  names: names$19
		};

		/*
		  reference
		    Department of Land and Survey Technical Circular 1973/32
		      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
		    OSG Technical Report 4.1
		      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
		  */

		/**
		 * iterations: Number of iterations to refine inverse transform.
		 *     0 -> km accuracy
		 *     1 -> m accuracy -- suitable for most mapping applications
		 *     2 -> mm accuracy
		 */


		function init$19() {
		  this.A = [];
		  this.A[1] = 0.6399175073;
		  this.A[2] = -0.1358797613;
		  this.A[3] = 0.063294409;
		  this.A[4] = -0.02526853;
		  this.A[5] = 0.0117879;
		  this.A[6] = -0.0055161;
		  this.A[7] = 0.0026906;
		  this.A[8] = -0.001333;
		  this.A[9] = 0.00067;
		  this.A[10] = -0.00034;

		  this.B_re = [];
		  this.B_im = [];
		  this.B_re[1] = 0.7557853228;
		  this.B_im[1] = 0;
		  this.B_re[2] = 0.249204646;
		  this.B_im[2] = 0.003371507;
		  this.B_re[3] = -0.001541739;
		  this.B_im[3] = 0.041058560;
		  this.B_re[4] = -0.10162907;
		  this.B_im[4] = 0.01727609;
		  this.B_re[5] = -0.26623489;
		  this.B_im[5] = -0.36249218;
		  this.B_re[6] = -0.6870983;
		  this.B_im[6] = -1.1651967;

		  this.C_re = [];
		  this.C_im = [];
		  this.C_re[1] = 1.3231270439;
		  this.C_im[1] = 0;
		  this.C_re[2] = -0.577245789;
		  this.C_im[2] = -0.007809598;
		  this.C_re[3] = 0.508307513;
		  this.C_im[3] = -0.112208952;
		  this.C_re[4] = -0.15094762;
		  this.C_im[4] = 0.18200602;
		  this.C_re[5] = 1.01418179;
		  this.C_im[5] = 1.64497696;
		  this.C_re[6] = 1.9660549;
		  this.C_im[6] = 2.5127645;

		  this.D = [];
		  this.D[1] = 1.5627014243;
		  this.D[2] = 0.5185406398;
		  this.D[3] = -0.03333098;
		  this.D[4] = -0.1052906;
		  this.D[5] = -0.0368594;
		  this.D[6] = 0.007317;
		  this.D[7] = 0.01220;
		  this.D[8] = 0.00394;
		  this.D[9] = -0.0013;
		}

		/**
		    New Zealand Map Grid Forward  - long/lat to x/y
		    long/lat in radians
		  */
		function forward$18(p) {
		  var n;
		  var lon = p.x;
		  var lat = p.y;

		  var delta_lat = lat - this.lat0;
		  var delta_lon = lon - this.long0;

		  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
		  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
		  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
		  var d_lambda = delta_lon;
		  var d_phi_n = 1; // d_phi^0

		  var d_psi = 0;
		  for (n = 1; n <= 10; n++) {
		    d_phi_n = d_phi_n * d_phi;
		    d_psi = d_psi + this.A[n] * d_phi_n;
		  }

		  // 2. Calculate theta
		  var th_re = d_psi;
		  var th_im = d_lambda;

		  // 3. Calculate z
		  var th_n_re = 1;
		  var th_n_im = 0; // theta^0
		  var th_n_re1;
		  var th_n_im1;

		  var z_re = 0;
		  var z_im = 0;
		  for (n = 1; n <= 6; n++) {
		    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		    th_n_re = th_n_re1;
		    th_n_im = th_n_im1;
		    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
		    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
		  }

		  // 4. Calculate easting and northing
		  p.x = (z_im * this.a) + this.x0;
		  p.y = (z_re * this.a) + this.y0;

		  return p;
		}

		/**
		    New Zealand Map Grid Inverse  -  x/y to long/lat
		  */
		function inverse$18(p) {
		  var n;
		  var x = p.x;
		  var y = p.y;

		  var delta_x = x - this.x0;
		  var delta_y = y - this.y0;

		  // 1. Calculate z
		  var z_re = delta_y / this.a;
		  var z_im = delta_x / this.a;

		  // 2a. Calculate theta - first approximation gives km accuracy
		  var z_n_re = 1;
		  var z_n_im = 0; // z^0
		  var z_n_re1;
		  var z_n_im1;

		  var th_re = 0;
		  var th_im = 0;
		  for (n = 1; n <= 6; n++) {
		    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
		    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
		    z_n_re = z_n_re1;
		    z_n_im = z_n_im1;
		    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
		    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
		  }

		  // 2b. Iterate to refine the accuracy of the calculation
		  //        0 iterations gives km accuracy
		  //        1 iteration gives m accuracy -- good enough for most mapping applications
		  //        2 iterations bives mm accuracy
		  for (var i = 0; i < this.iterations; i++) {
		    var th_n_re = th_re;
		    var th_n_im = th_im;
		    var th_n_re1;
		    var th_n_im1;

		    var num_re = z_re;
		    var num_im = z_im;
		    for (n = 2; n <= 6; n++) {
		      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		      th_n_re = th_n_re1;
		      th_n_im = th_n_im1;
		      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
		      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
		    }

		    th_n_re = 1;
		    th_n_im = 0;
		    var den_re = this.B_re[1];
		    var den_im = this.B_im[1];
		    for (n = 2; n <= 6; n++) {
		      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		      th_n_re = th_n_re1;
		      th_n_im = th_n_im1;
		      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
		      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
		    }

		    // Complex division
		    var den2 = den_re * den_re + den_im * den_im;
		    th_re = (num_re * den_re + num_im * den_im) / den2;
		    th_im = (num_im * den_re - num_re * den_im) / den2;
		  }

		  // 3. Calculate d_phi              ...                                    // and d_lambda
		  var d_psi = th_re;
		  var d_lambda = th_im;
		  var d_psi_n = 1; // d_psi^0

		  var d_phi = 0;
		  for (n = 1; n <= 9; n++) {
		    d_psi_n = d_psi_n * d_psi;
		    d_phi = d_phi + this.D[n] * d_psi_n;
		  }

		  // 4. Calculate latitude and longitude
		  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
		  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
		  var lon = this.long0 + d_lambda;

		  p.x = lon;
		  p.y = lat;

		  return p;
		}

		var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
		var nzmg = {
		  init: init$19,
		  forward: forward$18,
		  inverse: inverse$18,
		  names: names$20
		};

		/*
		  reference
		    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
		    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
		  */


		/* Initialize the Miller Cylindrical projection
		  -------------------------------------------*/
		function init$20() {
		  //no-op
		}

		/* Miller Cylindrical forward equations--mapping lat,long to x,y
		    ------------------------------------------------------------*/
		function forward$19(p) {
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  var x = this.x0 + this.a * dlon;
		  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

		  p.x = x;
		  p.y = y;
		  return p;
		}

		/* Miller Cylindrical inverse equations--mapping x,y to lat/long
		    ------------------------------------------------------------*/
		function inverse$19(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;

		  var lon = adjust_lon(this.long0 + p.x / this.a);
		  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$21 = ["Miller_Cylindrical", "mill"];
		var mill = {
		  init: init$20,
		  forward: forward$19,
		  inverse: inverse$19,
		  names: names$21
		};

		var MAX_ITER$3 = 20;
		function init$21() {
		  /* Place parameters in static storage for common use
		    -------------------------------------------------*/


		  if (!this.sphere) {
		    this.en = pj_enfn(this.es);
		  }
		  else {
		    this.n = 1;
		    this.m = 0;
		    this.es = 0;
		    this.C_y = Math.sqrt((this.m + 1) / this.n);
		    this.C_x = this.C_y / (this.m + 1);
		  }

		}

		/* Sinusoidal forward equations--mapping lat,long to x,y
		  -----------------------------------------------------*/
		function forward$20(p) {
		  var x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		    -----------------*/
		  lon = adjust_lon(lon - this.long0);

		  if (this.sphere) {
		    if (!this.m) {
		      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
		    }
		    else {
		      var k = this.n * Math.sin(lat);
		      for (var i = MAX_ITER$3; i; --i) {
		        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
		        lat -= V;
		        if (Math.abs(V) < EPSLN) {
		          break;
		        }
		      }
		    }
		    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
		    y = this.a * this.C_y * lat;

		  }
		  else {

		    var s = Math.sin(lat);
		    var c = Math.cos(lat);
		    y = this.a * pj_mlfn(lat, s, c, this.en);
		    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
		  }

		  p.x = x;
		  p.y = y;
		  return p;
		}

		function inverse$20(p) {
		  var lat, temp, lon, s;

		  p.x -= this.x0;
		  lon = p.x / this.a;
		  p.y -= this.y0;
		  lat = p.y / this.a;

		  if (this.sphere) {
		    lat /= this.C_y;
		    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
		    if (this.m) {
		      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
		    }
		    else if (this.n !== 1) {
		      lat = asinz(Math.sin(lat) / this.n);
		    }
		    lon = adjust_lon(lon + this.long0);
		    lat = adjust_lat(lat);
		  }
		  else {
		    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
		    s = Math.abs(lat);
		    if (s < HALF_PI) {
		      s = Math.sin(lat);
		      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
		      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
		      lon = adjust_lon(temp);
		    }
		    else if ((s - EPSLN) < HALF_PI) {
		      lon = this.long0;
		    }
		  }
		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$22 = ["Sinusoidal", "sinu"];
		var sinu = {
		  init: init$21,
		  forward: forward$20,
		  inverse: inverse$20,
		  names: names$22
		};

		function init$22() {}
		/* Mollweide forward equations--mapping lat,long to x,y
		    ----------------------------------------------------*/
		function forward$21(p) {

		  /* Forward equations
		      -----------------*/
		  var lon = p.x;
		  var lat = p.y;

		  var delta_lon = adjust_lon(lon - this.long0);
		  var theta = lat;
		  var con = Math.PI * Math.sin(lat);

		  /* Iterate using the Newton-Raphson method to find theta
		      -----------------------------------------------------*/
		  while (true) {
		    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
		    theta += delta_theta;
		    if (Math.abs(delta_theta) < EPSLN) {
		      break;
		    }
		  }
		  theta /= 2;

		  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
		       this is done here because of precision problems with "cos(theta)"
		       --------------------------------------------------------------------------*/
		  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
		    delta_lon = 0;
		  }
		  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
		  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

		  p.x = x;
		  p.y = y;
		  return p;
		}

		function inverse$21(p) {
		  var theta;
		  var arg;

		  /* Inverse equations
		      -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  arg = p.y / (1.4142135623731 * this.a);

		  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
		       a number very close to one is used instead.
		       -------------------------------------------------------------------*/
		  if (Math.abs(arg) > 0.999999999999) {
		    arg = 0.999999999999;
		  }
		  theta = Math.asin(arg);
		  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
		  if (lon < (-Math.PI)) {
		    lon = -Math.PI;
		  }
		  if (lon > Math.PI) {
		    lon = Math.PI;
		  }
		  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
		  if (Math.abs(arg) > 1) {
		    arg = 1;
		  }
		  var lat = Math.asin(arg);

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$23 = ["Mollweide", "moll"];
		var moll = {
		  init: init$22,
		  forward: forward$21,
		  inverse: inverse$21,
		  names: names$23
		};

		function init$23() {

		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  // Standard Parallels cannot be equal and on opposite sides of the equator
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
		  this.lat2 = this.lat2 || this.lat1;
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2);
		  this.e = Math.sqrt(this.es);
		  this.e0 = e0fn(this.es);
		  this.e1 = e1fn(this.es);
		  this.e2 = e2fn(this.es);
		  this.e3 = e3fn(this.es);

		  this.sinphi = Math.sin(this.lat1);
		  this.cosphi = Math.cos(this.lat1);

		  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
		  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

		  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
		    this.ns = this.sinphi;
		  }
		  else {
		    this.sinphi = Math.sin(this.lat2);
		    this.cosphi = Math.cos(this.lat2);
		    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
		    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
		    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
		  }
		  this.g = this.ml1 + this.ms1 / this.ns;
		  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
		  this.rh = this.a * (this.g - this.ml0);
		}

		/* Equidistant Conic forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------*/
		function forward$22(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var rh1;

		  /* Forward equations
		      -----------------*/
		  if (this.sphere) {
		    rh1 = this.a * (this.g - lat);
		  }
		  else {
		    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
		    rh1 = this.a * (this.g - ml);
		  }
		  var theta = this.ns * adjust_lon(lon - this.long0);
		  var x = this.x0 + rh1 * Math.sin(theta);
		  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
		  p.x = x;
		  p.y = y;
		  return p;
		}

		/* Inverse equations
		  -----------------*/
		function inverse$22(p) {
		  p.x -= this.x0;
		  p.y = this.rh - p.y + this.y0;
		  var con, rh1, lat, lon;
		  if (this.ns >= 0) {
		    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
		    con = -1;
		  }
		  var theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2(con * p.x, con * p.y);
		  }

		  if (this.sphere) {
		    lon = adjust_lon(this.long0 + theta / this.ns);
		    lat = adjust_lat(this.g - rh1 / this.a);
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    var ml = this.g - rh1 / this.a;
		    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
		    lon = adjust_lon(this.long0 + theta / this.ns);
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }

		}

		var names$24 = ["Equidistant_Conic", "eqdc"];
		var eqdc = {
		  init: init$23,
		  forward: forward$22,
		  inverse: inverse$22,
		  names: names$24
		};

		/* Initialize the Van Der Grinten projection
		  ----------------------------------------*/
		function init$24() {
		  //this.R = 6370997; //Radius of earth
		  this.R = this.a;
		}

		function forward$23(p) {

		  var lon = p.x;
		  var lat = p.y;

		  /* Forward equations
		    -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  var x, y;

		  if (Math.abs(lat) <= EPSLN) {
		    x = this.x0 + this.R * dlon;
		    y = this.y0;
		  }
		  var theta = asinz(2 * Math.abs(lat / Math.PI));
		  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
		    x = this.x0;
		    if (lat >= 0) {
		      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
		    }
		    else {
		      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
		    }
		    //  return(OK);
		  }
		  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
		  var asq = al * al;
		  var sinth = Math.sin(theta);
		  var costh = Math.cos(theta);

		  var g = costh / (sinth + costh - 1);
		  var gsq = g * g;
		  var m = g * (2 / sinth - 1);
		  var msq = m * m;
		  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
		  if (dlon < 0) {
		    con = -con;
		  }
		  x = this.x0 + con;
		  //con = Math.abs(con / (Math.PI * this.R));
		  var q = asq + g;
		  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
		  if (lat >= 0) {
		    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
		    y = this.y0 + con;
		  }
		  else {
		    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
		    y = this.y0 - con;
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}

		/* Van Der Grinten inverse equations--mapping x,y to lat/long
		  ---------------------------------------------------------*/
		function inverse$23(p) {
		  var lon, lat;
		  var xx, yy, xys, c1, c2, c3;
		  var a1;
		  var m1;
		  var con;
		  var th1;
		  var d;

		  /* inverse equations
		    -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  con = Math.PI * this.R;
		  xx = p.x / con;
		  yy = p.y / con;
		  xys = xx * xx + yy * yy;
		  c1 = -Math.abs(yy) * (1 + xys);
		  c2 = c1 - 2 * yy * yy + xx * xx;
		  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
		  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
		  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
		  m1 = 2 * Math.sqrt(-a1 / 3);
		  con = ((3 * d) / a1) / m1;
		  if (Math.abs(con) > 1) {
		    if (con >= 0) {
		      con = 1;
		    }
		    else {
		      con = -1;
		    }
		  }
		  th1 = Math.acos(con) / 3;
		  if (p.y >= 0) {
		    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
		  }
		  else {
		    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
		  }

		  if (Math.abs(xx) < EPSLN) {
		    lon = this.long0;
		  }
		  else {
		    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
		  }

		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
		var vandg = {
		  init: init$24,
		  forward: forward$23,
		  inverse: inverse$23,
		  names: names$25
		};

		function init$25() {
		  this.sin_p12 = Math.sin(this.lat0);
		  this.cos_p12 = Math.cos(this.lat0);
		}

		function forward$24(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var sinphi = Math.sin(p.y);
		  var cosphi = Math.cos(p.y);
		  var dlon = adjust_lon(lon - this.long0);
		  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
		  if (this.sphere) {
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North Pole case
		      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
		      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South Pole case
		      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
		      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
		      return p;
		    }
		    else {
		      //default case
		      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
		      c = Math.acos(cos_c);
		      kp = c / Math.sin(c);
		      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
		      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
		      return p;
		    }
		  }
		  else {
		    e0 = e0fn(this.es);
		    e1 = e1fn(this.es);
		    e2 = e2fn(this.es);
		    e3 = e3fn(this.es);
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North Pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
		      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
		      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South Pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
		      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
		      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
		      return p;
		    }
		    else {
		      //Default case
		      tanphi = sinphi / cosphi;
		      Nl1 = gN(this.a, this.e, this.sin_p12);
		      Nl = gN(this.a, this.e, sinphi);
		      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
		      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
		      if (Az === 0) {
		        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
		      }
		      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
		        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
		      }
		      else {
		        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
		      }
		      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
		      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
		      GH = G * H;
		      Hs = H * H;
		      s2 = s * s;
		      s3 = s2 * s;
		      s4 = s3 * s;
		      s5 = s4 * s;
		      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
		      p.x = this.x0 + c * Math.sin(Az);
		      p.y = this.y0 + c * Math.cos(Az);
		      return p;
		    }
		  }


		}

		function inverse$24(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
		  if (this.sphere) {
		    rh = Math.sqrt(p.x * p.x + p.y * p.y);
		    if (rh > (2 * HALF_PI * this.a)) {
		      return;
		    }
		    z = rh / this.a;

		    sinz = Math.sin(z);
		    cosz = Math.cos(z);

		    lon = this.long0;
		    if (Math.abs(rh) <= EPSLN) {
		      lat = this.lat0;
		    }
		    else {
		      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
		      con = Math.abs(this.lat0) - HALF_PI;
		      if (Math.abs(con) <= EPSLN) {
		        if (this.lat0 >= 0) {
		          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
		        }
		        else {
		          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
		        }
		      }
		      else {
		        /*con = cosz - this.sin_p12 * Math.sin(lat);
		        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
		          //no-op, just keep the lon value as is
		        } else {
		          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
		          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
		        }*/
		        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
		      }
		    }

		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    e0 = e0fn(this.es);
		    e1 = e1fn(this.es);
		    e2 = e2fn(this.es);
		    e3 = e3fn(this.es);
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      M = Mlp - rh;
		      lat = imlfn(M / this.a, e0, e1, e2, e3);
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      M = rh - Mlp;

		      lat = imlfn(M / this.a, e0, e1, e2, e3);
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    else {
		      //default case
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      Az = Math.atan2(p.x, p.y);
		      N1 = gN(this.a, this.e, this.sin_p12);
		      cosAz = Math.cos(Az);
		      tmp = this.e * this.cos_p12 * cosAz;
		      A = -tmp * tmp / (1 - this.es);
		      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
		      D = rh / N1;
		      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
		      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
		      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
		      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
		      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		  }

		}

		var names$26 = ["Azimuthal_Equidistant", "aeqd"];
		var aeqd = {
		  init: init$25,
		  forward: forward$24,
		  inverse: inverse$24,
		  names: names$26
		};

		function init$26() {
		  //double temp;      /* temporary variable    */

		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.sin_p14 = Math.sin(this.lat0);
		  this.cos_p14 = Math.cos(this.lat0);
		}

		/* Orthographic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$25(p) {
		  var sinphi, cosphi; /* sin and cos value        */
		  var dlon; /* delta longitude value      */
		  var coslon; /* cos of longitude        */
		  var ksp; /* scale factor          */
		  var g, x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  dlon = adjust_lon(lon - this.long0);

		  sinphi = Math.sin(lat);
		  cosphi = Math.cos(lat);

		  coslon = Math.cos(dlon);
		  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
		  ksp = 1;
		  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
		    x = this.a * ksp * cosphi * Math.sin(dlon);
		    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}

		function inverse$25(p) {
		  var rh; /* height above ellipsoid      */
		  var z; /* angle          */
		  var sinz, cosz; /* sin of z and cos of z      */
		  var con;
		  var lon, lat;
		  /* Inverse equations
		      -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  rh = Math.sqrt(p.x * p.x + p.y * p.y);
		  z = asinz(rh / this.a);

		  sinz = Math.sin(z);
		  cosz = Math.cos(z);

		  lon = this.long0;
		  if (Math.abs(rh) <= EPSLN) {
		    lat = this.lat0;
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
		  con = Math.abs(this.lat0) - HALF_PI;
		  if (Math.abs(con) <= EPSLN) {
		    if (this.lat0 >= 0) {
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
		    }
		    else {
		      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
		    }
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
		  p.x = lon;
		  p.y = lat;
		  return p;
		}

		var names$27 = ["ortho"];
		var ortho = {
		  init: init$26,
		  forward: forward$25,
		  inverse: inverse$25,
		  names: names$27
		};

		// QSC projection rewritten from the original PROJ4
		// https://github.com/OSGeo/proj.4/blob/master/src/PJ_qsc.c

		/* constants */
		var FACE_ENUM = {
		    FRONT: 1,
		    RIGHT: 2,
		    BACK: 3,
		    LEFT: 4,
		    TOP: 5,
		    BOTTOM: 6
		};

		var AREA_ENUM = {
		    AREA_0: 1,
		    AREA_1: 2,
		    AREA_2: 3,
		    AREA_3: 4
		};

		function init$27() {

		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  this.lat0 = this.lat0 || 0;
		  this.long0 = this.long0 || 0;
		  this.lat_ts = this.lat_ts || 0;
		  this.title = this.title || "Quadrilateralized Spherical Cube";

		  /* Determine the cube face from the center of projection. */
		  if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
		    this.face = FACE_ENUM.TOP;
		  } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
		    this.face = FACE_ENUM.BOTTOM;
		  } else if (Math.abs(this.long0) <= FORTPI) {
		    this.face = FACE_ENUM.FRONT;
		  } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
		    this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
		  } else {
		    this.face = FACE_ENUM.BACK;
		  }

		  /* Fill in useful values for the ellipsoid <-> sphere shift
		   * described in [LK12]. */
		  if (this.es !== 0) {
		    this.one_minus_f = 1 - (this.a - this.b) / this.a;
		    this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
		  }
		}

		// QSC forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$26(p) {
		  var xy = {x: 0, y: 0};
		  var lat, lon;
		  var theta, phi;
		  var t, mu;
		  /* nu; */
		  var area = {value: 0};

		  // move lon according to projection's lon
		  p.x -= this.long0;

		  /* Convert the geodetic latitude to a geocentric latitude.
		   * This corresponds to the shift from the ellipsoid to the sphere
		   * described in [LK12]. */
		  if (this.es !== 0) {//if (P->es != 0) {
		    lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
		  } else {
		    lat = p.y;
		  }

		  /* Convert the input lat, lon into theta, phi as used by QSC.
		   * This depends on the cube face and the area on it.
		   * For the top and bottom face, we can compute theta and phi
		   * directly from phi, lam. For the other faces, we must use
		   * unit sphere cartesian coordinates as an intermediate step. */
		  lon = p.x; //lon = lp.lam;
		  if (this.face === FACE_ENUM.TOP) {
		    phi = HALF_PI - lat;
		    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
		      area.value = AREA_ENUM.AREA_0;
		      theta = lon - HALF_PI;
		    } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
		      area.value = AREA_ENUM.AREA_1;
		      theta = (lon > 0.0 ? lon - SPI : lon + SPI);
		    } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
		      area.value = AREA_ENUM.AREA_2;
		      theta = lon + HALF_PI;
		    } else {
		      area.value = AREA_ENUM.AREA_3;
		      theta = lon;
		    }
		  } else if (this.face === FACE_ENUM.BOTTOM) {
		    phi = HALF_PI + lat;
		    if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
		      area.value = AREA_ENUM.AREA_0;
		      theta = -lon + HALF_PI;
		    } else if (lon < FORTPI && lon >= -FORTPI) {
		      area.value = AREA_ENUM.AREA_1;
		      theta = -lon;
		    } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
		      area.value = AREA_ENUM.AREA_2;
		      theta = -lon - HALF_PI;
		    } else {
		      area.value = AREA_ENUM.AREA_3;
		      theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
		    }
		  } else {
		    var q, r, s;
		    var sinlat, coslat;
		    var sinlon, coslon;

		    if (this.face === FACE_ENUM.RIGHT) {
		      lon = qsc_shift_lon_origin(lon, +HALF_PI);
		    } else if (this.face === FACE_ENUM.BACK) {
		      lon = qsc_shift_lon_origin(lon, +SPI);
		    } else if (this.face === FACE_ENUM.LEFT) {
		      lon = qsc_shift_lon_origin(lon, -HALF_PI);
		    }
		    sinlat = Math.sin(lat);
		    coslat = Math.cos(lat);
		    sinlon = Math.sin(lon);
		    coslon = Math.cos(lon);
		    q = coslat * coslon;
		    r = coslat * sinlon;
		    s = sinlat;

		    if (this.face === FACE_ENUM.FRONT) {
		      phi = Math.acos(q);
		      theta = qsc_fwd_equat_face_theta(phi, s, r, area);
		    } else if (this.face === FACE_ENUM.RIGHT) {
		      phi = Math.acos(r);
		      theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
		    } else if (this.face === FACE_ENUM.BACK) {
		      phi = Math.acos(-q);
		      theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
		    } else if (this.face === FACE_ENUM.LEFT) {
		      phi = Math.acos(-r);
		      theta = qsc_fwd_equat_face_theta(phi, s, q, area);
		    } else {
		      /* Impossible */
		      phi = theta = 0;
		      area.value = AREA_ENUM.AREA_0;
		    }
		  }

		  /* Compute mu and nu for the area of definition.
		   * For mu, see Eq. (3-21) in [OL76], but note the typos:
		   * compare with Eq. (3-14). For nu, see Eq. (3-38). */
		  mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
		  t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

		  /* Apply the result to the real area. */
		  if (area.value === AREA_ENUM.AREA_1) {
		    mu += HALF_PI;
		  } else if (area.value === AREA_ENUM.AREA_2) {
		    mu += SPI;
		  } else if (area.value === AREA_ENUM.AREA_3) {
		    mu += 1.5 * SPI;
		  }

		  /* Now compute x, y from mu and nu */
		  xy.x = t * Math.cos(mu);
		  xy.y = t * Math.sin(mu);
		  xy.x = xy.x * this.a + this.x0;
		  xy.y = xy.y * this.a + this.y0;

		  p.x = xy.x;
		  p.y = xy.y;
		  return p;
		}

		// QSC inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$26(p) {
		  var lp = {lam: 0, phi: 0};
		  var mu, nu, cosmu, tannu;
		  var tantheta, theta, cosphi, phi;
		  var t;
		  var area = {value: 0};

		  /* de-offset */
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;

		  /* Convert the input x, y to the mu and nu angles as used by QSC.
		   * This depends on the area of the cube face. */
		  nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
		  mu = Math.atan2(p.y, p.x);
		  if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
		    area.value = AREA_ENUM.AREA_0;
		  } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
		    area.value = AREA_ENUM.AREA_1;
		    mu -= HALF_PI;
		  } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
		    area.value = AREA_ENUM.AREA_2;
		    mu = (mu < 0.0 ? mu + SPI : mu - SPI);
		  } else {
		    area.value = AREA_ENUM.AREA_3;
		    mu += HALF_PI;
		  }

		  /* Compute phi and theta for the area of definition.
		   * The inverse projection is not described in the original paper, but some
		   * good hints can be found here (as of 2011-12-14):
		   * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
		   * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
		  t = (SPI / 12) * Math.tan(mu);
		  tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
		  theta = Math.atan(tantheta);
		  cosmu = Math.cos(mu);
		  tannu = Math.tan(nu);
		  cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
		  if (cosphi < -1) {
		    cosphi = -1;
		  } else if (cosphi > +1) {
		    cosphi = +1;
		  }

		  /* Apply the result to the real area on the cube face.
		   * For the top and bottom face, we can compute phi and lam directly.
		   * For the other faces, we must use unit sphere cartesian coordinates
		   * as an intermediate step. */
		  if (this.face === FACE_ENUM.TOP) {
		    phi = Math.acos(cosphi);
		    lp.phi = HALF_PI - phi;
		    if (area.value === AREA_ENUM.AREA_0) {
		      lp.lam = theta + HALF_PI;
		    } else if (area.value === AREA_ENUM.AREA_1) {
		      lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
		    } else if (area.value === AREA_ENUM.AREA_2) {
		      lp.lam = theta - HALF_PI;
		    } else /* area.value == AREA_ENUM.AREA_3 */ {
		      lp.lam = theta;
		    }
		  } else if (this.face === FACE_ENUM.BOTTOM) {
		    phi = Math.acos(cosphi);
		    lp.phi = phi - HALF_PI;
		    if (area.value === AREA_ENUM.AREA_0) {
		      lp.lam = -theta + HALF_PI;
		    } else if (area.value === AREA_ENUM.AREA_1) {
		      lp.lam = -theta;
		    } else if (area.value === AREA_ENUM.AREA_2) {
		      lp.lam = -theta - HALF_PI;
		    } else /* area.value == AREA_ENUM.AREA_3 */ {
		      lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
		    }
		  } else {
		    /* Compute phi and lam via cartesian unit sphere coordinates. */
		    var q, r, s;
		    q = cosphi;
		    t = q * q;
		    if (t >= 1) {
		      s = 0;
		    } else {
		      s = Math.sqrt(1 - t) * Math.sin(theta);
		    }
		    t += s * s;
		    if (t >= 1) {
		      r = 0;
		    } else {
		      r = Math.sqrt(1 - t);
		    }
		    /* Rotate q,r,s into the correct area. */
		    if (area.value === AREA_ENUM.AREA_1) {
		      t = r;
		      r = -s;
		      s = t;
		    } else if (area.value === AREA_ENUM.AREA_2) {
		      r = -r;
		      s = -s;
		    } else if (area.value === AREA_ENUM.AREA_3) {
		      t = r;
		      r = s;
		      s = -t;
		    }
		    /* Rotate q,r,s into the correct cube face. */
		    if (this.face === FACE_ENUM.RIGHT) {
		      t = q;
		      q = -r;
		      r = t;
		    } else if (this.face === FACE_ENUM.BACK) {
		      q = -q;
		      r = -r;
		    } else if (this.face === FACE_ENUM.LEFT) {
		      t = q;
		      q = r;
		      r = -t;
		    }
		    /* Now compute phi and lam from the unit sphere coordinates. */
		    lp.phi = Math.acos(-s) - HALF_PI;
		    lp.lam = Math.atan2(r, q);
		    if (this.face === FACE_ENUM.RIGHT) {
		      lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
		    } else if (this.face === FACE_ENUM.BACK) {
		      lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
		    } else if (this.face === FACE_ENUM.LEFT) {
		      lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
		    }
		  }

		  /* Apply the shift from the sphere to the ellipsoid as described
		   * in [LK12]. */
		  if (this.es !== 0) {
		    var invert_sign;
		    var tanphi, xa;
		    invert_sign = (lp.phi < 0 ? 1 : 0);
		    tanphi = Math.tan(lp.phi);
		    xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
		    lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
		    if (invert_sign) {
		      lp.phi = -lp.phi;
		    }
		  }

		  lp.lam += this.long0;
		  p.x = lp.lam;
		  p.y = lp.phi;
		  return p;
		}

		/* Helper function for forward projection: compute the theta angle
		 * and determine the area number. */
		function qsc_fwd_equat_face_theta(phi, y, x, area) {
		  var theta;
		  if (phi < EPSLN) {
		    area.value = AREA_ENUM.AREA_0;
		    theta = 0.0;
		  } else {
		    theta = Math.atan2(y, x);
		    if (Math.abs(theta) <= FORTPI) {
		      area.value = AREA_ENUM.AREA_0;
		    } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
		      area.value = AREA_ENUM.AREA_1;
		      theta -= HALF_PI;
		    } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
		      area.value = AREA_ENUM.AREA_2;
		      theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
		    } else {
		      area.value = AREA_ENUM.AREA_3;
		      theta += HALF_PI;
		    }
		  }
		  return theta;
		}

		/* Helper function: shift the longitude. */
		function qsc_shift_lon_origin(lon, offset) {
		  var slon = lon + offset;
		  if (slon < -SPI) {
		    slon += TWO_PI;
		  } else if (slon > +SPI) {
		    slon -= TWO_PI;
		  }
		  return slon;
		}

		var names$28 = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
		var qsc = {
		  init: init$27,
		  forward: forward$26,
		  inverse: inverse$26,
		  names: names$28
		};

		var includedProjections = function(proj4){
		  proj4.Proj.projections.add(tmerc);
		  proj4.Proj.projections.add(etmerc);
		  proj4.Proj.projections.add(utm);
		  proj4.Proj.projections.add(sterea);
		  proj4.Proj.projections.add(stere);
		  proj4.Proj.projections.add(somerc);
		  proj4.Proj.projections.add(omerc);
		  proj4.Proj.projections.add(lcc);
		  proj4.Proj.projections.add(krovak);
		  proj4.Proj.projections.add(cass);
		  proj4.Proj.projections.add(laea);
		  proj4.Proj.projections.add(aea);
		  proj4.Proj.projections.add(gnom);
		  proj4.Proj.projections.add(cea);
		  proj4.Proj.projections.add(eqc);
		  proj4.Proj.projections.add(poly);
		  proj4.Proj.projections.add(nzmg);
		  proj4.Proj.projections.add(mill);
		  proj4.Proj.projections.add(sinu);
		  proj4.Proj.projections.add(moll);
		  proj4.Proj.projections.add(eqdc);
		  proj4.Proj.projections.add(vandg);
		  proj4.Proj.projections.add(aeqd);
		  proj4.Proj.projections.add(ortho);
		  proj4.Proj.projections.add(qsc);
		};

		proj4$1.defaultDatum = 'WGS84'; //default datum
		proj4$1.Proj = Projection$1;
		proj4$1.WGS84 = new proj4$1.Proj('WGS84');
		proj4$1.Point = Point;
		proj4$1.toPoint = toPoint;
		proj4$1.defs = defs;
		proj4$1.transform = transform;
		proj4$1.mgrs = mgrs;
		proj4$1.version = version;
		includedProjections(proj4$1);

		return proj4$1;

	})));


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
		var L, proj4;
		if (true) {
			// AMD
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1), __webpack_require__(22)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof module === 'object' && typeof module.exports === "object") {
			// Node/CommonJS
			L = require('leaflet');
			proj4 = require('proj4');
			module.exports = factory(L, proj4);
		} else {
			// Browser globals
			if (typeof window.L === 'undefined' || typeof window.proj4 === 'undefined')
				throw 'Leaflet and proj4 must be loaded first';
			factory(window.L, window.proj4);
		}
	}(function (L, proj4) {
		if (proj4.__esModule && proj4.default) {
			// If proj4 was bundled as an ES6 module, unwrap it to get
			// to the actual main proj4 object.
			// See discussion in https://github.com/kartena/Proj4Leaflet/pull/147
			proj4 = proj4.default;
		}
	 
		L.Proj = {};

		L.Proj._isProj4Obj = function(a) {
			return (typeof a.inverse !== 'undefined' &&
				typeof a.forward !== 'undefined');
		};

		L.Proj.Projection = L.Class.extend({
			initialize: function(code, def, bounds) {
				var isP4 = L.Proj._isProj4Obj(code);
				this._proj = isP4 ? code : this._projFromCodeDef(code, def);
				this.bounds = isP4 ? def : bounds;
			},

			project: function (latlng) {
				var point = this._proj.forward([latlng.lng, latlng.lat]);
				return new L.Point(point[0], point[1]);
			},

			unproject: function (point, unbounded) {
				var point2 = this._proj.inverse([point.x, point.y]);
				return new L.LatLng(point2[1], point2[0], unbounded);
			},

			_projFromCodeDef: function(code, def) {
				if (def) {
					proj4.defs(code, def);
				} else if (proj4.defs[code] === undefined) {
					var urn = code.split(':');
					if (urn.length > 3) {
						code = urn[urn.length - 3] + ':' + urn[urn.length - 1];
					}
					if (proj4.defs[code] === undefined) {
						throw 'No projection definition for code ' + code;
					}
				}

				return proj4(code);
			}
		});

		L.Proj.CRS = L.Class.extend({
			includes: L.CRS,

			options: {
				transformation: new L.Transformation(1, 0, -1, 0)
			},

			initialize: function(a, b, c) {
				var code,
				    proj,
				    def,
				    options;

				if (L.Proj._isProj4Obj(a)) {
					proj = a;
					code = proj.srsCode;
					options = b || {};

					this.projection = new L.Proj.Projection(proj, options.bounds);
				} else {
					code = a;
					def = b;
					options = c || {};
					this.projection = new L.Proj.Projection(code, def, options.bounds);
				}

				L.Util.setOptions(this, options);
				this.code = code;
				this.transformation = this.options.transformation;

				if (this.options.origin) {
					this.transformation =
						new L.Transformation(1, -this.options.origin[0],
							-1, this.options.origin[1]);
				}

				if (this.options.scales) {
					this._scales = this.options.scales;
				} else if (this.options.resolutions) {
					this._scales = [];
					for (var i = this.options.resolutions.length - 1; i >= 0; i--) {
						if (this.options.resolutions[i]) {
							this._scales[i] = 1 / this.options.resolutions[i];
						}
					}
				}

				this.infinite = !this.options.bounds;

			},

			scale: function(zoom) {
				var iZoom = Math.floor(zoom),
					baseScale,
					nextScale,
					scaleDiff,
					zDiff;
				if (zoom === iZoom) {
					return this._scales[zoom];
				} else {
					// Non-integer zoom, interpolate
					baseScale = this._scales[iZoom];
					nextScale = this._scales[iZoom + 1];
					scaleDiff = nextScale - baseScale;
					zDiff = (zoom - iZoom);
					return baseScale + scaleDiff * zDiff;
				}
			},

			zoom: function(scale) {
				// Find closest number in this._scales, down
				var downScale = this._closestElement(this._scales, scale),
					downZoom = this._scales.indexOf(downScale),
					nextScale,
					nextZoom,
					scaleDiff;
				// Check if scale is downScale => return array index
				if (scale === downScale) {
					return downZoom;
				}
				if (downScale === undefined) {
					return -Infinity;
				}
				// Interpolate
				nextZoom = downZoom + 1;
				nextScale = this._scales[nextZoom];
				if (nextScale === undefined) {
					return Infinity;
				}
				scaleDiff = nextScale - downScale;
				return (scale - downScale) / scaleDiff + downZoom;
			},

			distance: L.CRS.Earth.distance,

			R: L.CRS.Earth.R,

			/* Get the closest lowest element in an array */
			_closestElement: function(array, element) {
				var low;
				for (var i = array.length; i--;) {
					if (array[i] <= element && (low === undefined || low < array[i])) {
						low = array[i];
					}
				}
				return low;
			}
		});

		L.Proj.GeoJSON = L.GeoJSON.extend({
			initialize: function(geojson, options) {
				this._callLevel = 0;
				L.GeoJSON.prototype.initialize.call(this, geojson, options);
			},

			addData: function(geojson) {
				var crs;

				if (geojson) {
					if (geojson.crs && geojson.crs.type === 'name') {
						crs = new L.Proj.CRS(geojson.crs.properties.name);
					} else if (geojson.crs && geojson.crs.type) {
						crs = new L.Proj.CRS(geojson.crs.type + ':' + geojson.crs.properties.code);
					}

					if (crs !== undefined) {
						this.options.coordsToLatLng = function(coords) {
							var point = L.point(coords[0], coords[1]);
							return crs.projection.unproject(point);
						};
					}
				}

				// Base class' addData might call us recursively, but
				// CRS shouldn't be cleared in that case, since CRS applies
				// to the whole GeoJSON, inluding sub-features.
				this._callLevel++;
				try {
					L.GeoJSON.prototype.addData.call(this, geojson);
				} finally {
					this._callLevel--;
					if (this._callLevel === 0) {
						delete this.options.coordsToLatLng;
					}
				}
			}
		});

		L.Proj.geoJson = function(geojson, options) {
			return new L.Proj.GeoJSON(geojson, options);
		};

		L.Proj.ImageOverlay = L.ImageOverlay.extend({
			initialize: function (url, bounds, options) {
				L.ImageOverlay.prototype.initialize.call(this, url, null, options);
				this._projectedBounds = bounds;
			},

			// Danger ahead: Overriding internal methods in Leaflet.
			// Decided to do this rather than making a copy of L.ImageOverlay
			// and doing very tiny modifications to it.
			// Future will tell if this was wise or not.
			_animateZoom: function (event) {
				var scale = this._map.getZoomScale(event.zoom);
				var northWest = L.point(this._projectedBounds.min.x, this._projectedBounds.max.y);
				var offset = this._projectedToNewLayerPoint(northWest, event.zoom, event.center);

				L.DomUtil.setTransform(this._image, offset, scale);
			},

			_reset: function () {
				var zoom = this._map.getZoom();
				var pixelOrigin = this._map.getPixelOrigin();
				var bounds = L.bounds(
					this._transform(this._projectedBounds.min, zoom)._subtract(pixelOrigin),
					this._transform(this._projectedBounds.max, zoom)._subtract(pixelOrigin)
				);
				var size = bounds.getSize();

				L.DomUtil.setPosition(this._image, bounds.min);
				this._image.style.width = size.x + 'px';
				this._image.style.height = size.y + 'px';
			},

			_projectedToNewLayerPoint: function (point, zoom, center) {
				var viewHalf = this._map.getSize()._divideBy(2);
				var newTopLeft = this._map.project(center, zoom)._subtract(viewHalf)._round();
				var topLeft = newTopLeft.add(this._map._getMapPanePos());

				return this._transform(point, zoom)._subtract(topLeft);
			},

			_transform: function (point, zoom) {
				var crs = this._map.options.crs;
				var transformation = crs.transformation;
				var scale = crs.scale(zoom);

				return transformation.transform(point, scale);
			}
		});

		L.Proj.imageOverlay = function (url, bounds, options) {
			return new L.Proj.ImageOverlay(url, bounds, options);
		};

		return L.Proj;
	}));


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	//请引入 proj4.js 和 proj4leaflet.js
	L.CRS.Baidu = new L.Proj.CRS('EPSG:900913', '+proj=merc +a=6378206 +b=6356584.314245179 +lat_ts=0.0 +lon_0=0.0 +x_0=0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext  +no_defs', {
	    resolutions: function () {
	        var level = 19;
	        var res = [];
	        res[0] = Math.pow(2, 18);
	        for (var i = 1; i < level; i++) {
	            res[i] = Math.pow(2, 18 - i);
	        }
	        return res;
	    }(),
	    origin: [0, 0],
	    bounds: L.bounds([20037508.342789244, 0], [0, 20037508.342789244])
	});
	L.tileLayer.baidu = function (option) {
	    option = option || {};
	    var layer = void 0;
	    var subdomains = '0123456789';
	    switch (option.layer) {
	        //单图层
	        case "vec":
	        default:
	            //'http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=pl&b=0&limit=60&scaler=1&udt=20170525'
	            layer = L.tileLayer('http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=' + (option.bigfont ? 'ph' : 'pl') + '&scaler=1&p=1', {
	                name: option.name, subdomains: subdomains, tms: true
	            });
	            break;
	        case "img_d":
	            layer = L.tileLayer('http://shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46', {
	                name: option.name, subdomains: subdomains, tms: true
	            });
	            break;
	        case "img_z":
	            layer = L.tileLayer('http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=' + (option.bigfont ? 'sh' : 'sl') + '&v=020', {
	                name: option.name, subdomains: subdomains, tms: true
	            });
	            break;

	        case "custom":
	            //Custom 各种自定义样式
	            //可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
	            option.customid = option.customid || 'midnight';
	            layer = L.tileLayer('http://api{s}.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=' + option.customid, {
	                name: option.name, subdomains: "012", tms: true
	            });
	            break;
	        case "time":
	            //实时路况
	            var time = new Date().getTime();
	            layer = L.tileLayer('http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=' + time + '&label=web2D&v=017', {
	                name: option.name, subdomains: subdomains, tms: true
	            });
	            break;
	        //合并
	        case "img":
	            layer = L.layerGroup([L.tileLayer.baidu({ name: "底图", layer: 'img_d', bigfont: option.bigfont }), L.tileLayer.baidu({ name: "注记", layer: 'img_z', bigfont: option.bigfont })]);
	            break;
	    }
	    return layer;
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {'use strict';

	var _simpleheat = __webpack_require__(26);

	var _simpleheat2 = _interopRequireDefault(_simpleheat);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	'use strict'; /**
	               * 热力图
	               * 增加
	               import simpleheat  from './lib/simpleheat.js';
	               * https://github.com/Leaflet/Leaflet.heat
	               */


	L.HeatLayer = (L.Layer ? L.Layer : L.Class).extend({

	    // options: {
	    //     minOpacity: 0.05,
	    //     maxZoom: 18,
	    //     radius: 25,
	    //     blur: 15,
	    //     max: 1.0
	    // },

	    initialize: function initialize(latlngs, options) {
	        this._latlngs = latlngs;
	        L.setOptions(this, options);
	    },

	    setLatLngs: function setLatLngs(latlngs) {
	        this._latlngs = latlngs;
	        return this.redraw();
	    },

	    addLatLng: function addLatLng(latlng) {
	        this._latlngs.push(latlng);
	        return this.redraw();
	    },

	    setOptions: function setOptions(options) {
	        L.setOptions(this, options);
	        if (this._heat) {
	            this._updateOptions();
	        }
	        return this.redraw();
	    },

	    redraw: function redraw() {
	        if (this._heat && !this._frame && this._map && !this._map._animating) {
	            this._frame = L.Util.requestAnimFrame(this._redraw, this);
	        }
	        return this;
	    },

	    onAdd: function onAdd(map) {
	        this._map = map;

	        if (!this._canvas) {
	            this._initCanvas();
	        }

	        if (this.options.pane) {
	            this.getPane().appendChild(this._canvas);
	        } else {
	            map._panes.overlayPane.appendChild(this._canvas);
	        }

	        map.on('moveend', this._reset, this);

	        if (map.options.zoomAnimation && L.Browser.any3d) {
	            map.on('zoomanim', this._animateZoom, this);
	        }

	        this._reset();
	    },

	    onRemove: function onRemove(map) {
	        if (this.options.pane) {
	            this.getPane().removeChild(this._canvas);
	        } else {
	            map.getPanes().overlayPane.removeChild(this._canvas);
	        }

	        map.off('moveend', this._reset, this);

	        if (map.options.zoomAnimation) {
	            map.off('zoomanim', this._animateZoom, this);
	        }
	    },

	    addTo: function addTo(map) {
	        map.addLayer(this);
	        return this;
	    },

	    _initCanvas: function _initCanvas() {
	        var canvas = this._canvas = L.DomUtil.create('canvas', 'leaflet-heatmap-layer leaflet-layer');

	        var originProp = L.DomUtil.testProp(['transformOrigin', 'WebkitTransformOrigin', 'msTransformOrigin']);
	        canvas.style[originProp] = '50% 50%';

	        var size = this._map.getSize();
	        canvas.width = size.x;
	        canvas.height = size.y;

	        var animated = this._map.options.zoomAnimation && L.Browser.any3d;
	        L.DomUtil.addClass(canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));

	        this._heat = (0, _simpleheat2.default)(canvas);
	        this._updateOptions();
	    },

	    _updateOptions: function _updateOptions() {
	        this._heat.radius(this.options.radius || this._heat.defaultRadius, this.options.blur);

	        if (this.options.gradient) {
	            this._heat.gradient(this.options.gradient);
	        }
	        if (this.options.max) {
	            this._heat.max(this.options.max);
	        }
	    },

	    _reset: function _reset() {
	        var topLeft = this._map.containerPointToLayerPoint([0, 0]);
	        L.DomUtil.setPosition(this._canvas, topLeft);

	        var size = this._map.getSize();

	        if (this._heat._width !== size.x) {
	            this._canvas.width = this._heat._width = size.x;
	        }
	        if (this._heat._height !== size.y) {
	            this._canvas.height = this._heat._height = size.y;
	        }

	        this._redraw();
	    },

	    _redraw: function _redraw() {
	        if (!this._map) {
	            return;
	        }
	        var data = [],
	            r = this._heat._r,
	            size = this._map.getSize(),
	            bounds = new L.Bounds(L.point([-r, -r]), size.add([r, r])),
	            max = this.options.max === undefined ? 1 : this.options.max,
	            maxZoom = this.options.maxZoom === undefined ? this._map.getMaxZoom() : this.options.maxZoom,
	            v = 1 / Math.pow(2, Math.max(0, Math.min(maxZoom - this._map.getZoom(), 12))),
	            cellSize = r / 2,
	            grid = [],
	            panePos = this._map._getMapPanePos(),
	            offsetX = panePos.x % cellSize,
	            offsetY = panePos.y % cellSize,
	            i,
	            len,
	            p,
	            cell,
	            x,
	            y,
	            j,
	            len2,
	            k;

	        // console.time('process');
	        for (i = 0, len = this._latlngs.length; i < len; i++) {
	            p = this._map.latLngToContainerPoint(this._latlngs[i]);
	            if (bounds.contains(p)) {
	                x = Math.floor((p.x - offsetX) / cellSize) + 2;
	                y = Math.floor((p.y - offsetY) / cellSize) + 2;

	                var alt = this._latlngs[i].alt !== undefined ? this._latlngs[i].alt : this._latlngs[i][2] !== undefined ? +this._latlngs[i][2] : 1;
	                k = alt * v;

	                grid[y] = grid[y] || [];
	                cell = grid[y][x];

	                if (!cell) {
	                    grid[y][x] = [p.x, p.y, k];
	                } else {
	                    cell[0] = (cell[0] * cell[2] + p.x * k) / (cell[2] + k); // x
	                    cell[1] = (cell[1] * cell[2] + p.y * k) / (cell[2] + k); // y
	                    cell[2] += k; // cumulated intensity value
	                }
	            }
	        }

	        for (i = 0, len = grid.length; i < len; i++) {
	            if (grid[i]) {
	                for (j = 0, len2 = grid[i].length; j < len2; j++) {
	                    cell = grid[i][j];
	                    if (cell) {
	                        data.push([Math.round(cell[0]), Math.round(cell[1]), Math.min(cell[2], max)]);
	                    }
	                }
	            }
	        }
	        // console.timeEnd('process');

	        // console.time('draw ' + data.length);
	        this._heat.data(data).draw(this.options.minOpacity);
	        // console.timeEnd('draw ' + data.length);

	        this._frame = null;
	    },

	    _animateZoom: function _animateZoom(e) {
	        var scale = this._map.getZoomScale(e.zoom),
	            offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());

	        if (L.DomUtil.setTransform) {
	            L.DomUtil.setTransform(this._canvas, offset, scale);
	        } else {
	            this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
	        }
	    }
	});

	L.heatLayer = function (latlngs, options) {
	    return new L.HeatLayer(latlngs, options);
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	if (true) module.exports = simpleheat;

	function simpleheat(canvas) {
	    if (!(this instanceof simpleheat)) return new simpleheat(canvas);

	    this._canvas = canvas = typeof canvas === 'string' ? document.getElementById(canvas) : canvas;

	    this._ctx = canvas.getContext('2d');
	    this._width = canvas.width;
	    this._height = canvas.height;

	    this._max = 1;
	    this._data = [];
	}

	simpleheat.prototype = {

	    defaultRadius: 25,

	    defaultGradient: {
	        0.4: 'blue',
	        0.6: 'cyan',
	        0.7: 'lime',
	        0.8: 'yellow',
	        1.0: 'red'
	    },

	    data: function data(_data) {
	        this._data = _data;
	        return this;
	    },

	    max: function max(_max) {
	        this._max = _max;
	        return this;
	    },

	    add: function add(point) {
	        this._data.push(point);
	        return this;
	    },

	    clear: function clear() {
	        this._data = [];
	        return this;
	    },

	    radius: function radius(r, blur) {
	        blur = blur === undefined ? 15 : blur;

	        // create a grayscale blurred circle image that we'll use for drawing points
	        var circle = this._circle = this._createCanvas(),
	            ctx = circle.getContext('2d'),
	            r2 = this._r = r + blur;

	        circle.width = circle.height = r2 * 2;

	        ctx.shadowOffsetX = ctx.shadowOffsetY = r2 * 2;
	        ctx.shadowBlur = blur;
	        ctx.shadowColor = 'black';

	        ctx.beginPath();
	        ctx.arc(-r2, -r2, r, 0, Math.PI * 2, true);
	        ctx.closePath();
	        ctx.fill();

	        return this;
	    },

	    resize: function resize() {
	        this._width = this._canvas.width;
	        this._height = this._canvas.height;
	    },

	    gradient: function gradient(grad) {
	        // create a 256x1 gradient that we'll use to turn a grayscale heatmap into a colored one
	        var canvas = this._createCanvas(),
	            ctx = canvas.getContext('2d'),
	            gradient = ctx.createLinearGradient(0, 0, 0, 256);

	        canvas.width = 1;
	        canvas.height = 256;

	        for (var i in grad) {
	            gradient.addColorStop(+i, grad[i]);
	        }

	        ctx.fillStyle = gradient;
	        ctx.fillRect(0, 0, 1, 256);

	        this._grad = ctx.getImageData(0, 0, 1, 256).data;

	        return this;
	    },

	    draw: function draw(minOpacity) {
	        if (!this._circle) this.radius(this.defaultRadius);
	        if (!this._grad) this.gradient(this.defaultGradient);

	        var ctx = this._ctx;

	        ctx.clearRect(0, 0, this._width, this._height);

	        // draw a grayscale heatmap by putting a blurred circle at each data point
	        for (var i = 0, len = this._data.length, p; i < len; i++) {
	            p = this._data[i];
	            ctx.globalAlpha = Math.max(p[2] / this._max, minOpacity === undefined ? 0.05 : minOpacity);
	            ctx.drawImage(this._circle, p[0] - this._r, p[1] - this._r);
	        }

	        // colorize the heatmap, using opacity value of each pixel to get the right color from our gradient
	        var colored = ctx.getImageData(0, 0, this._width, this._height);
	        this._colorize(colored.data, this._grad);
	        ctx.putImageData(colored, 0, 0);

	        return this;
	    },

	    _colorize: function _colorize(pixels, gradient) {
	        for (var i = 0, len = pixels.length, j; i < len; i += 4) {
	            j = pixels[i + 3] * 4; // get gradient color from opacity value

	            if (j) {
	                pixels[i] = gradient[j];
	                pixels[i + 1] = gradient[j + 1];
	                pixels[i + 2] = gradient[j + 2];
	            }
	        }
	    },

	    _createCanvas: function _createCanvas() {
	        if (typeof document !== 'undefined') {
	            return document.createElement('canvas');
	        } else {
	            // create a new canvas instance in node.js
	            // the canvas class needs to have a default constructor without any parameter
	            return new this._canvas.constructor();
	        }
	    }
	};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "COORDINATE_SYSTEM", {
	  enumerable: true,
	  get: function get() {
	    return _constants.COORDINATE_SYSTEM;
	  }
	});
	Object.defineProperty(exports, "Deck", {
	  enumerable: true,
	  get: function get() {
	    return _deck.default;
	  }
	});
	Object.defineProperty(exports, "LayerManager", {
	  enumerable: true,
	  get: function get() {
	    return _layerManager.default;
	  }
	});
	Object.defineProperty(exports, "AttributeManager", {
	  enumerable: true,
	  get: function get() {
	    return _attributeManager.default;
	  }
	});
	Object.defineProperty(exports, "Layer", {
	  enumerable: true,
	  get: function get() {
	    return _layer.default;
	  }
	});
	Object.defineProperty(exports, "CompositeLayer", {
	  enumerable: true,
	  get: function get() {
	    return _compositeLayer.default;
	  }
	});
	Object.defineProperty(exports, "Viewport", {
	  enumerable: true,
	  get: function get() {
	    return _viewport.default;
	  }
	});
	Object.defineProperty(exports, "WebMercatorViewport", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorViewport.default;
	  }
	});
	Object.defineProperty(exports, "project", {
	  enumerable: true,
	  get: function get() {
	    return _project.default;
	  }
	});
	Object.defineProperty(exports, "project64", {
	  enumerable: true,
	  get: function get() {
	    return _project2.default;
	  }
	});
	Object.defineProperty(exports, "lighting", {
	  enumerable: true,
	  get: function get() {
	    return _lighting.default;
	  }
	});
	Object.defineProperty(exports, "View", {
	  enumerable: true,
	  get: function get() {
	    return _view.default;
	  }
	});
	Object.defineProperty(exports, "MapView", {
	  enumerable: true,
	  get: function get() {
	    return _mapView.default;
	  }
	});
	Object.defineProperty(exports, "FirstPersonView", {
	  enumerable: true,
	  get: function get() {
	    return _firstPersonView.default;
	  }
	});
	Object.defineProperty(exports, "ThirdPersonView", {
	  enumerable: true,
	  get: function get() {
	    return _thirdPersonView.default;
	  }
	});
	Object.defineProperty(exports, "OrbitView", {
	  enumerable: true,
	  get: function get() {
	    return _orbitView.default;
	  }
	});
	Object.defineProperty(exports, "PerspectiveView", {
	  enumerable: true,
	  get: function get() {
	    return _perspectiveView.default;
	  }
	});
	Object.defineProperty(exports, "OrthographicView", {
	  enumerable: true,
	  get: function get() {
	    return _orthographicView.default;
	  }
	});
	Object.defineProperty(exports, "Controller", {
	  enumerable: true,
	  get: function get() {
	    return _controller.default;
	  }
	});
	Object.defineProperty(exports, "MapController", {
	  enumerable: true,
	  get: function get() {
	    return _mapController.default;
	  }
	});
	Object.defineProperty(exports, "log", {
	  enumerable: true,
	  get: function get() {
	    return _log.default;
	  }
	});
	Object.defineProperty(exports, "PerspectiveViewport", {
	  enumerable: true,
	  get: function get() {
	    return _perspectiveViewport.default;
	  }
	});
	Object.defineProperty(exports, "OrthographicViewport", {
	  enumerable: true,
	  get: function get() {
	    return _orthographicViewport.default;
	  }
	});
	exports.experimental = void 0;

	__webpack_require__(28);

	__webpack_require__(45);

	var _constants = __webpack_require__(237);

	var _deck = _interopRequireDefault(__webpack_require__(259));

	var _layerManager = _interopRequireDefault(__webpack_require__(260));

	var _attributeManager = _interopRequireDefault(__webpack_require__(262));

	var _layer = _interopRequireDefault(__webpack_require__(261));

	var _compositeLayer = _interopRequireDefault(__webpack_require__(390));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _webMercatorViewport = _interopRequireDefault(__webpack_require__(287));

	var _project = _interopRequireDefault(__webpack_require__(233));

	var _project2 = _interopRequireDefault(__webpack_require__(253));

	var _lighting = _interopRequireDefault(__webpack_require__(255));

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _mapView = _interopRequireDefault(__webpack_require__(286));

	var _firstPersonView = _interopRequireDefault(__webpack_require__(391));

	var _thirdPersonView = _interopRequireDefault(__webpack_require__(392));

	var _orbitView = _interopRequireDefault(__webpack_require__(393));

	var _perspectiveView = _interopRequireDefault(__webpack_require__(394));

	var _orthographicView = _interopRequireDefault(__webpack_require__(395));

	var _controller = _interopRequireDefault(__webpack_require__(385));

	var _mapController = _interopRequireDefault(__webpack_require__(384));

	var _firstPersonController = _interopRequireDefault(__webpack_require__(396));

	var _orbitController = _interopRequireDefault(__webpack_require__(397));

	var _effectManager = _interopRequireDefault(__webpack_require__(288));

	var _effect = _interopRequireDefault(__webpack_require__(289));

	var _transitionManager = __webpack_require__(388);

	var _linearInterpolator = _interopRequireDefault(__webpack_require__(386));

	var _viewportFlyToInterpolator = _interopRequireDefault(__webpack_require__(399));

	var _reflectionEffect = _interopRequireDefault(__webpack_require__(400));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _binSorter = _interopRequireDefault(__webpack_require__(403));

	var _colorUtils = __webpack_require__(404);

	var _scaleUtils = __webpack_require__(405);

	var _flatten = __webpack_require__(266);

	var _perspectiveViewport = _interopRequireDefault(__webpack_require__(406));

	var _orthographicViewport = _interopRequireDefault(__webpack_require__(407));

	var _firstPersonViewport = _interopRequireDefault(__webpack_require__(408));

	var _thirdPersonViewport = _interopRequireDefault(__webpack_require__(409));

	var _orbitViewport = _interopRequireDefault(__webpack_require__(398));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	/* eslint-disable max-len */
	// Intialize globals, check version
	// Import shaderlib to make sure shader modules are initialized
	// Core Library
	// Experimental Pure JS (non-React) bindings
	// Viewports
	// Shader modules
	// Controllers
	// Experimental Controllers
	// EXPERIMENTAL EXPORTS
	// Experimental Effects (non-React) bindings
	// Eperimental Transitions
	// Layer utilities
	// Export?
	// Export? luma.gl?
	// luma.gl?
	// DEPRECATED EXPORTS
	// DEPRECATED
	// Experimental Features may change in minor version bumps, use at your own risk)
	var experimental = {
	  FirstPersonController: _firstPersonController.default,
	  OrbitController: _orbitController.default,
	  FirstPersonViewport: _firstPersonViewport.default,
	  ThirdPersonViewport: _thirdPersonViewport.default,
	  OrbitViewport: _orbitViewport.default,
	  EffectManager: _effectManager.default,
	  Effect: _effect.default,
	  // Transitions
	  TRANSITION_EVENTS: _transitionManager.TRANSITION_EVENTS,
	  LinearInterpolator: _linearInterpolator.default,
	  ViewportFlyToInterpolator: _viewportFlyToInterpolator.default,
	  // TODO make this an internal export to set it apart from experimental
	  // export const internal
	  // For layers
	  BinSorter: _binSorter.default,
	  linearScale: _scaleUtils.linearScale,
	  getLinearScale: _scaleUtils.getLinearScale,
	  quantizeScale: _scaleUtils.quantizeScale,
	  getQuantizeScale: _scaleUtils.getQuantizeScale,
	  defaultColorRange: _colorUtils.defaultColorRange,
	  flattenVertices: _flatten.flattenVertices,
	  fillArray: _flatten.fillArray,
	  ReflectionEffect: _reflectionEffect.default
	};
	exports.experimental = experimental;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _globals = __webpack_require__(29);

	var _log = _interopRequireDefault(__webpack_require__(31));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// Version detection using babel plugin
	// Fallback for tests and SSR since global variable is defined by Webpack.

	/* global __VERSION__ */
	var version =  true ? "5.3.0-rc.2" : _globals.global.DECK_VERSION || 'untranspiled source';
	var STARTUP_MESSAGE = 'set deck.log.priority=1 (or higher) to trace attribute updates';

	if (_globals.global.deck && _globals.global.deck.VERSION !== version) {
	  throw new Error("deck.gl - multiple versions detected: ".concat(_globals.global.deck.VERSION, " vs ").concat(version));
	}

	if (!_globals.global.deck) {
	  /* global console */

	  /* eslint-disable no-console */
	  _log.default.log(0, "deck.gl ".concat(version, " - ").concat(STARTUP_MESSAGE))();

	  _globals.global.deck = _globals.global.deck || {
	    VERSION: version,
	    version: version,
	    log: _log.default
	  };
	} // TODO - Hack, remove when luma.gl 4.1.0-alpha.5 is published


	if (!console.table) {
	  console.table = function () {};
	} // Make sure we register shader modules


	__webpack_require__(45);
	//# sourceMappingURL=init.js.map

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {"use strict";

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// Purpose: include this in your module to avoids adding dependencies on
	// micro modules like 'global' and 'is-browser';

	/* global process, window, global, document */
	var isBrowser = (typeof process === "undefined" ? "undefined" : _typeof(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
	module.exports = {
	  window: typeof window !== 'undefined' ? window : global,
	  global: typeof global !== 'undefined' ? global : window,
	  document: typeof document !== 'undefined' ? document : {},
	  isBrowser: isBrowser
	};
	//# sourceMappingURL=globals.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30), (function() { return this; }())))

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;

	process.listeners = function (name) { return [] }

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _probe = __webpack_require__(32);

	var _default = new _probe.Log({
	  id: 'deck'
	});

	exports.default = _default;
	//# sourceMappingURL=log.js.map

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.experimental=exports.Stats=exports.COLOR=exports.Log=exports.VERSION=void 0;var _globals=__webpack_require__(33);Object.defineProperty(exports,'VERSION',{enumerable:!0,get:function get(){return _globals.VERSION}});var _log=__webpack_require__(34);Object.defineProperty(exports,'Log',{enumerable:!0,get:function get(){return _interopRequireDefault(_log).default}});var _color=__webpack_require__(39);Object.defineProperty(exports,'COLOR',{enumerable:!0,get:function get(){return _color.COLOR}});var _stats=__webpack_require__(42);Object.defineProperty(exports,'Stats',{enumerable:!0,get:function get(){return _interopRequireDefault(_stats).default}}),__webpack_require__(43);var _logToDom=__webpack_require__(44),_log2=_interopRequireDefault(_log);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}var experimental=exports.experimental={enableDOMLogging:_logToDom.enableDOMLogging};exports.default=new _log2.default({id:'probe.gl'});
	//# sourceMappingURL=index.js.map

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';Object.defineProperty(exports,'__esModule',{value:!0});var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&'function'==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?'symbol':typeof obj},isBrowser='object'!==('undefined'==typeof process?'undefined':_typeof(process))||'[object process]'!==process+''||process.browser,window_='undefined'==typeof window?global:window,document_='undefined'==typeof document?{}:document,global_='undefined'==typeof global?window:global,process_='object'===('undefined'==typeof process?'undefined':_typeof(process))?process:{},VERSION='1.0.2';exports.window=window_,exports.document=document_,exports.global=global_,exports.process=process_,exports.console=console,exports.isBrowser=isBrowser,exports.VERSION=VERSION;
	//# sourceMappingURL=globals.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30), (function() { return this; }())))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';Object.defineProperty(exports,'__esModule',{value:!0});var _typeof='function'==typeof Symbol&&'symbol'==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&'function'==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?'symbol':typeof obj},_createClass=function(){function defineProperties(target,props){for(var descriptor,i=0;i<props.length;i++)descriptor=props[i],descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,'value'in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_globals=__webpack_require__(33),_localStorage=__webpack_require__(36),_localStorage2=_interopRequireDefault(_localStorage),_timestamp=__webpack_require__(37),_formatters=__webpack_require__(38),_color=__webpack_require__(39),_autobind=__webpack_require__(40),_assert=__webpack_require__(41),_assert2=_interopRequireDefault(_assert);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2}return Array.from(arr)}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError('Cannot call a class as a function')}var originalConsole={debug:_globals.isBrowser?console.debug||console.log:console.log,log:console.log,info:console.info,warn:console.warn,error:console.error},DEFAULT_SETTINGS={enabled:!1,priority:0};function noop(){}var cache={};function getTableHeader(table){for(var key in table)for(var title in table[key])return title||'untitled';return'empty'}var Log=function(){function Log(){var _ref=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},id=_ref.id;_classCallCheck(this,Log),this.id=id,this.VERSION=_globals.VERSION,this._startTs=(0,_timestamp.getTimestamp)(),this._deltaTs=(0,_timestamp.getTimestamp)(),this.LOG_THROTTLE_TIMEOUT=0,this._storage=new _localStorage2.default('__probe-'+this.id+'__',DEFAULT_SETTINGS),this.userData={},this.timeStamp(this.id+' started'),(0,_autobind.autobind)(this),Object.seal(this)}return _createClass(Log,[{key:'isEnabled',value:function isEnabled(){return this._storage.config.enabled}},{key:'getPriority',value:function getPriority(){return this._storage.config.priority}},{key:'getLevel',value:function getLevel(){return this._storage.config.priority}},{key:'getTotal',value:function getTotal(){return+((0,_timestamp.getTimestamp)()-this._startTs).toPrecision(10)}},{key:'getDelta',value:function getDelta(){return+((0,_timestamp.getTimestamp)()-this._deltaTs).toPrecision(10)}},{key:'enable',value:function enable(){var enabled=!(0<arguments.length&&void 0!==arguments[0])||arguments[0];return this._storage.updateConfiguration({enabled:enabled}),this}},{key:'setLevel',value:function setLevel(level){return this._storage.updateConfiguration({priority:level}),this}},{key:'warn',value:function warn(message){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];return this._getLogFunction({message:message,args:args,method:originalConsole.warn,once:!0})}},{key:'error',value:function error(message){for(var _len2=arguments.length,args=Array(1<_len2?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];return this._getLogFunction({message:message,args:args,method:originalConsole.error})}},{key:'deprecated',value:function deprecated(oldUsage,newUsage){return this.warn('`'+oldUsage+'` is deprecated and will be removed in a later version. Use `'+newUsage+'` instead')}},{key:'removed',value:function removed(oldUsage,newUsage){return this.error('`'+oldUsage+'` has been removed. Use `'+newUsage+'` instead')}},{key:'probe',value:function probe(priority,message){for(var _len3=arguments.length,args=Array(2<_len3?_len3-2:0),_key3=2;_key3<_len3;_key3++)args[_key3-2]=arguments[_key3];return this._getLogFunction({priority:priority,message:message,args:args,method:originalConsole.log,time:!0,once:!0})}},{key:'log',value:function log(priority,message){for(var _len4=arguments.length,args=Array(2<_len4?_len4-2:0),_key4=2;_key4<_len4;_key4++)args[_key4-2]=arguments[_key4];return this._getLogFunction({priority:priority,message:message,args:args,method:originalConsole.debug})}},{key:'info',value:function info(priority,message){for(var _len5=arguments.length,args=Array(2<_len5?_len5-2:0),_key5=2;_key5<_len5;_key5++)args[_key5-2]=arguments[_key5];return this._getLogFunction({priority:priority,message:message,args:args,method:console.info})}},{key:'once',value:function once(priority,message){for(var _len6=arguments.length,args=Array(2<_len6?_len6-2:0),_key6=2;_key6<_len6;_key6++)args[_key6-2]=arguments[_key6];return this._getLogFunction({priority:priority,message:message,args:args,method:originalConsole.debug||originalConsole.info,once:!0})}},{key:'table',value:function table(priority,_table,columns){if(_table){var tag=getTableHeader(_table);return this._getLogFunction({priority:priority,message:_table,args:columns&&[columns],tag:tag,method:console.table||noop})}return noop}},{key:'image',value:function image(_ref2){var priority=_ref2.priority,_image=_ref2.image,_ref2$message=_ref2.message,message=void 0===_ref2$message?'':_ref2$message,_ref2$scale=_ref2.scale,scale=void 0===_ref2$scale?1:_ref2$scale;return priority>this.getPriority()?noop:_globals.isBrowser?this._logImageInBrowser({image:_image,message:message,scale:scale}):this._logImageInNode({image:_image,message:message,scale:scale})}},{key:'_logImageInNode',value:function _logImageInNode(_ref3){var image=_ref3.image,_ref3$message=_ref3.message,message=void 0===_ref3$message?'':_ref3$message,_ref3$scale=_ref3.scale,scale=void 0===_ref3$scale?1:_ref3$scale,asciify=null;try{asciify=module.require('asciify-image')}catch(error){}return asciify?function(){return asciify(image,{fit:'box',width:Math.round(80*scale)+'%'}).then(function(data){return console.log(data)})}:noop}},{key:'_logImageInBrowser',value:function _logImageInBrowser(_ref4){var image=_ref4.image,_ref4$message=_ref4.message,message=void 0===_ref4$message?'':_ref4$message,_ref4$scale=_ref4.scale,scale=void 0===_ref4$scale?1:_ref4$scale;if('string'==typeof image){var img=new Image;return img.onload=function(){var _console,args=(0,_formatters.formatImage)(img,message,scale);(_console=console).log.apply(_console,_toConsumableArray(args))},img.src=image,noop}var element=image.nodeName||'';if('img'===element.toLowerCase()){var _console2;return(_console2=console).log.apply(_console2,_toConsumableArray((0,_formatters.formatImage)(image,message,scale))),noop}if('canvas'===element.toLowerCase()){var _img=new Image;return _img.onload=function(){var _console3;return(_console3=console).log.apply(_console3,_toConsumableArray((0,_formatters.formatImage)(_img,message,scale)))},_img.src=image.toDataURL(),noop}return noop}},{key:'time',value:function time(priority,message){return this._getLogFunction({priority:priority,message:message,method:console.time?console.time:console.info})}},{key:'timeEnd',value:function timeEnd(priority,message){return this._getLogFunction({priority:priority,message:message,method:console.timeEnd?console.timeEnd:console.info})}},{key:'timeStamp',value:function timeStamp(priority,message){return this._getLogFunction({priority:priority,message:message,method:console.timeStamp||noop})}},{key:'group',value:function group(priority,message){var opts=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{collapsed:!1};opts=this._normalizeArguments({priority:priority,message:message,opts:opts});var _opts=opts,collapsed=_opts.collapsed;return this._getLogFunction({priority:priority,message:message,opts:opts,method:(collapsed?console.groupCollapsed:console.group)||console.info})}},{key:'groupCollapsed',value:function groupCollapsed(priority,message){var opts=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};return this.group(priority,message,Object.assign({},opts,{collapsed:!0}))}},{key:'groupEnd',value:function groupEnd(priority){return this._getLogFunction({priority:priority,message:'',method:console.groupEnd||noop})}},{key:'withGroup',value:function withGroup(priority,message,func){var opts=this._normalizeArguments({priority:priority,message:message});this.group(opts);try{func()}finally{this.groupEnd(opts.message)}}},{key:'trace',value:function trace(){console.trace&&console.trace()}},{key:'_shouldLog',value:function _shouldLog(priority){return priority=this._normalizePriority(priority),0===priority||this.isEnabled()&&this.getPriority()>=priority}},{key:'_getElapsedTime',value:function _getElapsedTime(){var total=this.getTotal(),delta=this.getDelta();return this._deltaTs=(0,_timestamp.getTimestamp)(),{total:total,delta:delta}}},{key:'_getLogFunction',value:function _getLogFunction(opts){if(this._shouldLog(opts.priority)){var _opts2=opts,method=_opts2.method;opts=this._parseArguments(opts),(0,_assert2.default)(method);var _opts3=opts,message=_opts3.message,tag=opts.tag||opts.message;if(opts.once)if(!cache[tag])cache[tag]=(0,_timestamp.getTimestamp)();else return noop;return message=this._decorateMessage(message,opts),method.bind.apply(method,[console,message].concat(_toConsumableArray(opts.args)))}return noop}},{key:'_parseArguments',value:function _parseArguments(options){var normOpts=this._normalizeArguments(options),_getElapsedTime2=this._getElapsedTime(),delta=_getElapsedTime2.delta,total=_getElapsedTime2.total;return Object.assign(options,normOpts,{delta:delta,total:total})}},{key:'_normalizePriority',value:function _normalizePriority(priority){var resolvedPriority;switch('undefined'==typeof priority?'undefined':_typeof(priority)){case'number':resolvedPriority=priority;break;case'object':resolvedPriority=priority.priority||0;break;default:resolvedPriority=0;}return(0,_assert2.default)(Number.isFinite(resolvedPriority)&&0<=resolvedPriority),resolvedPriority}},{key:'_normalizeArguments',value:function _normalizeArguments(_ref5){var priority=_ref5.priority,message=_ref5.message,_ref5$args=_ref5.args,args=void 0===_ref5$args?[]:_ref5$args,opts=_ref5.opts,newOpts={priority:this._normalizePriority(priority),message:message,args:args};switch('undefined'==typeof priority?'undefined':_typeof(priority)){case'string':case'function':void 0!==message&&args.unshift(message),Object.assign(newOpts,{message:priority});break;case'object':Object.assign(newOpts,priority);break;default:}return'function'==typeof newOpts.message&&(newOpts.message=this._shouldLog(newOpts.priority)?newOpts.message():''),(0,_assert2.default)('string'==typeof newOpts.message||'object'===_typeof(newOpts.message)),Object.assign(newOpts,opts)}},{key:'_decorateMessage',value:function _decorateMessage(message,opts){if('string'==typeof message){var time='';if(opts.time){var _getElapsedTime3=this._getElapsedTime(),total=_getElapsedTime3.total;time=(0,_formatters.leftPad)((0,_formatters.formatTime)(total))}message=opts.time?this.id+': '+time+'  '+message:this.id+': '+message,message=(0,_color.addColor)(message,opts.color,opts.background)}return message}},{key:'priority',set:function set(newPriority){return this._storage.updateConfiguration({priority:newPriority}),this},get:function get(){return this._storage.config.priority}}]),Log}();exports.default=Log,Log.VERSION=_globals.VERSION;
	//# sourceMappingURL=log.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module)))

/***/ }),
/* 35 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 36 */
/***/ (function(module, exports) {

	'use strict';var _createClass=function(){function defineProperties(target,props){for(var descriptor,i=0;i<props.length;i++)descriptor=props[i],descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,'value'in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}();Object.defineProperty(exports,'__esModule',{value:!0});function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError('Cannot call a class as a function')}function getStorage(type){try{var storage=window[type],x='__storage_test__';return storage.setItem(x,x),storage.removeItem(x),storage}catch(e){return null}}var LocalStorage=function(){function LocalStorage(id,defaultSettings){var type=2<arguments.length&&void 0!==arguments[2]?arguments[2]:'sessionStorage';_classCallCheck(this,LocalStorage),this.storage=getStorage(type),this.id=id,this.config={},Object.assign(this.config,defaultSettings),this._loadConfiguration()}return _createClass(LocalStorage,[{key:'getConfiguration',value:function getConfiguration(){return this.config}},{key:'setConfiguration',value:function setConfiguration(configuration){return this.config={},this.updateConfiguration(configuration)}},{key:'updateConfiguration',value:function updateConfiguration(configuration){if(Object.assign(this.config,configuration),this.storage){var serialized=JSON.stringify(this.config);this.storage.setItem(this.id,serialized)}return this}},{key:'_loadConfiguration',value:function _loadConfiguration(){var configuration={};if(this.storage){var serializedConfiguration=this.storage.getItem(this.id);configuration=serializedConfiguration?JSON.parse(serializedConfiguration):{}}return Object.assign(this.config,configuration),this}}]),LocalStorage}();exports.default=LocalStorage;
	//# sourceMappingURL=local-storage.js.map

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.startTimestamp=void 0,exports.getTimestamp=getTimestamp;var _globals=__webpack_require__(33);function getTimestamp(){if(!_globals.isBrowser){var secondsAndNanoseconds=_globals.process.hrtime();return secondsAndNanoseconds[0]+secondsAndNanoseconds[1]/1e6}return _globals.window.performance?_globals.window.performance.now():Date.now()}var startTimestamp=exports.startTimestamp=getTimestamp();
	//# sourceMappingURL=timestamp.js.map

/***/ }),
/* 38 */
/***/ (function(module, exports) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.formatTime=formatTime,exports.leftPad=leftPad,exports.rightPad=rightPad,exports.getSISuffix=getSISuffix,exports.formatSI=formatSI,exports.formatValue=formatValue,exports.formatImage=formatImage;function formatTime(ms){var formatted;return formatted=10>ms?ms.toFixed(2)+'ms':100>ms?ms.toFixed(1)+'ms':1e3>ms?ms.toFixed(0)+'ms':(ms/1e3).toFixed(2)+'s',formatted}function leftPad(string){var length=1<arguments.length&&arguments[1]!==void 0?arguments[1]:8,padLength=Math.max(length-string.length,0);return''+' '.repeat(padLength)+string}function rightPad(string){var length=1<arguments.length&&arguments[1]!==void 0?arguments[1]:8,padLength=Math.max(length-string.length,0);return''+string+' '.repeat(padLength)}function splitIntoBaseAndExponent(number){var base=number,exponent=0;if(0!==number){for(;10<=base||-10>=base;)base/=10,exponent++;for(;1>base&&-1<base;)base*=10,exponent--}return{base:base,exponent:exponent}}function getSISuffix(multipleOf3){var SI_SUFFIXES={0:'',1:'K',2:'M',3:'G',"-1":'m',"-2":'\xB5',"-3":'n'},key=multipleOf3+'';return key in SI_SUFFIXES?SI_SUFFIXES[key]:'e'+3*multipleOf3}function formatSI(number){var precision=1<arguments.length&&arguments[1]!==void 0?arguments[1]:3,_splitIntoBaseAndExpo=splitIntoBaseAndExponent(number),base=_splitIntoBaseAndExpo.base,exponent=_splitIntoBaseAndExpo.exponent,multipleOf3=Math.floor(exponent/3),digits=base*Math.pow(10,exponent-3*multipleOf3);return''+digits.toPrecision(precision)+getSISuffix(multipleOf3)}function formatValue(v){var _Mathabs=Math.abs,opts=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{},_opts$isInteger=opts.isInteger,isInteger=void 0!==_opts$isInteger&&_opts$isInteger;if(Array.isArray(v)||ArrayBuffer.isView(v))return formatArrayValue(v,opts);if(!Number.isFinite(v))return v+'';if(_Mathabs(v)<1e-16)return isInteger?'0':'0.';if(isInteger)return v.toFixed(0);if(100<_Mathabs(v)&&1e4>_Mathabs(v))return v.toFixed(0);var string=v.toPrecision(2),decimal=string.indexOf('.0');return decimal===string.length-2?string.slice(0,-1):string}function formatArrayValue(v,opts){for(var _opts$maxElts=opts.maxElts,maxElts=_opts$maxElts===void 0?16:_opts$maxElts,_opts$size=opts.size,size=_opts$size===void 0?1:_opts$size,string='[',i=0;i<v.length&&i<maxElts;++i)0<i&&(string+=','+(0==i%size?' ':'')),string+=formatValue(v[i],opts);var terminator=v.length>maxElts?'...':']';return''+string+terminator}function formatImage(image,message,scale){var _Mathfloor=Math.floor,maxWidth=3<arguments.length&&void 0!==arguments[3]?arguments[3]:600,imageUrl=image.src.replace(/\(/g,'%28').replace(/\)/g,'%29');image.width>maxWidth&&(scale=Math.min(scale,maxWidth/image.width));var width=image.width*scale,height=image.height*scale,style=['font-size:1px;','padding:'+_Mathfloor(height/2)+'px '+_Mathfloor(width/2)+'px;','line-height:'+height+'px;','background:url('+imageUrl+');','background-size:'+width+'px '+height+'px;','color:transparent;'].join('');return[message+' %c+',style]}
	//# sourceMappingURL=formatters.js.map

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.COLOR=void 0,exports.addColor=addColor;var _globals=__webpack_require__(33),COLOR=exports.COLOR={BLACK:30,RED:31,GREEN:32,YELLOW:33,BLUE:34,MAGENTA:35,CYAN:36,WHITE:37,BRIGHT_BLACK:90,BRIGHT_RED:91,BRIGHT_GREEN:92,BRIGHT_YELLOW:93,BRIGHT_BLUE:94,BRIGHT_MAGENTA:95,BRIGHT_CYAN:96,BRIGHT_WHITE:97};function getColor(color){return'string'==typeof color?COLOR[color.toUpperCase()]||COLOR.WHITE:color}function addColor(string,color,background){return _globals.isBrowser||'string'!=typeof string||(color&&(color=getColor(color),string='\x1B['+color+'m'+string+'\x1B[39m'),background&&(color=getColor(background),string='\x1B['+(background+10)+'m'+string+'\x1B[49m')),string}
	//# sourceMappingURL=color.js.map

/***/ }),
/* 40 */
/***/ (function(module, exports) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.autobind=autobind;function autobind(obj){var predefined=1<arguments.length&&arguments[1]!==void 0?arguments[1]:['constructor'],proto=Object.getPrototypeOf(obj),propNames=Object.getOwnPropertyNames(proto),_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _step,_loop=function(){var key=_step.value;'function'!=typeof obj[key]||predefined.find(function(name){return key===name})||(obj[key]=obj[key].bind(obj))},_iterator=propNames[Symbol.iterator]();!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0)_loop()}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError}}}
	//# sourceMappingURL=autobind.js.map

/***/ }),
/* 41 */
/***/ (function(module, exports) {

	"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=assert;function assert(condition,message){if(!condition)throw new Error("Assertion failed. "+message)}
	//# sourceMappingURL=assert.js.map

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0});var _createClass=function(){function defineProperties(target,props){for(var descriptor,i=0;i<props.length;i++)descriptor=props[i],descriptor.enumerable=descriptor.enumerable||!1,descriptor.configurable=!0,'value'in descriptor&&(descriptor.writable=!0),Object.defineProperty(target,descriptor.key,descriptor)}return function(Constructor,protoProps,staticProps){return protoProps&&defineProperties(Constructor.prototype,protoProps),staticProps&&defineProperties(Constructor,staticProps),Constructor}}(),_timestamp=__webpack_require__(37),_formatters=__webpack_require__(38);function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError('Cannot call a class as a function')}var Stats=function(){function Stats(_ref){var id=_ref.id;_classCallCheck(this,Stats),this.id=id,this.time=(0,_timestamp.getTimestamp)(),this.counters={},Object.seal(this)}var _Mathround=Math.round;return _createClass(Stats,[{key:'addCounter',value:function addCounter(name){return this._getCounter(name),this}},{key:'bump',value:function bump(name){var counter=this._getCounter(name);return counter.call++,counter.count++,this}},{key:'increment',value:function increment(name,count){var counter=this._getCounter(name);return counter.call++,counter.count+=count,this}},{key:'addTimer',value:function addTimer(name){var timer=this._getCounter(name);return timer.time=0,this}},{key:'addTime',value:function addTime(name,time){var timer=this._getCounter(name);return timer.time+=time,timer.count++,this}},{key:'timeStart',value:function timeStart(name){var timer=this._getCounter(name);timer._startTime=(0,_timestamp.getTimestamp)()}},{key:'timeEnd',value:function timeEnd(name){var timer=this._getCounter(name);this.addTime(name,(0,_timestamp.getTimestamp)()-timer._startTime)}},{key:'reset',value:function reset(){for(var key in this.time=(0,_timestamp.getTimestamp)(),this.counters){var counter=this.counters[key];counter.count=0,counter.time=0}return this}},{key:'hasTimeElapsed',value:function hasTimeElapsed(){0<arguments.length&&void 0!==arguments[0]?arguments[0]:1e3;return 1e3<(0,_timestamp.getTimestamp)()-this.time}},{key:'getStats',value:function getStats(){var deltaTime=((0,_timestamp.getTimestamp)()-this.time)/1e3,stats={};for(var key in this.counters){var counter=this.counters[key];stats[counter.title]={total:counter.count,fps:_Mathround(counter.count/deltaTime)},counter.time&&(stats[counter.title].totalTime=(0,_formatters.formatTime)(counter.time),stats[counter.title].avgTime=(0,_formatters.formatTime)(counter.time/counter.count))}return stats}},{key:'getStatsTable',value:function getStatsTable(){var stats=this.getStats();for(var key in stats)0===stats[key].total&&delete stats[key];return stats}},{key:'getStatNames',value:function getStatNames(){return Object.keys(this.counters)}},{key:'get',value:function get(name){var counter=this._getCounter(name);return counter.count}},{key:'getCount',value:function getCount(name){var counter=this._getCounter(name);return counter.count}},{key:'getFPS',value:function getFPS(name){var counter=this._getCounter(name),deltaTime=((0,_timestamp.getTimestamp)()-this.time)/1e3;return _Mathround(counter.count/deltaTime)}},{key:'getTimeString',value:function getTimeString(){return this.id+':'+(0,_formatters.formatTime)(this.time)+'('+this.count+')'}},{key:'oneSecondPassed',value:function oneSecondPassed(){var deltaTime=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1e3;return this.hasTimeElapsed(deltaTime)}},{key:'_getCounter',value:function _getCounter(name){var counter=this.counters[name];return counter||(counter={title:name,unit:'',timer:!1,count:0,time:0,totalTime:0,averageTime:0},this.counters[name]=counter),counter}},{key:'_incrementTimer',value:function _incrementTimer(counter,time,count){counter.count+=count,counter.totalTime+=time,counter.averageTime=counter.totalTime/count}}]),Stats}();exports.default=Stats;
	//# sourceMappingURL=stats.js.map

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';var _globals=__webpack_require__(33);_globals.global.probe={};
	//# sourceMappingURL=init.js.map

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';Object.defineProperty(exports,'__esModule',{value:!0}),exports.enableDOMLogging=enableDOMLogging,exports.logLineToDOM=logLineToDOM;var _globals=__webpack_require__(33),old=null;function enableDOMLogging(){var enable=!(0<arguments.length&&arguments[0]!==void 0)||arguments[0];enable&&!old&&(old=_globals.console.log.bind(_globals.console),_globals.console.log=function(){logLineToDOM.apply(void 0,arguments),old.apply(void 0,arguments)}),!enable&&old&&(_globals.console.log=old,old=null)}var logDiv=null;function logLineToDOM(message){if(!logDiv){var markdown=_globals.global.probe.markdown;logDiv=_globals.document.createElement(markdown?'pre':'div')}var childNodes=_globals.document.body.childNodes;_globals.document.body.insertBefore(logDiv,childNodes&&childNodes[0]),'string'==typeof message&&(logDiv.innerHTML+=message+'<br />')}exports.default=enableDOMLogging;
	//# sourceMappingURL=log-to-dom.js.map

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.initializeShaderModules = initializeShaderModules;
	Object.defineProperty(exports, "fp32", {
	  enumerable: true,
	  get: function get() {
	    return _luma.fp32;
	  }
	});
	Object.defineProperty(exports, "fp64", {
	  enumerable: true,
	  get: function get() {
	    return _luma.fp64;
	  }
	});
	Object.defineProperty(exports, "picking", {
	  enumerable: true,
	  get: function get() {
	    return _luma.picking;
	  }
	});
	Object.defineProperty(exports, "project", {
	  enumerable: true,
	  get: function get() {
	    return _project.default;
	  }
	});
	Object.defineProperty(exports, "project64", {
	  enumerable: true,
	  get: function get() {
	    return _project3.default;
	  }
	});
	Object.defineProperty(exports, "lighting", {
	  enumerable: true,
	  get: function get() {
	    return _lighting.default;
	  }
	});

	var _luma = __webpack_require__(46);

	var _project = _interopRequireDefault(__webpack_require__(233));

	var _project2 = _interopRequireDefault(__webpack_require__(252));

	var _project3 = _interopRequireDefault(__webpack_require__(253));

	var _lighting = _interopRequireDefault(__webpack_require__(255));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	function initializeShaderModules() {
	  (0, _luma.registerShaderModules)([_luma.fp32, _luma.fp64, _project.default, _project2.default, _project3.default, _lighting.default, _luma.picking]);
	  (0, _luma.setDefaultShaderModules)([_project.default]);
	}

	initializeShaderModules();
	//# sourceMappingURL=index.js.map

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "isWebGL", {
	  enumerable: true,
	  get: function get() {
	    return _webglChecks.isWebGL;
	  }
	});
	Object.defineProperty(exports, "isWebGL2", {
	  enumerable: true,
	  get: function get() {
	    return _webglChecks.isWebGL2;
	  }
	});
	Object.defineProperty(exports, "getKeyValue", {
	  enumerable: true,
	  get: function get() {
	    return _constantsToKeys.getKeyValue;
	  }
	});
	Object.defineProperty(exports, "getKey", {
	  enumerable: true,
	  get: function get() {
	    return _constantsToKeys.getKey;
	  }
	});
	Object.defineProperty(exports, "createGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.createGLContext;
	  }
	});
	Object.defineProperty(exports, "destroyGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.destroyGLContext;
	  }
	});
	Object.defineProperty(exports, "resizeGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.resizeGLContext;
	  }
	});
	Object.defineProperty(exports, "pollGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.pollGLContext;
	  }
	});
	Object.defineProperty(exports, "setContextDefaults", {
	  enumerable: true,
	  get: function get() {
	    return _context.setContextDefaults;
	  }
	});
	Object.defineProperty(exports, "deleteGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.destroyGLContext;
	  }
	});
	Object.defineProperty(exports, "pollContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.pollGLContext;
	  }
	});
	Object.defineProperty(exports, "trackContextCreation", {
	  enumerable: true,
	  get: function get() {
	    return _webglContext.trackContextCreation;
	  }
	});
	Object.defineProperty(exports, "trackContextState", {
	  enumerable: true,
	  get: function get() {
	    return _webglContext.trackContextState;
	  }
	});
	Object.defineProperty(exports, "resetParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.resetParameters;
	  }
	});
	Object.defineProperty(exports, "getParameter", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.getParameter;
	  }
	});
	Object.defineProperty(exports, "getParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.getParameters;
	  }
	});
	Object.defineProperty(exports, "setParameter", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.setParameter;
	  }
	});
	Object.defineProperty(exports, "setParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.setParameters;
	  }
	});
	Object.defineProperty(exports, "withParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.withParameters;
	  }
	});
	Object.defineProperty(exports, "getModifiedParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.getModifiedParameters;
	  }
	});
	Object.defineProperty(exports, "getContextInfo", {
	  enumerable: true,
	  get: function get() {
	    return _contextLimits.getContextInfo;
	  }
	});
	Object.defineProperty(exports, "getGLContextInfo", {
	  enumerable: true,
	  get: function get() {
	    return _contextLimits.getGLContextInfo;
	  }
	});
	Object.defineProperty(exports, "getContextLimits", {
	  enumerable: true,
	  get: function get() {
	    return _contextLimits.getContextLimits;
	  }
	});
	Object.defineProperty(exports, "glGetDebugInfo", {
	  enumerable: true,
	  get: function get() {
	    return _contextLimits.glGetDebugInfo;
	  }
	});
	Object.defineProperty(exports, "FEATURES", {
	  enumerable: true,
	  get: function get() {
	    return _contextFeatures.FEATURES;
	  }
	});
	Object.defineProperty(exports, "hasFeature", {
	  enumerable: true,
	  get: function get() {
	    return _contextFeatures.hasFeature;
	  }
	});
	Object.defineProperty(exports, "hasFeatures", {
	  enumerable: true,
	  get: function get() {
	    return _contextFeatures.hasFeatures;
	  }
	});
	Object.defineProperty(exports, "getFeatures", {
	  enumerable: true,
	  get: function get() {
	    return _contextFeatures.getFeatures;
	  }
	});
	Object.defineProperty(exports, "canCompileGLGSExtension", {
	  enumerable: true,
	  get: function get() {
	    return _contextFeatures.canCompileGLGSExtension;
	  }
	});
	Object.defineProperty(exports, "makeDebugContext", {
	  enumerable: true,
	  get: function get() {
	    return _debugContext.makeDebugContext;
	  }
	});
	Object.defineProperty(exports, "Buffer", {
	  enumerable: true,
	  get: function get() {
	    return _buffer.default;
	  }
	});
	Object.defineProperty(exports, "Shader", {
	  enumerable: true,
	  get: function get() {
	    return _shader.Shader;
	  }
	});
	Object.defineProperty(exports, "VertexShader", {
	  enumerable: true,
	  get: function get() {
	    return _shader.VertexShader;
	  }
	});
	Object.defineProperty(exports, "FragmentShader", {
	  enumerable: true,
	  get: function get() {
	    return _shader.FragmentShader;
	  }
	});
	Object.defineProperty(exports, "Program", {
	  enumerable: true,
	  get: function get() {
	    return _program.default;
	  }
	});
	Object.defineProperty(exports, "Framebuffer", {
	  enumerable: true,
	  get: function get() {
	    return _framebuffer.default;
	  }
	});
	Object.defineProperty(exports, "FramebufferObject", {
	  enumerable: true,
	  get: function get() {
	    return _framebuffer.default;
	  }
	});
	Object.defineProperty(exports, "Renderbuffer", {
	  enumerable: true,
	  get: function get() {
	    return _renderbuffer.default;
	  }
	});
	Object.defineProperty(exports, "Texture2D", {
	  enumerable: true,
	  get: function get() {
	    return _texture2d.default;
	  }
	});
	Object.defineProperty(exports, "TextureCube", {
	  enumerable: true,
	  get: function get() {
	    return _textureCube.default;
	  }
	});
	Object.defineProperty(exports, "draw", {
	  enumerable: true,
	  get: function get() {
	    return _draw.draw;
	  }
	});
	Object.defineProperty(exports, "clear", {
	  enumerable: true,
	  get: function get() {
	    return _clear.clear;
	  }
	});
	Object.defineProperty(exports, "clearBuffer", {
	  enumerable: true,
	  get: function get() {
	    return _clear.clearBuffer;
	  }
	});
	Object.defineProperty(exports, "FenceSync", {
	  enumerable: true,
	  get: function get() {
	    return _fenceSync.default;
	  }
	});
	Object.defineProperty(exports, "Query", {
	  enumerable: true,
	  get: function get() {
	    return _query.default;
	  }
	});
	Object.defineProperty(exports, "Sampler", {
	  enumerable: true,
	  get: function get() {
	    return _sampler.default;
	  }
	});
	Object.defineProperty(exports, "Texture3D", {
	  enumerable: true,
	  get: function get() {
	    return _texture3d.default;
	  }
	});
	Object.defineProperty(exports, "Texture2DArray", {
	  enumerable: true,
	  get: function get() {
	    return _texture2dArray.default;
	  }
	});
	Object.defineProperty(exports, "TransformFeedback", {
	  enumerable: true,
	  get: function get() {
	    return _transformFeedback.default;
	  }
	});
	Object.defineProperty(exports, "VertexArray", {
	  enumerable: true,
	  get: function get() {
	    return _vertexArray.default;
	  }
	});
	Object.defineProperty(exports, "UniformBufferLayout", {
	  enumerable: true,
	  get: function get() {
	    return _uniformBufferLayout.default;
	  }
	});
	Object.defineProperty(exports, "Model", {
	  enumerable: true,
	  get: function get() {
	    return _model.default;
	  }
	});
	Object.defineProperty(exports, "AnimationLoop", {
	  enumerable: true,
	  get: function get() {
	    return _animationLoop.default;
	  }
	});
	Object.defineProperty(exports, "AnimationLoopProxy", {
	  enumerable: true,
	  get: function get() {
	    return _animationLoopProxy.default;
	  }
	});
	Object.defineProperty(exports, "pickModels", {
	  enumerable: true,
	  get: function get() {
	    return _pickModels.default;
	  }
	});
	Object.defineProperty(exports, "encodePickingColor", {
	  enumerable: true,
	  get: function get() {
	    return _pickingColors.encodePickingColor;
	  }
	});
	Object.defineProperty(exports, "decodePickingColor", {
	  enumerable: true,
	  get: function get() {
	    return _pickingColors.decodePickingColor;
	  }
	});
	Object.defineProperty(exports, "getNullPickingColor", {
	  enumerable: true,
	  get: function get() {
	    return _pickingColors.getNullPickingColor;
	  }
	});
	Object.defineProperty(exports, "addEvents", {
	  enumerable: true,
	  get: function get() {
	    return _events.addEvents;
	  }
	});
	Object.defineProperty(exports, "Geometry", {
	  enumerable: true,
	  get: function get() {
	    return _geometry.default;
	  }
	});
	Object.defineProperty(exports, "ConeGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _coneGeometry.default;
	  }
	});
	Object.defineProperty(exports, "CubeGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _cubeGeometry.default;
	  }
	});
	Object.defineProperty(exports, "CylinderGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _cylinderGeometry.default;
	  }
	});
	Object.defineProperty(exports, "IcoSphereGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _icoSphereGeometry.default;
	  }
	});
	Object.defineProperty(exports, "PlaneGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _planeGeometry.default;
	  }
	});
	Object.defineProperty(exports, "SphereGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _sphereGeometry.default;
	  }
	});
	Object.defineProperty(exports, "TruncatedConeGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _truncatedConeGeometry.default;
	  }
	});
	Object.defineProperty(exports, "Cone", {
	  enumerable: true,
	  get: function get() {
	    return _cone.default;
	  }
	});
	Object.defineProperty(exports, "Cube", {
	  enumerable: true,
	  get: function get() {
	    return _cube.default;
	  }
	});
	Object.defineProperty(exports, "Cylinder", {
	  enumerable: true,
	  get: function get() {
	    return _cylinder.default;
	  }
	});
	Object.defineProperty(exports, "IcoSphere", {
	  enumerable: true,
	  get: function get() {
	    return _icoSphere.default;
	  }
	});
	Object.defineProperty(exports, "Plane", {
	  enumerable: true,
	  get: function get() {
	    return _plane.default;
	  }
	});
	Object.defineProperty(exports, "Sphere", {
	  enumerable: true,
	  get: function get() {
	    return _sphere.default;
	  }
	});
	Object.defineProperty(exports, "TruncatedCone", {
	  enumerable: true,
	  get: function get() {
	    return _truncatedCone.default;
	  }
	});
	Object.defineProperty(exports, "ClipSpaceQuad", {
	  enumerable: true,
	  get: function get() {
	    return _clipSpaceQuad.default;
	  }
	});
	Object.defineProperty(exports, "setPathPrefix", {
	  enumerable: true,
	  get: function get() {
	    return _io.setPathPrefix;
	  }
	});
	Object.defineProperty(exports, "loadFile", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadFile;
	  }
	});
	Object.defineProperty(exports, "loadImage", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadImage;
	  }
	});
	Object.defineProperty(exports, "loadFiles", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadFiles;
	  }
	});
	Object.defineProperty(exports, "loadImages", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadImages;
	  }
	});
	Object.defineProperty(exports, "loadTextures", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadTextures;
	  }
	});
	Object.defineProperty(exports, "loadProgram", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadProgram;
	  }
	});
	Object.defineProperty(exports, "loadModel", {
	  enumerable: true,
	  get: function get() {
	    return _io.loadModel;
	  }
	});
	Object.defineProperty(exports, "parseModel", {
	  enumerable: true,
	  get: function get() {
	    return _io.parseModel;
	  }
	});
	Object.defineProperty(exports, "ShaderCache", {
	  enumerable: true,
	  get: function get() {
	    return _shaderCache.default;
	  }
	});
	Object.defineProperty(exports, "assembleShaders", {
	  enumerable: true,
	  get: function get() {
	    return _assembleShaders.assembleShaders;
	  }
	});
	Object.defineProperty(exports, "registerShaderModules", {
	  enumerable: true,
	  get: function get() {
	    return _shaderModules.registerShaderModules;
	  }
	});
	Object.defineProperty(exports, "setDefaultShaderModules", {
	  enumerable: true,
	  get: function get() {
	    return _shaderModules.setDefaultShaderModules;
	  }
	});
	Object.defineProperty(exports, "fp32", {
	  enumerable: true,
	  get: function get() {
	    return _fp.default;
	  }
	});
	Object.defineProperty(exports, "fp64", {
	  enumerable: true,
	  get: function get() {
	    return _fp2.default;
	  }
	});
	Object.defineProperty(exports, "project", {
	  enumerable: true,
	  get: function get() {
	    return _project.default;
	  }
	});
	Object.defineProperty(exports, "lighting", {
	  enumerable: true,
	  get: function get() {
	    return _lighting.default;
	  }
	});
	Object.defineProperty(exports, "dirlight", {
	  enumerable: true,
	  get: function get() {
	    return _dirlight.default;
	  }
	});
	Object.defineProperty(exports, "picking", {
	  enumerable: true,
	  get: function get() {
	    return _picking.default;
	  }
	});
	Object.defineProperty(exports, "diffuse", {
	  enumerable: true,
	  get: function get() {
	    return _diffuse.default;
	  }
	});
	Object.defineProperty(exports, "GL", {
	  enumerable: true,
	  get: function get() {
	    return _constants.default;
	  }
	});
	Object.defineProperty(exports, "glGet", {
	  enumerable: true,
	  get: function get() {
	    return _glConstants.glGet;
	  }
	});
	Object.defineProperty(exports, "glKey", {
	  enumerable: true,
	  get: function get() {
	    return _glConstants.glKey;
	  }
	});
	Object.defineProperty(exports, "radians", {
	  enumerable: true,
	  get: function get() {
	    return _math.radians;
	  }
	});
	Object.defineProperty(exports, "degrees", {
	  enumerable: true,
	  get: function get() {
	    return _math.degrees;
	  }
	});
	Object.defineProperty(exports, "Vector2", {
	  enumerable: true,
	  get: function get() {
	    return _math.Vector2;
	  }
	});
	Object.defineProperty(exports, "Vector3", {
	  enumerable: true,
	  get: function get() {
	    return _math.Vector3;
	  }
	});
	Object.defineProperty(exports, "Vector4", {
	  enumerable: true,
	  get: function get() {
	    return _math.Vector4;
	  }
	});
	Object.defineProperty(exports, "Matrix4", {
	  enumerable: true,
	  get: function get() {
	    return _math.Matrix4;
	  }
	});
	Object.defineProperty(exports, "Quaternion", {
	  enumerable: true,
	  get: function get() {
	    return _math.Quaternion;
	  }
	});
	Object.defineProperty(exports, "readPixels", {
	  enumerable: true,
	  get: function get() {
	    return _functions.readPixels;
	  }
	});
	exports.experimental = void 0;

	var _webglChecks = __webpack_require__(47);

	var _constantsToKeys = __webpack_require__(57);

	var _context = __webpack_require__(60);

	var _webglContext = __webpack_require__(77);

	var _contextState = __webpack_require__(78);

	var _contextLimits = __webpack_require__(75);

	var _contextFeatures = __webpack_require__(79);

	var _debugContext = __webpack_require__(74);

	var _attribute = _interopRequireDefault(__webpack_require__(80));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	var _shader = __webpack_require__(85);

	var _program = _interopRequireDefault(__webpack_require__(86));

	var _framebuffer = _interopRequireDefault(__webpack_require__(89));

	var _renderbuffer = _interopRequireDefault(__webpack_require__(91));

	var _texture2d = _interopRequireDefault(__webpack_require__(90));

	var _textureCube = _interopRequireDefault(__webpack_require__(97));

	var _draw = __webpack_require__(98);

	var _clear = __webpack_require__(92);

	var _fenceSync = _interopRequireDefault(__webpack_require__(100));

	var _query = _interopRequireDefault(__webpack_require__(101));

	var _sampler = _interopRequireDefault(__webpack_require__(95));

	var _texture3d = _interopRequireDefault(__webpack_require__(102));

	var _texture2dArray = _interopRequireDefault(__webpack_require__(103));

	var _transformFeedback = _interopRequireDefault(__webpack_require__(104));

	var _vertexArray = _interopRequireDefault(__webpack_require__(87));

	var _uniformBufferLayout = _interopRequireDefault(__webpack_require__(105));

	var _model = _interopRequireDefault(__webpack_require__(106));

	var _animationLoop = _interopRequireDefault(__webpack_require__(190));

	var _animationLoopProxy = _interopRequireDefault(__webpack_require__(191));

	var _pickModels = _interopRequireDefault(__webpack_require__(192));

	var _pickingColors = __webpack_require__(194);

	var _events = __webpack_require__(195);

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	var _coneGeometry = _interopRequireDefault(__webpack_require__(197));

	var _cubeGeometry = _interopRequireDefault(__webpack_require__(199));

	var _cylinderGeometry = _interopRequireDefault(__webpack_require__(200));

	var _icoSphereGeometry = _interopRequireDefault(__webpack_require__(201));

	var _planeGeometry = _interopRequireDefault(__webpack_require__(202));

	var _sphereGeometry = _interopRequireDefault(__webpack_require__(203));

	var _truncatedConeGeometry = _interopRequireDefault(__webpack_require__(198));

	var _cone = _interopRequireDefault(__webpack_require__(204));

	var _cube = _interopRequireDefault(__webpack_require__(207));

	var _cylinder = _interopRequireDefault(__webpack_require__(208));

	var _icoSphere = _interopRequireDefault(__webpack_require__(209));

	var _plane = _interopRequireDefault(__webpack_require__(210));

	var _sphere = _interopRequireDefault(__webpack_require__(211));

	var _truncatedCone = _interopRequireDefault(__webpack_require__(212));

	var _clipSpaceQuad = _interopRequireDefault(__webpack_require__(213));

	var _io = __webpack_require__(214);

	var _shaderCache = _interopRequireDefault(__webpack_require__(187));

	var _assembleShaders = __webpack_require__(184);

	var _shaderModules = __webpack_require__(183);

	var _fp = _interopRequireDefault(__webpack_require__(218));

	var _fp2 = _interopRequireDefault(__webpack_require__(219));

	var _project = _interopRequireDefault(__webpack_require__(223));

	var _lighting = _interopRequireDefault(__webpack_require__(224));

	var _dirlight = _interopRequireDefault(__webpack_require__(228));

	var _picking = _interopRequireDefault(__webpack_require__(229));

	var _diffuse = _interopRequireDefault(__webpack_require__(230));

	var _transform = _interopRequireDefault(__webpack_require__(231));

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _glConstants = __webpack_require__(232);

	var _math = __webpack_require__(109);

	var _functions = __webpack_require__(99);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Export core modules for luma.gl
	// Initialize any global state
	__webpack_require__(84); // WebGL


	var experimental = {
	  clearBuffer: _clear.clearBuffer,
	  Transform: _transform.default,
	  Attribute: _attribute.default
	}; // DEPRECATED EXPORTS IN v5.3

	exports.experimental = experimental;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isWebGL = isWebGL;
	exports.isWebGL2 = isWebGL2;
	exports.assertWebGLContext = assertWebGLContext;
	exports.assertWebGL2Context = assertWebGL2Context;
	exports.ERR_WEBGL2 = exports.ERR_WEBGL = exports.ERR_CONTEXT = void 0;

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	// Heuristic testing of contexts (to indentify debug wrappers around gl contexts)
	var GL_ARRAY_BUFFER = 0x8892;
	var GL_TEXTURE_BINDING_3D = 0x806A;
	var ERR_CONTEXT = 'Invalid WebGLRenderingContext';
	exports.ERR_CONTEXT = ERR_CONTEXT;
	var ERR_WEBGL = ERR_CONTEXT;
	exports.ERR_WEBGL = ERR_WEBGL;
	var ERR_WEBGL2 = 'Requires WebGL2';
	exports.ERR_WEBGL2 = ERR_WEBGL2;

	function isWebGL(gl) {
	  return Boolean(gl && (_instanceof(gl, _webglUtils.WebGLRenderingContext) || gl.ARRAY_BUFFER === GL_ARRAY_BUFFER));
	}

	function isWebGL2(gl) {
	  return Boolean(gl && (_instanceof(gl, _webglUtils.WebGL2RenderingContext) || gl.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D));
	}

	function assertWebGLContext(gl) {
	  // Need to handle debug context
	  (0, _assert.default)(isWebGL(gl), ERR_CONTEXT);
	}

	function assertWebGL2Context(gl) {
	  // Need to handle debug context
	  (0, _assert.default)(isWebGL2(gl), ERR_WEBGL2);
	}
	//# sourceMappingURL=webgl-checks.js.map

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "Image", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.Image;
	  }
	});
	Object.defineProperty(exports, "WebGLRenderingContext", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLRenderingContext;
	  }
	});
	Object.defineProperty(exports, "WebGLProgram", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLProgram;
	  }
	});
	Object.defineProperty(exports, "WebGLShader", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLShader;
	  }
	});
	Object.defineProperty(exports, "WebGLBuffer", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLBuffer;
	  }
	});
	Object.defineProperty(exports, "WebGLFramebuffer", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLFramebuffer;
	  }
	});
	Object.defineProperty(exports, "WebGLRenderbuffer", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLRenderbuffer;
	  }
	});
	Object.defineProperty(exports, "WebGLTexture", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLTexture;
	  }
	});
	Object.defineProperty(exports, "WebGLUniformLocation", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLUniformLocation;
	  }
	});
	Object.defineProperty(exports, "WebGLActiveInfo", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLActiveInfo;
	  }
	});
	Object.defineProperty(exports, "WebGLShaderPrecisionFormat", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGLShaderPrecisionFormat;
	  }
	});
	Object.defineProperty(exports, "WebGL2RenderingContext", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.WebGL2RenderingContext;
	  }
	});
	Object.defineProperty(exports, "webGLTypesAvailable", {
	  enumerable: true,
	  get: function get() {
	    return _webglTypes.webGLTypesAvailable;
	  }
	});
	Object.defineProperty(exports, "isWebGL", {
	  enumerable: true,
	  get: function get() {
	    return _webglChecks.isWebGL;
	  }
	});
	Object.defineProperty(exports, "isWebGL2", {
	  enumerable: true,
	  get: function get() {
	    return _webglChecks.isWebGL2;
	  }
	});
	Object.defineProperty(exports, "assertWebGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _webglChecks.assertWebGLContext;
	  }
	});
	Object.defineProperty(exports, "assertWebGL2Context", {
	  enumerable: true,
	  get: function get() {
	    return _webglChecks.assertWebGL2Context;
	  }
	});
	Object.defineProperty(exports, "requestAnimationFrame", {
	  enumerable: true,
	  get: function get() {
	    return _requestAnimationFrame.requestAnimationFrame;
	  }
	});
	Object.defineProperty(exports, "cancelAnimationFrame", {
	  enumerable: true,
	  get: function get() {
	    return _requestAnimationFrame.cancelAnimationFrame;
	  }
	});
	Object.defineProperty(exports, "formatGLSLCompilerError", {
	  enumerable: true,
	  get: function get() {
	    return _formatGlslError.default;
	  }
	});
	Object.defineProperty(exports, "parseGLSLCompilerError", {
	  enumerable: true,
	  get: function get() {
	    return _formatGlslError.parseGLSLCompilerError;
	  }
	});
	Object.defineProperty(exports, "getShaderName", {
	  enumerable: true,
	  get: function get() {
	    return _getShaderName.default;
	  }
	});
	Object.defineProperty(exports, "getGLTypeFromTypedArray", {
	  enumerable: true,
	  get: function get() {
	    return _typedArrayUtils.getGLTypeFromTypedArray;
	  }
	});
	Object.defineProperty(exports, "getTypedArrayFromGLType", {
	  enumerable: true,
	  get: function get() {
	    return _typedArrayUtils.getTypedArrayFromGLType;
	  }
	});
	Object.defineProperty(exports, "flipRows", {
	  enumerable: true,
	  get: function get() {
	    return _typedArrayUtils.flipRows;
	  }
	});
	Object.defineProperty(exports, "scalePixels", {
	  enumerable: true,
	  get: function get() {
	    return _typedArrayUtils.scalePixels;
	  }
	});
	Object.defineProperty(exports, "getKeyValue", {
	  enumerable: true,
	  get: function get() {
	    return _constantsToKeys.getKeyValue;
	  }
	});
	Object.defineProperty(exports, "getKey", {
	  enumerable: true,
	  get: function get() {
	    return _constantsToKeys.getKey;
	  }
	});
	Object.defineProperty(exports, "getKeyType", {
	  enumerable: true,
	  get: function get() {
	    return _constantsToKeys.getKeyType;
	  }
	});
	Object.defineProperty(exports, "GL", {
	  enumerable: true,
	  get: function get() {
	    return _constants.default;
	  }
	});

	var _webglTypes = __webpack_require__(49);

	var _webglChecks = __webpack_require__(47);

	var _requestAnimationFrame = __webpack_require__(53);

	var _formatGlslError = _interopRequireWildcard(__webpack_require__(54));

	var _getShaderName = _interopRequireDefault(__webpack_require__(55));

	var _typedArrayUtils = __webpack_require__(56);

	var _constantsToKeys = __webpack_require__(57);

	var _constants = _interopRequireDefault(__webpack_require__(59));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.WebGL2RenderingContext = exports.WebGLShaderPrecisionFormat = exports.WebGLActiveInfo = exports.WebGLUniformLocation = exports.WebGLTexture = exports.WebGLRenderbuffer = exports.WebGLFramebuffer = exports.WebGLBuffer = exports.WebGLShader = exports.WebGLProgram = exports.WebGLRenderingContext = exports.Image = exports.webGLTypesAvailable = exports.headlessTypes = void 0;

	var _globals = __webpack_require__(50);

	var _isBrowser = _interopRequireDefault(__webpack_require__(51));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Load headless gl dynamically, if available
	var headlessTypes = null;
	exports.headlessTypes = headlessTypes;

	if (!_isBrowser.default) {
	  try {
	    exports.headlessTypes = headlessTypes = module.require('gl/wrap');
	  } catch (error) {
	    console.error("".concat(error.message));
	  }

	  console.warn(headlessTypes && headlessTypes.WebGLRenderingContext);
	}

	var DummyType = function DummyType() {
	  _classCallCheck(this, DummyType);
	};

	var _ref = headlessTypes || _globals.global,
	    _ref$WebGLRenderingCo = _ref.WebGLRenderingContext,
	    WebGLRenderingContext = _ref$WebGLRenderingCo === void 0 ? DummyType : _ref$WebGLRenderingCo,
	    _ref$WebGLProgram = _ref.WebGLProgram,
	    WebGLProgram = _ref$WebGLProgram === void 0 ? DummyType : _ref$WebGLProgram,
	    _ref$WebGLShader = _ref.WebGLShader,
	    WebGLShader = _ref$WebGLShader === void 0 ? DummyType : _ref$WebGLShader,
	    _ref$WebGLBuffer = _ref.WebGLBuffer,
	    WebGLBuffer = _ref$WebGLBuffer === void 0 ? DummyType : _ref$WebGLBuffer,
	    _ref$WebGLFramebuffer = _ref.WebGLFramebuffer,
	    WebGLFramebuffer = _ref$WebGLFramebuffer === void 0 ? DummyType : _ref$WebGLFramebuffer,
	    _ref$WebGLRenderbuffe = _ref.WebGLRenderbuffer,
	    WebGLRenderbuffer = _ref$WebGLRenderbuffe === void 0 ? DummyType : _ref$WebGLRenderbuffe,
	    _ref$WebGLTexture = _ref.WebGLTexture,
	    WebGLTexture = _ref$WebGLTexture === void 0 ? DummyType : _ref$WebGLTexture,
	    _ref$WebGLUniformLoca = _ref.WebGLUniformLocation,
	    WebGLUniformLocation = _ref$WebGLUniformLoca === void 0 ? DummyType : _ref$WebGLUniformLoca,
	    _ref$WebGLActiveInfo = _ref.WebGLActiveInfo,
	    WebGLActiveInfo = _ref$WebGLActiveInfo === void 0 ? DummyType : _ref$WebGLActiveInfo,
	    _ref$WebGLShaderPreci = _ref.WebGLShaderPrecisionFormat,
	    WebGLShaderPrecisionFormat = _ref$WebGLShaderPreci === void 0 ? DummyType : _ref$WebGLShaderPreci;

	exports.WebGLShaderPrecisionFormat = WebGLShaderPrecisionFormat;
	exports.WebGLActiveInfo = WebGLActiveInfo;
	exports.WebGLUniformLocation = WebGLUniformLocation;
	exports.WebGLTexture = WebGLTexture;
	exports.WebGLRenderbuffer = WebGLRenderbuffer;
	exports.WebGLFramebuffer = WebGLFramebuffer;
	exports.WebGLBuffer = WebGLBuffer;
	exports.WebGLShader = WebGLShader;
	exports.WebGLProgram = WebGLProgram;
	exports.WebGLRenderingContext = WebGLRenderingContext;
	var webGLTypesAvailable = WebGLRenderingContext !== DummyType && WebGLProgram !== DummyType && WebGLShader !== DummyType && WebGLBuffer !== DummyType && WebGLFramebuffer !== DummyType && WebGLRenderbuffer !== DummyType && WebGLTexture !== DummyType && WebGLUniformLocation !== DummyType && WebGLActiveInfo !== DummyType && WebGLShaderPrecisionFormat !== DummyType; // Ensures that WebGL2RenderingContext is defined in non-WebGL2 environments
	// so that apps can test their gl contexts with instanceof
	// E.g. if (gl instanceof WebGL2RenderingContext) { }

	exports.webGLTypesAvailable = webGLTypesAvailable;

	function getWebGL2RenderingContext() {
	  var WebGL2RenderingContextNotSupported = function WebGL2RenderingContextNotSupported() {
	    _classCallCheck(this, WebGL2RenderingContextNotSupported);
	  };

	  return _globals.global.WebGL2RenderingContext || WebGL2RenderingContextNotSupported;
	} // Ensure that Image is defined under Node.js


	function getImage() {
	  var ImageNotSupported = function ImageNotSupported() {
	    _classCallCheck(this, ImageNotSupported);
	  };

	  return _globals.global.Image || ImageNotSupported;
	}

	var WebGL2RenderingContext = getWebGL2RenderingContext();
	exports.WebGL2RenderingContext = WebGL2RenderingContext;
	var Image = getImage(); // Export the standard WebGL types

	exports.Image = Image;
	//# sourceMappingURL=webgl-types.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module)))

/***/ }),
/* 50 */
/***/ (function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.document = exports.global = exports.window = exports.self = void 0;

	/* global self, window, global, document */
	var globals = {
	  self: typeof self !== 'undefined' && self,
	  window: typeof window !== 'undefined' && window,
	  global: typeof global !== 'undefined' && global,
	  document: typeof document !== 'undefined' && document
	};
	var self_ = globals.self || globals.window || globals.global;
	exports.self = self_;
	var window_ = globals.window || globals.self || globals.global;
	exports.window = window_;
	var global_ = globals.global || globals.self || globals.window;
	exports.global = global_;
	var document_ = globals.document || {};
	exports.document = document_;
	//# sourceMappingURL=globals.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.isBrowserMainThread = void 0;

	var _isElectron = _interopRequireDefault(__webpack_require__(52));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var isNode = (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && String(process) === '[object process]' && !process.browser;
	var isBrowser = !isNode || _isElectron.default; // document does not exist on worker thread

	var isBrowserMainThread = isBrowser && typeof document !== 'undefined';
	exports.isBrowserMainThread = isBrowserMainThread;
	var _default = isBrowser;
	exports.default = _default;
	//# sourceMappingURL=is-browser.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	// based on https://github.com/cheton/is-electron
	// https://github.com/electron/electron/issues/2288

	/* global window, process, navigator */
	function isElectron() {
	  // Renderer process
	  if (typeof window !== 'undefined' && _typeof(window.process) === 'object' && window.process.type === 'renderer') {
	    return true;
	  } // Main process


	  if (typeof process !== 'undefined' && _typeof(process.versions) === 'object' && Boolean(process.versions.electron)) {
	    return true;
	  } // Detect the user agent when the `nodeIntegration` option is set to true


	  if ((typeof navigator === "undefined" ? "undefined" : _typeof(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
	    return true;
	  }

	  return false;
	}

	var _default = isElectron();

	exports.default = _default;
	//# sourceMappingURL=is-electron.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30)))

/***/ }),
/* 53 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.requestAnimationFrame = requestAnimationFrame;
	exports.cancelAnimationFrame = cancelAnimationFrame;

	// Node.js polyfills for requestAnimationFrame and cancelAnimationFrame

	/* global window, setTimeout, clearTimeout */
	function requestAnimationFrame(callback) {
	  return typeof window !== 'undefined' && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);
	}

	function cancelAnimationFrame(timerId) {
	  return typeof window !== 'undefined' && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
	}
	//# sourceMappingURL=request-animation-frame.js.map

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parseGLSLCompilerError = parseGLSLCompilerError;
	exports.default = formatGLSLCompilerError;

	var _getShaderName = _interopRequireWildcard(__webpack_require__(55));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	// TODO - formatGLSLCompilerError should not depend on this

	/**
	 * Parse a GLSL compiler error log into a string showing the source code around each error.
	 * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)
	 */

	/* eslint-disable no-continue, max-statements */
	function parseGLSLCompilerError(errLog, src, shaderType) {
	  var errorStrings = errLog.split(/\r?\n/);
	  var errors = {};
	  var warnings = {};
	  var name = (0, _getShaderName.default)(src) || '(unnamed)';
	  var shaderName = "".concat((0, _getShaderName.getShaderTypeName)(shaderType), " shader ").concat(name); // Parse the error - note: browser and driver dependent

	  for (var i = 0; i < errorStrings.length; i++) {
	    var errorString = errorStrings[i];

	    if (errorString.length <= 1) {
	      continue;
	    }

	    var segments = errorString.split(':');
	    var type = segments[0];
	    var line = parseInt(segments[2], 10);

	    if (isNaN(line)) {
	      throw new Error("GLSL compilation error in ".concat(shaderName, ": ").concat(errLog));
	    }

	    if (type !== 'WARNING') {
	      errors[line] = errorString;
	    } else {
	      warnings[line] = errorString;
	    }
	  } // Format the error inline with the code


	  var lines = addLineNumbers(src);
	  return {
	    shaderName: shaderName,
	    errors: formatErrors(errors, lines),
	    warnings: formatErrors(warnings, lines)
	  };
	} // Formats GLSL compiler error log into single string


	function formatGLSLCompilerError(errLog, src, shaderType) {
	  var _parseGLSLCompilerErr = parseGLSLCompilerError(errLog, src, shaderType),
	      shaderName = _parseGLSLCompilerErr.shaderName,
	      errors = _parseGLSLCompilerErr.errors,
	      warnings = _parseGLSLCompilerErr.warnings;

	  return "GLSL compilation error in ".concat(shaderName, "\n\n").concat(errors, "\n").concat(warnings);
	} // helper function, outputs annotated errors or warnings


	function formatErrors(errors, lines) {
	  var message = '';

	  for (var i = 0; i < lines.length; i++) {
	    var line = lines[i];

	    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
	      continue;
	    }

	    message += "".concat(line, "\n");

	    if (errors[i + 1]) {
	      var error = errors[i + 1];
	      var segments = error.split(':', 3);
	      var type = segments[0];
	      var column = parseInt(segments[1], 10) || 0;
	      var err = error.substring(segments.join(':').length + 1).trim();
	      message += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
	    }
	  }

	  return message;
	}
	/**
	 * Prepends line numbers to each line of a string.
	 * The line numbers will be left-padded with spaces to ensure an
	 * aligned layout when rendered using monospace fonts.
	 * @param {String} string - multi-line string to add line numbers to
	 * @param {Number} start=1 - number of spaces to add
	 * @param {String} delim =': ' - injected between line number and original line
	 * @return {String[]} strings - array of string, one per line, with line numbers added
	 */


	function addLineNumbers(string) {
	  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
	  var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';
	  var lines = string.split(/\r?\n/);
	  var maxDigits = String(lines.length + start - 1).length;
	  return lines.map(function (line, i) {
	    var lineNumber = i + start;
	    var digits = String(lineNumber).length;
	    var prefix = padLeft(lineNumber, maxDigits - digits);
	    return prefix + delim + line;
	  });
	}
	/**
	 * Pads a string with a number of spaces (space characters) to the left
	 * @param {String} string - string to pad
	 * @param {Number} digits - number of spaces to add
	 * @return {String} string - The padded string
	 */


	function padLeft(string, digits) {
	  var result = '';

	  for (var i = 0; i < digits; ++i) {
	    result += ' ';
	  }

	  return "".concat(result).concat(string);
	}
	//# sourceMappingURL=format-glsl-error.js.map

/***/ }),
/* 55 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getShaderName;
	exports.getShaderTypeName = getShaderTypeName;
	var GL_FRAGMENT_SHADER = 0x8B30;
	var GL_VERTEX_SHADER = 0x8B31; // Supports GLSLIFY style naming of shaders
	// #define SHADER_NAME ...

	function getShaderName(shader) {
	  var SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
	  var match = shader.match(SHADER_NAME_REGEXP);
	  return match ? match[1] : 'unnamed';
	}

	function getShaderTypeName(type) {
	  switch (type) {
	    case GL_FRAGMENT_SHADER:
	      return 'fragment';

	    case GL_VERTEX_SHADER:
	      return 'vertex';

	    default:
	      return 'unknown type';
	  }
	}
	//# sourceMappingURL=get-shader-name.js.map

/***/ }),
/* 56 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getGLTypeFromTypedArray = getGLTypeFromTypedArray;
	exports.getTypedArrayFromGLType = getTypedArrayFromGLType;
	exports.flipRows = flipRows;
	exports.scalePixels = scalePixels;
	// GL Constants
	var GL_BYTE = 0x1400;
	var GL_UNSIGNED_BYTE = 0x1401;
	var GL_SHORT = 0x1402;
	var GL_UNSIGNED_SHORT = 0x1403;
	var GL_INT = 0x1404;
	var GL_UNSIGNED_INT = 0x1405;
	var GL_FLOAT = 0x1406;
	var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
	var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
	var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
	var ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array'; // Converts TYPED ARRAYS to corresponding GL constant
	// Used to auto deduce gl parameter types

	function getGLTypeFromTypedArray(arrayOrType) {
	  // If typed array, look up constructor
	  var type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;

	  switch (type) {
	    case Float32Array:
	      return GL_FLOAT;

	    case Uint16Array:
	      return GL_UNSIGNED_SHORT;

	    case Uint32Array:
	      return GL_UNSIGNED_INT;

	    case Uint8Array:
	      return GL_UNSIGNED_BYTE;

	    case Uint8ClampedArray:
	      return GL_UNSIGNED_BYTE;

	    case Int8Array:
	      return GL_BYTE;

	    case Int16Array:
	      return GL_SHORT;

	    case Int32Array:
	      return GL_INT;

	    default:
	      throw new Error(ERR_TYPE_DEDUCTION);
	  }
	} // Converts GL constant to corresponding TYPED ARRAY
	// Used to auto deduce gl parameter types

	/* eslint-disable complexity */


	function getTypedArrayFromGLType(glType) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$clamped = _ref.clamped,
	      clamped = _ref$clamped === void 0 ? true : _ref$clamped;

	  // Sorted in some order of likelihood to reduce amount of comparisons
	  switch (glType) {
	    case GL_FLOAT:
	      return Float32Array;

	    case GL_UNSIGNED_SHORT:
	    case GL_UNSIGNED_SHORT_5_6_5:
	    case GL_UNSIGNED_SHORT_4_4_4_4:
	    case GL_UNSIGNED_SHORT_5_5_5_1:
	      return Uint16Array;

	    case GL_UNSIGNED_INT:
	      return Uint32Array;

	    case GL_UNSIGNED_BYTE:
	      return clamped ? Uint8ClampedArray : Uint8Array;

	    case GL_BYTE:
	      return Int8Array;

	    case GL_SHORT:
	      return Int16Array;

	    case GL_INT:
	      return Int32Array;

	    default:
	      throw new Error('Failed to deduce typed array type from GL constant');
	  }
	}
	/* eslint-enable complexity */
	// Flip rows (can be used on arrays returned from `Framebuffer.readPixels`)
	// https://stackoverflow.com/questions/41969562/
	// how-can-i-flip-the-result-of-webglrenderingcontext-readpixels


	function flipRows(_ref2) {
	  var data = _ref2.data,
	      width = _ref2.width,
	      height = _ref2.height,
	      _ref2$bytesPerPixel = _ref2.bytesPerPixel,
	      bytesPerPixel = _ref2$bytesPerPixel === void 0 ? 4 : _ref2$bytesPerPixel,
	      temp = _ref2.temp;
	  var bytesPerRow = width * bytesPerPixel; // make a temp buffer to hold one row

	  temp = temp || new Uint8Array(bytesPerRow);

	  for (var y = 0; y < height / 2; ++y) {
	    var topOffset = y * bytesPerRow;
	    var bottomOffset = (height - y - 1) * bytesPerRow; // make copy of a row on the top half

	    temp.set(data.subarray(topOffset, topOffset + bytesPerRow)); // copy a row from the bottom half to the top

	    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow); // copy the copy of the top half row to the bottom half

	    data.set(temp, bottomOffset);
	  }
	}

	function scalePixels(_ref3) {
	  var data = _ref3.data,
	      width = _ref3.width,
	      height = _ref3.height;
	  var newWidth = Math.round(width / 2);
	  var newHeight = Math.round(height / 2);
	  var newData = new Uint8Array(newWidth * newHeight * 4);

	  for (var y = 0; y < newHeight; y++) {
	    for (var x = 0; x < newWidth; x++) {
	      for (var c = 0; c < 4; c++) {
	        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
	      }
	    }
	  }

	  return {
	    data: newData,
	    width: newWidth,
	    height: newHeight
	  };
	}
	//# sourceMappingURL=typed-array-utils.js.map

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getKeyValue = getKeyValue;
	exports.getKey = getKey;
	exports.getKeyType = getKeyType;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Resolve a WebGL enumeration name (returns itself if already a number)
	function getKeyValue(gl, name) {
	  // If not a string, return (assume number)
	  if (typeof name !== 'string') {
	    return name;
	  } // If string converts to number, return number


	  var number = Number(name);

	  if (!isNaN(number)) {
	    return number;
	  } // Look up string, after removing any 'GL.' or 'gl.' prefix


	  name = name.replace(/^.*\./, '');
	  var value = gl[name];
	  (0, _assert.default)(value !== undefined, "Accessing undefined constant GL.".concat(name));
	  return value;
	}

	function getKey(gl, value) {
	  value = Number(value);

	  for (var key in gl) {
	    if (gl[key] === value) {
	      return "gl.".concat(key);
	    }
	  }

	  return String(value);
	}

	function getKeyType(gl, value) {
	  (0, _assert.default)(value !== undefined, 'undefined key');
	  value = Number(value);

	  for (var key in gl) {
	    if (gl[key] === value) {
	      return "gl.".concat(key);
	    }
	  }

	  return String(value);
	}
	//# sourceMappingURL=constants-to-keys.js.map

/***/ }),
/* 58 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = assert;

	// Recommendation is to ignore message but current test suite checks agains the
	// message so keep it for now.
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message || 'luma.gl: assertion failed.');
	  }
	}
	//# sourceMappingURL=assert.js.map

/***/ }),
/* 59 */
/***/ (function(module, exports) {

	"use strict";

	// GL constants, copied from Mozilla documentation
	// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants
	// Standard WebGL 1 constants
	// These constants are defined on the WebGLRenderingContext interface.

	/* eslint-disable key-spacing, max-len, no-inline-comments, camelcase */
	module.exports = {
	  // Clearing buffers
	  // Constants passed to clear() to clear buffer masks.
	  DEPTH_BUFFER_BIT: 0x00000100,
	  STENCIL_BUFFER_BIT: 0x00000400,
	  COLOR_BUFFER_BIT: 0x00004000,
	  // Rendering primitives
	  // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.
	  POINTS: 0x0000,
	  LINES: 0x0001,
	  LINE_LOOP: 0x0002,
	  LINE_STRIP: 0x0003,
	  TRIANGLES: 0x0004,
	  TRIANGLE_STRIP: 0x0005,
	  TRIANGLE_FAN: 0x0006,
	  // Blending modes
	  // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).
	  ZERO: 0,
	  ONE: 1,
	  SRC_COLOR: 0x0300,
	  ONE_MINUS_SRC_COLOR: 0x0301,
	  SRC_ALPHA: 0x0302,
	  ONE_MINUS_SRC_ALPHA: 0x0303,
	  DST_ALPHA: 0x0304,
	  ONE_MINUS_DST_ALPHA: 0x0305,
	  DST_COLOR: 0x0306,
	  ONE_MINUS_DST_COLOR: 0x0307,
	  SRC_ALPHA_SATURATE: 0x0308,
	  CONSTANT_COLOR: 0x8001,
	  ONE_MINUS_CONSTANT_COLOR: 0x8002,
	  CONSTANT_ALPHA: 0x8003,
	  ONE_MINUS_CONSTANT_ALPHA: 0x8004,
	  // Blending equations
	  // Constants passed to blendEquation() or blendEquationSeparate() to control
	  // how the blending is calculated (for both, RBG and alpha, or separately).
	  FUNC_ADD: 0x8006,
	  FUNC_SUBTRACT: 0x800A,
	  FUNC_REVERSE_SUBTRACT: 0x800B,
	  // Getting GL parameter information
	  // Constants passed to getParameter() to specify what information to return.
	  BLEND_EQUATION: 0x8009,
	  BLEND_EQUATION_RGB: 0x8009,
	  BLEND_EQUATION_ALPHA: 0x883D,
	  BLEND_DST_RGB: 0x80C8,
	  BLEND_SRC_RGB: 0x80C9,
	  BLEND_DST_ALPHA: 0x80CA,
	  BLEND_SRC_ALPHA: 0x80CB,
	  BLEND_COLOR: 0x8005,
	  ARRAY_BUFFER_BINDING: 0x8894,
	  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
	  LINE_WIDTH: 0x0B21,
	  ALIASED_POINT_SIZE_RANGE: 0x846D,
	  ALIASED_LINE_WIDTH_RANGE: 0x846E,
	  CULL_FACE_MODE: 0x0B45,
	  FRONT_FACE: 0x0B46,
	  DEPTH_RANGE: 0x0B70,
	  DEPTH_WRITEMASK: 0x0B72,
	  DEPTH_CLEAR_VALUE: 0x0B73,
	  DEPTH_FUNC: 0x0B74,
	  STENCIL_CLEAR_VALUE: 0x0B91,
	  STENCIL_FUNC: 0x0B92,
	  STENCIL_FAIL: 0x0B94,
	  STENCIL_PASS_DEPTH_FAIL: 0x0B95,
	  STENCIL_PASS_DEPTH_PASS: 0x0B96,
	  STENCIL_REF: 0x0B97,
	  STENCIL_VALUE_MASK: 0x0B93,
	  STENCIL_WRITEMASK: 0x0B98,
	  STENCIL_BACK_FUNC: 0x8800,
	  STENCIL_BACK_FAIL: 0x8801,
	  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
	  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
	  STENCIL_BACK_REF: 0x8CA3,
	  STENCIL_BACK_VALUE_MASK: 0x8CA4,
	  STENCIL_BACK_WRITEMASK: 0x8CA5,
	  VIEWPORT: 0x0BA2,
	  SCISSOR_BOX: 0x0C10,
	  COLOR_CLEAR_VALUE: 0x0C22,
	  COLOR_WRITEMASK: 0x0C23,
	  UNPACK_ALIGNMENT: 0x0CF5,
	  PACK_ALIGNMENT: 0x0D05,
	  MAX_TEXTURE_SIZE: 0x0D33,
	  MAX_VIEWPORT_DIMS: 0x0D3A,
	  SUBPIXEL_BITS: 0x0D50,
	  RED_BITS: 0x0D52,
	  GREEN_BITS: 0x0D53,
	  BLUE_BITS: 0x0D54,
	  ALPHA_BITS: 0x0D55,
	  DEPTH_BITS: 0x0D56,
	  STENCIL_BITS: 0x0D57,
	  POLYGON_OFFSET_UNITS: 0x2A00,
	  POLYGON_OFFSET_FACTOR: 0x8038,
	  TEXTURE_BINDING_2D: 0x8069,
	  SAMPLE_BUFFERS: 0x80A8,
	  SAMPLES: 0x80A9,
	  SAMPLE_COVERAGE_VALUE: 0x80AA,
	  SAMPLE_COVERAGE_INVERT: 0x80AB,
	  COMPRESSED_TEXTURE_FORMATS: 0x86A3,
	  VENDOR: 0x1F00,
	  RENDERER: 0x1F01,
	  VERSION: 0x1F02,
	  IMPLEMENTATION_COLOR_READ_TYPE: 0x8B9A,
	  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8B9B,
	  BROWSER_DEFAULT_WEBGL: 0x9244,
	  // Buffers
	  // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
	  // getBufferParameter().
	  STATIC_DRAW: 0x88E4,
	  STREAM_DRAW: 0x88E0,
	  DYNAMIC_DRAW: 0x88E8,
	  ARRAY_BUFFER: 0x8892,
	  ELEMENT_ARRAY_BUFFER: 0x8893,
	  BUFFER_SIZE: 0x8764,
	  BUFFER_USAGE: 0x8765,
	  // Vertex attributes
	  // Constants passed to getVertexAttrib().
	  CURRENT_VERTEX_ATTRIB: 0x8626,
	  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
	  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
	  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
	  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
	  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886A,
	  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
	  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889F,
	  // Culling
	  // Constants passed to cullFace().
	  CULL_FACE: 0x0B44,
	  FRONT: 0x0404,
	  BACK: 0x0405,
	  FRONT_AND_BACK: 0x0408,
	  // Enabling and disabling
	  // Constants passed to enable() or disable().
	  BLEND: 0x0BE2,
	  DEPTH_TEST: 0x0B71,
	  DITHER: 0x0BD0,
	  POLYGON_OFFSET_FILL: 0x8037,
	  SAMPLE_ALPHA_TO_COVERAGE: 0x809E,
	  SAMPLE_COVERAGE: 0x80A0,
	  SCISSOR_TEST: 0x0C11,
	  STENCIL_TEST: 0x0B90,
	  // Errors
	  // Constants returned from getError().
	  NO_ERROR: 0,
	  INVALID_ENUM: 0x0500,
	  INVALID_VALUE: 0x0501,
	  INVALID_OPERATION: 0x0502,
	  OUT_OF_MEMORY: 0x0505,
	  CONTEXT_LOST_WEBGL: 0x9242,
	  // Front face directions
	  // Constants passed to frontFace().
	  CW: 0x0900,
	  CCW: 0x0901,
	  // Hints
	  // Constants passed to hint()
	  DONT_CARE: 0x1100,
	  FASTEST: 0x1101,
	  NICEST: 0x1102,
	  GENERATE_MIPMAP_HINT: 0x8192,
	  // Data types
	  BYTE: 0x1400,
	  UNSIGNED_BYTE: 0x1401,
	  SHORT: 0x1402,
	  UNSIGNED_SHORT: 0x1403,
	  INT: 0x1404,
	  UNSIGNED_INT: 0x1405,
	  FLOAT: 0x1406,
	  // Pixel formats
	  DEPTH_COMPONENT: 0x1902,
	  ALPHA: 0x1906,
	  RGB: 0x1907,
	  RGBA: 0x1908,
	  LUMINANCE: 0x1909,
	  LUMINANCE_ALPHA: 0x190A,
	  // Pixel types
	  // UNSIGNED_BYTE: 0x1401,
	  UNSIGNED_SHORT_4_4_4_4: 0x8033,
	  UNSIGNED_SHORT_5_5_5_1: 0x8034,
	  UNSIGNED_SHORT_5_6_5: 0x8363,
	  // Shaders
	  // Constants passed to createShader() or getShaderParameter()
	  FRAGMENT_SHADER: 0x8B30,
	  VERTEX_SHADER: 0x8B31,
	  COMPILE_STATUS: 0x8B81,
	  DELETE_STATUS: 0x8B80,
	  LINK_STATUS: 0x8B82,
	  VALIDATE_STATUS: 0x8B83,
	  ATTACHED_SHADERS: 0x8B85,
	  ACTIVE_ATTRIBUTES: 0x8B89,
	  ACTIVE_UNIFORMS: 0x8B86,
	  MAX_VERTEX_ATTRIBS: 0x8869,
	  MAX_VERTEX_UNIFORM_VECTORS: 0x8DFB,
	  MAX_VARYING_VECTORS: 0x8DFC,
	  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8B4D,
	  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8B4C,
	  MAX_TEXTURE_IMAGE_UNITS: 0x8872,
	  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8DFD,
	  SHADER_TYPE: 0x8B4F,
	  SHADING_LANGUAGE_VERSION: 0x8B8C,
	  CURRENT_PROGRAM: 0x8B8D,
	  // Depth or stencil tests
	  // Constants passed to depthFunc() or stencilFunc().
	  NEVER: 0x0200,
	  ALWAYS: 0x0207,
	  LESS: 0x0201,
	  EQUAL: 0x0202,
	  LEQUAL: 0x0203,
	  GREATER: 0x0204,
	  GEQUAL: 0x0206,
	  NOTEQUAL: 0x0205,
	  // Stencil actions
	  // Constants passed to stencilOp().
	  KEEP: 0x1E00,
	  REPLACE: 0x1E01,
	  INCR: 0x1E02,
	  DECR: 0x1E03,
	  INVERT: 0x150A,
	  INCR_WRAP: 0x8507,
	  DECR_WRAP: 0x8508,
	  // Textures
	  // Constants passed to texParameteri(),
	  // texParameterf(), bindTexture(), texImage2D(), and others.
	  NEAREST: 0x2600,
	  LINEAR: 0x2601,
	  NEAREST_MIPMAP_NEAREST: 0x2700,
	  LINEAR_MIPMAP_NEAREST: 0x2701,
	  NEAREST_MIPMAP_LINEAR: 0x2702,
	  LINEAR_MIPMAP_LINEAR: 0x2703,
	  TEXTURE_MAG_FILTER: 0x2800,
	  TEXTURE_MIN_FILTER: 0x2801,
	  TEXTURE_WRAP_S: 0x2802,
	  TEXTURE_WRAP_T: 0x2803,
	  TEXTURE_2D: 0x0DE1,
	  TEXTURE: 0x1702,
	  TEXTURE_CUBE_MAP: 0x8513,
	  TEXTURE_BINDING_CUBE_MAP: 0x8514,
	  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
	  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
	  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
	  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
	  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
	  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851A,
	  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851C,
	  // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
	  TEXTURE0: 0x84C0,
	  ACTIVE_TEXTURE: 0x84E0,
	  REPEAT: 0x2901,
	  CLAMP_TO_EDGE: 0x812F,
	  MIRRORED_REPEAT: 0x8370,
	  // Emulation
	  TEXTURE_WIDTH: 0x1000,
	  TEXTURE_HEIGHT: 0x1001,
	  // Uniform types
	  FLOAT_VEC2: 0x8B50,
	  FLOAT_VEC3: 0x8B51,
	  FLOAT_VEC4: 0x8B52,
	  INT_VEC2: 0x8B53,
	  INT_VEC3: 0x8B54,
	  INT_VEC4: 0x8B55,
	  BOOL: 0x8B56,
	  BOOL_VEC2: 0x8B57,
	  BOOL_VEC3: 0x8B58,
	  BOOL_VEC4: 0x8B59,
	  FLOAT_MAT2: 0x8B5A,
	  FLOAT_MAT3: 0x8B5B,
	  FLOAT_MAT4: 0x8B5C,
	  SAMPLER_2D: 0x8B5E,
	  SAMPLER_CUBE: 0x8B60,
	  // Shader precision-specified types
	  LOW_FLOAT: 0x8DF0,
	  MEDIUM_FLOAT: 0x8DF1,
	  HIGH_FLOAT: 0x8DF2,
	  LOW_INT: 0x8DF3,
	  MEDIUM_INT: 0x8DF4,
	  HIGH_INT: 0x8DF5,
	  // Framebuffers and renderbuffers
	  FRAMEBUFFER: 0x8D40,
	  RENDERBUFFER: 0x8D41,
	  RGBA4: 0x8056,
	  RGB5_A1: 0x8057,
	  RGB565: 0x8D62,
	  DEPTH_COMPONENT16: 0x81A5,
	  STENCIL_INDEX: 0x1901,
	  STENCIL_INDEX8: 0x8D48,
	  DEPTH_STENCIL: 0x84F9,
	  RENDERBUFFER_WIDTH: 0x8D42,
	  RENDERBUFFER_HEIGHT: 0x8D43,
	  RENDERBUFFER_INTERNAL_FORMAT: 0x8D44,
	  RENDERBUFFER_RED_SIZE: 0x8D50,
	  RENDERBUFFER_GREEN_SIZE: 0x8D51,
	  RENDERBUFFER_BLUE_SIZE: 0x8D52,
	  RENDERBUFFER_ALPHA_SIZE: 0x8D53,
	  RENDERBUFFER_DEPTH_SIZE: 0x8D54,
	  RENDERBUFFER_STENCIL_SIZE: 0x8D55,
	  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8CD0,
	  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8CD1,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8CD2,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8CD3,
	  COLOR_ATTACHMENT0: 0x8CE0,
	  DEPTH_ATTACHMENT: 0x8D00,
	  STENCIL_ATTACHMENT: 0x8D20,
	  DEPTH_STENCIL_ATTACHMENT: 0x821A,
	  NONE: 0,
	  FRAMEBUFFER_COMPLETE: 0x8CD5,
	  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8CD6,
	  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8CD7,
	  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8CD9,
	  FRAMEBUFFER_UNSUPPORTED: 0x8CDD,
	  FRAMEBUFFER_BINDING: 0x8CA6,
	  RENDERBUFFER_BINDING: 0x8CA7,
	  READ_FRAMEBUFFER: 0x8CA8,
	  DRAW_FRAMEBUFFER: 0x8CA9,
	  MAX_RENDERBUFFER_SIZE: 0x84E8,
	  INVALID_FRAMEBUFFER_OPERATION: 0x0506,
	  // Pixel storage modes
	  // Constants passed to pixelStorei().
	  UNPACK_FLIP_Y_WEBGL: 0x9240,
	  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
	  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,
	  // /////////////////////////////////////////////////////
	  // Additional constants defined WebGL 2
	  // These constants are defined on the WebGL2RenderingContext interface.
	  // All WebGL 1 constants are also available in a WebGL 2 context.
	  // /////////////////////////////////////////////////////
	  // Getting GL parameter information
	  // Constants passed to getParameter()
	  // to specify what information to return.
	  READ_BUFFER: 0x0C02,
	  UNPACK_ROW_LENGTH: 0x0CF2,
	  UNPACK_SKIP_ROWS: 0x0CF3,
	  UNPACK_SKIP_PIXELS: 0x0CF4,
	  PACK_ROW_LENGTH: 0x0D02,
	  PACK_SKIP_ROWS: 0x0D03,
	  PACK_SKIP_PIXELS: 0x0D04,
	  TEXTURE_BINDING_3D: 0x806A,
	  UNPACK_SKIP_IMAGES: 0x806D,
	  UNPACK_IMAGE_HEIGHT: 0x806E,
	  MAX_3D_TEXTURE_SIZE: 0x8073,
	  MAX_ELEMENTS_VERTICES: 0x80E8,
	  MAX_ELEMENTS_INDICES: 0x80E9,
	  MAX_TEXTURE_LOD_BIAS: 0x84FD,
	  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8B49,
	  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8B4A,
	  MAX_ARRAY_TEXTURE_LAYERS: 0x88FF,
	  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
	  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
	  MAX_VARYING_COMPONENTS: 0x8B4B,
	  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8B8B,
	  RASTERIZER_DISCARD: 0x8C89,
	  VERTEX_ARRAY_BINDING: 0x85B5,
	  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
	  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
	  MAX_SERVER_WAIT_TIMEOUT: 0x9111,
	  MAX_ELEMENT_INDEX: 0x8D6B,
	  // Textures
	  // Constants passed to texParameteri(),
	  // texParameterf(), bindTexture(), texImage2D(), and others.
	  RED: 0x1903,
	  RGB8: 0x8051,
	  RGBA8: 0x8058,
	  RGB10_A2: 0x8059,
	  TEXTURE_3D: 0x806F,
	  TEXTURE_WRAP_R: 0x8072,
	  TEXTURE_MIN_LOD: 0x813A,
	  TEXTURE_MAX_LOD: 0x813B,
	  TEXTURE_BASE_LEVEL: 0x813C,
	  TEXTURE_MAX_LEVEL: 0x813D,
	  TEXTURE_COMPARE_MODE: 0x884C,
	  TEXTURE_COMPARE_FUNC: 0x884D,
	  SRGB: 0x8C40,
	  SRGB8: 0x8C41,
	  SRGB8_ALPHA8: 0x8C43,
	  COMPARE_REF_TO_TEXTURE: 0x884E,
	  RGBA32F: 0x8814,
	  RGB32F: 0x8815,
	  RGBA16F: 0x881A,
	  RGB16F: 0x881B,
	  TEXTURE_2D_ARRAY: 0x8C1A,
	  TEXTURE_BINDING_2D_ARRAY: 0x8C1D,
	  R11F_G11F_B10F: 0x8C3A,
	  RGB9_E5: 0x8C3D,
	  RGBA32UI: 0x8D70,
	  RGB32UI: 0x8D71,
	  RGBA16UI: 0x8D76,
	  RGB16UI: 0x8D77,
	  RGBA8UI: 0x8D7C,
	  RGB8UI: 0x8D7D,
	  RGBA32I: 0x8D82,
	  RGB32I: 0x8D83,
	  RGBA16I: 0x8D88,
	  RGB16I: 0x8D89,
	  RGBA8I: 0x8D8E,
	  RGB8I: 0x8D8F,
	  RED_INTEGER: 0x8D94,
	  RGB_INTEGER: 0x8D98,
	  RGBA_INTEGER: 0x8D99,
	  R8: 0x8229,
	  RG8: 0x822B,
	  R16F: 0x822D,
	  R32F: 0x822E,
	  RG16F: 0x822F,
	  RG32F: 0x8230,
	  R8I: 0x8231,
	  R8UI: 0x8232,
	  R16I: 0x8233,
	  R16UI: 0x8234,
	  R32I: 0x8235,
	  R32UI: 0x8236,
	  RG8I: 0x8237,
	  RG8UI: 0x8238,
	  RG16I: 0x8239,
	  RG16UI: 0x823A,
	  RG32I: 0x823B,
	  RG32UI: 0x823C,
	  R8_SNORM: 0x8F94,
	  RG8_SNORM: 0x8F95,
	  RGB8_SNORM: 0x8F96,
	  RGBA8_SNORM: 0x8F97,
	  RGB10_A2UI: 0x906F,

	  /* covered by extension
	  COMPRESSED_R11_EAC : 0x9270,
	  COMPRESSED_SIGNED_R11_EAC: 0x9271,
	  COMPRESSED_RG11_EAC: 0x9272,
	  COMPRESSED_SIGNED_RG11_EAC : 0x9273,
	  COMPRESSED_RGB8_ETC2 : 0x9274,
	  COMPRESSED_SRGB8_ETC2: 0x9275,
	  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 : 0x9276,
	  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC : 0x9277,
	  COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
	  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : 0x9279,
	  */
	  TEXTURE_IMMUTABLE_FORMAT: 0x912F,
	  TEXTURE_IMMUTABLE_LEVELS: 0x82DF,
	  // Pixel types
	  UNSIGNED_INT_2_10_10_10_REV: 0x8368,
	  UNSIGNED_INT_10F_11F_11F_REV: 0x8C3B,
	  UNSIGNED_INT_5_9_9_9_REV: 0x8C3E,
	  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8DAD,
	  UNSIGNED_INT_24_8: 0x84FA,
	  HALF_FLOAT: 0x140B,
	  RG: 0x8227,
	  RG_INTEGER: 0x8228,
	  INT_2_10_10_10_REV: 0x8D9F,
	  // Queries
	  CURRENT_QUERY: 0x8865,
	  QUERY_RESULT: 0x8866,
	  QUERY_RESULT_AVAILABLE: 0x8867,
	  ANY_SAMPLES_PASSED: 0x8C2F,
	  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8D6A,
	  // Draw buffers
	  MAX_DRAW_BUFFERS: 0x8824,
	  DRAW_BUFFER0: 0x8825,
	  DRAW_BUFFER1: 0x8826,
	  DRAW_BUFFER2: 0x8827,
	  DRAW_BUFFER3: 0x8828,
	  DRAW_BUFFER4: 0x8829,
	  DRAW_BUFFER5: 0x882A,
	  DRAW_BUFFER6: 0x882B,
	  DRAW_BUFFER7: 0x882C,
	  DRAW_BUFFER8: 0x882D,
	  DRAW_BUFFER9: 0x882E,
	  DRAW_BUFFER10: 0x882F,
	  DRAW_BUFFER11: 0x8830,
	  DRAW_BUFFER12: 0x8831,
	  DRAW_BUFFER13: 0x8832,
	  DRAW_BUFFER14: 0x8833,
	  DRAW_BUFFER15: 0x8834,
	  MAX_COLOR_ATTACHMENTS: 0x8CDF,
	  COLOR_ATTACHMENT1: 0x8CE1,
	  COLOR_ATTACHMENT2: 0x8CE2,
	  COLOR_ATTACHMENT3: 0x8CE3,
	  COLOR_ATTACHMENT4: 0x8CE4,
	  COLOR_ATTACHMENT5: 0x8CE5,
	  COLOR_ATTACHMENT6: 0x8CE6,
	  COLOR_ATTACHMENT7: 0x8CE7,
	  COLOR_ATTACHMENT8: 0x8CE8,
	  COLOR_ATTACHMENT9: 0x8CE9,
	  COLOR_ATTACHMENT10: 0x8CEA,
	  COLOR_ATTACHMENT11: 0x8CEB,
	  COLOR_ATTACHMENT12: 0x8CEC,
	  COLOR_ATTACHMENT13: 0x8CED,
	  COLOR_ATTACHMENT14: 0x8CEE,
	  COLOR_ATTACHMENT15: 0x8CEF,
	  // Samplers
	  SAMPLER_3D: 0x8B5F,
	  SAMPLER_2D_SHADOW: 0x8B62,
	  SAMPLER_2D_ARRAY: 0x8DC1,
	  SAMPLER_2D_ARRAY_SHADOW: 0x8DC4,
	  SAMPLER_CUBE_SHADOW: 0x8DC5,
	  INT_SAMPLER_2D: 0x8DCA,
	  INT_SAMPLER_3D: 0x8DCB,
	  INT_SAMPLER_CUBE: 0x8DCC,
	  INT_SAMPLER_2D_ARRAY: 0x8DCF,
	  UNSIGNED_INT_SAMPLER_2D: 0x8DD2,
	  UNSIGNED_INT_SAMPLER_3D: 0x8DD3,
	  UNSIGNED_INT_SAMPLER_CUBE: 0x8DD4,
	  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8DD7,
	  MAX_SAMPLES: 0x8D57,
	  SAMPLER_BINDING: 0x8919,
	  // Buffers
	  PIXEL_PACK_BUFFER: 0x88EB,
	  PIXEL_UNPACK_BUFFER: 0x88EC,
	  PIXEL_PACK_BUFFER_BINDING: 0x88ED,
	  PIXEL_UNPACK_BUFFER_BINDING: 0x88EF,
	  COPY_READ_BUFFER: 0x8F36,
	  COPY_WRITE_BUFFER: 0x8F37,
	  COPY_READ_BUFFER_BINDING: 0x8F36,
	  COPY_WRITE_BUFFER_BINDING: 0x8F37,
	  // Data types
	  FLOAT_MAT2x3: 0x8B65,
	  FLOAT_MAT2x4: 0x8B66,
	  FLOAT_MAT3x2: 0x8B67,
	  FLOAT_MAT3x4: 0x8B68,
	  FLOAT_MAT4x2: 0x8B69,
	  FLOAT_MAT4x3: 0x8B6A,
	  UNSIGNED_INT_VEC2: 0x8DC6,
	  UNSIGNED_INT_VEC3: 0x8DC7,
	  UNSIGNED_INT_VEC4: 0x8DC8,
	  UNSIGNED_NORMALIZED: 0x8C17,
	  SIGNED_NORMALIZED: 0x8F9C,
	  // Vertex attributes
	  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88FD,
	  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88FE,
	  // Transform feedback
	  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8C7F,
	  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8C80,
	  TRANSFORM_FEEDBACK_VARYINGS: 0x8C83,
	  TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,
	  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8C85,
	  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,
	  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,
	  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,
	  INTERLEAVED_ATTRIBS: 0x8C8C,
	  SEPARATE_ATTRIBS: 0x8C8D,
	  TRANSFORM_FEEDBACK_BUFFER: 0x8C8E,
	  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8C8F,
	  TRANSFORM_FEEDBACK: 0x8E22,
	  TRANSFORM_FEEDBACK_PAUSED: 0x8E23,
	  TRANSFORM_FEEDBACK_ACTIVE: 0x8E24,
	  TRANSFORM_FEEDBACK_BINDING: 0x8E25,
	  // Framebuffers and renderbuffers
	  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
	  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
	  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
	  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
	  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
	  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
	  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
	  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
	  FRAMEBUFFER_DEFAULT: 0x8218,
	  // DEPTH_STENCIL_ATTACHMENT : 0x821A,
	  // DEPTH_STENCIL: 0x84F9,
	  DEPTH24_STENCIL8: 0x88F0,
	  DRAW_FRAMEBUFFER_BINDING: 0x8CA6,
	  READ_FRAMEBUFFER_BINDING: 0x8CAA,
	  RENDERBUFFER_SAMPLES: 0x8CAB,
	  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8CD4,
	  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8D56,
	  // Uniforms
	  UNIFORM_BUFFER: 0x8A11,
	  UNIFORM_BUFFER_BINDING: 0x8A28,
	  UNIFORM_BUFFER_START: 0x8A29,
	  UNIFORM_BUFFER_SIZE: 0x8A2A,
	  MAX_VERTEX_UNIFORM_BLOCKS: 0x8A2B,
	  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8A2D,
	  MAX_COMBINED_UNIFORM_BLOCKS: 0x8A2E,
	  MAX_UNIFORM_BUFFER_BINDINGS: 0x8A2F,
	  MAX_UNIFORM_BLOCK_SIZE: 0x8A30,
	  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8A31,
	  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8A33,
	  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8A34,
	  ACTIVE_UNIFORM_BLOCKS: 0x8A36,
	  UNIFORM_TYPE: 0x8A37,
	  UNIFORM_SIZE: 0x8A38,
	  UNIFORM_BLOCK_INDEX: 0x8A3A,
	  UNIFORM_OFFSET: 0x8A3B,
	  UNIFORM_ARRAY_STRIDE: 0x8A3C,
	  UNIFORM_MATRIX_STRIDE: 0x8A3D,
	  UNIFORM_IS_ROW_MAJOR: 0x8A3E,
	  UNIFORM_BLOCK_BINDING: 0x8A3F,
	  UNIFORM_BLOCK_DATA_SIZE: 0x8A40,
	  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8A42,
	  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8A43,
	  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8A44,
	  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8A46,
	  // Sync objects
	  OBJECT_TYPE: 0x9112,
	  SYNC_CONDITION: 0x9113,
	  SYNC_STATUS: 0x9114,
	  SYNC_FLAGS: 0x9115,
	  SYNC_FENCE: 0x9116,
	  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
	  UNSIGNALED: 0x9118,
	  SIGNALED: 0x9119,
	  ALREADY_SIGNALED: 0x911A,
	  TIMEOUT_EXPIRED: 0x911B,
	  CONDITION_SATISFIED: 0x911C,
	  WAIT_FAILED: 0x911D,
	  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,
	  // Miscellaneous constants
	  COLOR: 0x1800,
	  DEPTH: 0x1801,
	  STENCIL: 0x1802,
	  MIN: 0x8007,
	  MAX: 0x8008,
	  DEPTH_COMPONENT24: 0x81A6,
	  STREAM_READ: 0x88E1,
	  STREAM_COPY: 0x88E2,
	  STATIC_READ: 0x88E5,
	  STATIC_COPY: 0x88E6,
	  DYNAMIC_READ: 0x88E9,
	  DYNAMIC_COPY: 0x88EA,
	  DEPTH_COMPONENT32F: 0x8CAC,
	  DEPTH32F_STENCIL8: 0x8CAD,
	  INVALID_INDEX: 0xFFFFFFFF,
	  TIMEOUT_IGNORED: -1,
	  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247,
	  // Constants defined in WebGL extensions
	  // ANGLE_instanced_arrays
	  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88FE,
	  // WEBGL_debug_renderer_info
	  UNMASKED_VENDOR_WEBGL: 0x9245,
	  UNMASKED_RENDERER_WEBGL: 0x9246,
	  // EXT_texture_filter_anisotropic
	  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84FF,
	  TEXTURE_MAX_ANISOTROPY_EXT: 0x84FE,
	  // WEBGL_compressed_texture_s3tc
	  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83F0,
	  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83F1,
	  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83F2,
	  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83F3,
	  // WEBGL_compressed_texture_es3
	  COMPRESSED_R11_EAC: 0x9270,
	  COMPRESSED_SIGNED_R11_EAC: 0x9271,
	  COMPRESSED_RG11_EAC: 0x9272,
	  COMPRESSED_SIGNED_RG11_EAC: 0x9273,
	  COMPRESSED_RGB8_ETC2: 0x9274,
	  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,
	  COMPRESSED_SRGB8_ETC2: 0x9276,
	  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,
	  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,
	  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,
	  // WEBGL_compressed_texture_pvrtc
	  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8C00,
	  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8C02,
	  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8C01,
	  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8C03,
	  // WEBGL_compressed_texture_etc1
	  COMPRESSED_RGB_ETC1_WEBGL: 0x8D64,
	  // WEBGL_compressed_texture_atc
	  COMPRESSED_RGB_ATC_WEBGL: 0x8C92,
	  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8C92,
	  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87EE,
	  // WEBGL_depth_texture
	  UNSIGNED_INT_24_8_WEBGL: 0x84FA,
	  // OES_texture_half_float
	  HALF_FLOAT_OES: 0x8D61,
	  // WEBGL_color_buffer_float
	  RGBA32F_EXT: 0x8814,
	  RGB32F_EXT: 0x8815,
	  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
	  UNSIGNED_NORMALIZED_EXT: 0x8C17,
	  // EXT_blend_minmax
	  MIN_EXT: 0x8007,
	  MAX_EXT: 0x8008,
	  // EXT_sRGB
	  SRGB_EXT: 0x8C40,
	  SRGB_ALPHA_EXT: 0x8C42,
	  SRGB8_ALPHA8_EXT: 0x8C43,
	  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,
	  // OES_standard_derivatives
	  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8B8B,
	  // WEBGL_draw_buffers
	  COLOR_ATTACHMENT0_WEBGL: 0x8CE0,
	  COLOR_ATTACHMENT1_WEBGL: 0x8CE1,
	  COLOR_ATTACHMENT2_WEBGL: 0x8CE2,
	  COLOR_ATTACHMENT3_WEBGL: 0x8CE3,
	  COLOR_ATTACHMENT4_WEBGL: 0x8CE4,
	  COLOR_ATTACHMENT5_WEBGL: 0x8CE5,
	  COLOR_ATTACHMENT6_WEBGL: 0x8CE6,
	  COLOR_ATTACHMENT7_WEBGL: 0x8CE7,
	  COLOR_ATTACHMENT8_WEBGL: 0x8CE8,
	  COLOR_ATTACHMENT9_WEBGL: 0x8CE9,
	  COLOR_ATTACHMENT10_WEBGL: 0x8CEA,
	  COLOR_ATTACHMENT11_WEBGL: 0x8CEB,
	  COLOR_ATTACHMENT12_WEBGL: 0x8CEC,
	  COLOR_ATTACHMENT13_WEBGL: 0x8CED,
	  COLOR_ATTACHMENT14_WEBGL: 0x8CEE,
	  COLOR_ATTACHMENT15_WEBGL: 0x8CEF,
	  DRAW_BUFFER0_WEBGL: 0x8825,
	  DRAW_BUFFER1_WEBGL: 0x8826,
	  DRAW_BUFFER2_WEBGL: 0x8827,
	  DRAW_BUFFER3_WEBGL: 0x8828,
	  DRAW_BUFFER4_WEBGL: 0x8829,
	  DRAW_BUFFER5_WEBGL: 0x882A,
	  DRAW_BUFFER6_WEBGL: 0x882B,
	  DRAW_BUFFER7_WEBGL: 0x882C,
	  DRAW_BUFFER8_WEBGL: 0x882D,
	  DRAW_BUFFER9_WEBGL: 0x882E,
	  DRAW_BUFFER10_WEBGL: 0x882F,
	  DRAW_BUFFER11_WEBGL: 0x8830,
	  DRAW_BUFFER12_WEBGL: 0x8831,
	  DRAW_BUFFER13_WEBGL: 0x8832,
	  DRAW_BUFFER14_WEBGL: 0x8833,
	  DRAW_BUFFER15_WEBGL: 0x8834,
	  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8CDF,
	  MAX_DRAW_BUFFERS_WEBGL: 0x8824,
	  // OES_vertex_array_object
	  VERTEX_ARRAY_BINDING_OES: 0x85B5,
	  // EXT_disjoint_timer_query
	  QUERY_COUNTER_BITS_EXT: 0x8864,
	  CURRENT_QUERY_EXT: 0x8865,
	  QUERY_RESULT_EXT: 0x8866,
	  QUERY_RESULT_AVAILABLE_EXT: 0x8867,
	  TIME_ELAPSED_EXT: 0x88BF,
	  TIMESTAMP_EXT: 0x8E28,
	  GPU_DISJOINT_EXT: 0x8FBB // A Boolean indicating whether or not the GPU performed any disjoint operation.

	};
	//# sourceMappingURL=constants.js.map

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.isWebGL = isWebGL;
	exports.isWebGL2 = isWebGL2;
	exports.assertWebGLContext = assertWebGLContext;
	exports.assertWebGL2Context = assertWebGL2Context;
	exports.setContextDefaults = setContextDefaults;
	exports.createGLContext = createGLContext;
	exports.destroyGLContext = destroyGLContext;
	exports.resizeGLContext = resizeGLContext;
	exports.pollGLContext = pollGLContext;
	exports.ERR_WEBGL2 = exports.ERR_WEBGL = exports.ERR_CONTEXT = void 0;

	var _webglUtils = __webpack_require__(48);

	var _createHeadlessContext = __webpack_require__(61);

	var _createCanvas = __webpack_require__(62);

	var _createBrowserContext = __webpack_require__(69);

	var _trackContextState = _interopRequireDefault(__webpack_require__(70));

	var _debugContext = __webpack_require__(74);

	var _contextLimits = __webpack_require__(75);

	var _queryManager = _interopRequireDefault(__webpack_require__(76));

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	// Heuristic testing of contexts (to indentify debug wrappers around gl contexts)
	var GL_ARRAY_BUFFER = 0x8892;
	var GL_TEXTURE_BINDING_3D = 0x806A;
	var ERR_CONTEXT = 'Invalid WebGLRenderingContext';
	exports.ERR_CONTEXT = ERR_CONTEXT;
	var ERR_WEBGL = ERR_CONTEXT;
	exports.ERR_WEBGL = ERR_WEBGL;
	var ERR_WEBGL2 = 'Requires WebGL2';
	exports.ERR_WEBGL2 = ERR_WEBGL2;

	function isWebGL(gl) {
	  return Boolean(gl && (_instanceof(gl, _webglUtils.WebGLRenderingContext) || gl.ARRAY_BUFFER === GL_ARRAY_BUFFER));
	}

	function isWebGL2(gl) {
	  return Boolean(gl && (_instanceof(gl, _webglUtils.WebGL2RenderingContext) || gl.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D));
	}

	function assertWebGLContext(gl) {
	  // Need to handle debug context
	  (0, _assert.default)(isWebGL(gl), ERR_CONTEXT);
	}

	function assertWebGL2Context(gl) {
	  // Need to handle debug context
	  (0, _assert.default)(isWebGL2(gl), ERR_WEBGL2);
	}

	var contextDefaults = {
	  // COMMON CONTEXT PARAMETERS
	  // Attempt to allocate WebGL2 context
	  webgl2: true,
	  // Attempt to create a WebGL2 context (false to force webgl1)
	  webgl1: true,
	  // Attempt to create a WebGL1 context (false to fail if webgl2 not available)
	  throwOnFailure: true,
	  manageState: true,
	  // BROWSER CONTEXT PARAMETERS
	  canvas: null,
	  // A canvas element or a canvas string id
	  debug: false,
	  // Instrument context (at the expense of performance)
	  // HEADLESS CONTEXT PARAMETERS
	  width: 800,
	  // width are height are only used by headless gl
	  height: 600 // WEBGL/HEADLESS CONTEXT PARAMETERS
	  // Remaining options are passed through to context creator

	};
	/*
	 * Change default context creation parameters.
	 * Main use case is regression test suite.
	 */

	function setContextDefaults() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  Object.assign(contextDefaults, {
	    width: 1,
	    height: 1
	  }, opts);
	}
	/*
	 * Creates a context giving access to the WebGL API
	 */

	/* eslint-disable complexity, max-statements */


	function createGLContext() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  opts = Object.assign({}, contextDefaults, opts);
	  var _opts = opts,
	      canvas = _opts.canvas,
	      width = _opts.width,
	      height = _opts.height,
	      throwOnError = _opts.throwOnError,
	      manageState = _opts.manageState,
	      debug = _opts.debug; // Error reporting function, enables exceptions to be disabled

	  function onError(message) {
	    if (throwOnError) {
	      throw new Error(message);
	    } // log.log(0, message)();


	    return null;
	  }

	  var gl;

	  if (_utils.isBrowser) {
	    // Get or create a canvas
	    var targetCanvas = (0, _createCanvas.getCanvas)({
	      canvas: canvas,
	      width: width,
	      height: height,
	      onError: onError
	    }); // Create a WebGL context in the canvas

	    gl = (0, _createBrowserContext.createBrowserContext)({
	      canvas: targetCanvas,
	      opts: opts
	    });
	  } else {
	    // Create a headless-gl context under Node.js
	    gl = (0, _createHeadlessContext.createHeadlessContext)({
	      width: width,
	      height: height,
	      opts: opts,
	      onError: onError
	    });
	  }

	  if (!gl) {
	    return null;
	  } // Install context state tracking


	  if (manageState) {
	    (0, _trackContextState.default)(gl, {
	      copyState: false,
	      log: function log() {
	        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	          args[_key] = arguments[_key];
	        }

	        return _utils.log.log.apply(_utils.log, [1].concat(args))();
	      }
	    });
	  } // Add debug instrumentation to the context


	  if (_utils.isBrowser && debug) {
	    gl = (0, _debugContext.makeDebugContext)(gl, {
	      debug: debug
	    }); // Debug forces log level to at least 1

	    _utils.log.priority = Math.max(_utils.log.priority, 1); // Log some debug info about the context
	  } // Log context information


	  logInfo(gl); // Add to seer integration

	  return gl;
	}

	function destroyGLContext(gl) {
	  // TODO - Remove from seer integration
	  // TODO - Unregister any tracking/polyfills
	  // There is no way to delete browser based context
	  // Destroy headless gl context
	  var ext = gl.getExtension('STACKGL_destroy_context');

	  if (ext) {
	    ext.destroy();
	  }
	}
	/**
	 * Resize the canvas' drawing buffer.
	 *
	 * Can match the canvas CSS size, and optionally also consider devicePixelRatio
	 * Can be called every frame
	 *
	 * Regardless of size, the drawing buffer will always be scaled to the viewport, but
	 * for best visual results, usually set to either:
	 *  canvas CSS width x canvas CSS height
	 *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
	 * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
	 *
	 * resizeGLContext(gl, {width, height, useDevicePixels})
	 */


	function resizeGLContext(gl) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  // Resize browser context
	  if (gl.canvas) {
	    /* global window */
	    var devicePixelRatio = opts.useDevicePixels ? window.devicePixelRatio || 1 : 1;
	    var width = "width" in opts ? opts.width : gl.canvas.clientWidth;
	    var height = "height" in opts ? opts.height : gl.canvas.clientHeight;
	    gl.canvas.width = width * devicePixelRatio;
	    gl.canvas.height = height * devicePixelRatio;
	    return;
	  } // Resize headless gl context


	  var ext = gl.getExtension('STACKGL_resize_drawingbuffer');

	  if (ext && "width" in opts && "height" in opts) {
	    ext.resize(opts.width, opts.height);
	  }
	} // POLLING FOR PENDING QUERIES
	// Calling this function checks all pending queries for completion


	function pollGLContext(gl) {
	  _queryManager.default.poll(gl);
	} // HELPER METHODS


	function logInfo(gl) {
	  var webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';
	  var info = (0, _contextLimits.glGetDebugInfo)(gl);
	  var driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
	  var debug = gl.debug ? ' debug' : '';

	  _utils.log.once(0, "".concat(webGL).concat(debug, " context ").concat(driver))();
	}
	//# sourceMappingURL=context.js.map

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createHeadlessContext = createHeadlessContext;
	exports.isWebglAvailable = exports.headlessGL = void 0;

	var _isBrowser = _interopRequireDefault(__webpack_require__(51));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable quotes, no-console */

	/* global console */
	var ERR_HEADLESSGL_LOAD = "WebGL not available in Node.js, install using \"npm install gl\".";
	var ERR_HEADLESSGL_NOT_AVAILABLE = 'Failed to create WebGL context in Node.js, headless gl not available';
	var ERR_HEADLESSGL_FAILED = 'Failed to create WebGL context in Node.js, headless gl returned null';
	var headlessGL = null;
	exports.headlessGL = headlessGL;

	if (!_isBrowser.default) {
	  try {
	    exports.headlessGL = headlessGL = module.require('gl');
	  } catch (error) {
	    console.error();
	    console.error("".concat(ERR_HEADLESSGL_LOAD, "\n").concat(error.message));
	  }
	}

	var isWebglAvailable = _isBrowser.default || headlessGL; // Create headless gl context (for running under Node.js)

	exports.isWebglAvailable = isWebglAvailable;

	function createHeadlessContext(_ref) {
	  var width = _ref.width,
	      height = _ref.height,
	      opts = _ref.opts,
	      onError = _ref.onError;
	  var webgl1 = opts.webgl1,
	      webgl2 = opts.webgl2;

	  if (webgl2 && !webgl1) {
	    return onError('headless-gl does not support WebGL2');
	  }

	  if (!headlessGL) {
	    return onError(ERR_HEADLESSGL_NOT_AVAILABLE);
	  }

	  var gl = headlessGL(width, height, opts);

	  if (!gl) {
	    return onError(ERR_HEADLESSGL_FAILED);
	  }

	  return gl;
	}
	//# sourceMappingURL=create-headless-context.js.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPageLoadPromise = getPageLoadPromise;
	exports.createCanvas = createCanvas;
	exports.getCanvas = getCanvas;
	exports.pageLoadPromise = void 0;

	var _utils = __webpack_require__(63);

	// Resizing a webgl canvas

	/* global window, document */
	var isPage = _utils.isBrowser && typeof document !== 'undefined';
	var isPageLoaded = isPage && document.readyState === 'complete';
	var pageLoadPromise = isPage ? new Promise(function (resolve, reject) {
	  if (isPageLoaded) {
	    resolve(document);
	    return;
	  }

	  window.onload = function () {
	    isPageLoaded = true;
	    resolve(document);
	  };
	}) : Promise.resolve({});
	/**
	 * Returns a promise that resolves when the page is loaded
	 * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted
	 * @return {Promise} - resolves when the page is loaded
	 */

	exports.pageLoadPromise = pageLoadPromise;

	function getPageLoadPromise() {
	  return pageLoadPromise;
	}
	/**
	 * Create a canvas
	 * @param {Number} width - set to 100%
	 * @param {Number} height - set to 100%
	 */


	function createCanvas(_ref) {
	  var _ref$width = _ref.width,
	      width = _ref$width === void 0 ? 800 : _ref$width,
	      _ref$height = _ref.height,
	      height = _ref$height === void 0 ? 600 : _ref$height,
	      _ref$id = _ref.id,
	      id = _ref$id === void 0 ? 'gl-canvas' : _ref$id,
	      _ref$insert = _ref.insert,
	      insert = _ref$insert === void 0 ? true : _ref$insert;
	  var canvas = document.createElement('canvas');
	  canvas.id = id;
	  canvas.style.width = Number.isFinite(width) ? "".concat(width, "px") : '100%';
	  canvas.style.height = Number.isFinite(height) ? "".concat(height, "px") : '100%'; // add the canvas to the body element once the page has loaded

	  if (insert) {
	    getPageLoadPromise().then(function (document) {
	      var body = document.body;
	      body.insertBefore(canvas, body.firstChild);
	    });
	  }

	  return canvas;
	}

	function getCanvas(_ref2) {
	  var canvas = _ref2.canvas,
	      width = _ref2.width,
	      height = _ref2.height,
	      _ref2$onError = _ref2.onError,
	      onError = _ref2$onError === void 0 ? function () {} : _ref2$onError;
	  var targetCanvas;

	  if (typeof canvas === 'string') {
	    if (!isPageLoaded) {
	      onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
	    }

	    targetCanvas = document.getElementById(canvas);
	  } else if (canvas) {
	    targetCanvas = canvas;
	  } else {
	    targetCanvas = createCanvas({
	      id: 'lumagl-canvas',
	      width: width,
	      height: height,
	      onError: onError
	    });
	  }

	  return targetCanvas;
	}
	//# sourceMappingURL=create-canvas.js.map

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "isBrowser", {
	  enumerable: true,
	  get: function get() {
	    return _isBrowser.default;
	  }
	});
	Object.defineProperty(exports, "isOldIE", {
	  enumerable: true,
	  get: function get() {
	    return _isOldIe.default;
	  }
	});
	Object.defineProperty(exports, "promisify", {
	  enumerable: true,
	  get: function get() {
	    return _promiseUtils.promisify;
	  }
	});
	Object.defineProperty(exports, "uid", {
	  enumerable: true,
	  get: function get() {
	    return _utils.uid;
	  }
	});
	Object.defineProperty(exports, "isPowerOfTwo", {
	  enumerable: true,
	  get: function get() {
	    return _utils.isPowerOfTwo;
	  }
	});
	Object.defineProperty(exports, "isObjectEmpty", {
	  enumerable: true,
	  get: function get() {
	    return _utils.isObjectEmpty;
	  }
	});
	Object.defineProperty(exports, "log", {
	  enumerable: true,
	  get: function get() {
	    return _log.default;
	  }
	});
	Object.defineProperty(exports, "formatValue", {
	  enumerable: true,
	  get: function get() {
	    return _formatValue.formatValue;
	  }
	});
	Object.defineProperty(exports, "assert", {
	  enumerable: true,
	  get: function get() {
	    return _assert.default;
	  }
	});

	var _isBrowser = _interopRequireDefault(__webpack_require__(51));

	var _isOldIe = _interopRequireDefault(__webpack_require__(64));

	var _promiseUtils = __webpack_require__(65);

	var _utils = __webpack_require__(66);

	var _log = _interopRequireDefault(__webpack_require__(67));

	var _formatValue = __webpack_require__(68);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = isOldIE;

	var _globals = __webpack_require__(50);

	// opts allows user agent to be overridden for testing
	function isOldIE() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var navigator = _globals.window.navigator || {};
	  var userAgent = opts.userAgent || navigator.userAgent; // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)
	  // have much better web standards support.

	  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
	  var isTrident = userAgent.indexOf('Trident/') !== -1;
	  return isMSIE || isTrident;
	}
	//# sourceMappingURL=is-old-ie.js.map

/***/ }),
/* 65 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.promisify = promisify;

	/**
	 * Converts a function that accepts a node style (err, result) callback
	 * as the last argument into a function that takes the same arguments
	 * and returns a promise that resolves or rejects with the values provided
	 * by the original callback
	 * @param {Function} func - function to wrap
	 * @return {Function} promisified function
	 */

	/* eslint-disable no-try-catch */
	function promisify(func) {
	  return function promisifiedFunction() {
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    return new Promise(function (resolve, reject) {
	      function callback(error, data) {
	        try {
	          if (error) {
	            reject(error);
	          } else {
	            resolve(data);
	          }
	        } catch (e) {
	          reject(e);
	        }
	      }

	      func.apply(void 0, args.concat([callback]));
	    });
	  };
	}
	/* eslint-enable no-try-catch */
	//# sourceMappingURL=promise-utils.js.map

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.uid = uid;
	exports.isPowerOfTwo = isPowerOfTwo;
	exports.isObjectEmpty = isObjectEmpty;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var uidCounters = {};
	/**
	 * Returns a UID.
	 * @param {String} id= - Identifier base name
	 * @return {number} uid
	 **/

	function uid() {
	  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'id';
	  uidCounters[id] = uidCounters[id] || 1;
	  var count = uidCounters[id]++;
	  return "".concat(id, "-").concat(count);
	}
	/**
	 * Verifies if a given number is power of two or not.
	 * @param {object} n - The number to check.
	 * @return {Array} Returns true if the given number is power of 2, false otherwise.
	 **/


	function isPowerOfTwo(n) {
	  (0, _assert.default)(typeof n === 'number', 'Input must be a number');
	  return n && (n & n - 1) === 0;
	} // Returns true if given object is empty, false otherwise.


	function isObjectEmpty(obj) {
	  var isEmpty = true;
	  /* eslint-disable no-unused-vars  */

	  for (var key in obj) {
	    isEmpty = false;
	    break;
	  }
	  /* eslint-enable no-unused-vars  */


	  return isEmpty;
	}
	//# sourceMappingURL=utils.js.map

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _probe = __webpack_require__(32);

	var _default = new _probe.Log({
	  id: 'luma'
	}).enable();

	exports.default = _default;
	//# sourceMappingURL=log.js.map

/***/ }),
/* 68 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.formatValue = formatValue;

	// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts

	/* eslint-disable no-console */
	function formatArrayValue(v, opts) {
	  var _opts$maxElts = opts.maxElts,
	      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
	      _opts$size = opts.size,
	      size = _opts$size === void 0 ? 1 : _opts$size;
	  var string = '[';

	  for (var i = 0; i < v.length && i < maxElts; ++i) {
	    if (i > 0) {
	      string += ",".concat(i % size === 0 ? ' ' : '');
	    }

	    string += formatValue(v[i], opts);
	  }

	  var terminator = v.length > maxElts ? '...' : ']';
	  return "".concat(string).concat(terminator);
	}

	function formatValue(v) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var EPSILON = 1e-16;
	  var _opts$isInteger = opts.isInteger,
	      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

	  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
	    return formatArrayValue(v, opts);
	  }

	  if (!Number.isFinite(v)) {
	    return String(v);
	  }

	  if (Math.abs(v) < EPSILON) {
	    return isInteger ? '0' : '0.';
	  }

	  if (isInteger) {
	    return v.toFixed(0);
	  }

	  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
	    return v.toFixed(0);
	  }

	  var string = v.toPrecision(2);
	  var decimal = string.indexOf('.0');
	  return decimal === string.length - 2 ? string.slice(0, -1) : string;
	}
	//# sourceMappingURL=format-value.js.map

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createBrowserContext = createBrowserContext;
	exports.trackContextCreation = trackContextCreation;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	/* global HTMLCanvasElement, WebGLRenderingContext */

	/**
	 * Create a WebGL context for a canvas
	 * Note calling this multiple time on the same canvas does return the same context
	 */
	function createBrowserContext(_ref) {
	  var canvas = _ref.canvas,
	      _ref$opts = _ref.opts,
	      opts = _ref$opts === void 0 ? {} : _ref$opts,
	      _ref$onError = _ref.onError,
	      onError = _ref$onError === void 0 ? function (message) {
	    return null;
	  } : _ref$onError;

	  // See if we can extract any extra information about why context creation failed
	  function onContextCreationError(error) {
	    onError("WebGL context: ".concat(error.statusMessage || 'Unknown error'));
	  }

	  canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
	  var _opts$webgl = opts.webgl1,
	      webgl1 = _opts$webgl === void 0 ? true : _opts$webgl,
	      _opts$webgl2 = opts.webgl2,
	      webgl2 = _opts$webgl2 === void 0 ? true : _opts$webgl2;
	  var gl = null; // Prefer webgl2 over webgl1, prefer conformant over experimental

	  if (webgl2) {
	    gl = gl || canvas.getContext('webgl2', opts);
	    gl = gl || canvas.getContext('experimental-webgl2', opts);
	  }

	  if (webgl1) {
	    gl = gl || canvas.getContext('webgl', opts);
	    gl = gl || canvas.getContext('experimental-webgl', opts);
	  }

	  canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);

	  if (!gl) {
	    return onError("Failed to create ".concat(webgl2 && !webgl1 ? 'WebGL2' : 'WebGL', " context"));
	  }

	  return gl;
	}
	/**
	 * Installs a spy on Canvas.getContext
	 * calls the provided callback with the {context}
	 */


	function trackContextCreation(_ref2) {
	  var _ref2$onContextCreate = _ref2.onContextCreate,
	      onContextCreate = _ref2$onContextCreate === void 0 ? function () {
	    return null;
	  } : _ref2$onContextCreate,
	      _ref2$onContextCreate2 = _ref2.onContextCreated,
	      onContextCreated = _ref2$onContextCreate2 === void 0 ? function () {} : _ref2$onContextCreate2;
	  (0, _assert.default)(onContextCreate || onContextCreated);

	  if (typeof HTMLCanvasElement !== 'undefined') {
	    var getContext = HTMLCanvasElement.prototype.getContext;

	    HTMLCanvasElement.prototype.getContext = function getContextSpy(type, opts) {
	      // Let intercepter create context
	      var context;

	      if (type === 'webgl') {
	        context = onContextCreate({
	          canvas: this,
	          type: type,
	          opts: opts,
	          getContext: getContext.bind(this)
	        });
	      } // If not, create context


	      context = context || getContext.call(this, type, opts); // Report it created

	      if (_instanceof(context, WebGLRenderingContext)) {
	        onContextCreated({
	          canvas: this,
	          context: context,
	          type: type,
	          opts: opts
	        });
	      }

	      return context;
	    };
	  }
	}
	//# sourceMappingURL=create-browser-context.js.map

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = trackContextState;
	exports.pushContextState = pushContextState;
	exports.popContextState = popContextState;
	exports.GL_STATE_SETTERS = exports.deepEqual = exports.clone = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _setParameters = __webpack_require__(71);

	var _polyfillContext = _interopRequireDefault(__webpack_require__(72));

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var clone = function clone(x) {
	  return Array.isArray(x) || ArrayBuffer.isView(x) ? x.slice() : x;
	};

	exports.clone = clone;

	var deepEqual = function deepEqual(x, y) {
	  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
	  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

	  if (isArrayX && isArrayY && x.length === y.length) {
	    for (var i = 0; i < x.length; ++i) {
	      if (x[i] !== y[i]) {
	        return false;
	      }
	    }

	    return true;
	  }

	  return x === y;
	}; // interceptors for WEBGL FUNCTIONS that set WebGLRenderingContext state
	// These "setters" map functions to gl parameters


	exports.deepEqual = deepEqual;
	var GL_STATE_SETTERS = {
	  // GENERIC SETTERS
	  enable: function enable(update, cap) {
	    return update(_defineProperty({}, cap, true));
	  },
	  disable: function disable(update, cap) {
	    return update(_defineProperty({}, cap, false));
	  },
	  pixelStorei: function pixelStorei(update, pname, param) {
	    return update(_defineProperty({}, pname, param));
	  },
	  hint: function hint(update, pname, _hint) {
	    return update(_defineProperty({}, pname, _hint));
	  },
	  // SPECIFIC SETTERS
	  bindFramebuffer: function bindFramebuffer(update, target, fb) {
	    var _update5;

	    switch (target) {
	      case _constants.default.FRAMEBUFFER:
	        return update((_update5 = {}, _defineProperty(_update5, _constants.default.DRAW_FRAMEBUFFER_BINDING, fb), _defineProperty(_update5, _constants.default.READ_FRAMEBUFFER_BINDING, fb), _update5));

	      case _constants.default.DRAW_FRAMEBUFFER:
	        return update(_defineProperty({}, _constants.default.DRAW_FRAMEBUFFER_BINDING, fb));

	      case _constants.default.READ_FRAMEBUFFER:
	        return update(_defineProperty({}, _constants.default.READ_FRAMEBUFFER_BINDING, fb));

	      default:
	        return null;
	    }
	  },
	  blendColor: function blendColor(update, r, g, b, a) {
	    return update(_defineProperty({}, _constants.default.BLEND_COLOR, new Float32Array([r, g, b, a])));
	  },
	  blendEquation: function blendEquation(update, mode) {
	    var _update9;

	    return update((_update9 = {}, _defineProperty(_update9, _constants.default.BLEND_EQUATION_RGB, mode), _defineProperty(_update9, _constants.default.BLEND_EQUATION_ALPHA, mode), _update9));
	  },
	  blendEquationSeparate: function blendEquationSeparate(update, modeRGB, modeAlpha) {
	    var _update10;

	    return update((_update10 = {}, _defineProperty(_update10, _constants.default.BLEND_EQUATION_RGB, modeRGB), _defineProperty(_update10, _constants.default.BLEND_EQUATION_ALPHA, modeAlpha), _update10));
	  },
	  blendFunc: function blendFunc(update, src, dst) {
	    var _update11;

	    return update((_update11 = {}, _defineProperty(_update11, _constants.default.BLEND_SRC_RGB, src), _defineProperty(_update11, _constants.default.BLEND_DST_RGB, dst), _defineProperty(_update11, _constants.default.BLEND_SRC_ALPHA, src), _defineProperty(_update11, _constants.default.BLEND_DST_ALPHA, dst), _update11));
	  },
	  blendFuncSeparate: function blendFuncSeparate(update, srcRGB, dstRGB, srcAlpha, dstAlpha) {
	    var _update12;

	    return update((_update12 = {}, _defineProperty(_update12, _constants.default.BLEND_SRC_RGB, srcRGB), _defineProperty(_update12, _constants.default.BLEND_DST_RGB, dstRGB), _defineProperty(_update12, _constants.default.BLEND_SRC_ALPHA, srcAlpha), _defineProperty(_update12, _constants.default.BLEND_DST_ALPHA, dstAlpha), _update12));
	  },
	  clearColor: function clearColor(update, r, g, b, a) {
	    return update(_defineProperty({}, _constants.default.COLOR_CLEAR_VALUE, new Float32Array([r, g, b, a])));
	  },
	  clearDepth: function clearDepth(update, depth) {
	    return update(_defineProperty({}, _constants.default.DEPTH_CLEAR_VALUE, depth));
	  },
	  clearStencil: function clearStencil(update, s) {
	    return update(_defineProperty({}, _constants.default.STENCIL_CLEAR_VALUE, s));
	  },
	  colorMask: function colorMask(update, r, g, b, a) {
	    return update(_defineProperty({}, _constants.default.COLOR_WRITEMASK, [r, g, b, a]));
	  },
	  cullFace: function cullFace(update, mode) {
	    return update(_defineProperty({}, _constants.default.CULL_FACE_MODE, mode));
	  },
	  depthFunc: function depthFunc(update, func) {
	    return update(_defineProperty({}, _constants.default.DEPTH_FUNC, func));
	  },
	  depthRange: function depthRange(update, zNear, zFar) {
	    return update(_defineProperty({}, _constants.default.DEPTH_RANGE, new Float32Array([zNear, zFar])));
	  },
	  depthMask: function depthMask(update, mask) {
	    return update(_defineProperty({}, _constants.default.DEPTH_WRITEMASK, mask));
	  },
	  frontFace: function frontFace(update, face) {
	    return update(_defineProperty({}, _constants.default.FRONT_FACE, face));
	  },
	  lineWidth: function lineWidth(update, width) {
	    return update(_defineProperty({}, _constants.default.LINE_WIDTH, width));
	  },
	  polygonOffset: function polygonOffset(update, factor, units) {
	    var _update23;

	    return update((_update23 = {}, _defineProperty(_update23, _constants.default.POLYGON_OFFSET_FACTOR, factor), _defineProperty(_update23, _constants.default.POLYGON_OFFSET_UNITS, units), _update23));
	  },
	  sampleCoverage: function sampleCoverage(update, value, invert) {
	    var _update24;

	    return update((_update24 = {}, _defineProperty(_update24, _constants.default.SAMPLE_COVERAGE_VALUE, value), _defineProperty(_update24, _constants.default.SAMPLE_COVERAGE_INVERT, invert), _update24));
	  },
	  scissor: function scissor(update, x, y, width, height) {
	    return update(_defineProperty({}, _constants.default.SCISSOR_BOX, new Int32Array([x, y, width, height])));
	  },
	  stencilMask: function stencilMask(update, mask) {
	    var _update26;

	    return update((_update26 = {}, _defineProperty(_update26, _constants.default.STENCIL_WRITEMASK, mask), _defineProperty(_update26, _constants.default.STENCIL_BACK_WRITEMASK, mask), _update26));
	  },
	  stencilMaskSeparate: function stencilMaskSeparate(update, face, mask) {
	    return update(_defineProperty({}, face === _constants.default.FRONT ? _constants.default.STENCIL_WRITEMASK : _constants.default.STENCIL_BACK_WRITEMASK, mask));
	  },
	  stencilFunc: function stencilFunc(update, func, ref, mask) {
	    var _update28;

	    return update((_update28 = {}, _defineProperty(_update28, _constants.default.STENCIL_FUNC, func), _defineProperty(_update28, _constants.default.STENCIL_REF, ref), _defineProperty(_update28, _constants.default.STENCIL_VALUE_MASK, mask), _defineProperty(_update28, _constants.default.STENCIL_BACK_FUNC, func), _defineProperty(_update28, _constants.default.STENCIL_BACK_REF, ref), _defineProperty(_update28, _constants.default.STENCIL_BACK_VALUE_MASK, mask), _update28));
	  },
	  stencilFuncSeparate: function stencilFuncSeparate(update, face, func, ref, mask) {
	    var _update29;

	    return update((_update29 = {}, _defineProperty(_update29, face === _constants.default.FRONT ? _constants.default.STENCIL_FUNC : _constants.default.STENCIL_BACK_FUNC, func), _defineProperty(_update29, face === _constants.default.FRONT ? _constants.default.STENCIL_REF : _constants.default.STENCIL_BACK_REF, ref), _defineProperty(_update29, face === _constants.default.FRONT ? _constants.default.STENCIL_VALUE_MASK : _constants.default.STENCIL_BACK_VALUE_MASK, mask), _update29));
	  },
	  stencilOp: function stencilOp(update, fail, zfail, zpass) {
	    var _update30;

	    return update((_update30 = {}, _defineProperty(_update30, _constants.default.STENCIL_FAIL, fail), _defineProperty(_update30, _constants.default.STENCIL_PASS_DEPTH_FAIL, zfail), _defineProperty(_update30, _constants.default.STENCIL_PASS_DEPTH_PASS, zpass), _defineProperty(_update30, _constants.default.STENCIL_BACK_FAIL, fail), _defineProperty(_update30, _constants.default.STENCIL_BACK_PASS_DEPTH_FAIL, zfail), _defineProperty(_update30, _constants.default.STENCIL_BACK_PASS_DEPTH_PASS, zpass), _update30));
	  },
	  stencilOpSeparate: function stencilOpSeparate(update, face, fail, zfail, zpass) {
	    var _update31;

	    return update((_update31 = {}, _defineProperty(_update31, face === _constants.default.FRONT ? _constants.default.STENCIL_FAIL : _constants.default.STENCIL_BACK_FAIL, fail), _defineProperty(_update31, face === _constants.default.FRONT ? _constants.default.STENCIL_PASS_DEPTH_FAIL : _constants.default.STENCIL_BACK_PASS_DEPTH_FAIL, zfail), _defineProperty(_update31, face === _constants.default.FRONT ? _constants.default.STENCIL_PASS_DEPTH_PASS : _constants.default.STENCIL_BACK_PASS_DEPTH_PASS, zpass), _update31));
	  },
	  viewport: function viewport(update, x, y, width, height) {
	    return update(_defineProperty({}, _constants.default.VIEWPORT, new Int32Array([x, y, width, height])));
	  }
	}; // HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT
	// Overrides a WebGLRenderingContext state "getter" function
	// to return values directly from cache

	exports.GL_STATE_SETTERS = GL_STATE_SETTERS;

	function installGetterOverride(gl, functionName) {
	  // Get the original function from the WebGLRenderingContext
	  var originalGetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called

	  gl[functionName] = function () {
	    var pname = arguments.length <= 0 ? undefined : arguments[0]; // WebGL limits are not prepopulated in the cache, we must
	    // query first time. They are all primitive (single value)

	    if (!(pname in gl.state.cache)) {
	      gl.state.cache[pname] = originalGetterFunc.apply(void 0, arguments);
	    } // Optionally call the original function to do a "hard" query from the WebGLRenderingContext


	    return gl.state.enable ? // Call the getter the params so that it can e.g. serve from a cache
	    gl.state.cache[pname] : // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
	    originalGetterFunc.apply(void 0, arguments);
	  }; // Set the name of this anonymous function to help in debugging and profiling


	  Object.defineProperty(gl[functionName], 'name', {
	    value: "".concat(functionName, "-from-cache"),
	    configurable: false
	  });
	} // Overrides a WebGLRenderingContext state "setter" function
	// to call a setter spy before the actual setter. Allows us to keep a cache
	// updated with a copy of the WebGL context state.


	function installSetterSpy(gl, functionName, setter) {
	  // Get the original function from the WebGLRenderingContext
	  var originalSetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called

	  gl[functionName] = function () {
	    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
	      params[_key] = arguments[_key];
	    }

	    // Update the value
	    // Call the setter with the state cache and the params so that it can store the parameters
	    var _setter = setter.apply(void 0, [gl.state._updateCache].concat(params)),
	        valueChanged = _setter.valueChanged,
	        oldValue = _setter.oldValue; // Call the original WebGLRenderingContext func to make sure the context actually gets updated


	    if (valueChanged) {
	      var _gl$state;

	      (_gl$state = gl.state).log.apply(_gl$state, ["gl.".concat(functionName)].concat(params)); // eslint-disable-line


	      originalSetterFunc.apply(void 0, params);
	    } // Note: if the original function fails to set the value, our state cache will be bad
	    // No solution for this at the moment, but assuming that this is unlikely to be a real problem
	    // We could call the setter after the originalSetterFunc. Concern is that this would
	    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions


	    return oldValue;
	  }; // Set the name of this anonymous function to help in debugging and profiling


	  Object.defineProperty(gl[functionName], 'name', {
	    value: "".concat(functionName, "-to-cache"),
	    configurable: false
	  });
	} // HELPER CLASS - GLState

	/* eslint-disable no-shadow */


	var GLState =
	/*#__PURE__*/
	function () {
	  function GLState(gl) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref$copyState = _ref.copyState,
	        copyState = _ref$copyState === void 0 ? false : _ref$copyState,
	        _ref$log = _ref.log,
	        log = _ref$log === void 0 ? function () {} : _ref$log;

	    _classCallCheck(this, GLState);

	    this.gl = gl;
	    this.stateStack = [];
	    this.enable = true;
	    this.cache = copyState ? (0, _setParameters.getParameters)(gl) : Object.assign({}, _setParameters.GL_PARAMETER_DEFAULTS);
	    this.log = log;
	    this._updateCache = this._updateCache.bind(this);
	    Object.seal(this);
	  }

	  _createClass(GLState, [{
	    key: "push",
	    value: function push() {
	      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      this.stateStack.push({});
	    }
	  }, {
	    key: "pop",
	    value: function pop() {
	      (0, _assert.default)(this.stateStack.length > 0); // Use the saved values in the state stack to restore parameters

	      var oldValues = this.stateStack[this.stateStack.length - 1];
	      (0, _setParameters.setParameters)(this.gl, oldValues, this.cache); // Don't pop until we have reset parameters (to make sure other "stack frames" are not affected)

	      this.stateStack.pop();
	    } // interceptor for context set functions - update our cache and our stack
	    // values (Object) - the key values for this setter

	  }, {
	    key: "_updateCache",
	    value: function _updateCache(values) {
	      var valueChanged = false;
	      var oldValue; // = undefined

	      var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

	      for (var key in values) {
	        (0, _assert.default)(key !== undefined); // Check that value hasn't already been shadowed

	        if (!deepEqual(values[key], this.cache[key])) {
	          valueChanged = true;
	          oldValue = this.cache[key]; // First, save current value being shadowed
	          // If a state stack frame is active, save the current parameter values for pop
	          // but first check that value hasn't already been shadowed and saved

	          if (oldValues && !(key in oldValues)) {
	            oldValues[key] = this.cache[key];
	          } // Save current value being shadowed


	          this.cache[key] = values[key];
	        }
	      }

	      return {
	        valueChanged: valueChanged,
	        oldValue: oldValue
	      };
	    }
	  }]);

	  return GLState;
	}(); // PUBLIC API

	/**
	 * Initialize WebGL state caching on a context
	 * can be called multiple times to enable/disable
	 * @param {WebGLRenderingContext} - context
	 */
	// After calling this function, context state will be cached
	// gl.state.push() and gl.state.pop() will be available for saving,
	// temporarily modifying, and then restoring state.


	function trackContextState(gl) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref2$enable = _ref2.enable,
	      enable = _ref2$enable === void 0 ? true : _ref2$enable,
	      copyState = _ref2.copyState;

	  (0, _assert.default)(copyState !== undefined);

	  if (!gl.state) {
	    (0, _polyfillContext.default)(gl); // Create a state cache

	    gl.state = new GLState(gl, {
	      copyState: copyState,
	      enable: enable
	    }); // intercept all setter functions in the table

	    for (var key in GL_STATE_SETTERS) {
	      var setter = GL_STATE_SETTERS[key];
	      installSetterSpy(gl, key, setter);
	    } // intercept all getter functions in the table


	    installGetterOverride(gl, 'getParameter');
	    installGetterOverride(gl, 'isEnabled');
	  }

	  gl.state.enable = enable;
	  return gl;
	}

	function pushContextState(gl) {
	  if (!gl.state) {
	    trackContextState(gl, {
	      copyState: false
	    });
	  }

	  gl.state.push();
	}

	function popContextState(gl) {
	  (0, _assert.default)(gl.state);
	  gl.state.pop();
	}
	//# sourceMappingURL=track-context-state.js.map

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setParameter = setParameter;
	exports.setParameters = setParameters;
	exports.getParameter = getParameter;
	exports.getParameters = getParameters;
	exports.getDefaultParameters = getDefaultParameters;
	exports.resetParameters = resetParameters;
	exports.getModifiedParameters = getModifiedParameters;
	exports.GL_PARAMETER_GETTERS = exports.GL_PARAMETER_SETTERS = exports.GL_PARAMETER_DEFAULTS = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _GL_PARAMETER_DEFAULT, _GL_PARAMETER_SETTERS, _GL_PARAMETER_GETTERS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// DEFAULT SETTINGS - FOR FAST CACHE INITIALIZATION AND CONTEXT RESETS
	var GL_PARAMETER_DEFAULTS = (_GL_PARAMETER_DEFAULT = {}, _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_COLOR, new Float32Array([0, 0, 0, 0])), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_EQUATION_RGB, _constants.default.FUNC_ADD), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_EQUATION_ALPHA, _constants.default.FUNC_ADD), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_SRC_RGB, _constants.default.ONE), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_DST_RGB, _constants.default.ZERO), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_SRC_ALPHA, _constants.default.ONE), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.BLEND_DST_ALPHA, _constants.default.ZERO), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.COLOR_CLEAR_VALUE, new Float32Array([0, 0, 0, 0])), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.COLOR_WRITEMASK, [true, true, true, true]), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.CULL_FACE, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.CULL_FACE_MODE, _constants.default.BACK), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.DEPTH_TEST, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.DEPTH_CLEAR_VALUE, 1), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.DEPTH_FUNC, _constants.default.LESS), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.DEPTH_RANGE, new Float32Array([0, 1])), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.DEPTH_WRITEMASK, true), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.DITHER, true), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.FRAMEBUFFER_BINDING, null), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.FRONT_FACE, _constants.default.CCW), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.GENERATE_MIPMAP_HINT, _constants.default.DONT_CARE), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.LINE_WIDTH, 1), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.POLYGON_OFFSET_FILL, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.POLYGON_OFFSET_FACTOR, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.POLYGON_OFFSET_UNITS, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.SAMPLE_COVERAGE_VALUE, 1.0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.SAMPLE_COVERAGE_INVERT, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.SCISSOR_TEST, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.SCISSOR_BOX, new Int32Array([0, 0, 1024, 1024])), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_TEST, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_CLEAR_VALUE, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_WRITEMASK, 0xFFFFFFFF), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_WRITEMASK, 0xFFFFFFFF), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_FUNC, _constants.default.ALWAYS), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_REF, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_VALUE_MASK, 0xFFFFFFFF), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_FUNC, _constants.default.ALWAYS), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_REF, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_VALUE_MASK, 0xFFFFFFFF), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_FAIL, _constants.default.KEEP), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_PASS_DEPTH_FAIL, _constants.default.KEEP), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_PASS_DEPTH_PASS, _constants.default.KEEP), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_FAIL, _constants.default.KEEP), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_PASS_DEPTH_FAIL, _constants.default.KEEP), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.STENCIL_BACK_PASS_DEPTH_PASS, _constants.default.KEEP), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.VIEWPORT, new Int32Array([0, 0, 1024, 1024])), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.PACK_ALIGNMENT, 4), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_ALIGNMENT, 4), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_FLIP_Y_WEBGL, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_COLORSPACE_CONVERSION_WEBGL, _constants.default.BROWSER_DEFAULT_WEBGL), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.FRAGMENT_SHADER_DERIVATIVE_HINT, _constants.default.DONT_CARE), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.READ_FRAMEBUFFER_BINDING, null), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.RASTERIZER_DISCARD, false), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.PACK_ROW_LENGTH, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.PACK_SKIP_PIXELS, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.PACK_SKIP_ROWS, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_ROW_LENGTH, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_IMAGE_HEIGHT, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_SKIP_PIXELS, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_SKIP_ROWS, 0), _defineProperty(_GL_PARAMETER_DEFAULT, _constants.default.UNPACK_SKIP_IMAGES, 0), _GL_PARAMETER_DEFAULT); // SETTER TABLES - ENABLES SETTING ANY PARAMETER WITH A COMMON API

	exports.GL_PARAMETER_DEFAULTS = GL_PARAMETER_DEFAULTS;

	var enable = function enable(gl, value, key) {
	  return value ? gl.enable(key) : gl.disable(key);
	};

	var hint = function hint(gl, value, key) {
	  return gl.hint(key, value);
	};

	var pixelStorei = function pixelStorei(gl, value, key) {
	  return gl.pixelStorei(key, value);
	};

	var drawFramebuffer = function drawFramebuffer(gl, value) {
	  var target = (0, _webglUtils.isWebGL2)(gl) ? _constants.default.DRAW_FRAMEBUFFER : _constants.default.FRAMEBUFFER;
	  return gl.bindFramebuffer(target, value);
	};

	var readFramebuffer = function readFramebuffer(gl, value) {
	  return gl.bindFramebuffer(_constants.default.READ_FRAMEBUFFER, value);
	}; // Map from WebGL parameter names to corresponding WebGL setter functions
	// WegGL constants are read by parameter names, but set by function names
	// NOTE: When value type is a string, it will be handled by 'COMPOSITE_GL_PARAMETER_SETTERS'


	var GL_PARAMETER_SETTERS = (_GL_PARAMETER_SETTERS = {}, _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_COLOR, function (gl, value) {
	  return gl.blendColor.apply(gl, _toConsumableArray(value));
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_EQUATION_RGB, 'blendEquation'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_EQUATION_ALPHA, 'blendEquation'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_SRC_RGB, 'blendFunc'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_DST_RGB, 'blendFunc'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_SRC_ALPHA, 'blendFunc'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.BLEND_DST_ALPHA, 'blendFunc'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.COLOR_CLEAR_VALUE, function (gl, value) {
	  return gl.clearColor.apply(gl, _toConsumableArray(value));
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.COLOR_WRITEMASK, function (gl, value) {
	  return gl.colorMask.apply(gl, _toConsumableArray(value));
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.CULL_FACE, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.CULL_FACE_MODE, function (gl, value) {
	  return gl.cullFace(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.DEPTH_TEST, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.DEPTH_CLEAR_VALUE, function (gl, value) {
	  return gl.clearDepth(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.DEPTH_FUNC, function (gl, value) {
	  return gl.depthFunc(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.DEPTH_RANGE, function (gl, value) {
	  return gl.depthRange.apply(gl, _toConsumableArray(value));
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.DEPTH_WRITEMASK, function (gl, value) {
	  return gl.depthMask(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.DITHER, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.FRAGMENT_SHADER_DERIVATIVE_HINT, hint), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.FRAMEBUFFER_BINDING, drawFramebuffer), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.FRONT_FACE, function (gl, value) {
	  return gl.frontFace(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.GENERATE_MIPMAP_HINT, hint), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.LINE_WIDTH, function (gl, value) {
	  return gl.lineWidth(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.POLYGON_OFFSET_FILL, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.POLYGON_OFFSET_FACTOR, 'polygonOffset'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.POLYGON_OFFSET_UNITS, 'polygonOffset'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.RASTERIZER_DISCARD, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.SAMPLE_COVERAGE_VALUE, 'sampleCoverage'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.SAMPLE_COVERAGE_INVERT, 'sampleCoverage'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.SCISSOR_TEST, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.SCISSOR_BOX, function (gl, value) {
	  return gl.scissor.apply(gl, _toConsumableArray(value));
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_TEST, enable), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_CLEAR_VALUE, function (gl, value) {
	  return gl.clearStencil(value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_WRITEMASK, function (gl, value) {
	  return gl.stencilMaskSeparate(_constants.default.FRONT, value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_WRITEMASK, function (gl, value) {
	  return gl.stencilMaskSeparate(_constants.default.BACK, value);
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_FUNC, 'stencilFuncFront'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_REF, 'stencilFuncFront'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_VALUE_MASK, 'stencilFuncFront'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_FUNC, 'stencilFuncBack'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_REF, 'stencilFuncBack'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_VALUE_MASK, 'stencilFuncBack'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_FAIL, 'stencilOpFront'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_PASS_DEPTH_FAIL, 'stencilOpFront'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_PASS_DEPTH_PASS, 'stencilOpFront'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_FAIL, 'stencilOpBack'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_PASS_DEPTH_FAIL, 'stencilOpBack'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.STENCIL_BACK_PASS_DEPTH_PASS, 'stencilOpBack'), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.VIEWPORT, function (gl, value) {
	  return gl.viewport.apply(gl, _toConsumableArray(value));
	}), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.PACK_ALIGNMENT, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_ALIGNMENT, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_FLIP_Y_WEBGL, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_COLORSPACE_CONVERSION_WEBGL, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.PACK_ROW_LENGTH, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.PACK_SKIP_PIXELS, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.PACK_SKIP_ROWS, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.READ_FRAMEBUFFER_BINDING, readFramebuffer), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_ROW_LENGTH, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_IMAGE_HEIGHT, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_SKIP_PIXELS, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_SKIP_ROWS, pixelStorei), _defineProperty(_GL_PARAMETER_SETTERS, _constants.default.UNPACK_SKIP_IMAGES, pixelStorei), _GL_PARAMETER_SETTERS); // COMPOSITE_WEBGL_PARAMETER_

	exports.GL_PARAMETER_SETTERS = GL_PARAMETER_SETTERS;
	var COMPOSITE_GL_PARAMETER_SETTERS = {
	  blendEquation: function blendEquation(gl, values) {
	    return gl.blendEquationSeparate(values[_constants.default.BLEND_EQUATION_RGB], values[_constants.default.BLEND_EQUATION_ALPHA]);
	  },
	  blendFunc: function blendFunc(gl, values) {
	    return gl.blendFuncSeparate(values[_constants.default.BLEND_SRC_RGB], values[_constants.default.BLEND_DST_RGB], values[_constants.default.BLEND_SRC_ALPHA], values[_constants.default.BLEND_DST_ALPHA]);
	  },
	  polygonOffset: function polygonOffset(gl, values) {
	    return gl.polygonOffset(values[_constants.default.POLYGON_OFFSET_FACTOR], values[_constants.default.POLYGON_OFFSET_UNITS]);
	  },
	  sampleCoverage: function sampleCoverage(gl, values) {
	    return gl.sampleCoverage(values[_constants.default.SAMPLE_COVERAGE_VALUE], values[_constants.default.SAMPLE_COVERAGE_INVERT]);
	  },
	  stencilFuncFront: function stencilFuncFront(gl, values) {
	    return gl.stencilFuncSeparate(_constants.default.FRONT, values[_constants.default.STENCIL_FUNC], values[_constants.default.STENCIL_REF], values[_constants.default.STENCIL_VALUE_MASK]);
	  },
	  stencilFuncBack: function stencilFuncBack(gl, values) {
	    return gl.stencilFuncSeparate(_constants.default.BACK, values[_constants.default.STENCIL_BACK_FUNC], values[_constants.default.STENCIL_BACK_REF], values[_constants.default.STENCIL_BACK_VALUE_MASK]);
	  },
	  stencilOpFront: function stencilOpFront(gl, values) {
	    return gl.stencilOpSeparate(_constants.default.FRONT, values[_constants.default.STENCIL_FAIL], values[_constants.default.STENCIL_PASS_DEPTH_FAIL], values[_constants.default.STENCIL_PASS_DEPTH_PASS]);
	  },
	  stencilOpBack: function stencilOpBack(gl, values) {
	    return gl.stencilOpSeparate(_constants.default.BACK, values[_constants.default.STENCIL_BACK_FAIL], values[_constants.default.STENCIL_BACK_PASS_DEPTH_FAIL], values[_constants.default.STENCIL_BACK_PASS_DEPTH_PASS]);
	  }
	}; // GETTER TABLE - FOR READING OUT AN ENTIRE CONTEXT

	var isEnabled = function isEnabled(gl, key) {
	  return gl.isEnabled(key);
	}; // Exceptions for any keys that cannot be queried by gl.getParameters


	var GL_PARAMETER_GETTERS = (_GL_PARAMETER_GETTERS = {}, _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.BLEND, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.CULL_FACE, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.DEPTH_TEST, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.DITHER, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.POLYGON_OFFSET_FILL, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.SAMPLE_ALPHA_TO_COVERAGE, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.SAMPLE_COVERAGE, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.SCISSOR_TEST, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.STENCIL_TEST, isEnabled), _defineProperty(_GL_PARAMETER_GETTERS, _constants.default.RASTERIZER_DISCARD, isEnabled), _GL_PARAMETER_GETTERS); // HELPER METHODS

	exports.GL_PARAMETER_GETTERS = GL_PARAMETER_GETTERS;

	var deepArrayEqual = function deepArrayEqual(x, y) {
	  if (x === y) {
	    return true;
	  }

	  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
	  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);

	  if (isArrayX && isArrayY && x.length === y.length) {
	    for (var i = 0; i < x.length; ++i) {
	      if (x[i] !== y[i]) {
	        return false;
	      }
	    }

	    return true;
	  }

	  return false;
	}; // PUBLIC METHODS
	// Sets any single GL parameter regardless of function (gl.getParameter/gl.isEnabled...)
	// Returns the previous value
	// Note: limited to parameter values


	function setParameter(gl, key, value) {
	  var getter = GL_PARAMETER_GETTERS[key];
	  var prevValue = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
	  var setter = GL_PARAMETER_SETTERS[key];
	  (0, _assert.default)(typeof setter === 'function');
	  setter(gl, value, Number(key));
	  return prevValue;
	} // Sets any GL parameter regardless of function (gl.blendMode, ...)
	// Note: requires a `cache` object to be set on the context (gl.state.cache)
	// This object is used to fill in any missing values for composite setter functions


	function setParameters(gl, values) {
	  var compositeSetters = {}; // HANDLE PRIMITIVE SETTERS (and make note of any composite setters)

	  for (var key in values) {
	    var glConstant = Number(key);
	    var setter = GL_PARAMETER_SETTERS[key];

	    if (setter) {
	      // Composite setters should only be called once, so save them
	      if (typeof setter === 'string') {
	        compositeSetters[setter] = true;
	      } else {
	        // if (gl[glConstant] !== undefined) {
	        // TODO - added above check since this is being called on WebGL2 values in WebGL1...
	        // TODO - deep equal on values? only call setter if value has changed?
	        // NOTE - the setter will automatically update this.state
	        setter(gl, values[key], glConstant);
	      }
	    }
	  } // HANDLE COMPOSITE SETTERS
	  // NOTE: any non-provided values needed by composite setters are filled in from state cache
	  // The cache parameter is automatically retrieved from the context
	  // This depends on `trackContextState`, which is technically a "circular" dependency.
	  // But it is too inconvenient to always require a cache parameter here.
	  // This is the ONLY external dependency in this module/


	  var cache = gl.state && gl.state.cache;

	  if (cache) {
	    var mergedValues = Object.assign({}, cache, values);

	    for (var _key in compositeSetters) {
	      // TODO - avoid calling composite setters if values have not changed.
	      var compositeSetter = COMPOSITE_GL_PARAMETER_SETTERS[_key]; // Note - if `trackContextState` has been called,
	      // the setter will automatically update this.state.cache

	      compositeSetter(gl, mergedValues);
	    }
	  } // Add a log for the else case?

	} // Queries any single GL parameter regardless of function (gl.getParameter/gl.isEnabled...)


	function getParameter(gl, key) {
	  var getter = GL_PARAMETER_GETTERS[key];
	  return getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
	} // Copies the state from a context (gl.getParameter should not be overriden)
	// Reads the entire WebGL state from a context
	// Caveat: This generates a huge amount of synchronous driver roundtrips and should be
	// considered a very slow operation, to be used only if/when a context already manipulated
	// by external code needs to be synchronized for the first time
	// @return {Object} - a newly created map, with values keyed by GL parameters


	function getParameters(gl, parameters) {
	  // default to querying all parameters
	  parameters = parameters || GL_PARAMETER_DEFAULTS; // support both arrays of parameters and objects (keys represent parameters)

	  var parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
	  var state = {};
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var key = _step.value;
	      state[key] = getParameter(gl, key);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return state;
	}

	function getDefaultParameters(gl) {
	  // TODO - Query GL.VIEWPORT and GL.SCISSOR_BOX since these are dynamic
	  return Object.assign({}, GL_PARAMETER_DEFAULTS, {// TODO: For viewport and scissor default values are set at the time of
	    // context creation based on canvas size, we can query them here but it will
	    // not match with what we have in GL_PARAMETER_DEFAULTS table, we should revisit.
	    // [GL.VIEWPORT]: gl.constructor.prototype.getParameter.call(gl, GL.VIEWPORT),
	    // [GL.SCISSOR_BOX]: gl.constructor.prototype.getParameter.call(gl, GL.SCISSOR_BOX)
	  });
	} // Reset all parameters to a pure context state


	function resetParameters(gl) {
	  setParameters(gl, getDefaultParameters(gl));
	} // Get all parameters that have been modified from a pure context state


	function getModifiedParameters(gl) {
	  var values = getParameters(GL_PARAMETER_DEFAULTS);
	  var modified = {};

	  for (var key in GL_PARAMETER_DEFAULTS) {
	    if (!deepArrayEqual(values[key], GL_PARAMETER_DEFAULTS[key])) {
	      modified[key] = values[key];
	    }
	  }

	  return modified;
	}
	//# sourceMappingURL=set-parameters.js.map

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = polyfillContext;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _polyfillGetParameter = __webpack_require__(73);

	var _WEBGL_CONTEXT_POLYFI;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var OES_vertex_array_object = 'OES_vertex_array_object';
	var ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
	var WEBGL_draw_buffers = 'WEBGL_draw_buffers';
	var EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
	var EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
	var EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
	var ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension'; // Return true if WebGL2 context

	function isWebGL2(gl) {
	  var GL_TEXTURE_BINDING_3D = 0x806A;
	  return gl && gl.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D;
	} // Return object with webgl2 flag and an extension


	function getExtensionData(gl, extension) {
	  return {
	    webgl2: isWebGL2(gl),
	    ext: gl.getExtension(extension)
	  };
	} // function mapExtensionConstant(gl, constant) {
	//   switch (constant) {
	//   case ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES: return GL.FRAGMENT_SHADER_DERIVATIVE_HINT;
	//   }
	// }


	var WEBGL_CONTEXT_POLYFILLS = (_WEBGL_CONTEXT_POLYFI = {}, _defineProperty(_WEBGL_CONTEXT_POLYFI, OES_vertex_array_object, {
	  meta: {
	    suffix: 'OES'
	  },
	  // NEW METHODS
	  createVertexArray: function createVertexArray() {
	    (0, _assert.default)(false, ERR_VAO_NOT_SUPPORTED);
	  },
	  deleteVertexArray: function deleteVertexArray() {},
	  bindVertexArray: function bindVertexArray() {},
	  isVertexArray: function isVertexArray() {
	    return false;
	  }
	}), _defineProperty(_WEBGL_CONTEXT_POLYFI, ANGLE_instanced_arrays, {
	  meta: {
	    suffix: 'ANGLE' // constants: {
	    //   VERTEX_ATTRIB_ARRAY_DIVISOR: 'VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE'
	    // }

	  },
	  vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {
	    // Accept divisor 0 even if instancing is not supported (0 = no instancing)
	    (0, _assert.default)(divisor === 0, 'WebGL instanced rendering not supported');
	  },
	  drawElementsInstanced: function drawElementsInstanced() {},
	  drawArraysInstanced: function drawArraysInstanced() {}
	}), _defineProperty(_WEBGL_CONTEXT_POLYFI, WEBGL_draw_buffers, {
	  meta: {
	    suffix: 'WEBGL'
	  },
	  drawBuffers: function drawBuffers() {
	    (0, _assert.default)(false);
	  }
	}), _defineProperty(_WEBGL_CONTEXT_POLYFI, EXT_disjoint_timer_query, {
	  meta: {
	    suffix: 'EXT'
	  },
	  // WebGL1: Polyfills the WebGL2 Query API
	  createQuery: function createQuery() {
	    (0, _assert.default)(false);
	  },
	  deleteQuery: function deleteQuery() {
	    (0, _assert.default)(false);
	  },
	  beginQuery: function beginQuery() {
	    (0, _assert.default)(false);
	  },
	  endQuery: function endQuery() {},
	  getQuery: function getQuery(handle, pname) {
	    return this.getQueryObject(handle, pname);
	  },
	  // The WebGL1 extension uses getQueryObject rather then getQueryParameter
	  getQueryParameter: function getQueryParameter(handle, pname) {
	    return this.getQueryObject(handle, pname);
	  },
	  // plus the additional `queryCounter` method
	  queryCounter: function queryCounter() {},
	  getQueryObject: function getQueryObject() {}
	}), _defineProperty(_WEBGL_CONTEXT_POLYFI, EXT_disjoint_timer_query_webgl2, {
	  meta: {
	    suffix: 'EXT'
	  },
	  // install `queryCounter`
	  // `null` avoids overwriting WebGL1 `queryCounter` if the WebGL2 extension is not available
	  queryCounter: null
	}), _defineProperty(_WEBGL_CONTEXT_POLYFI, "OVERRIDES", {
	  // Ensure readBuffer is a no-op
	  readBuffer: function readBuffer(gl, originalFunc, attachment) {
	    if (isWebGL2(gl)) {
	      originalFunc(attachment);
	    } else {// assert(attachment !== GL_COLOR_ATTACHMENT0 && attachment !== GL_FRONT);
	    }
	  },
	  // Override for getVertexAttrib that returns sane values for non-WebGL1 constants
	  getVertexAttrib: function getVertexAttrib(gl, originalFunc, location, pname) {
	    // const gl = this; // eslint-disable-line
	    var _getExtensionData = getExtensionData(gl, ANGLE_instanced_arrays),
	        webgl2 = _getExtensionData.webgl2,
	        ext = _getExtensionData.ext;

	    var GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;
	    var GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;
	    var result;

	    switch (pname) {
	      // WebGL1 attributes will never be integer
	      case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
	        result = !webgl2 ? false : undefined;
	        break;
	      // if instancing is not available, return 0 meaning divisor has not been set

	      case GL_VERTEX_ATTRIB_ARRAY_DIVISOR:
	        result = !webgl2 && !ext ? 0 : undefined;
	        break;

	      default:
	    }

	    return result !== undefined ? result : originalFunc(location, pname);
	  },
	  // Handle transform feedback and uniform block queries in WebGL1
	  getProgramParameter: function getProgramParameter(gl, originalFunc, program, pname) {
	    var GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;
	    var GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;
	    var GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36;
	    var GL_SEPARATE_ATTRIBS = 0x8C8D;

	    if (!isWebGL2(gl)) {
	      switch (pname) {
	        case GL_TRANSFORM_FEEDBACK_BUFFER_MODE:
	          return GL_SEPARATE_ATTRIBS;

	        case GL_TRANSFORM_FEEDBACK_VARYINGS:
	          return 0;

	        case GL_ACTIVE_UNIFORM_BLOCKS:
	          return 0;

	        default:
	      }
	    }

	    return originalFunc(program, pname);
	  },
	  getInternalformatParameter: function getInternalformatParameter(gl, originalFunc, target, format, pname) {
	    var GL_SAMPLES = 0x80A9;

	    if (!isWebGL2(gl)) {
	      switch (pname) {
	        case GL_SAMPLES:
	          return new Int32Array([0]);

	        default:
	      }
	    }

	    return gl.getInternalformatParameter(target, format, pname);
	  },
	  getTexParameter: function getTexParameter(gl, originalFunc, target, pname) {
	    var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;

	    switch (pname) {
	      case GL_TEXTURE_MAX_ANISOTROPY_EXT:
	        var extensions = gl.luma.extensions;
	        var ext = extensions[EXT_texture_filter_anisotropic];
	        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || GL_TEXTURE_MAX_ANISOTROPY_EXT;
	        break;

	      default:
	    }

	    return originalFunc(target, pname);
	  },
	  getParameter: _polyfillGetParameter.getParameterPolyfill,
	  hint: function hint(gl, originalFunc, pname, value) {
	    // TODO - handle GL.FRAGMENT_SHADER_DERIVATIVE_HINT:
	    // switch (pname) {
	    // case GL.FRAGMENT_SHADER_DERIVATIVE_HINT:
	    // }
	    return originalFunc(pname, value);
	  }
	}), _WEBGL_CONTEXT_POLYFI);

	function initializeExtensions(gl) {
	  gl.luma.extensions = {};
	  var EXTENSIONS = gl.getSupportedExtensions();
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = EXTENSIONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var extension = _step.value;
	      gl.luma[extension] = gl.getExtension(extension);
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	} // Polyfills a single WebGL extension into the `target` object


	function polyfillExtension(gl, _ref) {
	  var extension = _ref.extension,
	      target = _ref.target,
	      target2 = _ref.target2;
	  var defaults = WEBGL_CONTEXT_POLYFILLS[extension];
	  (0, _assert.default)(defaults);
	  var _defaults$meta = defaults.meta,
	      meta = _defaults$meta === void 0 ? {} : _defaults$meta;
	  var _meta$suffix = meta.suffix,
	      suffix = _meta$suffix === void 0 ? '' : _meta$suffix;
	  var ext = gl.getExtension(extension);
	  Object.keys(defaults).forEach(function (key) {
	    var extKey = "".concat(key).concat(suffix);
	    var polyfill = null;

	    if (key === 'meta') {// ignore
	    } else if (typeof gl[key] === 'function') {// WebGL2 implementation is already
	    } else if (ext && typeof ext[extKey] === 'function') {
	      // pick extension implemenentation,if available
	      polyfill = function polyfill() {
	        return ext[extKey].apply(ext, arguments);
	      };
	    } else if (typeof defaults[key] === 'function') {
	      // pick the mock implementation, if no implementation was detected
	      polyfill = defaults[key].bind(target);
	    }

	    if (polyfill) {
	      target[key] = polyfill;
	      target2[key] = polyfill;
	    }
	  });
	} // Install simple overrides (mostly get* functions)


	function installOverrides(gl, _ref2) {
	  var target = _ref2.target,
	      target2 = _ref2.target2;
	  var OVERRIDES = WEBGL_CONTEXT_POLYFILLS.OVERRIDES;
	  Object.keys(OVERRIDES).forEach(function (key) {
	    if (typeof OVERRIDES[key] === 'function') {
	      // install an override, if no implementation was detected
	      var originalFunc = gl[key] ? gl[key].bind(gl) : function () {};
	      var polyfill = OVERRIDES[key].bind(null, gl, originalFunc);
	      target[key] = polyfill;
	      target2[key] = polyfill;
	    }
	  });
	} // Registers polyfill or mock functions for all known extensions


	function polyfillContext(gl) {
	  gl.luma = gl.luma || {};
	  initializeExtensions(gl);

	  if (!gl.luma.polyfilled) {
	    for (var extension in WEBGL_CONTEXT_POLYFILLS) {
	      if (extension !== 'overrides') {
	        polyfillExtension(gl, {
	          extension: extension,
	          target: gl.luma,
	          target2: gl
	        });
	      }
	    }

	    installOverrides(gl, {
	      target: gl.luma,
	      target2: gl
	    });
	    gl.luma.polyfilled = true;
	  }

	  return gl;
	}
	//# sourceMappingURL=polyfill-context.js.map

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getParameterPolyfill = getParameterPolyfill;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _WEBGL_PARAMETERS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var OES_element_index = 'OES_element_index';
	var WEBGL_draw_buffers = 'WEBGL_draw_buffers';
	var EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
	var EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
	var EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
	var WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';
	var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8B8B;
	var GL_DONT_CARE = 0x1100;
	var GL_GPU_DISJOINT_EXT = 0x8FBB;
	var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;
	var GL_UNMASKED_VENDOR_WEBGL = 0x9245; // vendor string of the graphics driver.

	var GL_UNMASKED_RENDERER_WEBGL = 0x9246; // renderer string of the graphics driver.

	var getWebGL2ValueOrZero = function getWebGL2ValueOrZero(gl) {
	  return !isWebGL2(gl) ? 0 : undefined;
	}; // if a function returns undefined in this table,
	// the original getParameter will be called, defeating the override


	var WEBGL_PARAMETERS = (_WEBGL_PARAMETERS = {}, _defineProperty(_WEBGL_PARAMETERS, _constants.default.READ_BUFFER, function (gl) {
	  return !isWebGL2(gl) ? _constants.default.COLOR_ATTACHMENT0 : undefined;
	}), _defineProperty(_WEBGL_PARAMETERS, GL_FRAGMENT_SHADER_DERIVATIVE_HINT, function (gl) {
	  return !isWebGL2(gl) ? GL_DONT_CARE : undefined;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.RASTERIZER_DISCARD, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.SAMPLES, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, GL_GPU_DISJOINT_EXT, function (gl, getParameter) {
	  var ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
	  return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
	}), _defineProperty(_WEBGL_PARAMETERS, GL_UNMASKED_VENDOR_WEBGL, function (gl, getParameter) {
	  var ext = gl.getExtension(WEBGL_debug_renderer_info);
	  return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || _constants.default.VENDOR);
	}), _defineProperty(_WEBGL_PARAMETERS, GL_UNMASKED_RENDERER_WEBGL, function (gl, getParameter) {
	  var ext = gl.getExtension(WEBGL_debug_renderer_info);
	  return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || _constants.default.RENDERER);
	}), _defineProperty(_WEBGL_PARAMETERS, GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, function (gl, getParameter) {
	  var ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
	  return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_3D_TEXTURE_SIZE, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_ARRAY_TEXTURE_LAYERS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_CLIENT_WAIT_TIMEOUT_WEBGL, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_COLOR_ATTACHMENTS, function (gl, getParameter) {
	  if (!isWebGL2(gl)) {
	    var ext = gl.getExtension(WEBGL_draw_buffers);
	    return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
	  }

	  return undefined;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_COMBINED_UNIFORM_BLOCKS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_DRAW_BUFFERS, function (gl) {
	  if (!isWebGL2(gl)) {
	    var ext = gl.getExtension(WEBGL_draw_buffers);
	    return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
	  }

	  return undefined;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_ELEMENT_INDEX, // Guess: per webglstats.com 99.6% of webgl2 supports 2147483647
	function (gl) {
	  return gl.getExtension(OES_element_index) ? 2147483647 : 65535;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_ELEMENTS_INDICES, // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
	function (gl) {
	  return gl.getExtension(OES_element_index) ? 16777216 : 65535;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_ELEMENTS_VERTICES, // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
	function (gl) {
	  return 16777216;
	}), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_FRAGMENT_INPUT_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_FRAGMENT_UNIFORM_BLOCKS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_FRAGMENT_UNIFORM_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_SAMPLES, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_SERVER_WAIT_TIMEOUT, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_TEXTURE_LOD_BIAS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_UNIFORM_BLOCK_SIZE, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_UNIFORM_BUFFER_BINDINGS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_VARYING_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_VERTEX_OUTPUT_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_VERTEX_UNIFORM_BLOCKS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_VERTEX_UNIFORM_COMPONENTS, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MIN_PROGRAM_TEXEL_OFFSET, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.MAX_PROGRAM_TEXEL_OFFSET, getWebGL2ValueOrZero), _defineProperty(_WEBGL_PARAMETERS, _constants.default.UNIFORM_BUFFER_OFFSET_ALIGNMENT, getWebGL2ValueOrZero), _WEBGL_PARAMETERS); // Return true if WebGL2 context

	function isWebGL2(gl) {
	  var GL_TEXTURE_BINDING_3D = 0x806A;
	  return gl && gl.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D;
	} // A "replacement" gl.getParameter that accepts "enums" from extensions and WebGL2
	// and returns reasonably safe defaults


	function getParameterPolyfill(gl, originalGetParameter, pname) {
	  // Return mock limits (usually 0) for WebGL2 constants to ensure these
	  // can be queries without error
	  var limit = WEBGL_PARAMETERS[pname];
	  var value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
	  var result = value !== undefined ? value : originalGetParameter(pname);
	  return result;
	}
	//# sourceMappingURL=polyfill-get-parameter.js.map

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.enableDebug = enableDebug;
	exports.makeDebugContext = makeDebugContext;
	exports.getRealContext = getRealContext;
	exports.getDebugContext = getDebugContext;

	var _globals = __webpack_require__(50);

	var _utils = __webpack_require__(63);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	// Helper to get shared context data
	function getContextData(gl) {
	  gl.luma = gl.luma || {};
	  return gl.luma;
	} // Enable or disable debug checks in debug contexts
	// Non-debug contexts do not have checks (to ensure performance)
	// Turning off debug for debug contexts removes most of the performance penalty


	function enableDebug(debug) {
	  _utils.log.debug = debug;
	} // Returns (a potentially new) context with debug instrumentation turned off or on.
	// Note that this actually returns a new context


	function makeDebugContext(gl) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$debug = _ref.debug,
	      debug = _ref$debug === void 0 ? true : _ref$debug;

	  if (gl === null) {
	    // Return to ensure we don't create a context in this case.
	    return null;
	  }

	  return debug ? getDebugContext(gl) : getRealContext(gl);
	} // Returns the real context from either of the real/debug contexts


	function getRealContext(gl) {
	  if (gl === null) {
	    // Return to ensure we don't create a context in this case.
	    return null;
	  }

	  var data = getContextData(gl); // If the context has a realContext member, it is a debug context so return the realContext

	  return data.realContext ? data.realContext : gl;
	} // Returns the debug context from either of the real/debug contexts


	function getDebugContext(gl) {
	  if (gl === null) {
	    // Return to ensure we don't create a context in this case.
	    return null;
	  }

	  if (!_globals.global.WebGLDebug) {
	    _utils.log.warn('WebGL debug mode activation failed. import "luma.gl/debug" to enable.')();

	    return gl;
	  }

	  var data = getContextData(gl); // If this *is* a debug context, return itself

	  if (data.realContext) {
	    return gl;
	  } // If this already has a debug context, return it.


	  if (data.debugContext) {
	    return data.debugContext;
	  } // Create a new debug context


	  var WebGLDebugContext = function WebGLDebugContext() {
	    _classCallCheck(this, WebGLDebugContext);
	  };

	  var debugContext = _globals.global.WebGLDebug.makeDebugContext(gl, onGLError, onValidateGLFunc);

	  Object.assign(WebGLDebugContext.prototype, debugContext); // Store the debug context

	  data.debugContext = debugContext;
	  debugContext.debug = true;
	  debugContext.gl = gl;

	  _utils.log.info('debug context actived.'); // Return it


	  return debugContext;
	} // DEBUG TRACING


	function getFunctionString(functionName, functionArgs) {
	  var args = _globals.global.WebGLDebug.glFunctionArgsToString(functionName, functionArgs);

	  args = "".concat(args.slice(0, 100)).concat(args.length > 100 ? '...' : '');
	  return "gl.".concat(functionName, "(").concat(args, ")");
	}

	function onGLError(err, functionName, args) {
	  var errorMessage = _globals.global.WebGLDebug.glEnumToString(err);

	  var functionArgs = _globals.global.WebGLDebug.glFunctionArgsToString(functionName, args);

	  var message = "".concat(errorMessage, " in gl.").concat(functionName, "(").concat(functionArgs, ")");

	  if (_utils.log.throw) {
	    throw new Error(message);
	  } else {
	    _utils.log.error(message)();

	    debugger; // eslint-disable-line
	  }
	} // Don't generate function string until it is needed


	function onValidateGLFunc(functionName, functionArgs) {
	  var functionString;

	  if (_utils.log.priority >= 4) {
	    functionString = getFunctionString(functionName, functionArgs);

	    _utils.log.info(4, functionString)();
	  }

	  if (_utils.log.break) {
	    functionString = functionString || getFunctionString(functionName, functionArgs);

	    var isBreakpoint = _utils.log.break && _utils.log.break.every(function (breakOn) {
	      return functionString.indexOf(breakOn) !== -1;
	    });

	    if (isBreakpoint) {
	      debugger; // eslint-disable-line
	    }
	  }

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = functionArgs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var arg = _step.value;

	      if (arg === undefined) {
	        functionString = functionString || getFunctionString(functionName, functionArgs);

	        if (_utils.log.throw) {
	          throw new Error("Undefined argument: ".concat(functionString));
	        } else {
	          _utils.log.error("Undefined argument: ".concat(functionString));

	          debugger; // eslint-disable-line
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}
	//# sourceMappingURL=debug-context.js.map

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getContextLimits = getContextLimits;
	exports.getGLContextInfo = getGLContextInfo;
	exports.getGLContextInfo2 = getGLContextInfo2;
	exports.getContextInfo = getContextInfo;
	exports.glGetDebugInfo = glGetDebugInfo;
	exports.TEST_EXPORTS = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglUtils = __webpack_require__(48);

	var _WEBGL_LIMITS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var WEBGL_LIMITS = (_WEBGL_LIMITS = {}, _defineProperty(_WEBGL_LIMITS, _constants.default.ALIASED_LINE_WIDTH_RANGE, {
	  gl1: new Float32Array([1, 1])
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.ALIASED_POINT_SIZE_RANGE, {
	  gl1: new Float32Array([1, 1])
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_TEXTURE_SIZE, {
	  gl1: 64,
	  gl2: 2048
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_CUBE_MAP_TEXTURE_SIZE, {
	  gl1: 16
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_TEXTURE_IMAGE_UNITS, {
	  gl1: 8
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_COMBINED_TEXTURE_IMAGE_UNITS, {
	  gl1: 8
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VERTEX_TEXTURE_IMAGE_UNITS, {
	  gl1: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_RENDERBUFFER_SIZE, {
	  gl1: 1
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VARYING_VECTORS, {
	  gl1: 8
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VERTEX_ATTRIBS, {
	  gl1: 8
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VERTEX_UNIFORM_VECTORS, {
	  gl1: 128
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_FRAGMENT_UNIFORM_VECTORS, {
	  gl1: 16
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VIEWPORT_DIMS, {
	  gl1: new Int32Array([0, 0])
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_3D_TEXTURE_SIZE, {
	  gl1: 0,
	  gl2: 256
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_ARRAY_TEXTURE_LAYERS, {
	  gl1: 0,
	  gl2: 256
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_CLIENT_WAIT_TIMEOUT_WEBGL, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_COLOR_ATTACHMENTS, {
	  gl1: 0,
	  gl2: 4
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_COMBINED_UNIFORM_BLOCKS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_DRAW_BUFFERS, {
	  gl1: 0,
	  gl2: 4
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_ELEMENT_INDEX, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_ELEMENTS_INDICES, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_ELEMENTS_VERTICES, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_FRAGMENT_INPUT_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_FRAGMENT_UNIFORM_BLOCKS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_FRAGMENT_UNIFORM_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_SAMPLES, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_SERVER_WAIT_TIMEOUT, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_TEXTURE_LOD_BIAS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_UNIFORM_BLOCK_SIZE, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_UNIFORM_BUFFER_BINDINGS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VARYING_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VERTEX_OUTPUT_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VERTEX_UNIFORM_BLOCKS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_VERTEX_UNIFORM_COMPONENTS, {
	  gl1: 0,
	  gl2: 0
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MIN_PROGRAM_TEXEL_OFFSET, {
	  gl1: 0,
	  gl2: -8,
	  negative: true
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.MAX_PROGRAM_TEXEL_OFFSET, {
	  gl1: 0,
	  gl2: 7
	}), _defineProperty(_WEBGL_LIMITS, _constants.default.UNIFORM_BUFFER_OFFSET_ALIGNMENT, {
	  gl1: 0,
	  gl2: 0 // GLint

	}), _WEBGL_LIMITS);

	function getContextLimits(gl) {
	  gl.luma = gl.luma || {};

	  if (!gl.luma.limits) {
	    gl.luma.limits = {};
	    gl.luma.webgl1MinLimits = {};
	    gl.luma.webgl2MinLimits = {};
	    var isWebgl2 = (0, _webglUtils.isWebGL2)(gl); // WEBGL limits

	    for (var parameter in WEBGL_LIMITS) {
	      var limit = WEBGL_LIMITS[parameter];
	      var webgl1MinLimit = limit.gl1;
	      var webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
	      var minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit; // Check if we can query for this limit

	      var limitNotAvailable = 'gl2' in limit && !isWebgl2 || 'extension' in limit && !gl.getExtension(limit.extension);
	      var value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
	      gl.luma.limits[parameter] = value;
	      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
	      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
	    }
	  }

	  return gl.luma.limits;
	}

	function getGLContextInfo(gl) {
	  gl.luma = gl.luma || {};

	  if (!gl.luma.info) {
	    var _gl$luma$info;

	    var info = gl.getExtension('WEBGL_debug_renderer_info');
	    gl.luma.info = (_gl$luma$info = {}, _defineProperty(_gl$luma$info, _constants.default.VENDOR, gl.getParameter(_constants.default.VENDOR)), _defineProperty(_gl$luma$info, _constants.default.RENDERER, gl.getParameter(_constants.default.RENDERER)), _defineProperty(_gl$luma$info, _constants.default.UNMASKED_VENDOR_WEBGL, gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || _constants.default.VENDOR)), _defineProperty(_gl$luma$info, _constants.default.UNMASKED_RENDERER_WEBGL, gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || _constants.default.RENDERER)), _defineProperty(_gl$luma$info, _constants.default.VERSION, gl.getParameter(_constants.default.VERSION)), _defineProperty(_gl$luma$info, _constants.default.SHADING_LANGUAGE_VERSION, gl.getParameter(_constants.default.SHADING_LANGUAGE_VERSION)), _gl$luma$info);
	  }

	  return gl.luma.info;
	}

	var GL_UNMASKED_VENDOR_WEBGL = 0x9245; // vendor string of the graphics driver.

	var GL_UNMASKED_RENDERER_WEBGL = 0x9246; // renderer string of the graphics driver.

	function getGLContextInfo2(gl) {
	  var vendorMasked = gl.getParameter(_constants.default.VENDOR);
	  var rendererMasked = gl.getParameter(_constants.default.RENDERER);
	  var ext = gl.getExtension('WEBGL_debug_renderer_info');
	  var vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || _constants.default.VENDOR);
	  var rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || _constants.default.RENDERER);
	  return {
	    vendor: vendorUnmasked || vendorMasked,
	    renderer: rendererUnmasked || rendererMasked,
	    vendorMasked: vendorMasked,
	    rendererMasked: rendererMasked,
	    version: gl.getParameter(_constants.default.VERSION),
	    shadingLanguageVersion: gl.getParameter(_constants.default.SHADING_LANGUAGE_VERSION)
	  };
	}

	function getContextInfo(gl) {
	  var limits = getContextLimits(gl);
	  var info = getGLContextInfo(gl);
	  return {
	    // basic information
	    vendor: info[GL_UNMASKED_VENDOR_WEBGL] || info[_constants.default.VENDOR],
	    renderer: info[GL_UNMASKED_RENDERER_WEBGL] || info[_constants.default.RENDERER],
	    version: info[_constants.default.VERSION],
	    shadingLanguageVersion: info[_constants.default.SHADING_LANGUAGE_VERSION],
	    // info, caps and limits
	    info: info,
	    limits: limits,
	    webgl1MinLimits: gl.luma.webgl1MinLimits,
	    webgl2MinLimits: gl.luma.webgl2MinLimits
	  };
	} // DEBUG INFO

	/**
	 * Provides strings identifying the GPU vendor and driver.
	 * https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/
	 * @param {WebGLRenderingContext} gl - context
	 * @return {Object} - 'vendor' and 'renderer' string fields.
	 */


	function glGetDebugInfo(gl) {
	  return getGLContextInfo2(gl); // const info = gl.getExtension('WEBGL_debug_renderer_info');
	  // // We can't determine if 'WEBGL_debug_renderer_info' is supported by
	  // // checking whether info is null here. Firefox doesn't follow the
	  // // specs by returning null for unsupported extension. Instead,
	  // // it returns an object without GL_UNMASKED_VENDOR_WEBGL and GL_UNMASKED_RENDERER_WEBGL.
	  // return {
	  //   vendor: (info && info.UNMASKED_VENDOR_WEBGL) ?
	  //     gl.getParameter(info.UNMASKED_VENDOR_WEBGL) : 'unknown',
	  //   renderer: (info && info.UNMASKED_RENDERER_WEBGL) ?
	  //     gl.getParameter(info.UNMASKED_RENDERER_WEBGL) : 'unknown'
	  // };
	}

	var TEST_EXPORTS = {
	  WEBGL_LIMITS: WEBGL_LIMITS
	};
	exports.TEST_EXPORTS = TEST_EXPORTS;
	//# sourceMappingURL=context-limits.js.map

/***/ }),
/* 76 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	//
	// Internal class that helps "asynchronous WebGL query objects" manage
	// pending requests (e.g. for EXT_disjoint_timer_query and WebGL2 queries)
	//
	// Creates and manages promises for the queries.
	// Tracks pending queries enabling polling.
	// Tracks pending queries enabling invalidation.
	// Provides some standard error messages.
	//
	// Remarks:
	// - Maintains a minimal list of pending queries only to minimize GC impact
	// - Exported as a singleton class instance.
	var ERR_DELETED = 'Query was deleted before result was available';
	var ERR_CANCEL = 'Query was canceled before result was available';

	var noop = function noop(x) {
	  return x;
	};

	var QueryManager =
	/*#__PURE__*/
	function () {
	  function QueryManager() {
	    _classCallCheck(this, QueryManager);

	    this.pendingQueries = new Set();
	    this.invalidQueryType = null;
	    this.invalidErrorMessage = '';

	    this.checkInvalid = function () {
	      return false;
	    };
	  } // API THAT SHOULD BE EXPOSED TO APPLICATION
	  // Checks invalidation callback and then all pending queries for completion
	  // Should only be called once per tick


	  _createClass(QueryManager, [{
	    key: "poll",
	    value: function poll(gl) {
	      this.cancelInvalidQueries(gl); // Now check availability of results and resolve promises as appropriate

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.pendingQueries.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var query = _step.value;
	          var resultAvailable = query.isResultAvailable();

	          if (resultAvailable) {
	            var result = query.getResult();
	            this.resolveQuery(query, result);
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    } // API FOR MANAGED QUERY CLASSES
	    // Registers query invalidation method - used to detect disjoint timer queries

	  }, {
	    key: "setInvalidator",
	    value: function setInvalidator(_ref) {
	      var queryType = _ref.queryType,
	          errorMessage = _ref.errorMessage,
	          checkInvalid = _ref.checkInvalid;
	      this.invalidQueryType = queryType;
	      this.invalidErrorMessage = errorMessage;
	      this.checkInvalid = checkInvalid;
	    } // Starts a query, sets up a new promise

	  }, {
	    key: "beginQuery",
	    value: function beginQuery(query) {
	      var onComplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;
	      var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop;
	      // Make sure disjoint state is cleared, so that this query starts fresh
	      // Cancel other queries if needed
	      this.cancelInvalidQueries(query.gl); // Cancel current promise - noop if already resolved or rejected

	      this.cancelQuery(query); // Create a new promise with attached resolve and reject methods

	      var resolvers = {};
	      query.promise = new Promise(function (resolve, reject) {
	        resolvers.resolve = resolve;
	        resolvers.reject = reject;
	      });
	      Object.assign(query.promise, resolvers); // Add this query to the pending queries

	      this.pendingQueries.add(query); // Register the callbacks

	      return query.promise.then(onComplete).catch(onError);
	    } // Resolves a query with a result

	  }, {
	    key: "resolveQuery",
	    value: function resolveQuery(query, result) {
	      this.pendingQueries.delete(query);
	      query.promise.resolve(result);
	    } // Rejects the promise

	  }, {
	    key: "rejectQuery",
	    value: function rejectQuery(query, errorMessage) {
	      this.pendingQueries.delete(query);

	      if (query.promise) {
	        query.promise.reject(new Error(errorMessage));
	      }
	    } // Rejects promise with standard message for Query.delete()

	  }, {
	    key: "deleteQuery",
	    value: function deleteQuery(query) {
	      return this.rejectQuery(query, ERR_DELETED);
	    } // Rejects promise with standard message for Query.cancel()

	  }, {
	    key: "cancelQuery",
	    value: function cancelQuery(query) {
	      return this.rejectQuery(query, ERR_CANCEL);
	    } // Rejects promise with registered message for invalidation

	  }, {
	    key: "invalidateQuery",
	    value: function invalidateQuery(query) {
	      if (_instanceof(query, this.invalidQueryType)) {
	        this.rejectQuery(query, this.invalidErrorMessage);
	      }
	    } // Checks all queries to see if need to be invalidated

	  }, {
	    key: "cancelInvalidQueries",
	    value: function cancelInvalidQueries(gl) {
	      // We assume that we can cancel queries for all context.
	      // Should be OK since this is used to check for "disjoint" GPU state
	      if (this.checkInvalid(gl)) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = this.pendingQueries.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var query = _step2.value;
	            this.invalidateQuery(query);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }
	    }
	  }]);

	  return QueryManager;
	}();

	var _default = new QueryManager();

	exports.default = _default;
	//# sourceMappingURL=query-manager.js.map

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "createGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.createGLContext;
	  }
	});
	Object.defineProperty(exports, "destroyGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.destroyGLContext;
	  }
	});
	Object.defineProperty(exports, "resizeGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.resizeGLContext;
	  }
	});
	Object.defineProperty(exports, "pollGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.pollGLContext;
	  }
	});
	Object.defineProperty(exports, "withParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.withParameters;
	  }
	});
	Object.defineProperty(exports, "resetParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.resetParameters;
	  }
	});
	Object.defineProperty(exports, "getContextInfo", {
	  enumerable: true,
	  get: function get() {
	    return _contextLimits.getContextInfo;
	  }
	});
	Object.defineProperty(exports, "pageLoadPromise", {
	  enumerable: true,
	  get: function get() {
	    return _createCanvas.pageLoadPromise;
	  }
	});
	Object.defineProperty(exports, "getPageLoadPromise", {
	  enumerable: true,
	  get: function get() {
	    return _createCanvas.getPageLoadPromise;
	  }
	});
	Object.defineProperty(exports, "createCanvas", {
	  enumerable: true,
	  get: function get() {
	    return _createCanvas.createCanvas;
	  }
	});
	Object.defineProperty(exports, "getCanvas", {
	  enumerable: true,
	  get: function get() {
	    return _createCanvas.getCanvas;
	  }
	});
	Object.defineProperty(exports, "createHeadlessContext", {
	  enumerable: true,
	  get: function get() {
	    return _createHeadlessContext.createHeadlessContext;
	  }
	});
	Object.defineProperty(exports, "trackContextCreation", {
	  enumerable: true,
	  get: function get() {
	    return _createBrowserContext.trackContextCreation;
	  }
	});
	Object.defineProperty(exports, "createBrowserContext", {
	  enumerable: true,
	  get: function get() {
	    return _createBrowserContext.createBrowserContext;
	  }
	});
	Object.defineProperty(exports, "polyfillContext", {
	  enumerable: true,
	  get: function get() {
	    return _polyfillContext.default;
	  }
	});
	Object.defineProperty(exports, "trackContextState", {
	  enumerable: true,
	  get: function get() {
	    return _trackContextState.default;
	  }
	});

	var _context = __webpack_require__(60);

	var _contextState = __webpack_require__(78);

	var _contextLimits = __webpack_require__(75);

	var _createCanvas = __webpack_require__(62);

	var _createHeadlessContext = __webpack_require__(61);

	var _createBrowserContext = __webpack_require__(69);

	var _polyfillContext = _interopRequireDefault(__webpack_require__(72));

	var _trackContextState = _interopRequireDefault(__webpack_require__(70));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setParameters = setParameters;
	exports.withParameters = withParameters;
	Object.defineProperty(exports, "getParameter", {
	  enumerable: true,
	  get: function get() {
	    return _setParameters.getParameter;
	  }
	});
	Object.defineProperty(exports, "getParameters", {
	  enumerable: true,
	  get: function get() {
	    return _setParameters.getParameters;
	  }
	});
	Object.defineProperty(exports, "setParameter", {
	  enumerable: true,
	  get: function get() {
	    return _setParameters.setParameter;
	  }
	});
	Object.defineProperty(exports, "resetParameters", {
	  enumerable: true,
	  get: function get() {
	    return _setParameters.resetParameters;
	  }
	});
	Object.defineProperty(exports, "getModifiedParameters", {
	  enumerable: true,
	  get: function get() {
	    return _setParameters.getModifiedParameters;
	  }
	});
	exports.LUMA_SETTERS = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _trackContextState = __webpack_require__(70);

	var _setParameters = __webpack_require__(71);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	// map of parameter setter function names, parameter constants, default values and types
	// - Uses gl function names, except when setter function exist that are named differently
	// - When the WebGL api offers <setter> and <setter>Separate (e.g. blendEquation and
	//   blendEquationSeparate, we use non-separate name, but accept both non-separate and
	//   separate arguments. Thus, a `getParameter` call will always return all the separate values
	//   in an array, in a form that can be accepted by the setter.
	var LUMA_SETTERS = {
	  framebuffer: function framebuffer(gl, _framebuffer) {
	    var handle = _framebuffer && _framebuffer.handle ? _framebuffer.handle : _framebuffer;
	    return gl.bindFramebuffer(_constants.default.FRAMEBUFFER, handle);
	  },
	  blend: function blend(gl, value) {
	    return value ? gl.enable(_constants.default.BLEND) : gl.disable(_constants.default.BLEND);
	  },
	  blendColor: function blendColor(gl, value) {
	    return gl.blendColor.apply(gl, _toConsumableArray(value));
	  },
	  blendEquation: function blendEquation(gl, args) {
	    args = isArray(args) ? args : [args, args];
	    gl.blendEquationSeparate.apply(gl, _toConsumableArray(args));
	  },
	  blendFunc: function blendFunc(gl, args) {
	    args = isArray(args) && args.length === 2 ? _toConsumableArray(args).concat(_toConsumableArray(args)) : args;
	    gl.blendFuncSeparate.apply(gl, _toConsumableArray(args));
	  },
	  clearColor: function clearColor(gl, value) {
	    return gl.clearColor.apply(gl, _toConsumableArray(value));
	  },
	  clearDepth: function clearDepth(gl, value) {
	    return gl.clearDepth(value);
	  },
	  clearStencil: function clearStencil(gl, value) {
	    return gl.clearStencil(value);
	  },
	  colorMask: function colorMask(gl, value) {
	    return gl.colorMask.apply(gl, _toConsumableArray(value));
	  },
	  cull: function cull(gl, value) {
	    return value ? gl.enable(_constants.default.CULL_FACE) : gl.disable(_constants.default.CULL_FACE);
	  },
	  cullFace: function cullFace(gl, value) {
	    return gl.cullFace(value);
	  },
	  depthTest: function depthTest(gl, value) {
	    return value ? gl.enable(_constants.default.DEPTH_TEST) : gl.disable(_constants.default.DEPTH_TEST);
	  },
	  depthFunc: function depthFunc(gl, value) {
	    return gl.depthFunc(value);
	  },
	  depthMask: function depthMask(gl, value) {
	    return gl.depthMask(value);
	  },
	  depthRange: function depthRange(gl, value) {
	    return gl.depthRange.apply(gl, _toConsumableArray(value));
	  },
	  dither: function dither(gl, value) {
	    return value ? gl.enable(_constants.default.DITHER) : gl.disable(_constants.default.DITHER);
	  },
	  derivativeHint: function derivativeHint(gl, value) {
	    // gl1: 'OES_standard_derivatives'
	    gl.hint(_constants.default.FRAGMENT_SHADER_DERIVATIVE_HINT, value);
	  },
	  frontFace: function frontFace(gl, value) {
	    return gl.frontFace(value);
	  },
	  mipmapHint: function mipmapHint(gl, value) {
	    return gl.hint(_constants.default.GENERATE_MIPMAP_HINT, value);
	  },
	  lineWidth: function lineWidth(gl, value) {
	    return gl.lineWidth(value);
	  },
	  polygonOffsetFill: function polygonOffsetFill(gl, value) {
	    return value ? gl.enable(_constants.default.POLYGON_OFFSET_FILL) : gl.disable(_constants.default.POLYGON_OFFSET_FILL);
	  },
	  polygonOffset: function polygonOffset(gl, value) {
	    return gl.polygonOffset.apply(gl, _toConsumableArray(value));
	  },
	  sampleCoverage: function sampleCoverage(gl, value) {
	    return gl.sampleCoverage.apply(gl, _toConsumableArray(value));
	  },
	  scissorTest: function scissorTest(gl, value) {
	    return value ? gl.enable(_constants.default.SCISSOR_TEST) : gl.disable(_constants.default.SCISSOR_TEST);
	  },
	  scissor: function scissor(gl, value) {
	    return gl.scissor.apply(gl, _toConsumableArray(value));
	  },
	  stencilTest: function stencilTest(gl, value) {
	    return value ? gl.enable(_constants.default.STENCIL_TEST) : gl.disable(_constants.default.STENCIL_TEST);
	  },
	  stencilMask: function stencilMask(gl, value) {
	    value = isArray(value) ? value : [value, value];

	    var _value = value,
	        _value2 = _slicedToArray(_value, 2),
	        mask = _value2[0],
	        backMask = _value2[1];

	    gl.stencilMaskSeparate(_constants.default.FRONT, mask);
	    gl.stencilMaskSeparate(_constants.default.BACK, backMask);
	  },
	  stencilFunc: function stencilFunc(gl, args) {
	    args = isArray(args) && args.length === 3 ? _toConsumableArray(args).concat(_toConsumableArray(args)) : args;

	    var _args = args,
	        _args2 = _slicedToArray(_args, 6),
	        func = _args2[0],
	        ref = _args2[1],
	        mask = _args2[2],
	        backFunc = _args2[3],
	        backRef = _args2[4],
	        backMask = _args2[5];

	    gl.stencilFuncSeparate(_constants.default.FRONT, func, ref, mask);
	    gl.stencilFuncSeparate(_constants.default.BACK, backFunc, backRef, backMask);
	  },
	  stencilOp: function stencilOp(gl, args) {
	    args = isArray(args) && args.length === 3 ? _toConsumableArray(args).concat(_toConsumableArray(args)) : args;

	    var _args3 = args,
	        _args4 = _slicedToArray(_args3, 6),
	        sfail = _args4[0],
	        dpfail = _args4[1],
	        dppass = _args4[2],
	        backSfail = _args4[3],
	        backDpfail = _args4[4],
	        backDppass = _args4[5];

	    gl.stencilOpSeparate(_constants.default.FRONT, sfail, dpfail, dppass);
	    gl.stencilOpSeparate(_constants.default.BACK, backSfail, backDpfail, backDppass);
	  },
	  viewport: function viewport(gl, value) {
	    return gl.viewport.apply(gl, _toConsumableArray(value));
	  }
	}; // HELPERS

	exports.LUMA_SETTERS = LUMA_SETTERS;

	function isArray(array) {
	  return Array.isArray(array) || ArrayBuffer.isView(array);
	} // GETTERS AND SETTERS
	// Get the parameter value(s) from the context


	// Note: "setParameters" is given extra treatment below
	// Set the parameter value(s) by key to the context
	// Sets value with key to context.
	// Value may be "normalized" (in case a short form is supported). In that case
	// the normalized value is retured.
	function setParameters(gl, parameters) {
	  (0, _setParameters.setParameters)(gl, parameters);

	  for (var key in parameters) {
	    var setter = LUMA_SETTERS[key];

	    if (setter) {
	      setter(gl, parameters[key], key);
	    }
	  }
	} // VERY LIMITED / BASIC GL STATE MANAGEMENT
	// Executes a function with gl states temporarily set, exception safe
	// Currently support pixelStorage, scissor test and framebuffer binding


	function withParameters(gl, parameters, func) {
	  // assertWebGLContext(gl);
	  if ((0, _utils.isObjectEmpty)(parameters)) {
	    // Avoid setting state if no parameters provided. Just call and return
	    return func(gl);
	  }

	  var _parameters$nocatch = parameters.nocatch,
	      nocatch = _parameters$nocatch === void 0 ? true : _parameters$nocatch; // frameBuffer not supported use framebuffer

	  (0, _assert.default)(!parameters.frameBuffer);
	  (0, _trackContextState.pushContextState)(gl);
	  setParameters(gl, parameters); // Setup is done, call the function

	  var value;

	  if (nocatch) {
	    // Avoid try catch to minimize stack size impact for safe execution paths
	    value = func(gl);
	    (0, _trackContextState.popContextState)(gl);
	  } else {
	    // Wrap in a try-catch to ensure that parameters are restored on exceptions
	    try {
	      value = func(gl);
	    } finally {
	      (0, _trackContextState.popContextState)(gl);
	    }
	  }

	  return value;
	}
	//# sourceMappingURL=context-state.js.map

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.canCompileGLGSExtension = canCompileGLGSExtension;
	exports.hasFeature = hasFeature;
	exports.hasFeatures = hasFeatures;
	exports.getFeatures = getFeatures;
	exports.TEST_EXPORTS = exports.FEATURES = void 0;

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Feature detection for WebGL
	//
	// Provides a function that enables simple checking of which WebGL features are
	// available in an WebGL1 or WebGL2 environment.

	/* eslint-disable no-inline-comments, max-len */
	// Defines luma.gl "feature" names and semantics
	var WEBGL_FEATURES = {
	  // API SUPPORT
	  VERTEX_ARRAY_OBJECT: ['OES_vertex_array_object', true],
	  TIMER_QUERY: ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2'],
	  INSTANCED_RENDERING: ['ANGLE_instanced_arrays', true],
	  MULTIPLE_RENDER_TARGETS: ['WEBGL_draw_buffers', true],
	  // FEATURES
	  ELEMENT_INDEX_UINT32: ['OES_element_index_uint', true],
	  BLEND_EQUATION_MINMAX: ['EXT_blend_minmax', true],
	  // TEXTURES, RENDERBUFFERS
	  COLOR_ENCODING_SRGB: ['EXT_sRGB', true],
	  // TEXTURES
	  TEXTURE_DEPTH: ['WEBGL_depth_texture', true],
	  TEXTURE_FLOAT: ['OES_texture_float', true],
	  TEXTURE_HALF_FLOAT: ['OES_texture_half_float', true],
	  TEXTURE_FILTER_LINEAR_FLOAT: ['OES_texture_float_linear'],
	  TEXTURE_FILTER_LINEAR_HALF_FLOAT: ['OES_texture_half_float_linear'],
	  TEXTURE_FILTER_ANISOTROPIC: ['EXT_texture_filter_anisotropic'],
	  // FRAMEBUFFERS, TEXTURES AND RENDERBUFFERS
	  COLOR_ATTACHMENT_RGBA32F: ['WEBGL_color_buffer_float', 'EXT_color_buffer_float'],
	  COLOR_ATTACHMENT_FLOAT: [false, 'EXT_color_buffer_float'],
	  COLOR_ATTACHMENT_HALF_FLOAT: [false, 'EXT_color_buffer_half_float'],
	  // GLSL extensions
	  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true],
	  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
	  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
	  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
	}; // Create a key-mirrored FEATURES array

	var FEATURES = {};
	exports.FEATURES = FEATURES;
	Object.keys(WEBGL_FEATURES).forEach(function (key) {
	  FEATURES[key] = key;
	});
	// Enables feature detection in IE11 due to a bug where gl.getExtension may return true
	// but fail to compile when the extension is enabled in the shader. Specifically,
	// the OES_standard_derivatives extension fails to compile in IE11 even though its included
	// in the list of supported extensions.
	var compiledGlslExtensions = {}; // opts allows user agent to be overridden for testing

	function canCompileGLGSExtension(gl, cap) {
	  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var feature = WEBGL_FEATURES[cap];
	  (0, _assert.default)(feature, cap);

	  if (!(0, _utils.isOldIE)(opts)) {
	    return true;
	  }

	  if (cap in compiledGlslExtensions) {
	    return compiledGlslExtensions[cap];
	  }

	  var extensionName = feature[0];
	  var source = "#extension GL_".concat(extensionName, " : enable\nvoid main(void) {}");
	  var shader = gl.createShader(gl.VERTEX_SHADER);
	  gl.shaderSource(shader, source);
	  gl.compileShader(shader);
	  var canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	  gl.deleteShader(shader);
	  compiledGlslExtensions[cap] = canCompile;
	  return canCompile;
	} // TODO - cache the value


	function getFeature(gl, cap) {
	  var feature = WEBGL_FEATURES[cap];
	  (0, _assert.default)(feature, cap); // Get extension name from table

	  var extensionName = (0, _webglUtils.isWebGL2)(gl) ? feature[1] || feature[0] : feature[0]; // Check if the value is dependent on checking an extension

	  var value = typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;
	  (0, _assert.default)(value === false || value === true);
	  return value;
	} // capability can be a WebGL extension name or a luma capability name


	function hasFeature(gl, feature) {
	  return hasFeatures(gl, feature);
	}

	function hasFeatures(gl, features) {
	  features = Array.isArray(features) ? features : [features];
	  return features.every(function (feature) {
	    return getFeature(gl, feature);
	  });
	}

	function getFeatures(gl) {
	  gl.luma = gl.luma || {};

	  if (!gl.luma.caps) {
	    gl.luma.caps = {};
	    gl.luma.caps.webgl2 = (0, _webglUtils.isWebGL2)(gl);

	    for (var cap in WEBGL_FEATURES) {
	      gl.luma.caps[cap] = getFeature(gl, cap);
	    }
	  }

	  return gl.luma.caps;
	}

	var TEST_EXPORTS = {
	  WEBGL_FEATURES: WEBGL_FEATURES
	};
	exports.TEST_EXPORTS = TEST_EXPORTS;
	//# sourceMappingURL=context-features.js.map

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _webgl = __webpack_require__(81);

	var _constants = _interopRequireDefault(__webpack_require__(59));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var Attribute =
	/*#__PURE__*/
	function () {
	  function Attribute(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Attribute);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? 'unnamed-attribute' : _opts$id,
	        type = opts.type,
	        _opts$isIndexed = opts.isIndexed,
	        isIndexed = _opts$isIndexed === void 0 ? false : _opts$isIndexed; // Options that cannot be changed later

	    this.gl = gl;
	    this.id = id;
	    this.isIndexed = isIndexed;
	    this.target = isIndexed ? _constants.default.ELEMENT_ARRAY_BUFFER : _constants.default.ARRAY_BUFFER;
	    this.type = type; // Initialize the attribute descriptor, with WebGL and metadata fields

	    this.value = null;
	    this.externalBuffer = null;
	    this.buffer = null;
	    this.userData = {}; // Reserved for application

	    this.update(opts); // Sanity - no app fields on our attributes. Use userData instead.

	    Object.seal(this); // Check all fields and generate helpful error messages

	    this._validateAttributeDefinition();
	  }

	  _createClass(Attribute, [{
	    key: "delete",
	    value: function _delete() {
	      if (this.buffer) {
	        this.buffer.delete();
	        this.buffer = null;
	      }
	    }
	  }, {
	    key: "update",
	    value: function update(_ref) {
	      var value = _ref.value,
	          buffer = _ref.buffer,
	          _ref$size = _ref.size,
	          size = _ref$size === void 0 ? this.size : _ref$size,
	          _ref$offset = _ref.offset,
	          offset = _ref$offset === void 0 ? this.offset || 0 : _ref$offset,
	          _ref$stride = _ref.stride,
	          stride = _ref$stride === void 0 ? this.stride || 0 : _ref$stride,
	          _ref$normalized = _ref.normalized,
	          normalized = _ref$normalized === void 0 ? this.normalized || false : _ref$normalized,
	          _ref$integer = _ref.integer,
	          integer = _ref$integer === void 0 ? this.integer || false : _ref$integer,
	          _ref$instanced = _ref.instanced,
	          instanced = _ref$instanced === void 0 ? this.instanced || 0 : _ref$instanced,
	          _ref$isGeneric = _ref.isGeneric,
	          isGeneric = _ref$isGeneric === void 0 ? this.isGeneric || false : _ref$isGeneric,
	          isInstanced = _ref.isInstanced;
	      this.size = size;
	      this.offset = offset;
	      this.stride = stride;
	      this.normalized = normalized;
	      this.integer = integer;
	      this.isGeneric = isGeneric;

	      if (isInstanced !== undefined) {
	        this.instanced = isInstanced ? 1 : 0;
	      } else {
	        this.instanced = instanced;
	      }

	      if (buffer) {
	        this.externalBuffer = buffer;
	        this.type = buffer.type;
	      } else if (value) {
	        this.externalBuffer = null;
	        this.value = value;

	        if (!isGeneric) {
	          // Create buffer if needed
	          this.buffer = this.buffer || new _webgl.Buffer(this.gl, {
	            target: this.target,
	            type: this.type
	          });
	          this.buffer.setData({
	            data: value
	          });
	          this.type = this.buffer.type;
	        }
	      }
	    }
	  }, {
	    key: "getBuffer",
	    value: function getBuffer() {
	      if (this.isGeneric) {
	        return null;
	      }

	      return this.externalBuffer || this.buffer;
	    }
	  }, {
	    key: "_validateAttributeDefinition",
	    value: function _validateAttributeDefinition() {
	      (0, _assert.default)(this.size >= 1 && this.size <= 4, "Attribute definition for ".concat(this.id, " invalid size"));
	    }
	  }]);

	  return Attribute;
	}();

	exports.default = Attribute;
	//# sourceMappingURL=attribute.js.map

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "Image", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.Image;
	  }
	});
	Object.defineProperty(exports, "WebGLRenderingContext", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLRenderingContext;
	  }
	});
	Object.defineProperty(exports, "WebGLProgram", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLProgram;
	  }
	});
	Object.defineProperty(exports, "WebGLShader", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLShader;
	  }
	});
	Object.defineProperty(exports, "WebGLBuffer", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLBuffer;
	  }
	});
	Object.defineProperty(exports, "WebGLFramebuffer", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLFramebuffer;
	  }
	});
	Object.defineProperty(exports, "WebGLRenderbuffer", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLRenderbuffer;
	  }
	});
	Object.defineProperty(exports, "WebGLTexture", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLTexture;
	  }
	});
	Object.defineProperty(exports, "WebGLUniformLocation", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLUniformLocation;
	  }
	});
	Object.defineProperty(exports, "WebGLActiveInfo", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLActiveInfo;
	  }
	});
	Object.defineProperty(exports, "WebGLShaderPrecisionFormat", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGLShaderPrecisionFormat;
	  }
	});
	Object.defineProperty(exports, "WebGL2RenderingContext", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.WebGL2RenderingContext;
	  }
	});
	Object.defineProperty(exports, "webGLTypesAvailable", {
	  enumerable: true,
	  get: function get() {
	    return _webglUtils.webGLTypesAvailable;
	  }
	});
	Object.defineProperty(exports, "isWebGL", {
	  enumerable: true,
	  get: function get() {
	    return _context.isWebGL;
	  }
	});
	Object.defineProperty(exports, "isWebGL2", {
	  enumerable: true,
	  get: function get() {
	    return _context.isWebGL2;
	  }
	});
	Object.defineProperty(exports, "createGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.createGLContext;
	  }
	});
	Object.defineProperty(exports, "destroyGLContext", {
	  enumerable: true,
	  get: function get() {
	    return _context.destroyGLContext;
	  }
	});
	Object.defineProperty(exports, "withParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.withParameters;
	  }
	});
	Object.defineProperty(exports, "resetParameters", {
	  enumerable: true,
	  get: function get() {
	    return _contextState.resetParameters;
	  }
	});
	Object.defineProperty(exports, "getContextInfo", {
	  enumerable: true,
	  get: function get() {
	    return _contextLimits.getContextInfo;
	  }
	});
	Object.defineProperty(exports, "Attribute", {
	  enumerable: true,
	  get: function get() {
	    return _attribute.default;
	  }
	});
	Object.defineProperty(exports, "Buffer", {
	  enumerable: true,
	  get: function get() {
	    return _buffer.default;
	  }
	});
	Object.defineProperty(exports, "Shader", {
	  enumerable: true,
	  get: function get() {
	    return _shader.Shader;
	  }
	});
	Object.defineProperty(exports, "VertexShader", {
	  enumerable: true,
	  get: function get() {
	    return _shader.VertexShader;
	  }
	});
	Object.defineProperty(exports, "FragmentShader", {
	  enumerable: true,
	  get: function get() {
	    return _shader.FragmentShader;
	  }
	});
	Object.defineProperty(exports, "Program", {
	  enumerable: true,
	  get: function get() {
	    return _program.default;
	  }
	});
	Object.defineProperty(exports, "Framebuffer", {
	  enumerable: true,
	  get: function get() {
	    return _framebuffer.default;
	  }
	});
	Object.defineProperty(exports, "Renderbuffer", {
	  enumerable: true,
	  get: function get() {
	    return _renderbuffer.default;
	  }
	});
	Object.defineProperty(exports, "Texture2D", {
	  enumerable: true,
	  get: function get() {
	    return _texture2d.default;
	  }
	});
	Object.defineProperty(exports, "TextureCube", {
	  enumerable: true,
	  get: function get() {
	    return _textureCube.default;
	  }
	});
	Object.defineProperty(exports, "draw", {
	  enumerable: true,
	  get: function get() {
	    return _draw.draw;
	  }
	});
	Object.defineProperty(exports, "clear", {
	  enumerable: true,
	  get: function get() {
	    return _clear.clear;
	  }
	});
	Object.defineProperty(exports, "readPixels", {
	  enumerable: true,
	  get: function get() {
	    return _functions.readPixels;
	  }
	});
	Object.defineProperty(exports, "parseUniformName", {
	  enumerable: true,
	  get: function get() {
	    return _uniforms.parseUniformName;
	  }
	});
	Object.defineProperty(exports, "getUniformSetter", {
	  enumerable: true,
	  get: function get() {
	    return _uniforms.getUniformSetter;
	  }
	});
	Object.defineProperty(exports, "checkUniformValues", {
	  enumerable: true,
	  get: function get() {
	    return _uniforms.checkUniformValues;
	  }
	});
	Object.defineProperty(exports, "VertexArray", {
	  enumerable: true,
	  get: function get() {
	    return _vertexArray.default;
	  }
	});

	var _webglUtils = __webpack_require__(48);

	var _context = __webpack_require__(60);

	var _contextState = __webpack_require__(78);

	var _contextLimits = __webpack_require__(75);

	var _attribute = _interopRequireDefault(__webpack_require__(80));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	var _shader = __webpack_require__(85);

	var _program = _interopRequireDefault(__webpack_require__(86));

	var _framebuffer = _interopRequireDefault(__webpack_require__(89));

	var _renderbuffer = _interopRequireDefault(__webpack_require__(91));

	var _texture2d = _interopRequireDefault(__webpack_require__(90));

	var _textureCube = _interopRequireDefault(__webpack_require__(97));

	var _draw = __webpack_require__(98);

	var _clear = __webpack_require__(92);

	var _functions = __webpack_require__(99);

	var _uniforms = __webpack_require__(94);

	var _vertexArray = _interopRequireDefault(__webpack_require__(87));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.BufferLayout = void 0;

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _webglUtils = __webpack_require__(48);

	var _typedArrayUtils = __webpack_require__(56);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var GL_COPY_READ_BUFFER = 0x8F36;
	var GL_COPY_WRITE_BUFFER = 0x8F37;
	var GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
	var GL_UNIFORM_BUFFER = 0x8A11;
	var GL_ARRAY_BUFFER = 0x8892;
	var GL_STATIC_DRAW = 0x88E4;
	var GL_FLOAT = 0x1406;

	var BufferLayout =
	/**
	 * @classdesc
	 * Store characteristics of a data layout
	 * This data can be used when updating vertex attributes with
	 * the associated buffer, freeing the application from keeping
	 * track of this metadata.
	 *
	 * @class
	 * @param {GLuint} size - number of values per element (1-4)
	 * @param {GLuint} type - type of values (e.g. gl.FLOAT)
	 * @param {GLbool} normalized=false - normalize integers to [-1,1] or [0,1]
	 * @param {GLuint} integer=false - WebGL2 only, int-to-float conversion
	 * @param {GLuint} stride=0 - supports strided arrays
	 * @param {GLuint} offset=0 - supports strided arrays
	 */
	function BufferLayout() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      type = _ref.type,
	      _ref$size = _ref.size,
	      size = _ref$size === void 0 ? 1 : _ref$size,
	      _ref$offset = _ref.offset,
	      offset = _ref$offset === void 0 ? 0 : _ref$offset,
	      _ref$stride = _ref.stride,
	      stride = _ref$stride === void 0 ? 0 : _ref$stride,
	      _ref$normalized = _ref.normalized,
	      normalized = _ref$normalized === void 0 ? false : _ref$normalized,
	      _ref$integer = _ref.integer,
	      integer = _ref$integer === void 0 ? false : _ref$integer,
	      _ref$instanced = _ref.instanced,
	      instanced = _ref$instanced === void 0 ? 0 : _ref$instanced;

	  _classCallCheck(this, BufferLayout);

	  this.type = type;
	  this.size = size;
	  this.offset = offset;
	  this.stride = stride;
	  this.normalized = normalized;
	  this.integer = integer;
	  this.instanced = instanced;
	};

	exports.BufferLayout = BufferLayout;

	var Buffer =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Buffer, _Resource);

	  function Buffer(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Buffer);

	    _this = _possibleConstructorReturn(this, (Buffer.__proto__ || Object.getPrototypeOf(Buffer)).call(this, gl, opts)); // In WebGL1, we need to make sure we use GL.ELEMENT_ARRAY_BUFFER when
	    // initializing element buffers, otherwise the buffer type will be locked
	    // to a generic (non-element) buffer.
	    // In WebGL2, we can use GL_COPY_READ_BUFFER which avoids locking the type here

	    _this.target = opts.target || (_this.gl.webgl2 ? GL_COPY_READ_BUFFER : GL_ARRAY_BUFFER);

	    _this.setData(opts);

	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  } // Stores the layout of data with the buffer, makes it easy to e.g. set it as an attribute later


	  _createClass(Buffer, [{
	    key: "setDataLayout",
	    value: function setDataLayout(_ref2) {
	      var layout = _ref2.layout,
	          type = _ref2.type,
	          _ref2$size = _ref2.size,
	          size = _ref2$size === void 0 ? 1 : _ref2$size,
	          _ref2$offset = _ref2.offset,
	          offset = _ref2$offset === void 0 ? 0 : _ref2$offset,
	          _ref2$stride = _ref2.stride,
	          stride = _ref2$stride === void 0 ? 0 : _ref2$stride,
	          _ref2$normalized = _ref2.normalized,
	          normalized = _ref2$normalized === void 0 ? false : _ref2$normalized,
	          _ref2$integer = _ref2.integer,
	          integer = _ref2$integer === void 0 ? false : _ref2$integer,
	          _ref2$instanced = _ref2.instanced,
	          instanced = _ref2$instanced === void 0 ? 0 : _ref2$instanced;
	      this.layout = layout || new BufferLayout({
	        type: type || this.type,
	        // Use autodeduced type if available
	        size: size,
	        offset: offset,
	        stride: stride,
	        normalized: normalized,
	        integer: integer,
	        instanced: instanced
	      });
	      return this;
	    }
	  }, {
	    key: "updateLayout",
	    value: function updateLayout(opts) {
	      Object.assign(this.layout, opts);
	    } // Creates and initializes the buffer object's data store.

	  }, {
	    key: "initialize",
	    value: function initialize() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          data = _ref3.data,
	          bytes = _ref3.bytes,
	          _ref3$usage = _ref3.usage,
	          usage = _ref3$usage === void 0 ? GL_STATIC_DRAW : _ref3$usage,
	          layout = _ref3.layout,
	          type = _ref3.type,
	          _ref3$size = _ref3.size,
	          size = _ref3$size === void 0 ? 1 : _ref3$size,
	          _ref3$offset = _ref3.offset,
	          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
	          _ref3$stride = _ref3.stride,
	          stride = _ref3$stride === void 0 ? 0 : _ref3$stride,
	          _ref3$normalized = _ref3.normalized,
	          normalized = _ref3$normalized === void 0 ? false : _ref3$normalized,
	          _ref3$integer = _ref3.integer,
	          integer = _ref3$integer === void 0 ? false : _ref3$integer,
	          _ref3$instanced = _ref3.instanced,
	          instanced = _ref3$instanced === void 0 ? 0 : _ref3$instanced,
	          _ref3$index = _ref3.index,
	          index = _ref3$index === void 0 ? null : _ref3$index;

	      var opts = arguments[0];

	      if (!data) {
	        type = type || GL_FLOAT; // Workaround needed for Safari (#291):
	        // gl.bufferData with size (second argument) equal to 0 crashes.
	        // hence create zero sized array.

	        if (!bytes || bytes === 0) {
	          bytes = 0;
	          data = new Float32Array(0);
	        }
	      } else {
	        type = type || (0, _typedArrayUtils.getGLTypeFromTypedArray)(data);
	        bytes = data.byteLength;
	        (0, _assert.default)(type);
	      }

	      this.bytes = bytes;
	      this.bytesUsed = bytes;
	      this.data = data;
	      this.type = type;
	      this.usage = usage;
	      this.index = index; // Call after type is set

	      this.setDataLayout(Object.assign(opts)); // Create the buffer - binding it here for the first time locks the type
	      // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type

	      var target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;
	      this.gl.bindBuffer(target, this.handle);
	      this.gl.bufferData(target, data || bytes, usage);
	      this.gl.bindBuffer(target, null);
	      return this;
	    } // DEPRECATED - Can we change to call `subData`?

	  }, {
	    key: "setData",
	    value: function setData(options) {
	      return this.initialize(options);
	    } // Updates a subset of a buffer object's data store.

	  }, {
	    key: "subData",
	    value: function subData() {
	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          data = _ref4.data,
	          _ref4$offset = _ref4.offset,
	          offset = _ref4$offset === void 0 ? 0 : _ref4$offset,
	          _ref4$srcOffset = _ref4.srcOffset,
	          srcOffset = _ref4$srcOffset === void 0 ? 0 : _ref4$srcOffset,
	          length = _ref4.length;

	      (0, _assert.default)(data); // Create the buffer - binding it here for the first time locks the type
	      // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type

	      var target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;
	      this.gl.bindBuffer(target, this.handle); // WebGL2: subData supports additional srcOffset and length parameters

	      if (srcOffset !== 0 || length !== undefined) {
	        (0, _webglUtils.assertWebGL2Context)(this.gl);
	        this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);
	      } else {
	        this.gl.bufferSubData(target, offset, data);
	      }

	      this.gl.bindBuffer(target, null);
	      return this;
	    } // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer

	  }, {
	    key: "copyData",
	    value: function copyData(_ref5) {
	      var sourceBuffer = _ref5.sourceBuffer,
	          _ref5$readOffset = _ref5.readOffset,
	          readOffset = _ref5$readOffset === void 0 ? 0 : _ref5$readOffset,
	          _ref5$writeOffset = _ref5.writeOffset,
	          writeOffset = _ref5$writeOffset === void 0 ? 0 : _ref5$writeOffset,
	          size = _ref5.size;
	      (0, _webglUtils.assertWebGL2Context)(this.gl); // Use GL_COPY_READ_BUFFER+GL_COPY_WRITE_BUFFER avoid disturbing other targets and locking type

	      this.gl.bindBuffer(GL_COPY_READ_BUFFER, sourceBuffer.handle);
	      this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, this.handle);
	      this.gl.copyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, readOffset, writeOffset, size);
	      this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);
	      this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, null);
	      return this;
	    } // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.

	  }, {
	    key: "getData",
	    value: function getData() {
	      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref6$dstData = _ref6.dstData,
	          dstData = _ref6$dstData === void 0 ? null : _ref6$dstData,
	          _ref6$srcByteOffset = _ref6.srcByteOffset,
	          srcByteOffset = _ref6$srcByteOffset === void 0 ? 0 : _ref6$srcByteOffset,
	          _ref6$dstOffset = _ref6.dstOffset,
	          dstOffset = _ref6$dstOffset === void 0 ? 0 : _ref6$dstOffset,
	          _ref6$length = _ref6.length,
	          length = _ref6$length === void 0 ? 0 : _ref6$length;

	      (0, _webglUtils.assertWebGL2Context)(this.gl);
	      var ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.type, {
	        clamped: false
	      });

	      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

	      var dstAvailableElementCount;
	      var dstElementCount;
	      var dstElementOffset = dstOffset;

	      if (dstData) {
	        dstElementCount = dstData.length;
	        dstAvailableElementCount = dstElementCount - dstElementOffset;
	      } else {
	        // Allocate ArrayBufferView with enough size to copy all eligible data.
	        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);
	        dstElementCount = dstElementOffset + dstAvailableElementCount;
	      }

	      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
	      length = length || copyElementCount;
	      (0, _assert.default)(length <= copyElementCount, 'Invalid srcByteOffset, dstOffset and length combination');
	      dstData = dstData || new ArrayType(dstElementCount); // Use GL_COPY_READ_BUFFER to avoid disturbing other targets and locking type

	      this.gl.bindBuffer(GL_COPY_READ_BUFFER, this.handle);
	      this.gl.getBufferSubData(GL_COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);
	      this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);
	      return dstData;
	    }
	    /**
	     * Binds a buffer to a given binding point (target).
	     *   GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.
	     *
	     * @param {Glenum} target - target for the bind operation.
	     *
	     * @param {GLuint} index= - the index of the target.
	     *   - GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state
	     * @param {GLuint} offset=0 - the index of the target.
	     *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.
	     * @param {GLuint} size= - the index of the target.
	     *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.
	     * @returns {Buffer} - Returns itself for chaining.
	     */

	  }, {
	    key: "bind",
	    value: function bind() {
	      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref7$target = _ref7.target,
	          target = _ref7$target === void 0 ? this.target : _ref7$target,
	          _ref7$index = _ref7.index,
	          index = _ref7$index === void 0 ? this.index : _ref7$index,
	          _ref7$offset = _ref7.offset,
	          offset = _ref7$offset === void 0 ? 0 : _ref7$offset,
	          size = _ref7.size;

	      // NOTE: While GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could
	      // be used as direct binding points, they will not affect transform feedback or
	      // uniform buffer state. Instead indexed bindings need to be made.
	      var type = target === GL_UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER ? size !== undefined ? 'ranged' : 'indexed' : 'non-indexed';

	      switch (type) {
	        case 'non-indexed':
	          this.gl.bindBuffer(target, this.handle);
	          break;

	        case 'indexed':
	          (0, _webglUtils.assertWebGL2Context)(this.gl);
	          (0, _assert.default)(offset === 0); // Make sure offset wasn't supplied

	          this.gl.bindBufferBase(target, index, this.handle);
	          break;

	        case 'ranged':
	          (0, _webglUtils.assertWebGL2Context)(this.gl);
	          this.gl.bindBufferRange(target, index, this.handle, offset, size);
	          break;

	        default:
	          (0, _assert.default)(false);
	      }

	      return this;
	    }
	  }, {
	    key: "unbind",
	    value: function unbind() {
	      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref8$target = _ref8.target,
	          target = _ref8$target === void 0 ? this.target : _ref8$target,
	          _ref8$index = _ref8.index,
	          index = _ref8$index === void 0 ? this.index : _ref8$index;

	      var isIndexedBuffer = target === GL_UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER;

	      if (isIndexedBuffer) {
	        this.gl.bindBufferBase(target, index, null);
	      } else {
	        this.gl.bindBuffer(target, null);
	      }

	      return this;
	    } // TODO - is this the right place?
	    // gl.TRANSFORM_FEEDBACK_BUFFER_BINDING: Returns a WebGLBuffer.
	    // gl.TRANSFORM_FEEDBACK_BUFFER_SIZE: Returns a GLsizeiptr.
	    // gl.TRANSFORM_FEEDBACK_BUFFER_START: Returns a GLintptr.
	    // gl.UNIFORM_BUFFER_BINDING: Returns a WebGLBuffer.
	    // gl.UNIFORM_BUFFER_SIZE: Returns a GLsizeiptr.
	    // gl.UNIFORM_BUFFER_START: Returns a GLintptr.

	  }, {
	    key: "getIndexedParameter",
	    value: function getIndexedParameter(binding, index) {
	      // Create the buffer - if binding it here for the first time, this locks the type
	      // In WebGL2, use GL_COPY_READ_BUFFER to avoid locking the type
	      var target = this.gl.webgl2 ? GL_COPY_READ_BUFFER : this.target;
	      this.gl.bindBuffer(target, index);
	      return this.gl.getIndexedParameter(binding, index);
	    } // RESOURCE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createBuffer();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteBuffer(this.handle);
	    }
	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname) {
	      this.gl.bindBuffer(this.target, this.handle);
	      var value = this.gl.getBufferParameter(this.target, pname);
	      this.gl.bindBuffer(this.target, null);
	      return value;
	    }
	  }, {
	    key: "_getAvailableElementCount",
	    value: function _getAvailableElementCount(srcByteOffset) {
	      var ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(this.type, {
	        clamped: false
	      });
	      var sourceElementCount = this.bytes / ArrayType.BYTES_PER_ELEMENT;
	      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
	      return sourceElementCount - sourceElementOffset;
	    }
	  }]);

	  return Buffer;
	}(_resource.default);

	exports.default = Buffer;
	//# sourceMappingURL=buffer.js.map

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _init = _interopRequireDefault(__webpack_require__(84));

	var _webglContext = __webpack_require__(77);

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods'; // TODO - Handle context loss
	// function glGetContextLossCount(gl) {
	//   return (gl.luma && gl.luma.glCount) || 0;
	// }

	var Resource =
	/*#__PURE__*/
	function () {
	  function Resource(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Resource);

	    (0, _webglUtils.assertWebGLContext)(gl);
	    var id = opts.id,
	        _opts$userData = opts.userData,
	        userData = _opts$userData === void 0 ? {} : _opts$userData;
	    this.gl = gl;
	    this.ext = (0, _webglContext.polyfillContext)(gl);
	    this.id = id || (0, _utils.uid)(this.constructor.name);
	    this.userData = userData;
	    this.opts = opts; // Set the handle
	    // If handle was provided, use it, otherwise create a new handle
	    // TODO - Stores the handle with context loss information
	    // this.glCount = glGetContextLossCount(this.gl);
	    // Default VertexArray needs to be created with null handle, so compare against undefined

	    this._handle = opts.handle;

	    if (this._handle === undefined) {
	      this._handle = this._createHandle();
	    }

	    this._addStats();
	  }

	  _createClass(Resource, [{
	    key: "toString",
	    value: function toString() {
	      return "".concat(this.constructor.name, "(").concat(this.id, ")");
	    }
	  }, {
	    key: "delete",
	    value: function _delete() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$deleteChildren = _ref.deleteChildren,
	          deleteChildren = _ref$deleteChildren === void 0 ? false : _ref$deleteChildren;

	      // Delete this object, and get refs to any children
	      var children = this._handle && this._deleteHandle(this._handle);

	      this._handle = null;

	      this._removeStats(); // Optionally, recursively delete the children


	      if (children && deleteChildren) {
	        children.filter(Boolean).forEach(function (child) {
	          child.delete();
	        });
	      }

	      return this;
	    }
	  }, {
	    key: "unbind",
	    value: function unbind() {
	      this.bind(null);
	    }
	    /**
	     * Query a Resource parameter
	     *
	     * @param {GLenum} pname
	     * @return {GLint|GLfloat|GLenum} param
	     */

	  }, {
	    key: "getParameter",
	    value: function getParameter(pname) {
	      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      pname = (0, _webglUtils.getKeyValue)(this.gl, pname);
	      (0, _assert.default)(pname);
	      var parameters = this.constructor.PARAMETERS || {}; // Use parameter definitions to handle unsupported parameters

	      var parameter = parameters[pname];

	      if (parameter) {
	        var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl); // Check if we can query for this parameter

	        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

	        if (!parameterAvailable) {
	          var webgl1Default = parameter.webgl1;
	          var webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
	          var defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
	          return defaultValue;
	        }
	      } // If unknown parameter - Could be a valid parameter not covered by PARAMS
	      // Attempt to query for it and let WebGL report errors


	      return this._getParameter(pname, opts);
	    } // Many resources support a getParameter call -
	    // getParameters will get all parameters - slow but useful for debugging

	  }, {
	    key: "getParameters",
	    value: function getParameters() {
	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _ref2 = {},
	          parameters = _ref2.parameters,
	          keys = _ref2.keys; // Get parameter definitions for this Resource

	      var PARAMETERS = this.constructor.PARAMETERS || {};
	      var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl);
	      var values = {}; // Query all parameters if no list provided

	      var parameterKeys = parameters || Object.keys(PARAMETERS); // WEBGL limits

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var pname = _step.value;
	          var parameter = PARAMETERS[pname]; // Check if this parameter is available on this platform

	          var parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

	          if (parameterAvailable) {
	            var key = keys ? (0, _webglUtils.getKey)(this.gl, pname) : pname;
	            values[key] = this.getParameter(pname, opts);

	            if (keys && parameter.type === 'GLenum') {
	              values[key] = (0, _webglUtils.getKey)(this.gl, values[key]);
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return values;
	    }
	    /**
	     * Update a Resource setting
	     *
	     * @todo - cache parameter to avoid issuing WebGL calls?
	     *
	     * @param {GLenum} pname - parameter (GL constant, value or key)
	     * @param {GLint|GLfloat|GLenum} value
	     * @return {Resource} returns self to enable chaining
	     */

	  }, {
	    key: "setParameter",
	    value: function setParameter(pname, value) {
	      pname = (0, _webglUtils.getKeyValue)(this.gl, pname);
	      (0, _assert.default)(pname);
	      var parameters = this.constructor.PARAMETERS || {};
	      var parameter = parameters[pname];

	      if (parameter) {
	        var isWebgl2 = (0, _webglUtils.isWebGL2)(this.gl); // Check if this parameter is available on this platform

	        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

	        if (!parameterAvailable) {
	          throw new Error('Parameter not available on this platform');
	        } // Handle string keys


	        if (parameter.type === 'GLenum') {
	          value = (0, _webglUtils.getKeyValue)(value);
	        }
	      } // If unknown parameter - Could be a valid parameter not covered by PARAMS
	      // attempt to set it and let WebGL report errors


	      this._setParameter(pname, value);

	      return this;
	    }
	    /*
	     * Batch update resource parameters
	     * Assumes the subclass supports a setParameter call
	     */

	  }, {
	    key: "setParameters",
	    value: function setParameters(parameters) {
	      for (var pname in parameters) {
	        this.setParameter(pname, parameters[pname]);
	      }

	      return this;
	    } // PUBLIC VIRTUAL METHODS

	  }, {
	    key: "initialize",
	    value: function initialize(opts) {} // PROTECTED METHODS - These must be overridden by subclass

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
	    }
	  }, {
	    key: "_getOptsFromHandle",
	    value: function _getOptsFromHandle() {
	      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
	    }
	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname, opts) {
	      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
	    }
	    /**
	     * @param {GLenum} pname
	     * @param {GLint|GLfloat|GLenum} param
	     * @return {Sampler} returns self to enable chaining
	     */

	  }, {
	    key: "_setParameter",
	    value: function _setParameter(pname, value) {
	      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
	    } // PRIVATE METHODS

	  }, {
	    key: "_context",
	    value: function _context() {
	      this.gl.luma = this.gl.luma || {};
	      return this.gl.luma;
	    }
	  }, {
	    key: "_addStats",
	    value: function _addStats() {
	      var name = this.constructor.name;
	      var stats = _init.default.stats;
	      stats.resourceCount = stats.resourceCount || 0;
	      stats.resourceMap = stats.resourceMap || {}; // Resource creation stats

	      stats.resourceCount++;
	      stats.resourceMap[name] = stats.resourceMap[name] || {
	        created: 0,
	        active: 0
	      };
	      stats.resourceMap[name].created++;
	      stats.resourceMap[name].active++;
	    }
	  }, {
	    key: "_removeStats",
	    value: function _removeStats() {
	      var name = this.constructor.name;
	      var stats = _init.default.stats;
	      stats.resourceMap[name].active--;
	    }
	  }, {
	    key: "handle",
	    get: function get() {
	      // TODO - Add context loss handling
	      // Will regenerate and reinitialize the handle if necessary
	      // const glCount = glGetContextLossCount(this.gl);
	      // if (this.glCount !== glCount) {
	      //   this._handle = this._createHandle(this.opts);
	      //   this._glCount = glCount;
	      //   // Reinitialize object
	      //   this.initialize(this.opts);
	      // }
	      return this._handle;
	    }
	  }]);

	  return Resource;
	}();

	exports.default = Resource;
	//# sourceMappingURL=resource.js.map

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "global", {
	  enumerable: true,
	  get: function get() {
	    return _globals.global;
	  }
	});
	exports.default = void 0;

	var _isBrowser = _interopRequireDefault(__webpack_require__(51));

	var _globals = __webpack_require__(50);

	var _log = _interopRequireDefault(__webpack_require__(67));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Version detection using babel plugin

	/* global __VERSION__ */
	var VERSION =  true ? "5.3.0-rc.1" : 'untranspiled source';
	var STARTUP_MESSAGE = 'set luma.log.priority=1 (or higher) to trace rendering'; // Assign luma.log.priority in console to control logging: \
	// 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
	// luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;

	if (_globals.global.luma && _globals.global.luma.VERSION !== VERSION) {
	  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(_globals.global.luma.VERSION, " vs ").concat(VERSION));
	}

	if (!_globals.global.luma) {
	  if (_isBrowser.default) {
	    _log.default.log(0, "luma.gl ".concat(VERSION, " - ").concat(STARTUP_MESSAGE))();
	  }

	  _globals.global.luma = _globals.global.luma || {
	    VERSION: VERSION,
	    version: VERSION,
	    log: _log.default,
	    // A global stats object that various components can add information to
	    // E.g. see webgl/resource.js
	    stats: {},
	    // Keep some luma globals in a sub-object
	    // This allows us to dynamically detect if certain modules have been
	    // included (such as IO and headless) and enable related functionality,
	    // without unconditionally requiring and thus bundling big dependencies
	    // into the app.
	    globals: {
	      modules: {},
	      nodeIO: {}
	    }
	  };
	}

	var _default = _globals.global.luma;
	exports.default = _default;
	//# sourceMappingURL=init.js.map

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.FragmentShader = exports.VertexShader = exports.Shader = void 0;

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';
	var GL_FRAGMENT_SHADER = 0x8B30;
	var GL_VERTEX_SHADER = 0x8B31;
	var GL_COMPILE_STATUS = 0x8B81;
	var GL_SHADER_TYPE = 0x8B4F; // For now this is an internal class

	var Shader =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Shader, _Resource);

	  _createClass(Shader, null, [{
	    key: "getTypeName",
	    value: function getTypeName(shaderType) {
	      switch (shaderType) {
	        case GL_VERTEX_SHADER:
	          return 'vertex-shader';

	        case GL_FRAGMENT_SHADER:
	          return 'fragment-shader';

	        default:
	          (0, _assert.default)(false);
	          return 'unknown';
	      }
	    }
	    /* eslint-disable max-statements */

	  }]);

	  function Shader(gl, source, shaderType) {
	    var _this;

	    _classCallCheck(this, Shader);

	    (0, _webglUtils.assertWebGLContext)(gl);
	    (0, _assert.default)(typeof source === 'string', ERR_SOURCE);
	    _this = _possibleConstructorReturn(this, (Shader.__proto__ || Object.getPrototypeOf(Shader)).call(this, gl, {
	      id: (0, _webglUtils.getShaderName)(source) || (0, _utils.uid)(Shader.getTypeName(shaderType))
	    }));
	    _this.shaderType = shaderType;
	    _this.source = source;
	    _this.opts.source = source;

	    _this.initialize(_this.opts);

	    return _this;
	  }

	  _createClass(Shader, [{
	    key: "initialize",
	    value: function initialize(_ref) {
	      var source = _ref.source;
	      var shaderName = (0, _webglUtils.getShaderName)(source);

	      if (shaderName) {
	        this.id = (0, _utils.uid)(shaderName);
	      }

	      this._compile(source);

	      this.opts.source = source;
	    } // Accessors

	  }, {
	    key: "getParameter",
	    value: function getParameter(pname) {
	      return this.gl.getShaderParameter(this.handle, pname);
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return "".concat(this.getTypeName(this.shaderType), ":").concat(this.id);
	    }
	  }, {
	    key: "getName",
	    value: function getName() {
	      return (0, _webglUtils.getShaderName)(this.opts.source) || 'unnamed-shader';
	    }
	  }, {
	    key: "getSource",
	    value: function getSource() {
	      return this.gl.getShaderSource(this.handle);
	    } // Debug method - Returns translated source if available

	  }, {
	    key: "getTranslatedSource",
	    value: function getTranslatedSource() {
	      var extension = this.gl.getExtension('WEBGL_debug_shaders');
	      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';
	    } // PRIVATE METHODS

	  }, {
	    key: "_compile",
	    value: function _compile() {
	      this.gl.shaderSource(this.handle, this.source);
	      this.gl.compileShader(this.handle); // TODO - For performance reasons, avoid checking shader compilation errors on production?
	      // TODO - Load log even when no error reported, to catch warnings?
	      // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings

	      var compileStatus = this.getParameter(GL_COMPILE_STATUS);

	      if (!compileStatus) {
	        var infoLog = this.gl.getShaderInfoLog(this.handle);

	        var _parseGLSLCompilerErr = (0, _webglUtils.parseGLSLCompilerError)(infoLog, this.source, this.shaderType),
	            shaderName = _parseGLSLCompilerErr.shaderName,
	            errors = _parseGLSLCompilerErr.errors,
	            warnings = _parseGLSLCompilerErr.warnings;

	        _utils.log.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();

	        _utils.log.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();

	        throw new Error("GLSL compilation errors in ".concat(shaderName));
	      }
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteShader(this.handle);
	    }
	  }, {
	    key: "_getOptsFromHandle",
	    value: function _getOptsFromHandle() {
	      return {
	        type: this.getParameter(GL_SHADER_TYPE),
	        source: this.getSource()
	      };
	    }
	  }]);

	  return Shader;
	}(_resource.default);

	exports.Shader = Shader;

	var VertexShader =
	/*#__PURE__*/
	function (_Shader) {
	  _inherits(VertexShader, _Shader);

	  function VertexShader(gl, source) {
	    _classCallCheck(this, VertexShader);

	    return _possibleConstructorReturn(this, (VertexShader.__proto__ || Object.getPrototypeOf(VertexShader)).call(this, gl, source, GL_VERTEX_SHADER));
	  } // PRIVATE METHODS


	  _createClass(VertexShader, [{
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createShader(GL_VERTEX_SHADER);
	    }
	  }]);

	  return VertexShader;
	}(Shader);

	exports.VertexShader = VertexShader;

	var FragmentShader =
	/*#__PURE__*/
	function (_Shader2) {
	  _inherits(FragmentShader, _Shader2);

	  function FragmentShader(gl, source) {
	    _classCallCheck(this, FragmentShader);

	    return _possibleConstructorReturn(this, (FragmentShader.__proto__ || Object.getPrototypeOf(FragmentShader)).call(this, gl, source, GL_FRAGMENT_SHADER));
	  } // PRIVATE METHODS


	  _createClass(FragmentShader, [{
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createShader(GL_FRAGMENT_SHADER);
	    }
	  }]);

	  return FragmentShader;
	}(Shader);

	exports.FragmentShader = FragmentShader;
	//# sourceMappingURL=shader.js.map

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getUniformDescriptors = getUniformDescriptors;
	exports.getVaryingMap = getVaryingMap;
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _vertexArray = _interopRequireDefault(__webpack_require__(87));

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _texture = _interopRequireDefault(__webpack_require__(88));

	var _framebuffer = _interopRequireDefault(__webpack_require__(89));

	var _uniforms = __webpack_require__(94);

	var _shader = __webpack_require__(85);

	var _buffer2 = _interopRequireDefault(__webpack_require__(82));

	var _contextState = __webpack_require__(78);

	var _webglUtils = __webpack_require__(48);

	var _attributeUtils = __webpack_require__(96);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return _get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var LOG_PROGRAM_PERF_PRIORITY = 3; // const GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;
	// const GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;
	// MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS : 0x8C80,
	// TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,
	// TRANSFORM_FEEDBACK_BUFFER_SIZE : 0x8C85,
	// TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,
	// MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,
	// MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,

	var GL_INTERLEAVED_ATTRIBS = 0x8C8C;
	var GL_SEPARATE_ATTRIBS = 0x8C8D;

	var Program =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Program, _Resource);

	  function Program(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Program);

	    _this = _possibleConstructorReturn(this, (Program.__proto__ || Object.getPrototypeOf(Program)).call(this, gl, opts));

	    _this.initialize(opts);

	    _this.vertexAttributes = _vertexArray.default.getDefaultArray(gl);
	    Object.seal(_assertThisInitialized(_this));

	    _this._setId(opts.id);

	    return _this;
	  }

	  _createClass(Program, [{
	    key: "initialize",
	    value: function initialize() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          vs = _ref.vs,
	          fs = _ref.fs,
	          defaultUniforms = _ref.defaultUniforms,
	          varyings = _ref.varyings,
	          _ref$bufferMode = _ref.bufferMode,
	          bufferMode = _ref$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _ref$bufferMode;

	      // Create shaders if needed
	      this.vs = typeof vs === 'string' ? new _shader.VertexShader(this.gl, vs) : vs;
	      this.fs = typeof fs === 'string' ? new _shader.FragmentShader(this.gl, fs) : fs;
	      (0, _assert.default)(_instanceof(this.vs, _shader.VertexShader), 'Program: bad vertex shader');
	      (0, _assert.default)(_instanceof(this.fs, _shader.FragmentShader), 'Program: bad fragment shader');
	      this.defaultUniforms = defaultUniforms; // Setup varyings if supplied

	      if (varyings) {
	        (0, _webglUtils.assertWebGL2Context)(this.gl);
	        this.varyings = varyings;
	        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
	        this.varyingMap = getVaryingMap(varyings, bufferMode);
	      } else {
	        this.varyingMap = {};
	      }

	      this._compileAndLink(); // Experimental flag to avoid deleting Program object while it is cached


	      this._isCached = false;
	      return this;
	    } // Generates warning if a vertex shader attribute is not setup.

	  }, {
	    key: "checkAttributeBindings",
	    value: function checkAttributeBindings(_ref2) {
	      var vertexArray = _ref2.vertexArray;
	      var filledLocations = vertexArray ? vertexArray.filledLocations : this.vertexAttributes.filledLocations;

	      for (var attributeName in this._attributeToLocationMap) {
	        var location = this._attributeToLocationMap[attributeName];

	        if (!filledLocations[location] && !this._warnedLocations[location]) {
	          // throw new Error(`Program ${this.id}: ` +
	          //   `Attribute ${location}:${attributeName} not supplied`);
	          _utils.log.warn("Program ".concat(this.id, ": Attribute ").concat(location, ":").concat(attributeName, " not supplied"))();

	          this._warnedLocations[location] = true;
	        }
	      }

	      return this;
	    }
	  }, {
	    key: "delete",
	    value: function _delete() {
	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      if (this._isCached) {
	        // This object is cached, do not delete
	        return this;
	      }

	      return _get(Program.prototype.__proto__ || Object.getPrototypeOf(Program.prototype), "delete", this).call(this, opts);
	    }
	  }, {
	    key: "reset",
	    value: function reset() {
	      this.unsetBuffers(); // TODO - reset uniforms and attributes to initial state
	    }
	  }, {
	    key: "use",
	    value: function use() {
	      this.gl.useProgram(this.handle);
	      return this;
	    } // A good thing about webGL is that there are so many ways to draw things,
	    // e.g. depending on whether data is indexed and/or isInstanced.
	    // This function unifies those into a single call with simple parameters
	    // that have sane defaults.

	  }, {
	    key: "draw",
	    value: function draw(_ref3) {
	      var _this2 = this;

	      var _ref3$drawMode = _ref3.drawMode,
	          drawMode = _ref3$drawMode === void 0 ? _constants.default.TRIANGLES : _ref3$drawMode,
	          vertexCount = _ref3.vertexCount,
	          _ref3$offset = _ref3.offset,
	          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
	          start = _ref3.start,
	          end = _ref3.end,
	          _ref3$isIndexed = _ref3.isIndexed,
	          isIndexed = _ref3$isIndexed === void 0 ? false : _ref3$isIndexed,
	          _ref3$indexType = _ref3.indexType,
	          indexType = _ref3$indexType === void 0 ? _constants.default.UNSIGNED_SHORT : _ref3$indexType,
	          _ref3$isInstanced = _ref3.isInstanced,
	          isInstanced = _ref3$isInstanced === void 0 ? false : _ref3$isInstanced,
	          _ref3$instanceCount = _ref3.instanceCount,
	          instanceCount = _ref3$instanceCount === void 0 ? 0 : _ref3$instanceCount,
	          _ref3$vertexArray = _ref3.vertexArray,
	          vertexArray = _ref3$vertexArray === void 0 ? null : _ref3$vertexArray,
	          _ref3$transformFeedba = _ref3.transformFeedback,
	          transformFeedback = _ref3$transformFeedba === void 0 ? null : _ref3$transformFeedba,
	          _ref3$uniforms = _ref3.uniforms,
	          uniforms = _ref3$uniforms === void 0 ? {} : _ref3$uniforms,
	          _ref3$samplers = _ref3.samplers,
	          samplers = _ref3$samplers === void 0 ? {} : _ref3$samplers,
	          _ref3$parameters = _ref3.parameters,
	          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;
	      vertexArray = vertexArray || _vertexArray.default.getDefaultArray(this.gl);
	      vertexArray.bind(function () {
	        _this2.gl.useProgram(_this2.handle);

	        if (transformFeedback) {
	          var primitiveMode = (0, _attributeUtils.getPrimitiveDrawMode)(drawMode);
	          transformFeedback.begin(primitiveMode);
	        }

	        _this2.setUniforms(uniforms, samplers);

	        (0, _contextState.withParameters)(_this2.gl, parameters, function () {
	          // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension
	          if (isIndexed && isInstanced) {
	            _this2.ext.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
	          } else if (isIndexed && (0, _webglUtils.isWebGL2)(_this2.gl) && !isNaN(start) && !isNaN(end)) {
	            _this2.gl.drawElementsRange(drawMode, start, end, vertexCount, indexType, offset);
	          } else if (isIndexed) {
	            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);
	          } else if (isInstanced) {
	            _this2.ext.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
	          } else {
	            _this2.gl.drawArrays(drawMode, offset, vertexCount);
	          }
	        }); // this.gl.useProgram(null);

	        if (transformFeedback) {
	          transformFeedback.end();
	        }
	      });
	      return this;
	    }
	    /**
	     * Attach a map of Buffers values to a program
	     * Only attributes with names actually present in the linked program
	     * will be updated. Other supplied buffers will be ignored.
	     *
	     * @param {Object} attributes - An object map with attribute names being keys
	     *  and values are expected to be instances of Attribute.
	     * @returns {Program} Returns itself for chaining.
	     */

	  }, {
	    key: "setAttributes",
	    value: function setAttributes(attributes) {
	      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref4$clear = _ref4.clear,
	          clear = _ref4$clear === void 0 ? true : _ref4$clear,
	          _ref4$drawParams = _ref4.drawParams,
	          drawParams = _ref4$drawParams === void 0 ? {} : _ref4$drawParams;

	      if (clear) {
	        this.vertexAttributes.clearBindings();
	      } // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER
	      // index type is saved for drawElement calls


	      drawParams.isInstanced = false;
	      drawParams.isIndexed = false;
	      drawParams.indexType = null;

	      var _sortBuffersByLocatio = this._sortBuffersByLocation(attributes),
	          locations = _sortBuffersByLocatio.locations,
	          elements = _sortBuffersByLocatio.elements; // Process locations in order


	      for (var location = 0; location < locations.length; ++location) {
	        var attributeName = locations[location];
	        var attribute = attributes[attributeName]; // DISABLE MISSING ATTRIBUTE

	        if (!attribute) {
	          this.vertexAttributes.disable(location);
	        } else if (attribute.isGeneric) {
	          this._setAttributeToGeneric({
	            location: location,
	            array: attribute.value
	          });
	        } else {
	          this._setAttributeToBuffer({
	            location: location,
	            buffer: attribute.getBuffer(),
	            layout: attribute
	          });

	          Object.assign(drawParams, {
	            isInstanced: attribute.instanced > 0
	          });
	        }
	      } // SET ELEMENTS ARRAY BUFFER


	      if (elements) {
	        var _attribute = attributes[elements];

	        _attribute.getBuffer().bind();

	        drawParams.isIndexed = true;
	        drawParams.indexType = _attribute.type;
	      }

	      return this;
	    }
	    /**
	     * Attach a map of Buffers values to a program
	     * Only attributes with names actually present in the linked program
	     * will be updated. Other supplied buffers will be ignored.
	     *
	     * @param {Object} buffers - An object map with attribute names being keys
	     *  and values are expected to be instances of Buffer.
	     * @returns {Program} Returns itself for chaining.
	     */

	    /* eslint-disable max-statements */

	  }, {
	    key: "setBuffers",
	    value: function setBuffers(buffers) {
	      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref5$clear = _ref5.clear,
	          clear = _ref5$clear === void 0 ? true : _ref5$clear,
	          _ref5$drawParams = _ref5.drawParams,
	          drawParams = _ref5$drawParams === void 0 ? {} : _ref5$drawParams;

	      _utils.log.deprecated('Program: `setBuffers`', '`setAttributes`');

	      if (clear) {
	        this.vertexAttributes.clearBindings();
	      } // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER
	      // index type is saved for drawElement calls


	      drawParams.isInstanced = false;
	      drawParams.isIndexed = false;
	      drawParams.indexType = null;

	      var _sortBuffersByLocatio2 = this._sortBuffersByLocation(buffers),
	          locations = _sortBuffersByLocatio2.locations,
	          elements = _sortBuffersByLocatio2.elements; // Process locations in order


	      for (var location = 0; location < locations.length; ++location) {
	        var bufferName = locations[location];
	        var buffer = buffers[bufferName]; // DISABLE MISSING ATTRIBUTE

	        if (!buffer) {
	          this.vertexAttributes.disable(location);
	        } else if (_instanceof(buffer, _buffer2.default)) {
	          this._setAttributeToBuffer({
	            location: location,
	            buffer: buffer,
	            layout: buffer.layout
	          });

	          Object.assign(drawParams, {
	            isInstanced: buffer.layout.instanced > 0
	          });
	        } else {
	          this._setAttributeToGeneric({
	            location: location,
	            array: buffer
	          });
	        }
	      } // SET ELEMENTS ARRAY BUFFER


	      if (elements) {
	        var _buffer = buffers[elements];

	        _buffer.bind();

	        drawParams.isIndexed = true;
	        drawParams.indexType = _buffer.layout.type;
	      }

	      return this;
	    }
	    /* eslint-enable max-statements */

	    /*
	     * @returns {Program} Returns itself for chaining.
	     */

	  }, {
	    key: "unsetBuffers",
	    value: function unsetBuffers() {
	      var length = this._attributeCount;

	      for (var i = 1; i < length; ++i) {
	        // this.vertexAttributes.setDivisor(i, 0);
	        this.vertexAttributes.disable(i);
	      } // Clear elements buffer


	      this.gl.bindBuffer(_constants.default.ELEMENT_ARRAY_BUFFER, null);
	      return this;
	    }
	    /**
	     * Apply a set of uniform values to a program
	     * Only uniforms with names actually present in the linked program
	     * will be updated.
	     * other uniforms will be ignored
	     *
	     * @param {Object} uniformMap - An object with names being keys
	     * @returns {Program} - returns itself for chaining.
	     */

	    /* eslint-disable max-depth */

	  }, {
	    key: "setUniforms",
	    value: function setUniforms(uniforms) {
	      var samplers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      for (var uniformName in uniforms) {
	        var uniform = uniforms[uniformName];
	        var uniformSetter = this._uniformSetters[uniformName];
	        var sampler = samplers[uniformName];

	        if (uniformSetter) {
	          if (_instanceof(uniform, _framebuffer.default)) {
	            uniform = uniform.texture;
	          }

	          if (_instanceof(uniform, _texture.default)) {
	            if (uniformSetter.textureIndex === undefined) {
	              uniformSetter.textureIndex = this._textureIndexCounter++;
	            } // Bind texture to index


	            var texture = uniform;
	            var textureIndex = uniformSetter.textureIndex;
	            texture.bind(textureIndex); // Bind a sampler (if supplied) to index

	            if (sampler) {
	              sampler.bind(textureIndex);
	            } // Set the uniform sampler to the texture index


	            uniformSetter(textureIndex);
	          } else {
	            // Just set the value
	            uniformSetter(uniform);
	          }
	        }
	      }

	      return this;
	    }
	    /* eslint-enable max-depth */
	    // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)

	  }, {
	    key: "uniformBlockBinding",
	    value: function uniformBlockBinding(blockIndex, blockBinding) {
	      (0, _webglUtils.assertWebGL2Context)(this.gl);
	      this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);
	    } // setTransformFeedbackBuffers(buffers) {
	    //   for (const buffer of buffers) {
	    //     buffer.bindBase()
	    //   }
	    // }

	    /**
	     * ATTRIBUTES API
	     * (Locations are numeric indices)
	     * @return {Number} count
	     */

	  }, {
	    key: "getAttributeCount",
	    value: function getAttributeCount() {
	      return this._getParameter(_constants.default.ACTIVE_ATTRIBUTES);
	    }
	    /**
	     * Returns location (index) of a name
	     * @param {String} attributeName - name of an attribute
	     *   (matches name in a linked shader)
	     * @returns {Number} - // array of actual attribute names from shader linking
	     */

	  }, {
	    key: "getAttributeLocation",
	    value: function getAttributeLocation(attributeName) {
	      return this.gl.getAttribLocation(this.handle, attributeName);
	    }
	    /**
	     * Returns an object with info about attribute at index "location"/
	     * @param {int} location - index of an attribute
	     * @returns {WebGLActiveInfo} - info about an active attribute
	     *   fields: {name, size, type}
	     */

	  }, {
	    key: "getAttributeInfo",
	    value: function getAttributeInfo(location) {
	      return this.gl.getActiveAttrib(this.handle, location);
	    }
	    /**
	     * UNIFORMS API
	     * (Locations are numeric indices)
	     * @return {Number} count
	     */

	  }, {
	    key: "getUniformCount",
	    value: function getUniformCount() {
	      return this._getParameter(_constants.default.ACTIVE_UNIFORMS);
	    }
	    /*
	     * @returns {WebGLActiveInfo} - object with {name, size, type}
	     */

	  }, {
	    key: "getUniformInfo",
	    value: function getUniformInfo(index) {
	      return this.gl.getActiveUniform(this.handle, index);
	    }
	    /*
	     * @returns {WebGLUniformLocation} - opaque object representing location
	     * of uniform, used by setter methods
	     */

	  }, {
	    key: "getUniformLocation",
	    value: function getUniformLocation(name) {
	      return this.gl.getUniformLocation(this.handle, name);
	    }
	  }, {
	    key: "getUniformValue",
	    value: function getUniformValue(location) {
	      return this.gl.getUniform(this.handle, location);
	    }
	    /* eslint-disable max-len */
	    // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)
	    // For valid `pname` values check :
	    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms

	  }, {
	    key: "getActiveUniforms",
	    value: function getActiveUniforms(uniformIndices, pname) {
	      return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);
	    }
	    /* eslint-enable max-len */
	    // WebGL2

	    /**
	     * @param {GLuint} index
	     * @return {WebGLActiveInfo} - object with {name, size, type}
	     */

	  }, {
	    key: "getVarying",
	    value: function getVarying(program, index) {
	      var result = this.gl.getTransformFeedbackVarying(program, index);
	      return result;
	    } // Retrieves the assigned color number binding for the user-defined varying
	    // out variable name for program. program must have previously been linked.

	  }, {
	    key: "getFragDataLocation",
	    value: function getFragDataLocation(varyingName) {
	      (0, _webglUtils.assertWebGL2Context)(this.gl);
	      return this.gl.getFragDataLocation(this.handle, varyingName);
	    } // @returns {WebGLShader[]} - array of attached WebGLShader objects

	  }, {
	    key: "getAttachedShaders",
	    value: function getAttachedShaders() {
	      return this.gl.getAttachedShaders(this.handle);
	    } // Retrieves the index of a uniform block

	  }, {
	    key: "getUniformBlockIndex",
	    value: function getUniformBlockIndex(blockName) {
	      (0, _webglUtils.assertWebGL2Context)(this.gl);
	      return this.gl.getUniformBlockIndex(this.handle, blockName);
	    }
	    /* eslint-disable max-len */
	    // Retrieves information about an active uniform block (`blockIndex`)
	    // For valid `pname` values check :
	    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter

	  }, {
	    key: "getActiveUniformBlockParameter",
	    value: function getActiveUniformBlockParameter(blockIndex, pname) {
	      (0, _webglUtils.assertWebGL2Context)(this.gl);
	      return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
	    }
	    /* eslint-enable max-len */
	    // PRIVATE METHODS

	  }, {
	    key: "_setAttributeToGeneric",
	    value: function _setAttributeToGeneric(_ref6) {
	      var location = _ref6.location,
	          array = _ref6.array;
	      this.vertexAttributes.setGeneric({
	        location: location,
	        array: array
	      });
	      this.vertexAttributes.disable(location, true);
	    }
	  }, {
	    key: "_setAttributeToBuffer",
	    value: function _setAttributeToBuffer(_ref7) {
	      var location = _ref7.location,
	          buffer = _ref7.buffer,
	          layout = _ref7.layout;
	      var divisor = layout.instanced ? 1 : 0;
	      this.vertexAttributes.setBuffer({
	        location: location,
	        buffer: buffer,
	        layout: layout
	      });
	      this.vertexAttributes.setDivisor(location, divisor);
	      this.vertexAttributes.enable(location);
	    }
	  }, {
	    key: "_compileAndLink",
	    value: function _compileAndLink() {
	      var gl = this.gl;
	      gl.attachShader(this.handle, this.vs.handle);
	      gl.attachShader(this.handle, this.fs.handle);

	      _utils.log.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();

	      gl.linkProgram(this.handle);

	      _utils.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))(); // Avoid checking program linking error in production


	      if (gl.debug || _utils.log.priority > 0) {
	        gl.validateProgram(this.handle);
	        var linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);

	        if (!linked) {
	          throw new Error("Error linking ".concat(gl.getProgramInfoLog(this.handle)));
	        }
	      }

	      this._queryAttributeLocations();

	      this._queryUniformLocations();
	    }
	  }, {
	    key: "_sortBuffersByLocation",
	    value: function _sortBuffersByLocation(buffers) {
	      var elements = null;
	      var locations = []; // Reutrn early if no buffers to be bound.

	      if ((0, _utils.isObjectEmpty)(buffers)) {
	        return {
	          locations: locations,
	          elements: elements
	        };
	      }

	      locations = new Array(this._attributeCount);

	      for (var bufferName in buffers) {
	        var buffer = buffers[bufferName];
	        var location = this._attributeToLocationMap[bufferName];

	        if (location === undefined) {
	          if (buffer.target === _constants.default.ELEMENT_ARRAY_BUFFER && elements) {
	            throw new Error("".concat(this._print(bufferName), " duplicate GL.ELEMENT_ARRAY_BUFFER"));
	          } else if (buffer.target === _constants.default.ELEMENT_ARRAY_BUFFER) {
	            elements = bufferName;
	          } else if (!this._warnedLocations[location]) {
	            _utils.log.log(2, "".concat(this._print(bufferName), " not used"))();

	            this._warnedLocations[location] = true;
	          }
	        } else {
	          if (buffer.target === _constants.default.ELEMENT_ARRAY_BUFFER) {
	            throw new Error("".concat(this._print(bufferName), ":").concat(location, " ") + 'has both location and type gl.ELEMENT_ARRAY_BUFFER');
	          }

	          locations[location] = bufferName;
	        }
	      }

	      return {
	        locations: locations,
	        elements: elements
	      };
	    } // Check that all active attributes are enabled

	  }, {
	    key: "_areAllAttributesEnabled",
	    value: function _areAllAttributesEnabled() {
	      var length = this._attributeCount;

	      for (var i = 0; i < length; ++i) {
	        if (!this.vertexAttributes.isEnabled(i)) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "_print",
	    value: function _print(bufferName) {
	      return "Program ".concat(this.id, ": Attribute ").concat(bufferName);
	    }
	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createProgram();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteProgram(this.handle);
	    }
	  }, {
	    key: "_getName",
	    value: function _getName() {
	      var programName = this.vs.getName() || this.fs.getName();
	      programName = programName.replace(/shader/i, '');
	      programName = programName ? "".concat(programName, "-program") : 'program';
	      return programName;
	    }
	  }, {
	    key: "_getOptionsFromHandle",
	    value: function _getOptionsFromHandle(handle) {
	      var shaderHandles = this.gl.getAttachedShaders(handle);
	      var opts = {};
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var shaderHandle = _step.value;
	          var type = this.gl.getShaderParameter(this.handle, _constants.default.SHADER_TYPE);

	          switch (type) {
	            case _constants.default.VERTEX_SHADER:
	              opts.vs = new _shader.VertexShader({
	                handle: shaderHandle
	              });
	              break;

	            case _constants.default.FRAGMENT_SHADER:
	              opts.fs = new _shader.FragmentShader({
	                handle: shaderHandle
	              });
	              break;

	            default:
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return opts;
	    }
	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname) {
	      return this.gl.getProgramParameter(this.handle, pname);
	    } // query attribute locations and build name to location map.

	  }, {
	    key: "_queryAttributeLocations",
	    value: function _queryAttributeLocations() {
	      this._attributeToLocationMap = {};
	      this._attributeCount = this.getAttributeCount();

	      for (var location = 0; location < this._attributeCount; location++) {
	        var name = this.getAttributeInfo(location).name;
	        this._attributeToLocationMap[name] = this.getAttributeLocation(name);
	      }

	      this._warnedLocations = {};
	    } // query uniform locations and build name to setter map.

	  }, {
	    key: "_queryUniformLocations",
	    value: function _queryUniformLocations() {
	      var gl = this.gl;
	      this._uniformSetters = {};
	      this._uniformCount = this.getUniformCount();

	      for (var i = 0; i < this._uniformCount; i++) {
	        var info = this.getUniformInfo(i);
	        var parsedName = (0, _uniforms.parseUniformName)(info.name);
	        var location = this.getUniformLocation(parsedName.name);
	        this._uniformSetters[parsedName.name] = (0, _uniforms.getUniformSetter)(gl, location, info, parsedName.isArray);
	      }

	      this._textureIndexCounter = 0;
	    }
	  }, {
	    key: "_setId",
	    value: function _setId(id) {
	      // If program is not named, name it after shader names
	      if (!id) {
	        var programName = this._getName(); // TODO - this.id will already have been initialized


	        this.id = (0, _utils.uid)(programName);
	      }
	    }
	  }]);

	  return Program;
	}(_resource.default); // create uniform setters
	// Map of uniform names to setter functions


	exports.default = Program;

	function getUniformDescriptors(gl, program) {
	  var uniformDescriptors = {};
	  var length = program.getUniformCount();

	  for (var i = 0; i < length; i++) {
	    var info = program.getUniformInfo(i);
	    var location = program.getUniformLocation(info.name);
	    var descriptor = (0, _uniforms.getUniformSetter)(gl, location, info);
	    uniformDescriptors[descriptor.name] = descriptor;
	  }

	  return uniformDescriptors;
	} // Get a map of buffer indices


	function getVaryingMap(varyings, bufferMode) {
	  var varyingMap = {};
	  var index = 0;
	  (0, _assert.default)(bufferMode === GL_SEPARATE_ATTRIBS || bufferMode === GL_INTERLEAVED_ATTRIBS);
	  var indexIncrement = bufferMode === GL_SEPARATE_ATTRIBS ? 1 : 0;
	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = varyings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var varying = _step2.value;
	      varyingMap[varying] = index;
	      index += indexIncrement;
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  return varyingMap;
	}
	//# sourceMappingURL=program.js.map

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	/* eslint-disable camelcase */
	var OES_vertex_array_object = 'OES_vertex_array_object';
	var GL_ELEMENT_ARRAY_BUFFER = 0x8893; // const GL_CURRENT_VERTEX_ATTRIB = 0x8626;

	var GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
	var GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
	var GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
	var GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
	var GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
	var GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
	var GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
	var GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;
	var GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;
	var PARAMETERS = [GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_POINTER, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR];
	var ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';

	var VertexArray =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(VertexArray, _Resource);

	  _createClass(VertexArray, [{
	    key: "MAX_ATTRIBUTES",
	    get: function get() {
	      return this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS);
	    } // Create a VertexArray

	  }], [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      return (0, _webglUtils.isWebGL2)(gl) || gl.getExtension(OES_vertex_array_object);
	    }
	  }, {
	    key: "getDefaultArray",
	    value: function getDefaultArray(gl) {
	      gl.luma = gl.luma || {};

	      if (!gl.luma.defaultVertexArray) {
	        gl.luma.defaultVertexArray = new VertexArray(gl, {
	          handle: null
	        });
	      }

	      return gl.luma.defaultVertexArray;
	    }
	  }, {
	    key: "getMaxAttributes",
	    value: function getMaxAttributes(gl) {
	      return gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
	    }
	  }]);

	  function VertexArray(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, VertexArray);

	    _this = _possibleConstructorReturn(this, (VertexArray.__proto__ || Object.getPrototypeOf(VertexArray)).call(this, gl, opts));
	    _this.elements = null;
	    _this.buffers = {}; // new Array(this.MAX_VERTEX_ATTRIBS).fill(null);

	    _this.locations = {};
	    _this.names = {};
	    _this.drawParameters = {};
	    _this._bound = false;
	    _this._filledLocations = {};
	    Object.seal(_assertThisInitialized(_this));

	    _this.initialize(opts);

	    return _this;
	  }

	  _createClass(VertexArray, [{
	    key: "initialize",
	    value: function initialize() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$buffers = _ref.buffers,
	          buffers = _ref$buffers === void 0 ? {} : _ref$buffers,
	          _ref$elements = _ref.elements,
	          elements = _ref$elements === void 0 ? null : _ref$elements,
	          _ref$locations = _ref.locations,
	          locations = _ref$locations === void 0 ? {} : _ref$locations;

	      this.setLocations(locations);
	      this.setBuffers(buffers, {
	        clear: true
	      });
	      this.setElements(elements);
	    }
	  }, {
	    key: "setBuffer",
	    // Set a location in vertex attributes array to a buffer
	    value: function setBuffer() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          location = _ref2.location,
	          buffer = _ref2.buffer,
	          target = _ref2.target,
	          layout = _ref2.layout;

	      var gl = this.gl; // Copy main data characteristics from buffer

	      target = target !== undefined ? target : buffer.target;
	      layout = layout !== undefined ? layout : buffer.layout;
	      (0, _utils.assert)(target, 'setBuffer needs target');
	      (0, _utils.assert)(layout, 'setBuffer called on uninitialized buffer');
	      this._filledLocations[location] = true;
	      this.bind(function () {
	        // a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target
	        buffer.bind({
	          target: gl.ARRAY_BUFFER
	        });
	        var _layout = layout,
	            size = _layout.size,
	            type = _layout.type,
	            normalized = _layout.normalized,
	            stride = _layout.stride,
	            offset = _layout.offset; // Attach _bound ARRAY_BUFFER with specified buffer format to location

	        if (!layout.integer) {
	          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
	        } else {
	          // specifies *integer* data formats and locations of vertex attributes
	          (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));
	          gl.vertexAttribIPointer(location, size, type, stride, offset);
	        }
	      });
	    } // Set (bind) an array or map of vertex array buffers, either in numbered or
	    // named locations. (named locations requires `locations` to have been provided).
	    // For names that are not present in `location`, the supplied buffers will be ignored.
	    // if a single buffer of type GL.ELEMENT_ARRAY_BUFFER is present, it will be set as elements
	    // @param {Object} buffers - An object map with attribute names being keys
	    //   and values are expected to be instances of Buffer.

	  }, {
	    key: "setBuffers",
	    value: function setBuffers(buffers) {
	      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref3$clear = _ref3.clear,
	          clear = _ref3$clear === void 0 ? true : _ref3$clear;

	      if (clear) {
	        this.clearBindings();
	      }

	      var _getLocations2 = this._getLocations(buffers),
	          locations = _getLocations2.locations,
	          elements = _getLocations2.elements;

	      this.ext.bindVertexArray(this.handle); // Process locations in order

	      for (var location in locations) {
	        var bufferData = locations[location];

	        if (bufferData) {
	          var _getBufferAndLayout2 = this._getBufferAndLayout(bufferData),
	              buffer = _getBufferAndLayout2.buffer,
	              layout = _getBufferAndLayout2.layout;

	          this.setBuffer({
	            location: location,
	            buffer: buffer,
	            layout: layout
	          });
	          this.setDivisor(location, layout.instanced ? 1 : 0);
	          this.enable(location);
	        } else {
	          // DISABLE MISSING ATTRIBUTE
	          this.disable(location);
	        }
	      }

	      this.buffers = buffers;
	      this.ext.bindVertexArray(null);

	      if (elements) {
	        this.setElements(elements);
	      }
	    } // Register an optional buffer name to location mapping

	  }, {
	    key: "setLocations",
	    value: function setLocations(locations) {
	      this.locations = locations;
	      this.names = {};
	    } // Set (bind) an elements buffer, for indexed rendering. Must be GL.ELEMENT_ARRAY_BUFFER

	  }, {
	    key: "setElements",
	    value: function setElements(elements) {
	      (0, _utils.assert)(!elements || elements.target === GL_ELEMENT_ARRAY_BUFFER, ERR_ELEMENTS);
	      this.ext.bindVertexArray(this.handle);
	      this.gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, elements && elements.handle);
	      this.ext.bindVertexArray(null);
	      this.elements = elements;
	      return this;
	    }
	  }, {
	    key: "clearBindings",
	    value: function clearBindings() {
	      var _this2 = this;

	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref4$disableZero = _ref4.disableZero,
	          disableZero = _ref4$disableZero === void 0 ? false : _ref4$disableZero;

	      this.bind(function () {
	        for (var location in _this2._filledLocations) {
	          if (_this2._filledLocations[location] && (location > 0 || disableZero)) {
	            _this2.gl.disableVertexAttribArray(location);
	          }
	        }

	        _this2._filledLocations = {};
	      });
	    } // Enable an attribute

	  }, {
	    key: "enable",
	    value: function enable(location) {
	      var _this3 = this;

	      this.bind(function () {
	        _this3.gl.enableVertexAttribArray(location);
	      });
	    } // Disable an attribute
	    // Perf penalty when disabling attribute 0:
	    // https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
	    // this-has-significant-performance-penalt

	  }, {
	    key: "disable",
	    value: function disable(location) {
	      var _this4 = this;

	      var disableZero = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (location > 0 || disableZero) {
	        this.bind(function () {
	          _this4.gl.disableVertexAttribArray(location);
	        });
	      }
	    } // Set the frequency divisor used for instanced rendering.

	  }, {
	    key: "setDivisor",
	    value: function setDivisor(location, divisor) {
	      var _this5 = this;

	      this.bind(function () {
	        _this5.ext.vertexAttribDivisor(location, divisor);
	      });
	    } // Specify values for generic vertex attributes

	  }, {
	    key: "setGeneric",
	    value: function setGeneric(_ref5) {
	      var location = _ref5.location,
	          array = _ref5.array;
	      this._filledLocations[location] = true;

	      switch (array.constructor) {
	        case Float32Array:
	          this._setGenericFloatArray(location, array);

	          break;

	        case Int32Array:
	          this._setGenericIntArray(location, array);

	          break;

	        case Uint32Array:
	          this._setGenericUintArray(location, array);

	          break;

	        default:
	          this.setGenericValues.apply(this, [location].concat(_toConsumableArray(array)));
	      }
	    } // Specify values for generic vertex attributes

	  }, {
	    key: "setGenericValues",
	    value: function setGenericValues(location, v0, v1, v2, v3) {
	      var gl = this.gl;

	      switch (arguments.length - 1) {
	        case 1:
	          gl.vertexAttrib1f(location, v0);
	          break;

	        case 2:
	          gl.vertexAttrib2f(location, v0, v1);
	          break;

	        case 3:
	          gl.vertexAttrib3f(location, v0, v1, v2);
	          break;

	        case 4:
	          gl.vertexAttrib4f(location, v0, v1, v2, v3);
	          break;

	        default:
	          (0, _utils.assert)(false);
	      } // assert(gl instanceof WebGL2RenderingContext, 'WebGL2 required');
	      // Looks like these will check how many arguments were supplied?
	      // gl.vertexAttribI4i(location, v0, v1, v2, v3);
	      // gl.vertexAttribI4ui(location, v0, v1, v2, v3);

	    }
	  }, {
	    key: "bind",
	    value: function bind() {
	      var funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;

	      if (typeof funcOrHandle !== 'function') {
	        this.bindVertexArray(funcOrHandle);
	        return this;
	      }

	      var value;

	      if (!this._bound) {
	        this.ext.bindVertexArray(this.handle);
	        this._bound = true;
	        value = funcOrHandle();
	        this.ext.bindVertexArray(null);
	        this._bound = false;
	      } else {
	        value = funcOrHandle();
	      }

	      return value;
	    } // PRIVATE
	    // Auto detect draw parameters from the complement of buffers provided

	  }, {
	    key: "_deduceDrawParameters",
	    value: function _deduceDrawParameters() {
	      // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER
	      // index type is saved for drawElement calls
	      var isInstanced = false;
	      var isIndexed = false;
	      var indexType = null; // Check if we have an elements array buffer

	      if (this.elements) {
	        isIndexed = true;
	        indexType = this.elements.layout.type;
	      } // Check if any instanced buffers


	      this.buffers.forEach(function (buffer) {
	        if (buffer.layout.instanced > 0) {
	          isInstanced = true;
	        }
	      });
	      return {
	        isInstanced: isInstanced,
	        isIndexed: isIndexed,
	        indexType: indexType
	      };
	    } //         this._filledLocations[bufferName] = true;

	  }, {
	    key: "_getLocations",
	    value: function _getLocations(buffers) {
	      // Try to extract elements and locations
	      var elements = null;
	      var locations = {};

	      for (var bufferName in buffers) {
	        var buffer = buffers[bufferName]; // Check if this is an elements array

	        if (buffer && buffer.target === GL_ELEMENT_ARRAY_BUFFER) {
	          (0, _utils.assert)(!elements, 'Duplicate GL.ELEMENT_ARRAY_BUFFER'); // assert(location === undefined, 'GL.ELEMENT_ARRAY_BUFFER assigned to location');

	          elements = buffer;
	        }

	        var location = Number(bufferName); // if key is a number, interpret as the location
	        // if key is not a location number, assume it is a named buffer, look it up in supplied map

	        if (!Number.isFinite(location)) {
	          location = this.locations[bufferName];
	        }

	        (0, _utils.assert)(Number.isFinite(location));
	        (0, _utils.assert)(!locations[location], "Duplicate attribute for binding point ".concat(location));
	        locations[location] = buffer;
	      }

	      return {
	        locations: locations,
	        elements: elements
	      };
	    }
	  }, {
	    key: "_sortBuffersByLocation",
	    value: function _sortBuffersByLocation(buffers) {
	      // Try to extract elements and locations
	      var elements = null;
	      var locations = new Array(this._attributeCount).fill(null);

	      for (var bufferName in buffers) {
	        var buffer = buffers[bufferName]; // Check if this is an elements arrau

	        if (buffer.target === GL_ELEMENT_ARRAY_BUFFER) {
	          (0, _utils.assert)(!elements, 'Duplicate GL.ELEMENT_ARRAY_BUFFER'); // assert(location === undefined, 'GL.ELEMENT_ARRAY_BUFFER assigned to location');

	          elements = buffer;
	        } else if (!this._warn[bufferName]) {
	          _utils.log.warn(2, "".concat(this._print(bufferName), " not used"))();

	          this._warn[bufferName] = true;
	        }

	        var location = Number(bufferName); // if key is a number, interpret as the location
	        // if key is not a location number, assume it is a named buffer, look it up in supplied map

	        if (!Number.isFinite(location)) {
	          location = this.locations[bufferName];
	        }

	        locations[location] = bufferName;
	        (0, _utils.assert)(locations[location] === null, "Duplicate attribute for binding point ".concat(location));
	        locations[location] = location;
	      }

	      return {
	        locations: locations,
	        elements: elements
	      };
	    }
	  }, {
	    key: "_getBufferAndLayout",
	    value: function _getBufferAndLayout(bufferData) {
	      // Check if buffer was supplied
	      var buffer;
	      var layout;

	      if (bufferData.handle) {
	        buffer = bufferData;
	        layout = bufferData.layout;
	      } else {
	        buffer = bufferData.buffer;
	        layout = Object.assign({}, buffer.layout, bufferData.layout || {}, bufferData);
	      }

	      return {
	        buffer: buffer,
	        layout: layout
	      };
	    } // TODO - this doesn't minimize well, choose one of the two API styles?

	  }, {
	    key: "_setGenericFloatArray",
	    value: function _setGenericFloatArray(location, array) {
	      var gl = this.gl;

	      switch (array.length) {
	        case 1:
	          gl.vertexAttrib1fv(location, array);
	          break;

	        case 2:
	          gl.vertexAttrib2fv(location, array);
	          break;

	        case 3:
	          gl.vertexAttrib3fv(location, array);
	          break;

	        case 4:
	          gl.vertexAttrib4fv(location, array);
	          break;

	        default:
	          (0, _utils.assert)(false);
	      }
	    }
	  }, {
	    key: "_setGenericIntArray",
	    value: function _setGenericIntArray(location, array) {
	      var gl = this.gl;
	      (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));

	      switch (array.length) {
	        case 1:
	          gl.vertexAttribI1iv(location, array);
	          break;

	        case 2:
	          gl.vertexAttribI2iv(location, array);
	          break;

	        case 3:
	          gl.vertexAttribI3iv(location, array);
	          break;

	        case 4:
	          gl.vertexAttribI4iv(location, array);
	          break;

	        default:
	          (0, _utils.assert)(false);
	      }
	    }
	  }, {
	    key: "_setGenericUintArray",
	    value: function _setGenericUintArray(location, array) {
	      var gl = this.gl;
	      (0, _utils.assert)((0, _webglUtils.isWebGL2)(gl));

	      switch (array.length) {
	        case 1:
	          gl.vertexAttribI1uiv(location, array);
	          break;

	        case 2:
	          gl.vertexAttribI2uiv(location, array);
	          break;

	        case 3:
	          gl.vertexAttribI3uiv(location, array);
	          break;

	        case 4:
	          gl.vertexAttribI4uiv(location, array);
	          break;

	        default:
	          (0, _utils.assert)(false);
	      }
	    } // RESOURCE IMPLEMENTATION

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.ext.createVertexArray();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle(handle) {
	      this.ext.deleteVertexArray(handle);
	      return [this.elements]; // return [this.elements, ...this.buffers];
	    } // Generic getter for information about a vertex attribute at a given position
	    // @param {GLuint} location - index of the vertex attribute.
	    // @param {GLenum} pname - specifies the information to query.
	    // @returns {*} - requested vertex attribute information (specified by pname)

	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname, _ref6) {
	      var location = _ref6.location;
	      (0, _utils.assert)(Number.isFinite(location));
	      this.ext.bindVertexArray(this.handle); // Let the polyfill intercept the query

	      var result;

	      switch (pname) {
	        case GL_VERTEX_ATTRIB_ARRAY_POINTER:
	          result = this.gl.getVertexAttribOffset(location, pname);
	          break;

	        default:
	          result = this.ext.getVertexAttrib(location, pname);
	      }

	      this.ext.bindVertexArray(null);
	      return result;
	    }
	  }, {
	    key: "_getData",
	    value: function _getData() {
	      var _this6 = this;

	      return new Array(this.MAX_ATTRIBUTES).fill(0).map(function (_, location) {
	        var result = {};
	        PARAMETERS.forEach(function (parameter) {
	          result[(0, _webglUtils.getKey)(_this6.gl, parameter)] = _this6.getParameter(parameter, {
	            location: location
	          });
	        });
	        return result;
	      });
	    }
	  }, {
	    key: "_bind",
	    value: function _bind(handle) {
	      this.ext.bindVertexArray(handle);
	    }
	  }, {
	    key: "filledLocations",
	    get: function get() {
	      return this._filledLocations;
	    }
	  }]);

	  return VertexArray;
	}(_resource.default);

	exports.default = VertexArray;
	//# sourceMappingURL=vertex-array.js.map

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.TEXTURE_FORMATS = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	var _contextState = __webpack_require__(78);

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _TEXTURE_FORMATS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// Supported min filters for NPOT texture.
	var NPOT_MIN_FILTERS = [_constants.default.LINEAR, _constants.default.NEAREST]; // const S3TC = 'WEBGL_compressed_texture_s3tc';
	// const PVRTC = 'WEBGL_compressed_texture_pvrtc';
	// const ES3 = 'WEBGL_compressed_texture_es3';
	// const ETC1 = 'WEBGL_compressed_texture_etc1';
	// const SRGB = 'EXT_sRGB';
	// const DEPTH = 'WEBGL_depth_texture';
	// Legal combinations for internalFormat, format and type

	var TEXTURE_FORMATS = (_TEXTURE_FORMATS = {}, _defineProperty(_TEXTURE_FORMATS, _constants.default.RGB, {
	  dataFormat: _constants.default.RGB,
	  types: [_constants.default.UNSIGNED_BYTE, _constants.default.UNSIGNED_SHORT_5_6_5]
	}), _defineProperty(_TEXTURE_FORMATS, _constants.default.RGBA, {
	  dataFormat: _constants.default.RGBA,
	  types: [_constants.default.UNSIGNED_BYTE, _constants.default.UNSIGNED_SHORT_4_4_4_4, _constants.default.UNSIGNED_SHORT_5_5_5_1]
	}), _defineProperty(_TEXTURE_FORMATS, _constants.default.ALPHA, {
	  dataFormat: _constants.default.ALPHA,
	  types: [_constants.default.UNSIGNED_BYTE]
	}), _defineProperty(_TEXTURE_FORMATS, _constants.default.LUMINANCE, {
	  dataFormat: _constants.default.LUMINANCE,
	  types: [_constants.default.UNSIGNED_BYTE]
	}), _defineProperty(_TEXTURE_FORMATS, _constants.default.LUMINANCE_ALPHA, {
	  dataFormat: _constants.default.LUMINANCE_ALPHA,
	  types: [_constants.default.UNSIGNED_BYTE] // [GL.DEPTH_COMPONENT]: {types: [GL.UNSIGNED_SHORT, GL.UNSIGNED_INT, GL.UNSIGNED_INT_24_8], gl1: DEPTH},
	  // [GL.DEPTH_STENCIL]: {gl1: DEPTH},
	  // Sized texture format - more performance
	  // R
	  // [GL.R8]: {dataFormat: GL.RED, types: [GL.UNSIGNED_BYTE], gl2: true},
	  // [GL.R16F]: {dataFormat: GL.RED, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},
	  // [GL.R32F]: {dataFormat: GL.RED, types: [GL.FLOAT], gl2: true},
	  // [GL.R8UI]: {dataFormat: GL.RED_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},
	  // // RG
	  // [GL.RG8]: {dataFormat: GL.RG, types: [GL.UNSIGNED_BYTE], gl2: true},
	  // [GL.RG16F]: {dataFormat: GL.RG, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},
	  // [GL.RG32F]: {dataFormat: GL.RG, types: [GL.FLOAT], gl2: true},
	  // [GL.RG8UI]: {dataFormat: GL.RG_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},
	  // // RGB
	  // [GL.RGB8]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
	  // [GL.SRGB8]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
	  // [GL.RGB565]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_6_5], gl2: true},
	  // [GL.R11F_G11F_B10F]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_INT_10F_11F_11F_REV, GL.HALF_FLOAT, GL.FLOAT], gl2: true},
	  // [GL.RGB9_E5]: {dataFormat: GL.RGB, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true, gl1: 'WEBGL_color_buffer_half_float'},
	  // [GL.RGB16F]: {dataFormat: GL.RGB, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true, gl1: 'WEBGL_color_buffer_float'},
	  // [GL.RGB32F]: {dataFormat: GL.RGB, types: [GL.FLOAT], gl2: true},
	  // [GL.RGB8UI]: {dataFormat: GL.RGB_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},
	  // // RGBA
	  // [GL.RGBA8]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
	  // [GL.SRGB8_ALPHA8]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
	  // [GL.RGB5_A1]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_5_5_1], gl2: true},
	  // [GL.RGBA4]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_4_4_4_4], gl2: true},
	  // [GL.RGBA16F]: {dataFormat: GL.RGBA, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},
	  // [GL.RGBA32F]: {dataFormat: GL.RGBA, types: [GL.FLOAT], gl2: true},
	  // [GL.RGBA8UI]: {dataFormat: GL.RGBA_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true}
	  // Compressed formats
	  // WEBGL_compressed_texture_s3tc
	  // [GL.COMPRESSED_RGB_S3TC_DXT1_EXT]: {compressed: true, gl1: S3TC},
	  // [GL.COMPRESSED_RGBA_S3TC_DXT1_EXT]: {compressed: true, gl1: S3TC},
	  // [GL.COMPRESSED_RGBA_S3TC_DXT3_EXT]: {compressed: true, gl1: S3TC},
	  // [GL.COMPRESSED_RGBA_S3TC_DXT5_EXT]: {compressed: true, gl1: S3TC},
	  // WEBGL_compressed_texture_es3
	  // [GL.COMPRESSED_R11_EAC]: {compressed: true, gl1: ES3}, // RED
	  // [GL.COMPRESSED_SIGNED_R11_EAC]: {compressed: true, gl1: ES3}, // RED
	  // [GL.COMPRESSED_RG11_EAC]: {compressed: true, gl1: ES3}, // RG
	  // [GL.COMPRESSED_SIGNED_RG11_EAC]: {compressed: true, gl1: ES3}, // RG
	  // [GL.COMPRESSED_RGB8_ETC2]: {compressed: true, gl1: ES3}, // RGB
	  // [GL.COMPRESSED_RGBA8_ETC2_EAC]: {compressed: true, gl1: ES3}, // RBG
	  // [GL.COMPRESSED_SRGB8_ETC2]: {compressed: true, gl1: ES3}, // RGB
	  // [GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: {compressed: true, gl1: ES3}, // RGBA
	  // [GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: {compressed: true, gl1: ES3}, // RGBA
	  // [GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: {compressed: true, gl1: ES3}, // RGBA

	  /* WebGL2 guaranteed availability compressed formats?
	  COMPRESSED_R11_EAC RED
	  COMPRESSED_SIGNED_R11_EAC RED
	  COMPRESSED_RG11_EAC RG
	  COMPRESSED_SIGNED_RG11_EAC RG
	  COMPRESSED_RGB8_ETC2 RGB
	  COMPRESSED_SRGB8_ETC2 RGB
	  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA
	  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA
	  COMPRESSED_RGBA8_ETC2_EAC RGBA
	  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
	  */
	  // WEBGL_compressed_texture_pvrtc
	  // [GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]: {compressed: true, gl1: PVRTC},
	  // [GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]: {compressed: true, gl1: PVRTC},
	  // [GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]: {compressed: true, gl1: PVRTC},
	  // [GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]: {compressed: true, gl1: PVRTC},
	  // WEBGL_compressed_texture_etc1
	  // [GL.COMPRESSED_RGB_ETC1_WEBGL]: {compressed: true, gl1: ETC1},
	  // WEBGL_compressed_texture_atc
	  // [GL.COMPRESSED_RGB_ATC_WEBGL]: {compressed: true, gl1: ETC1},
	  // [GL.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL]: {compressed: true, gl1: ETC1},
	  // [GL.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL]: {compressed: true, gl1: ETC1}

	}), _TEXTURE_FORMATS);
	exports.TEXTURE_FORMATS = TEXTURE_FORMATS;

	function isFormatSupported(gl, format) {
	  var info = TEXTURE_FORMATS[format];

	  if (!info) {
	    return false;
	  }

	  if (info.gl1 === undefined && info.gl2 === undefined) {
	    // No info - always supported
	    return true;
	  }

	  var value = (0, _webglUtils.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;
	  return typeof value === 'string' ? gl.getExtension(value) : value;
	}

	function isLinearFilteringSupported(gl, format) {
	  var info = TEXTURE_FORMATS[format];

	  switch (info && info.types[0]) {
	    // Both WebGL1 and WebGL2?
	    case _constants.default.FLOAT:
	      return gl.getExtension('OES_texture_float_linear');
	    // Not in WebGL2?

	    case _constants.default.HALF_FLOAT:
	      return gl.getExtension('OES_texture_half_float_linear');

	    default:
	      return true;
	  }
	}

	var Texture =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Texture, _Resource);

	  _createClass(Texture, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          format = _ref.format,
	          linearFiltering = _ref.linearFiltering;

	      var supported = true;

	      if (format) {
	        supported = supported && isFormatSupported(gl, format);
	        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));
	      }

	      return supported;
	    } // target cannot be modified by bind:
	    // textures are special because when you first bind them to a target,
	    // they get special information. When you first bind a texture as a
	    // GL_TEXTURE_2D, you are actually setting special state in the texture.
	    // You are saying that this texture is a 2D texture.
	    // And it will always be a 2D texture; this state cannot be changed ever.
	    // If you have a texture that was first bound as a GL_TEXTURE_2D,
	    // you must always bind it as a GL_TEXTURE_2D;
	    // attempting to bind it as GL_TEXTURE_1D will give rise to an error
	    // (while run-time).

	  }]);

	  function Texture(gl, opts) {
	    var _this;

	    _classCallCheck(this, Texture);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('texture') : _opts$id,
	        handle = opts.handle,
	        target = opts.target;
	    _this = _possibleConstructorReturn(this, (Texture.__proto__ || Object.getPrototypeOf(Texture)).call(this, gl, {
	      id: id,
	      handle: handle
	    }));
	    _this.target = target;
	    _this.hasFloatTexture = gl.getExtension('OES_texture_float');
	    _this.textureUnit = undefined;
	    return _this;
	  }

	  _createClass(Texture, [{
	    key: "toString",
	    value: function toString() {
	      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
	    }
	    /* eslint-disable max-len, max-statements */

	  }, {
	    key: "initialize",
	    value: function initialize() {
	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var data = opts.data;
	      var _opts$pixels = opts.pixels,
	          pixels = _opts$pixels === void 0 ? null : _opts$pixels,
	          _opts$format = opts.format,
	          format = _opts$format === void 0 ? _constants.default.RGBA : _opts$format,
	          _opts$type = opts.type,
	          type = _opts$type === void 0 ? _constants.default.UNSIGNED_BYTE : _opts$type,
	          _opts$border = opts.border,
	          border = _opts$border === void 0 ? 0 : _opts$border,
	          _opts$recreate = opts.recreate,
	          recreate = _opts$recreate === void 0 ? false : _opts$recreate,
	          _opts$parameters = opts.parameters,
	          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,
	          _opts$pixelStore = opts.pixelStore,
	          pixelStore = _opts$pixelStore === void 0 ? {} : _opts$pixelStore,
	          _opts$unpackFlipY = opts.unpackFlipY,
	          unpackFlipY = _opts$unpackFlipY === void 0 ? true : _opts$unpackFlipY;
	      var _opts$mipmaps = opts.mipmaps,
	          mipmaps = _opts$mipmaps === void 0 ? true : _opts$mipmaps; // pixels variable is for API compatibility purpose

	      if (!data) {
	        // TODO - This looks backwards? Commenting out for now until we decide
	        // which prop to use
	        // log.deprecated('data', 'pixels')();
	        data = pixels;
	      }

	      var width = opts.width,
	          height = opts.height,
	          dataFormat = opts.dataFormat; // Deduce width and height

	      var _deduceParameters2 = this._deduceParameters({
	        format: format,
	        type: type,
	        dataFormat: dataFormat,
	        compressed: false,
	        data: data,
	        width: width,
	        height: height
	      });

	      width = _deduceParameters2.width;
	      height = _deduceParameters2.height;
	      dataFormat = _deduceParameters2.dataFormat;
	      // Store opts for accessors
	      this.width = width;
	      this.height = height;
	      this.format = format;
	      this.type = type;
	      this.dataFormat = dataFormat;
	      this.border = border;
	      this.mipmaps = mipmaps; // Note: luma.gl defaults to GL.UNPACK_FLIP_Y_WEBGL = true;
	      // TODO - compare v4 and v3

	      var DEFAULT_TEXTURE_SETTINGS = _defineProperty({}, _constants.default.UNPACK_FLIP_Y_WEBGL, unpackFlipY);

	      var glSettings = Object.assign({}, DEFAULT_TEXTURE_SETTINGS, pixelStore);

	      if (this._isNPOT()) {
	        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();

	        mipmaps = false;

	        this._updateForNPOT(parameters);
	      }

	      this.setImageData({
	        data: data,
	        width: width,
	        height: height,
	        format: format,
	        type: type,
	        dataFormat: dataFormat,
	        border: border,
	        mipmaps: mipmaps,
	        parameters: glSettings
	      });

	      if (mipmaps) {
	        this.generateMipmap();
	      } // Set texture sampler parameters


	      this.setParameters(parameters); // TODO - Store data to enable auto recreate on context loss

	      if (recreate) {
	        this.data = data;
	      }
	    } // If size has changed, reinitializes with current format
	    // note clears image and mipmaps

	  }, {
	    key: "resize",
	    value: function resize(_ref2) {
	      var width = _ref2.width,
	          height = _ref2.height;

	      if (width !== this.width || height !== this.height) {
	        return this.initialize({
	          width: width,
	          height: height,
	          format: this.format,
	          type: this.type,
	          dataFormat: this.dataFormat,
	          border: this.border,
	          mipmaps: false
	        });
	      }

	      return this;
	    } // Call to regenerate mipmaps after modifying texture(s)

	  }, {
	    key: "generateMipmap",
	    value: function generateMipmap() {
	      var _this2 = this;

	      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      this.gl.bindTexture(this.target, this.handle);
	      (0, _contextState.withParameters)(this.gl, params, function () {
	        _this2.gl.generateMipmap(_this2.target);
	      });
	      this.gl.bindTexture(this.target, null);
	      return this;
	    }
	    /*
	     * Allocates storage
	     * @param {*} pixels -
	     *  null - create empty texture of specified format
	     *  Typed array - init from image data in typed array
	     *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
	     *  HTMLImageElement|Image - Inits with content of image. Auto width/height
	     *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
	     *  HTMLVideoElement - Creates video texture. Auto width/height
	     *
	     * @param {GLint} width -
	     * @param {GLint} height -
	     * @param {GLint} mipMapLevel -
	     * @param {GLenum} format - format of image data.
	     * @param {GLenum} type
	     *  - format of array (autodetect from type) or
	     *  - (WEBGL2) format of buffer
	     * @param {Number} offset - (WEBGL2) offset from start of buffer
	     * @param {GLint} border - must be 0.
	     * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
	     */

	    /* eslint-disable max-len, max-statements, complexity */

	  }, {
	    key: "setImageData",
	    value: function setImageData(_ref3) {
	      var _this3 = this;

	      var _ref3$target = _ref3.target,
	          target = _ref3$target === void 0 ? this.target : _ref3$target,
	          _ref3$pixels = _ref3.pixels,
	          pixels = _ref3$pixels === void 0 ? null : _ref3$pixels,
	          _ref3$data = _ref3.data,
	          data = _ref3$data === void 0 ? null : _ref3$data,
	          width = _ref3.width,
	          height = _ref3.height,
	          _ref3$level = _ref3.level,
	          level = _ref3$level === void 0 ? 0 : _ref3$level,
	          _ref3$format = _ref3.format,
	          format = _ref3$format === void 0 ? _constants.default.RGBA : _ref3$format,
	          type = _ref3.type,
	          dataFormat = _ref3.dataFormat,
	          _ref3$offset = _ref3.offset,
	          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
	          _ref3$border = _ref3.border,
	          border = _ref3$border === void 0 ? 0 : _ref3$border,
	          _ref3$compressed = _ref3.compressed,
	          compressed = _ref3$compressed === void 0 ? false : _ref3$compressed,
	          _ref3$parameters = _ref3.parameters,
	          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;

	      // pixels variable is  for API compatibility purpose
	      if (!data) {
	        data = pixels;
	      }

	      var _deduceParameters3 = this._deduceParameters({
	        format: format,
	        type: type,
	        dataFormat: dataFormat,
	        compressed: compressed,
	        data: data,
	        width: width,
	        height: height
	      });

	      type = _deduceParameters3.type;
	      dataFormat = _deduceParameters3.dataFormat;
	      compressed = _deduceParameters3.compressed;
	      width = _deduceParameters3.width;
	      height = _deduceParameters3.height;
	      var gl = this.gl;
	      gl.bindTexture(this.target, this.handle);
	      var dataType = null;

	      var _getDataType2 = this._getDataType({
	        data: data,
	        compressed: compressed
	      });

	      data = _getDataType2.data;
	      dataType = _getDataType2.dataType;
	      (0, _contextState.withParameters)(this.gl, parameters, function () {
	        switch (dataType) {
	          case 'null':
	            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
	            break;

	          case 'typed-array':
	            // Looks like this assert is not necessary, as offset is ignored under WebGL1
	            // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');
	            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);
	            break;

	          case 'buffer':
	            // WebGL2 enables creating textures directly from a WebGL buffer
	            (0, _webglUtils.assertWebGL2Context)(gl);
	            gl.bindBuffer(_constants.default.PIXEL_UNPACK_BUFFER, data.handle || data);
	            gl.texImage2D(target, level, format, width, height, border, format, type, offset);
	            break;

	          case 'browser-object':
	            gl.texImage2D(target, level, format, format, type, data);
	            break;

	          case 'compressed':
	            gl.compressedTexImage2D(_this3.target, level, format, width, height, border, data);
	            break;

	          default:
	            (0, _assert.default)(false, 'Unknown image data type');
	        }
	      });
	    }
	    /* eslint-enable max-len, max-statements, complexity */

	    /**
	     * Redefines an area of an existing texture
	     * Note: does not allocate storage
	     */

	    /*
	     * Redefines an area of an existing texture
	     * @param {*} pixels, data -
	     *  null - create empty texture of specified format
	     *  Typed array - init from image data in typed array
	     *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
	     *  HTMLImageElement|Image - Inits with content of image. Auto width/height
	     *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
	     *  HTMLVideoElement - Creates video texture. Auto width/height
	     *
	     * @param {GLint} x - xOffset from where texture to be updated
	     * @param {GLint} y - yOffset from where texture to be updated
	     * @param {GLint} width - width of the sub image to be updated
	     * @param {GLint} height - height of the sub image to be updated
	     * @param {GLint} level - mip level to be updated
	     * @param {GLenum} format - internal format of image data.
	     * @param {GLenum} type
	     *  - format of array (autodetect from type) or
	     *  - (WEBGL2) format of buffer or ArrayBufferView
	     * @param {GLenum} dataFormat - format of image data.
	     * @param {Number} offset - (WEBGL2) offset from start of buffer
	     * @param {GLint} border - must be 0.
	     * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
	     */

	  }, {
	    key: "setSubImageData",
	    value: function setSubImageData(_ref4) {
	      var _this4 = this;

	      var _ref4$target = _ref4.target,
	          target = _ref4$target === void 0 ? this.target : _ref4$target,
	          _ref4$pixels = _ref4.pixels,
	          pixels = _ref4$pixels === void 0 ? null : _ref4$pixels,
	          _ref4$data = _ref4.data,
	          data = _ref4$data === void 0 ? null : _ref4$data,
	          _ref4$x = _ref4.x,
	          x = _ref4$x === void 0 ? 0 : _ref4$x,
	          _ref4$y = _ref4.y,
	          y = _ref4$y === void 0 ? 0 : _ref4$y,
	          width = _ref4.width,
	          height = _ref4.height,
	          _ref4$level = _ref4.level,
	          level = _ref4$level === void 0 ? 0 : _ref4$level,
	          _ref4$format = _ref4.format,
	          format = _ref4$format === void 0 ? _constants.default.RGBA : _ref4$format,
	          type = _ref4.type,
	          dataFormat = _ref4.dataFormat,
	          _ref4$compressed = _ref4.compressed,
	          compressed = _ref4$compressed === void 0 ? false : _ref4$compressed,
	          _ref4$offset = _ref4.offset,
	          offset = _ref4$offset === void 0 ? 0 : _ref4$offset,
	          _ref4$border = _ref4.border,
	          border = _ref4$border === void 0 ? 0 : _ref4$border,
	          _ref4$parameters = _ref4.parameters,
	          parameters = _ref4$parameters === void 0 ? {} : _ref4$parameters;

	      var _deduceParameters4 = this._deduceParameters({
	        format: format,
	        type: type,
	        dataFormat: dataFormat,
	        compressed: compressed,
	        data: data,
	        width: width,
	        height: height
	      });

	      type = _deduceParameters4.type;
	      dataFormat = _deduceParameters4.dataFormat;
	      compressed = _deduceParameters4.compressed;
	      width = _deduceParameters4.width;
	      height = _deduceParameters4.height;

	      // pixels variable is  for API compatibility purpose
	      if (!data) {
	        data = pixels;
	      } // Support ndarrays


	      if (data && data.data) {
	        var ndarray = data;
	        data = ndarray.data;
	        width = ndarray.shape[0];
	        height = ndarray.shape[1];
	      } // Support buffers


	      if (_instanceof(data, _buffer.default)) {
	        data = data.handle;
	      }

	      this.gl.bindTexture(this.target, this.handle);
	      (0, _contextState.withParameters)(this.gl, parameters, function () {
	        // TODO - x,y parameters
	        if (compressed) {
	          _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
	        } else if (data === null) {
	          _this4.gl.texSubImage2D(target, level, format, width, height, border, dataFormat, type, null);
	        } else if (ArrayBuffer.isView(data)) {
	          _this4.gl.texSubImage2D(target, level, x, y, width, height, format, type, data, offset);
	        } else if (_instanceof(data, _webglUtils.WebGLBuffer)) {
	          // WebGL2 allows us to create texture directly from a WebGL buffer
	          (0, _webglUtils.assertWebGL2Context)(_this4.gl); // This texImage2D signature uses currently bound GL_PIXEL_UNPACK_BUFFER

	          _this4.gl.bindBuffer(_constants.default.PIXEL_UNPACK_BUFFER, data);

	          _this4.gl.texSubImage2D(target, level, format, width, height, border, format, type, offset);

	          _this4.gl.bindBuffer(_constants.default.GL_PIXEL_UNPACK_BUFFER, null);
	        } else {
	          // Assume data is a browser supported object (ImageData, Canvas, ...)
	          _this4.gl.texSubImage2D(target, level, x, y, format, type, data);
	        }
	      });
	      this.gl.bindTexture(this.target, null);
	    }
	    /* eslint-enable max-len, max-statements, complexity */

	    /**
	     * Defines a two-dimensional texture image or cube-map texture image with
	     * pixels from the current framebuffer (rather than from client memory).
	     * (gl.copyTexImage2D wrapper)
	     *
	     * Note that binding a texture into a Framebuffer's color buffer and
	     * rendering can be faster.
	     */

	  }, {
	    key: "copyFramebuffer",
	    value: function copyFramebuffer(_ref5) {
	      var _ref5$target = _ref5.target,
	          target = _ref5$target === void 0 ? this.target : _ref5$target,
	          framebuffer = _ref5.framebuffer,
	          _ref5$offset = _ref5.offset,
	          offset = _ref5$offset === void 0 ? 0 : _ref5$offset,
	          _ref5$x = _ref5.x,
	          x = _ref5$x === void 0 ? 0 : _ref5$x,
	          _ref5$y = _ref5.y,
	          y = _ref5$y === void 0 ? 0 : _ref5$y,
	          width = _ref5.width,
	          height = _ref5.height,
	          _ref5$level = _ref5.level,
	          level = _ref5$level === void 0 ? 0 : _ref5$level,
	          _ref5$internalFormat = _ref5.internalFormat,
	          internalFormat = _ref5$internalFormat === void 0 ? _constants.default.RGBA : _ref5$internalFormat,
	          _ref5$border = _ref5.border,
	          border = _ref5$border === void 0 ? 0 : _ref5$border;

	      if (framebuffer) {
	        framebuffer.bind();
	      } // target


	      this.bind();
	      this.gl.copyTexImage2D(this.target, level, internalFormat, x, y, width, height, border);
	      this.unbind();

	      if (framebuffer) {
	        framebuffer.unbind();
	      }
	    }
	  }, {
	    key: "getActiveUnit",
	    value: function getActiveUnit() {
	      return this.gl.getParameter(_constants.default.ACTIVE_TEXTURE) - _constants.default.TEXTURE0;
	    } // target cannot be modified by bind:
	    // textures are special because when you first bind them to a target,
	    // they get special information. When you first bind a texture as a
	    // GL_TEXTURE_2D, you are actually setting special state in the texture.
	    // You are saying that this texture is a 2D texture.
	    // And it will always be a 2D texture; this state cannot be changed ever.
	    // If you have a texture that was first bound as a GL_TEXTURE_2D,
	    // you must always bind it as a GL_TEXTURE_2D;
	    // attempting to bind it as GL_TEXTURE_1D will give rise to an error
	    // (while run-time).

	  }, {
	    key: "bind",
	    value: function bind() {
	      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;

	      if (textureUnit === undefined) {
	        throw new Error('Texture.bind: must specify texture unit');
	      }

	      this.textureUnit = textureUnit;
	      this.gl.activeTexture(_constants.default.TEXTURE0 + textureUnit);
	      this.gl.bindTexture(this.target, this.handle);
	      return textureUnit;
	    }
	  }, {
	    key: "unbind",
	    value: function unbind() {
	      if (this.textureUnit === undefined) {
	        throw new Error('Texture.unbind: texture unit not specified');
	      }

	      this.gl.activeTexture(_constants.default.TEXTURE0 + this.textureUnit);
	      this.gl.bindTexture(this.target, null);
	      return this.textureUnit;
	    } // PRIVATE METHODS

	  }, {
	    key: "_getDataType",
	    value: function _getDataType(_ref6) {
	      var data = _ref6.data,
	          _ref6$compressed = _ref6.compressed,
	          compressed = _ref6$compressed === void 0 ? false : _ref6$compressed;

	      if (compressed) {
	        return {
	          data: data,
	          dataType: 'compressed'
	        };
	      }

	      if (data === null) {
	        return {
	          data: data,
	          dataType: 'null'
	        };
	      }

	      if (ArrayBuffer.isView(data)) {
	        return {
	          data: data,
	          dataType: 'typed-array'
	        };
	      }

	      if (_instanceof(data, _buffer.default)) {
	        return {
	          data: data.handle,
	          dataType: 'buffer'
	        };
	      }

	      if (_instanceof(data, _webglUtils.WebGLBuffer)) {
	        return {
	          data: data,
	          dataType: 'buffer'
	        };
	      } // Assume data is a browser supported object (ImageData, Canvas, ...)


	      return {
	        data: data,
	        dataType: 'browser-object'
	      };
	    } // Image 3D copies from Typed Array or WebGLBuffer

	  }, {
	    key: "setImage3D",
	    value: function setImage3D(_ref7) {
	      var _ref7$level = _ref7.level,
	          level = _ref7$level === void 0 ? 0 : _ref7$level,
	          _ref7$internalformat = _ref7.internalformat,
	          internalformat = _ref7$internalformat === void 0 ? _constants.default.RGBA : _ref7$internalformat,
	          width = _ref7.width,
	          height = _ref7.height,
	          _ref7$depth = _ref7.depth,
	          depth = _ref7$depth === void 0 ? 1 : _ref7$depth,
	          _ref7$border = _ref7.border,
	          border = _ref7$border === void 0 ? 0 : _ref7$border,
	          format = _ref7.format,
	          _ref7$type = _ref7.type,
	          type = _ref7$type === void 0 ? _constants.default.UNSIGNED_BYTE : _ref7$type,
	          _ref7$offset = _ref7.offset,
	          offset = _ref7$offset === void 0 ? 0 : _ref7$offset,
	          pixels = _ref7.pixels;

	      if (ArrayBuffer.isView(pixels)) {
	        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, pixels);
	        return this;
	      }

	      if (_instanceof(pixels, _buffer.default)) {
	        this.gl.bindBuffer(_constants.default.PIXEL_UNPACK_BUFFER, pixels.handle);
	        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, offset);
	      }

	      return this;
	    }
	    /* Copied from texture-2d.js
	    // WebGL2
	    setPixels(opts = {}) {
	      const {
	        buffer,
	        width = null,
	        height = null,
	        mipmapLevel = 0,
	        format = GL.RGBA,
	        type = GL.UNSIGNED_BYTE,
	        border = 0
	      } = opts;
	       const {gl} = this;
	       // This signature of texImage2D uses currently bound GL_PIXEL_UNPACK_BUFFER
	      gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);
	      // And as always, we must also bind the texture itself
	      this.bind();
	       gl.texImage2D(gl.TEXTURE_2D,
	        mipmapLevel, format, width, height, border, format, type, buffer.target);
	       this.unbind();
	      gl.bindBuffer(GL.GL_PIXEL_UNPACK_BUFFER, null);
	      return this;
	    }
	     setImageDataFromCompressedBuffer(opts) {
	      const {
	        buffer,
	        // offset = 0,
	        width = null,
	        height = null,
	        mipmapLevel = 0,
	        internalFormat = GL.RGBA,
	        // format = GL.RGBA,
	        // type = GL.UNSIGNED_BYTE,
	        border = 0
	      } = opts;
	       const {gl} = this;
	      gl.compressedTexImage2D(this.target,
	        mipmapLevel, internalFormat, width, height, border, buffer);
	      // gl.compressedTexSubImage2D(target,
	      //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);
	      return this;
	    }
	     copySubImage(opts) {
	      const {
	        // pixels,
	        // offset = 0,
	        // x,
	        // y,
	        // width,
	        // height,
	        // mipmapLevel = 0,
	        // internalFormat = GL.RGBA,
	        // type = GL.UNSIGNED_BYTE,
	        // border = 0
	      } = opts;
	       // if (pixels instanceof ArrayBufferView) {
	      //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);
	      // }
	      // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);
	      // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);
	      // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);
	      // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);
	      // // Additional signature in a WebGL 2 context:
	      // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);
	    }
	    */
	    // HELPER METHODS

	  }, {
	    key: "_deduceParameters",
	    value: function _deduceParameters(opts) {
	      var format = opts.format,
	          data = opts.data;
	      var width = opts.width,
	          height = opts.height,
	          dataFormat = opts.dataFormat,
	          type = opts.type,
	          compressed = opts.compressed; // Deduce format and type from format

	      var textureFormat = TEXTURE_FORMATS[format];
	      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
	      type = type || textureFormat && textureFormat.types[0]; // Deduce compression from format

	      compressed = compressed || textureFormat && textureFormat.compressed;

	      var _deduceImageSize2 = this._deduceImageSize({
	        data: data,
	        width: width,
	        height: height
	      });

	      width = _deduceImageSize2.width;
	      height = _deduceImageSize2.height;
	      return {
	        dataFormat: dataFormat,
	        type: type,
	        compressed: compressed,
	        width: width,
	        height: height,
	        format: format,
	        data: data
	      };
	    }
	    /* global ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement */

	  }, {
	    key: "_deduceImageSize",
	    value: function _deduceImageSize(_ref8) {
	      var data = _ref8.data,
	          width = _ref8.width,
	          height = _ref8.height;
	      var size;

	      if (typeof ImageData !== 'undefined' && _instanceof(data, ImageData)) {
	        size = {
	          width: data.width,
	          height: data.height
	        };
	      } else if (typeof HTMLImageElement !== 'undefined' && _instanceof(data, HTMLImageElement)) {
	        size = {
	          width: data.naturalWidth,
	          height: data.naturalHeight
	        };
	      } else if (typeof HTMLCanvasElement !== 'undefined' && _instanceof(data, HTMLCanvasElement)) {
	        size = {
	          width: data.width,
	          height: data.height
	        };
	      } else if (typeof HTMLVideoElement !== 'undefined' && _instanceof(data, HTMLVideoElement)) {
	        size = {
	          width: data.videoWidth,
	          height: data.videoHeight
	        };
	      } else if (!data) {
	        size = {
	          width: width >= 0 ? width : 1,
	          height: height >= 0 ? height : 1
	        };
	      } else {
	        size = {
	          width: width,
	          height: height
	        };
	      }

	      (0, _assert.default)(size, 'Could not deduced texture size');
	      (0, _assert.default)(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');
	      (0, _assert.default)(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');
	      return size;
	    } // RESOURCE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createTexture();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteTexture(this.handle);
	    }
	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname) {
	      switch (pname) {
	        case _constants.default.TEXTURE_WIDTH:
	          return this.width;

	        case _constants.default.TEXTURE_HEIGHT:
	          return this.height;

	        default:
	          this.gl.bindTexture(this.target, this.handle);
	          var value = this.gl.getTexParameter(this.target, pname);
	          this.gl.bindTexture(this.target, null);
	          return value;
	      }
	    }
	  }, {
	    key: "_setParameter",
	    value: function _setParameter(pname, param) {
	      this.gl.bindTexture(this.target, this.handle); // NOTE: Apply NPOT workaround

	      param = this._getNPOTParam(pname, param); // Apparently there are some integer/float conversion rules that made
	      // the WebGL committe expose two parameter setting functions in JavaScript.
	      // For now, pick the float version for parameters specified as GLfloat.

	      switch (pname) {
	        case _constants.default.TEXTURE_MIN_LOD:
	        case _constants.default.TEXTURE_MAX_LOD:
	          this.gl.texParameterf(this.handle, pname, param);
	          break;

	        case _constants.default.TEXTURE_WIDTH:
	        case _constants.default.TEXTURE_HEIGHT:
	          throw new Error('Cannot set emulated parameter');

	        default:
	          this.gl.texParameteri(this.target, pname, param);
	          break;
	      }

	      this.gl.bindTexture(this.target, null);
	      return this;
	    }
	  }, {
	    key: "_isNPOT",
	    value: function _isNPOT() {
	      return !(0, _webglUtils.isWebGL2)(this.gl) && (!(0, _utils.isPowerOfTwo)(this.width) || !(0, _utils.isPowerOfTwo)(this.height));
	    } // Update default settings which are not supported by NPOT textures.

	  }, {
	    key: "_updateForNPOT",
	    value: function _updateForNPOT(parameters) {
	      if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
	        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR"))();

	        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
	      }

	      if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
	        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE"))();

	        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
	      }

	      if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
	        _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE"))();

	        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
	      }
	    }
	  }, {
	    key: "_getNPOTParam",
	    value: function _getNPOTParam(pname, param) {
	      if (this._isNPOT()) {
	        switch (pname) {
	          case _constants.default.TEXTURE_MIN_FILTER:
	            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
	              _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR"))();

	              param = _constants.default.LINEAR;
	            }

	            break;

	          case _constants.default.TEXTURE_WRAP_S:
	          case _constants.default.TEXTURE_WRAP_T:
	            if (param !== _constants.default.CLAMP_TO_EDGE) {
	              _utils.log.warn("texture: ".concat(this, " is Non-Power-Of-Two, ").concat((0, _webglUtils.getKey)(this.gl, pname), " to CLAMP_TO_EDGE"))();

	              param = _constants.default.CLAMP_TO_EDGE;
	            }

	            break;

	          default:
	            break;
	        }
	      }

	      return param;
	    }
	  }]);

	  return Texture;
	}(_resource.default);

	exports.default = Texture;
	//# sourceMappingURL=texture.js.map

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _texture2d = _interopRequireDefault(__webpack_require__(90));

	var _renderbuffer = _interopRequireDefault(__webpack_require__(91));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	var _clear2 = __webpack_require__(92);

	var _webglContext = __webpack_require__(77);

	var _contextFeatures = __webpack_require__(79);

	var _typedArrayUtils = __webpack_require__(56);

	var _formatUtils = __webpack_require__(93);

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	// Local constants - will collapse during minification
	var GL_FRAMEBUFFER = 0x8D40;
	var GL_DRAW_FRAMEBUFFER = 0x8CA8;
	var GL_READ_FRAMEBUFFER = 0x8CA9;
	var GL_COLOR_ATTACHMENT0 = 0x8CE0;
	var GL_DEPTH_ATTACHMENT = 0x8D00;
	var GL_STENCIL_ATTACHMENT = 0x8D20; // const GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;

	var GL_RENDERBUFFER = 0x8D41;
	var GL_TEXTURE_3D = 0x806F;
	var GL_TEXTURE_2D_ARRAY = 0x8C1A;
	var GL_TEXTURE_2D = 0x0DE1;
	var GL_TEXTURE_CUBE_MAP = 0x8513;
	var GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
	var GL_DEPTH_BUFFER_BIT = 0x00000100;
	var GL_STENCIL_BUFFER_BIT = 0x00000400;
	var GL_COLOR_BUFFER_BIT = 0x00004000;
	var ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';

	var Framebuffer =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Framebuffer, _Resource);

	  _createClass(Framebuffer, [{
	    key: "MAX_COLOR_ATTACHMENTS",
	    get: function get() {
	      return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);
	    }
	  }, {
	    key: "MAX_DRAW_BUFFERS",
	    get: function get() {
	      return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);
	    }
	  }], [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          colorBufferFloat = _ref.colorBufferFloat,
	          colorBufferHalfFloat = _ref.colorBufferHalfFloat;

	      var supported = true;
	      supported = colorBufferFloat && gl.getExtension((0, _webglUtils.isWebGL2)(gl) ? 'EXT_color_buffer_float' : 'WEBGL_color_buffer_float');
	      supported = colorBufferHalfFloat && gl.getExtension((0, _webglUtils.isWebGL2)(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');
	      return supported;
	    } // Create a Framebuffer wrapper for the default framebuffer (target === null)

	  }, {
	    key: "getDefaultFramebuffer",
	    value: function getDefaultFramebuffer(gl) {
	      gl.luma = gl.luma || {};

	      if (!gl.luma.defaultFramebuffer) {
	        gl.luma.defaultFramebuffer = new Framebuffer(gl, {
	          handle: null,
	          attachments: {}
	        });
	      } // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?


	      return gl.luma.defaultFramebuffer;
	    }
	  }]);

	  function Framebuffer(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Framebuffer);

	    _this = _possibleConstructorReturn(this, (Framebuffer.__proto__ || Object.getPrototypeOf(Framebuffer)).call(this, gl, opts)); // Public members

	    _this.width = null;
	    _this.height = null;
	    _this.attachments = {};
	    _this.readBuffer = GL_COLOR_ATTACHMENT0;
	    _this.drawBuffers = [GL_COLOR_ATTACHMENT0];

	    _this.initialize(opts);

	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  }

	  _createClass(Framebuffer, [{
	    key: "initialize",
	    value: function initialize(_ref2) {
	      var _ref2$width = _ref2.width,
	          width = _ref2$width === void 0 ? 1 : _ref2$width,
	          _ref2$height = _ref2.height,
	          height = _ref2$height === void 0 ? 1 : _ref2$height,
	          _ref2$attachments = _ref2.attachments,
	          attachments = _ref2$attachments === void 0 ? null : _ref2$attachments,
	          _ref2$color = _ref2.color,
	          color = _ref2$color === void 0 ? true : _ref2$color,
	          _ref2$depth = _ref2.depth,
	          depth = _ref2$depth === void 0 ? true : _ref2$depth,
	          _ref2$stencil = _ref2.stencil,
	          stencil = _ref2$stencil === void 0 ? false : _ref2$stencil,
	          _ref2$check = _ref2.check,
	          check = _ref2$check === void 0 ? true : _ref2$check,
	          readBuffer = _ref2.readBuffer,
	          drawBuffers = _ref2.drawBuffers;
	      (0, _assert.default)(width >= 0 && height >= 0, 'Width and height need to be integers'); // Store actual width and height for diffing

	      this.width = width;
	      this.height = height; // Resize any provided attachments - note that resize only resizes if needed
	      // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)

	      if (attachments) {
	        for (var attachment in attachments) {
	          var target = attachments[attachment];
	          var object = Array.isArray(target) ? target[0] : target;
	          object.resize({
	            width: width,
	            height: height
	          });
	        }
	      } else {
	        // Create any requested default attachments
	        attachments = this._createDefaultAttachments({
	          color: color,
	          depth: depth,
	          stencil: stencil,
	          width: width,
	          height: height
	        });
	      }

	      this.update({
	        clearAttachments: true,
	        attachments: attachments,
	        readBuffer: readBuffer,
	        drawBuffers: drawBuffers
	      }); // Checks that framebuffer was properly set up, if not, throws an explanatory error

	      if (attachments && check) {
	        this.checkStatus();
	      }
	    }
	  }, {
	    key: "update",
	    value: function update(_ref3) {
	      var _ref3$attachments = _ref3.attachments,
	          attachments = _ref3$attachments === void 0 ? {} : _ref3$attachments,
	          readBuffer = _ref3.readBuffer,
	          drawBuffers = _ref3.drawBuffers,
	          _ref3$clearAttachment = _ref3.clearAttachments,
	          clearAttachments = _ref3$clearAttachment === void 0 ? false : _ref3$clearAttachment;
	      this.attach(attachments, {
	        clearAttachments: clearAttachments
	      });
	      var gl = this.gl; // Multiple render target support, set read buffer and draw buffers

	      var prevHandle = gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);

	      if (readBuffer) {
	        this._setReadBuffer(readBuffer);
	      }

	      if (drawBuffers) {
	        this._setDrawBuffers(drawBuffers);
	      }

	      gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);
	      return this;
	    } // Attachment resize is expected to be a noop if size is same

	  }, {
	    key: "resize",
	    value: function resize() {
	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          width = _ref4.width,
	          height = _ref4.height;

	      // for default framebuffer, just update the stored size
	      if (this.handle === null) {
	        (0, _assert.default)(width === undefined && height === undefined);
	        this.width = this.gl.drawingBufferWidth;
	        this.height = this.gl.drawingBufferHeight;
	        return this;
	      }

	      if (width === undefined) {
	        width = this.gl.drawingBufferWidth;
	      }

	      if (height === undefined) {
	        height = this.gl.drawingBufferHeight;
	      }

	      if (width !== this.width && height !== this.height) {
	        _utils.log.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width, "x").concat(height));
	      }

	      for (var attachmentPoint in this.attachments) {
	        this.attachments[attachmentPoint].resize({
	          width: width,
	          height: height
	        });
	      }

	      this.width = width;
	      this.height = height;
	      return this;
	    } // Attach from a map of attachments

	  }, {
	    key: "attach",
	    value: function attach(attachments) {
	      var _this2 = this;

	      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref5$clearAttachment = _ref5.clearAttachments,
	          clearAttachments = _ref5$clearAttachment === void 0 ? false : _ref5$clearAttachment;

	      var newAttachments = {}; // Any current attachments need to be removed, add null values to map

	      if (clearAttachments) {
	        Object.keys(this.attachments).forEach(function (key) {
	          newAttachments[key] = null;
	        });
	      } // Overlay the new attachments


	      Object.assign(newAttachments, attachments);
	      var prevHandle = this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle); // Walk the attachments

	      for (var attachment in newAttachments) {
	        // Ensure key is not undefined
	        (0, _assert.default)(attachment !== 'undefined', 'Misspelled framebuffer binding point?');
	        var descriptor = newAttachments[attachment];
	        var object = descriptor;

	        if (!object) {
	          this._unattach({
	            attachment: attachment
	          });
	        } else if (_instanceof(object, _renderbuffer.default)) {
	          this._attachRenderbuffer({
	            attachment: attachment,
	            renderbuffer: object
	          });
	        } else if (Array.isArray(descriptor)) {
	          var _descriptor = _slicedToArray(descriptor, 3),
	              texture = _descriptor[0],
	              _descriptor$ = _descriptor[1],
	              layer = _descriptor$ === void 0 ? 0 : _descriptor$,
	              _descriptor$2 = _descriptor[2],
	              level = _descriptor$2 === void 0 ? 0 : _descriptor$2;

	          object = texture;

	          this._attachTexture({
	            attachment: attachment,
	            texture: texture,
	            layer: layer,
	            level: level
	          });
	        } else {
	          this._attachTexture({
	            attachment: attachment,
	            texture: object,
	            layer: 0,
	            level: 0
	          });
	        } // Resize objects


	        if (object) {
	          object.resize({
	            width: this.width,
	            height: this.height
	          });
	        }
	      }

	      this.gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null); // Assign to attachments and remove any nulls to get a clean attachment map

	      Object.assign(this.attachments, attachments);
	      Object.keys(this.attachments).filter(function (key) {
	        return !_this2.attachments[key];
	      }).forEach(function (key) {
	        delete _this2.attachments[key];
	      });
	    }
	  }, {
	    key: "checkStatus",
	    value: function checkStatus() {
	      var gl = this.gl;
	      var prevHandle = gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);
	      var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER);
	      gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);

	      if (status !== gl.FRAMEBUFFER_COMPLETE) {
	        throw new Error(_getFrameBufferStatus(status));
	      }

	      return this;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          color = _ref6.color,
	          depth = _ref6.depth,
	          stencil = _ref6.stencil,
	          _ref6$drawBuffers = _ref6.drawBuffers,
	          drawBuffers = _ref6$drawBuffers === void 0 ? [] : _ref6$drawBuffers;

	      // Bind framebuffer and delegate to global clear functions
	      var prevHandle = this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);

	      if (color || depth || stencil) {
	        (0, _clear2.clear)(this.gl, {
	          color: color,
	          depth: depth,
	          stencil: stencil
	        });
	      }

	      drawBuffers.forEach(function (value, drawBuffer) {
	        (0, _clear2.clearBuffer)({
	          drawBuffer: drawBuffer,
	          value: value
	        });
	      });
	      this.gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);
	      return this;
	    } // NOTE: Slow requires roundtrip to GPU
	    // App can provide pixelArray or have it auto allocated by this method
	    // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,
	    //  newly allocated by this method unless provided by app.

	  }, {
	    key: "readPixels",
	    value: function readPixels(_ref7) {
	      var _ref7$x = _ref7.x,
	          x = _ref7$x === void 0 ? 0 : _ref7$x,
	          _ref7$y = _ref7.y,
	          y = _ref7$y === void 0 ? 0 : _ref7$y,
	          _ref7$width = _ref7.width,
	          width = _ref7$width === void 0 ? this.width : _ref7$width,
	          _ref7$height = _ref7.height,
	          height = _ref7$height === void 0 ? this.height : _ref7$height,
	          _ref7$format = _ref7.format,
	          format = _ref7$format === void 0 ? _constants.default.RGBA : _ref7$format,
	          type = _ref7.type,
	          _ref7$pixelArray = _ref7.pixelArray,
	          pixelArray = _ref7$pixelArray === void 0 ? null : _ref7$pixelArray,
	          _ref7$attachment = _ref7.attachment,
	          attachment = _ref7$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref7$attachment;
	      var gl = this.gl; // TODO - Set and unset gl.readBuffer

	      if (attachment === _constants.default.COLOR_ATTACHMENT0 && this.handle === null) {
	        attachment = _constants.default.FRONT;
	      } // Deduce type and allocated pixelArray if needed


	      if (!pixelArray) {
	        // Allocate pixel array if not already available, using supplied type
	        type = type || gl.UNSIGNED_BYTE;
	        var ArrayType = (0, _typedArrayUtils.getTypedArrayFromGLType)(type, {
	          clamped: false
	        });
	        var components = (0, _formatUtils.glFormatToComponents)(format); // TODO - check for composite type (components = 1).

	        pixelArray = pixelArray || new ArrayType(width * height * components);
	      } // Pixel array available, if necessary, deduce type from it.


	      type = type || (0, _typedArrayUtils.getGLTypeFromTypedArray)(pixelArray);
	      var prevHandle = this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);
	      this.gl.readPixels(x, y, width, height, format, type, pixelArray);
	      this.gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);
	      return pixelArray;
	    } // Reads data into provided buffer object asynchronously
	    // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.

	  }, {
	    key: "readPixelsToBuffer",
	    value: function readPixelsToBuffer(_ref8) {
	      var _ref8$x = _ref8.x,
	          x = _ref8$x === void 0 ? 0 : _ref8$x,
	          _ref8$y = _ref8.y,
	          y = _ref8$y === void 0 ? 0 : _ref8$y,
	          _ref8$width = _ref8.width,
	          width = _ref8$width === void 0 ? this.width : _ref8$width,
	          _ref8$height = _ref8.height,
	          height = _ref8$height === void 0 ? this.height : _ref8$height,
	          _ref8$format = _ref8.format,
	          format = _ref8$format === void 0 ? _constants.default.RGBA : _ref8$format,
	          type = _ref8.type,
	          _ref8$buffer = _ref8.buffer,
	          buffer = _ref8$buffer === void 0 ? null : _ref8$buffer,
	          _ref8$byteOffset = _ref8.byteOffset,
	          byteOffset = _ref8$byteOffset === void 0 ? 0 : _ref8$byteOffset;
	      var gl = this.gl; // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature

	      (0, _webglUtils.assertWebGL2Context)(gl); // deduce type if not available.

	      type = type || (buffer ? buffer.type : _constants.default.UNSIGNED_BYTE);

	      if (!buffer) {
	        // Create new buffer with enough size
	        var components = (0, _formatUtils.glFormatToComponents)(format);
	        var byteCount = (0, _formatUtils.glTypeToBytes)(type);
	        var bytes = byteOffset + width * height * components * byteCount;
	        buffer = new _buffer.default(gl, {
	          bytes: bytes,
	          type: type,
	          size: components
	        });
	      }

	      buffer.bind({
	        target: _constants.default.PIXEL_PACK_BUFFER
	      });
	      (0, _webglContext.withParameters)(gl, {
	        framebuffer: this
	      }, function () {
	        gl.readPixels(x, y, width, height, format, type, byteOffset);
	      });
	      buffer.unbind({
	        target: _constants.default.PIXEL_PACK_BUFFER
	      });
	      return buffer;
	    } // Reads pixels as a dataUrl

	  }, {
	    key: "copyToDataUrl",
	    value: function copyToDataUrl() {
	      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref9$attachment = _ref9.attachment,
	          attachment = _ref9$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref9$attachment,
	          _ref9$maxHeight = _ref9.maxHeight,
	          maxHeight = _ref9$maxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref9$maxHeight;

	      var data = this.readPixels({
	        attachment: attachment
	      }); // Scale down

	      var width = this.width,
	          height = this.height;

	      while (height > maxHeight) {
	        var _scalePixels = (0, _webglUtils.scalePixels)({
	          data: data,
	          width: width,
	          height: height
	        });

	        data = _scalePixels.data;
	        width = _scalePixels.width;
	        height = _scalePixels.height;
	      } // Flip to top down coordinate system


	      (0, _webglUtils.flipRows)({
	        data: data,
	        width: width,
	        height: height
	      });
	      /* global document */

	      var canvas = document.createElement('canvas');
	      canvas.width = width;
	      canvas.height = height;
	      var context = canvas.getContext('2d'); // Copy the pixels to a 2D canvas

	      var imageData = context.createImageData(width, height);
	      imageData.data.set(data);
	      context.putImageData(imageData, 0, 0);
	      return canvas.toDataURL();
	    } // Reads pixels into an HTML Image

	  }, {
	    key: "copyToImage",
	    value: function copyToImage() {
	      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref10$image = _ref10.image,
	          image = _ref10$image === void 0 ? null : _ref10$image,
	          _ref10$attachment = _ref10.attachment,
	          attachment = _ref10$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref10$attachment,
	          _ref10$maxHeight = _ref10.maxHeight,
	          maxHeight = _ref10$maxHeight === void 0 ? Number.MAX_SAFE_INTEGER : _ref10$maxHeight;

	      /* global Image */
	      var dataUrl = this.readDataUrl({
	        attachment: attachment
	      });
	      image = image || new Image();
	      image.src = dataUrl;
	      return image;
	    } // copyToFramebuffer({width, height}) {
	    //   const scaleX = width / this.width;
	    //   const scaleY = height / this.height;
	    //   const scale = Math.min(scaleX, scaleY);
	    //   width = width * scale;
	    //   height = height * scale;
	    //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});
	    //   this.blit();
	    // }
	    // Copy a rectangle from a framebuffer attachment into a texture (at an offset)

	  }, {
	    key: "copyToTexture",
	    value: function copyToTexture(_ref11) {
	      var texture = _ref11.texture,
	          target = _ref11.target,
	          _ref11$xoffset = _ref11.xoffset,
	          xoffset = _ref11$xoffset === void 0 ? 0 : _ref11$xoffset,
	          _ref11$yoffset = _ref11.yoffset,
	          yoffset = _ref11$yoffset === void 0 ? 0 : _ref11$yoffset,
	          _ref11$zoffset = _ref11.zoffset,
	          zoffset = _ref11$zoffset === void 0 ? 0 : _ref11$zoffset,
	          _ref11$mipmapLevel = _ref11.mipmapLevel,
	          mipmapLevel = _ref11$mipmapLevel === void 0 ? 0 : _ref11$mipmapLevel,
	          _ref11$attachment = _ref11.attachment,
	          attachment = _ref11$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref11$attachment,
	          _ref11$x = _ref11.x,
	          x = _ref11$x === void 0 ? 0 : _ref11$x,
	          _ref11$y = _ref11.y,
	          y = _ref11$y === void 0 ? 0 : _ref11$y,
	          width = _ref11.width,
	          height = _ref11.height;
	      var gl = this.gl;
	      var prevHandle = gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);
	      var prevBuffer = gl.readBuffer(attachment);
	      width = Number.isFinite(width) ? width : texture.width;
	      height = Number.isFinite(height) ? height : texture.height; // target

	      switch (texture.target) {
	        case GL_TEXTURE_2D:
	        case GL_TEXTURE_CUBE_MAP:
	          gl.copyTexSubImage2D(target || texture.target, mipmapLevel, xoffset, yoffset, x, y, width, height);
	          break;

	        case GL_TEXTURE_2D_ARRAY:
	        case GL_TEXTURE_3D:
	          gl.copyTexSubImage3D(target || texture.target, mipmapLevel, xoffset, yoffset, zoffset, x, y, width, height);
	          break;

	        default:
	      }

	      gl.readBuffer(prevBuffer);
	      gl.bindFramebuffer(GL_FRAMEBUFFER, prevHandle || null);
	      return texture;
	    } // WEBGL2 INTERFACE
	    // Copies a rectangle of pixels between framebuffers

	  }, {
	    key: "blit",
	    value: function blit(_ref12) {
	      var srcFramebuffer = _ref12.srcFramebuffer,
	          _ref12$attachment = _ref12.attachment,
	          attachment = _ref12$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref12$attachment,
	          _ref12$srcX = _ref12.srcX0,
	          srcX0 = _ref12$srcX === void 0 ? 0 : _ref12$srcX,
	          _ref12$srcY = _ref12.srcY0,
	          srcY0 = _ref12$srcY === void 0 ? 0 : _ref12$srcY,
	          srcX1 = _ref12.srcX1,
	          srcY1 = _ref12.srcY1,
	          _ref12$dstX = _ref12.dstX0,
	          dstX0 = _ref12$dstX === void 0 ? 0 : _ref12$dstX,
	          _ref12$dstY = _ref12.dstY0,
	          dstY0 = _ref12$dstY === void 0 ? 0 : _ref12$dstY,
	          dstX1 = _ref12.dstX1,
	          dstY1 = _ref12.dstY1,
	          _ref12$color = _ref12.color,
	          color = _ref12$color === void 0 ? true : _ref12$color,
	          _ref12$depth = _ref12.depth,
	          depth = _ref12$depth === void 0 ? false : _ref12$depth,
	          _ref12$stencil = _ref12.stencil,
	          stencil = _ref12$stencil === void 0 ? false : _ref12$stencil,
	          _ref12$mask = _ref12.mask,
	          mask = _ref12$mask === void 0 ? 0 : _ref12$mask,
	          _ref12$filter = _ref12.filter,
	          filter = _ref12$filter === void 0 ? _constants.default.NEAREST : _ref12$filter;
	      var gl = this.gl;
	      (0, _webglUtils.assertWebGL2Context)(gl);

	      if (!srcFramebuffer.handle && attachment === GL_COLOR_ATTACHMENT0) {
	        attachment = _constants.default.FRONT;
	      }

	      if (color) {
	        mask |= GL_COLOR_BUFFER_BIT;
	      }

	      if (depth) {
	        mask |= GL_DEPTH_BUFFER_BIT;
	      }

	      if (stencil) {
	        mask |= GL_STENCIL_BUFFER_BIT;
	      }

	      (0, _assert.default)(mask);
	      srcX1 = srcX1 === undefined ? srcFramebuffer.width : srcX1;
	      srcY1 = srcY1 === undefined ? srcFramebuffer.height : srcY1;
	      dstX1 = dstX1 === undefined ? this.width : dstX1;
	      dstY1 = dstY1 === undefined ? this.height : dstY1;
	      var prevDrawHandle = gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, this.handle);
	      var prevReadHandle = gl.bindFramebuffer(GL_READ_FRAMEBUFFER, srcFramebuffer.handle);
	      gl.readBuffer(attachment);
	      gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
	      gl.readBuffer(this.readBuffer);
	      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, prevReadHandle || null);
	      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, prevDrawHandle || null);
	      return this;
	    } // signals to the GL that it need not preserve all pixels of a specified region
	    // of the framebuffer

	  }, {
	    key: "invalidate",
	    value: function invalidate(_ref13) {
	      var _ref13$attachments = _ref13.attachments,
	          attachments = _ref13$attachments === void 0 ? [] : _ref13$attachments,
	          _ref13$x = _ref13.x,
	          x = _ref13$x === void 0 ? 0 : _ref13$x,
	          _ref13$y = _ref13.y,
	          y = _ref13$y === void 0 ? 0 : _ref13$y,
	          width = _ref13.width,
	          height = _ref13.height;
	      var gl = this.gl;
	      (0, _webglUtils.assertWebGL2Context)(gl);
	      var prevHandle = gl.bindFramebuffer(GL_READ_FRAMEBUFFER, this.handle);
	      var invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;

	      if (invalidateAll) {
	        gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments);
	      } else {
	        gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments, x, y, width, height);
	      }

	      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, prevHandle);
	      return this;
	    } // Return the value for `pname` of the specified attachment.
	    // The type returned is the type of the requested pname

	  }, {
	    key: "getAttachmentParameter",
	    value: function getAttachmentParameter() {
	      var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref14$attachment = _ref14.attachment,
	          attachment = _ref14$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref14$attachment,
	          pname = _ref14.pname;

	      var value = this._getAttachmentParameterFallback(pname);

	      if (value === null) {
	        this.gl.bindTexture(GL_FRAMEBUFFER, this.handle);
	        value = this.gl.getFramebufferAttachmentParameter(GL_FRAMEBUFFER, attachment, pname);
	        this.gl.bindTexture(GL_FRAMEBUFFER, null);
	      }

	      return value;
	    }
	  }, {
	    key: "getAttachmentParameters",
	    value: function getAttachmentParameters() {
	      var attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GL_COLOR_ATTACHMENT0;
	      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.ATTACHMENT_PARAMETERS || {};
	      var values = {};

	      for (var pname in parameters) {
	        values[pname] = this.getAttachmentParameter(pname);
	      }

	      return this;
	    } // DEBUG
	    // Note: Will only work when called in an event handler

	  }, {
	    key: "show",
	    value: function show() {
	      /* global window */
	      if (typeof window !== 'undefined') {
	        window.open(this.copyToDataUrl(), 'luma-debug-texture');
	      }

	      return this;
	    }
	  }, {
	    key: "log",
	    value: function log() {
	      var _ref15 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref15$priority = _ref15.priority,
	          priority = _ref15$priority === void 0 ? 0 : _ref15$priority,
	          _ref15$message = _ref15.message,
	          message = _ref15$message === void 0 ? '' : _ref15$message;

	      if (priority > _utils.log.priority || typeof window === 'undefined') {
	        return this;
	      }

	      message = message || "Framebuffer ".concat(this.id);
	      var image = this.copyToDataUrl({
	        maxHeight: 100
	      });

	      _utils.log.image({
	        priority: priority,
	        message: message,
	        image: image
	      }, message)();

	      return this;
	    } // WEBGL INTERFACE

	  }, {
	    key: "bind",
	    value: function bind() {
	      var _ref16 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref16$target = _ref16.target,
	          target = _ref16$target === void 0 ? GL_FRAMEBUFFER : _ref16$target;

	      this.gl.bindFramebuffer(target, this.handle);
	      return this;
	    }
	  }, {
	    key: "unbind",
	    value: function unbind() {
	      var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref17$target = _ref17.target,
	          target = _ref17$target === void 0 ? GL_FRAMEBUFFER : _ref17$target;

	      this.gl.bindFramebuffer(target, null);
	      return this;
	    } // PRIVATE METHODS

	  }, {
	    key: "_createDefaultAttachments",
	    value: function _createDefaultAttachments(_ref18) {
	      var color = _ref18.color,
	          depth = _ref18.depth,
	          stencil = _ref18.stencil,
	          width = _ref18.width,
	          height = _ref18.height;
	      var defaultAttachments = null; // Add a color buffer if requested and not supplied

	      if (color) {
	        var _parameters;

	        defaultAttachments = defaultAttachments || {};
	        defaultAttachments[GL_COLOR_ATTACHMENT0] = new _texture2d.default(this.gl, {
	          pixels: null,
	          // reserves texture memory, but texels are undefined
	          format: _constants.default.RGBA,
	          type: _constants.default.UNSIGNED_BYTE,
	          width: width,
	          height: height,
	          // Note: Mipmapping can be disabled by texture resource when we resize the texture
	          // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant
	          // behavior we always disable mipmaps.
	          mipmaps: false,
	          // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.
	          // Set WRAP modes that support NPOT textures too.
	          parameters: (_parameters = {}, _defineProperty(_parameters, _constants.default.TEXTURE_MIN_FILTER, _constants.default.NEAREST), _defineProperty(_parameters, _constants.default.TEXTURE_MAG_FILTER, _constants.default.NEAREST), _defineProperty(_parameters, _constants.default.TEXTURE_WRAP_S, _constants.default.CLAMP_TO_EDGE), _defineProperty(_parameters, _constants.default.TEXTURE_WRAP_T, _constants.default.CLAMP_TO_EDGE), _parameters)
	        });
	      } // Add a depth buffer if requested and not supplied


	      if (depth) {
	        defaultAttachments = defaultAttachments || {};
	        defaultAttachments[GL_DEPTH_ATTACHMENT] = new _renderbuffer.default(this.gl, {
	          format: _constants.default.DEPTH_COMPONENT16,
	          width: width,
	          height: height
	        });
	      } // TODO - handle stencil and combined depth and stencil


	      return defaultAttachments;
	    }
	  }, {
	    key: "_unattach",
	    value: function _unattach(_ref19) {
	      var attachment = _ref19.attachment;
	      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);
	      this.gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, null);
	      delete this.attachments[attachment];
	    }
	  }, {
	    key: "_attachRenderbuffer",
	    value: function _attachRenderbuffer(_ref20) {
	      var _ref20$attachment = _ref20.attachment,
	          attachment = _ref20$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref20$attachment,
	          renderbuffer = _ref20.renderbuffer;
	      var gl = this.gl; // TODO - is the bind needed?
	      // gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.handle);

	      gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, renderbuffer.handle); // TODO - is the unbind needed?
	      // gl.bindRenderbuffer(GL_RENDERBUFFER, null);

	      this.attachments[attachment] = renderbuffer;
	    } // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`
	    // level = 0 - mipmapLevel (must be 0 in WebGL1)

	  }, {
	    key: "_attachTexture",
	    value: function _attachTexture(_ref21) {
	      var _ref21$attachment = _ref21.attachment,
	          attachment = _ref21$attachment === void 0 ? GL_COLOR_ATTACHMENT0 : _ref21$attachment,
	          texture = _ref21.texture,
	          layer = _ref21.layer,
	          level = _ref21.level;
	      var gl = this.gl;
	      gl.bindTexture(texture.target, texture.handle);

	      switch (texture.target) {
	        case GL_TEXTURE_2D_ARRAY:
	        case GL_TEXTURE_3D:
	          gl.framebufferTextureLayer(GL_FRAMEBUFFER, attachment, texture.target, level, layer);
	          break;

	        case GL_TEXTURE_CUBE_MAP:
	          // layer must be a cubemap face (or if index, converted to cube map face)
	          var face = mapIndexToCubeMapFace(layer);
	          gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, face, texture.handle, level);
	          break;

	        case GL_TEXTURE_2D:
	          gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, GL_TEXTURE_2D, texture.handle, level);
	          break;

	        default:
	          (0, _assert.default)(false, 'Illegal texture type');
	      }

	      gl.bindTexture(texture.target, null);
	      this.attachments[attachment] = texture;
	    } // Expects framebuffer to be bound

	  }, {
	    key: "_setReadBuffer",
	    value: function _setReadBuffer(gl, readBuffer) {
	      if ((0, _webglUtils.isWebGL2)(gl)) {
	        gl.readBuffer(readBuffer);
	      } else {
	        // Setting to color attachment 0 is a noop, so allow it in WebGL1
	        (0, _assert.default)(readBuffer === GL_COLOR_ATTACHMENT0 || readBuffer === _constants.default.BACK, ERR_MULTIPLE_RENDERTARGETS);
	      }

	      this.readBuffer = readBuffer;
	    } // Expects framebuffer to be bound

	  }, {
	    key: "_setDrawBuffers",
	    value: function _setDrawBuffers(gl, drawBuffers) {
	      if ((0, _webglUtils.isWebGL2)(gl)) {
	        gl.drawBuffers(drawBuffers);
	      } else {
	        var ext = gl.getExtension('WEBGL_draw_buffers');

	        if (ext) {
	          ext.drawBuffersWEBGL(drawBuffers);
	        } else {
	          // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1
	          (0, _assert.default)(drawBuffers.length === 1 && (drawBuffers[0] === GL_COLOR_ATTACHMENT0 || drawBuffers[0] === _constants.default.BACK), ERR_MULTIPLE_RENDERTARGETS);
	        }
	      }

	      this.drawBuffers = drawBuffers;
	    } // Attempt to provide workable defaults for WebGL2 symbols under WebGL1
	    // null means OK to query

	    /* eslint-disable complexity */

	  }, {
	    key: "_getAttachmentParameterFallback",
	    value: function _getAttachmentParameterFallback(pname) {
	      var caps = (0, _contextFeatures.getFeatures)(this.gl);

	      switch (pname) {
	        case _constants.default.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:
	          // GLint
	          return !caps.webgl2 ? 0 : null;

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:
	          // GLint
	          return !caps.webgl2 ? 8 : null;

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:
	          // GLenum
	          return !caps.webgl2 ? _constants.default.UNSIGNED_INT : null;

	        case _constants.default.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
	          return !caps.webgl2 && !caps.EXT_sRGB ? _constants.default.LINEAR : null;

	        default:
	          return null;
	      }
	    }
	    /* eslint-enable complexity */
	    // RESOURCE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createFramebuffer();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteFramebuffer(this.handle);
	    }
	  }, {
	    key: "color",
	    get: function get() {
	      return this.attachments[GL_COLOR_ATTACHMENT0] || null;
	    }
	  }, {
	    key: "texture",
	    get: function get() {
	      return this.attachments[GL_COLOR_ATTACHMENT0] || null;
	    }
	  }, {
	    key: "depth",
	    get: function get() {
	      return this.attachments[GL_DEPTH_ATTACHMENT] || null;
	    }
	  }, {
	    key: "stencil",
	    get: function get() {
	      return this.attachments[GL_STENCIL_ATTACHMENT] || null;
	    }
	  }]);

	  return Framebuffer;
	}(_resource.default); // PUBLIC METHODS
	// Map an index to a cube map face constant


	exports.default = Framebuffer;

	function mapIndexToCubeMapFace(layer) {
	  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)
	  // if smaller assume layer is index, otherwise assume it is already a cube map face constant
	  return layer < GL_TEXTURE_CUBE_MAP_POSITIVE_X ? layer + GL_TEXTURE_CUBE_MAP_POSITIVE_X : layer;
	} // Helper METHODS
	// Get a string describing the framebuffer error if installed


	function _getFrameBufferStatus(status) {
	  // Use error mapping if installed
	  var STATUS = Framebuffer.STATUS || {};
	  return STATUS[status] || "Framebuffer error ".concat(status);
	}
	//# sourceMappingURL=framebuffer.js.map

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _texture = _interopRequireDefault(__webpack_require__(88));

	var _webglUtils = __webpack_require__(48);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var Texture2D =
	/*#__PURE__*/
	function (_Texture) {
	  _inherits(Texture2D, _Texture);

	  _createClass(Texture2D, null, [{
	    key: "isSupported",
	    value: function isSupported(gl, opts) {
	      return _texture.default.isSupported(gl, opts);
	    }
	    /**
	     * @classdesc
	     * 2D WebGL Texture
	     * Note: Constructor will initialize your texture.
	     *
	     * @class
	     * @param {WebGLRenderingContext} gl - gl context
	     * @param {Image|ArrayBuffer|null} opts= - named options
	     * @param {Image|ArrayBuffer|null} opts.data= - buffer
	     * @param {GLint} width - width of texture
	     * @param {GLint} height - height of texture
	     */

	  }]);

	  function Texture2D(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Texture2D);

	    (0, _webglUtils.assertWebGLContext)(gl);
	    _this = _possibleConstructorReturn(this, (Texture2D.__proto__ || Object.getPrototypeOf(Texture2D)).call(this, gl, Object.assign({}, opts, {
	      target: gl.TEXTURE_2D
	    })));

	    _this.initialize(opts);

	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  } // target cannot be modified by bind:
	  // textures are special because when you first bind them to a target,
	  // they get special information. When you first bind a texture as a
	  // GL_TEXTURE_2D, you are actually setting special state in the texture.
	  // You are saying that this texture is a 2D texture.
	  // And it will always be a 2D texture; this state cannot be changed ever.
	  // If you have a texture that was first bound as a GL_TEXTURE_2D,
	  // you must always bind it as a GL_TEXTURE_2D;
	  // attempting to bind it as GL_TEXTURE_1D will give rise to an error
	  // (while run-time).


	  _createClass(Texture2D, [{
	    key: "bind",
	    value: function bind() {
	      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;
	      var gl = this.gl;

	      if (textureUnit === undefined) {
	        throw new Error('Texture.bind: must specify texture unit');
	      }

	      this.textureUnit = textureUnit;
	      gl.activeTexture(gl.TEXTURE0 + textureUnit);
	      gl.bindTexture(this.target, this.handle);
	      return textureUnit;
	    }
	  }, {
	    key: "unbind",
	    value: function unbind() {
	      var gl = this.gl;

	      if (this.textureUnit === undefined) {
	        throw new Error('Texture.unbind: texture unit not specified');
	      }

	      gl.activeTexture(gl.TEXTURE0 + this.textureUnit);
	      gl.bindTexture(this.target, null);
	      return this.textureUnit;
	    }
	  }, {
	    key: "getActiveUnit",
	    value: function getActiveUnit() {
	      return this.gl.getParameter(_constants.default.ACTIVE_TEXTURE) - _constants.default.TEXTURE0;
	    }
	  }]);

	  return Texture2D;
	}(_texture.default);

	exports.default = Texture2D;
	//# sourceMappingURL=texture-2d.js.map

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.RENDERBUFFER_FORMATS = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglUtils = __webpack_require__(48);

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _RENDERBUFFER_FORMATS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// Define local GL constants to optimize minification
	var GL_RENDERBUFFER = 0x8D41;
	var GL_SAMPLES = 0x80A9;
	var GL_RENDERBUFFER_WIDTH = 0x8D42;
	var GL_RENDERBUFFER_HEIGHT = 0x8D43;
	var GL_RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
	var GL_RENDERBUFFER_SAMPLES = 0x8CAB; // Define local extension strings to optimize minification
	// const SRGB = 'EXT_sRGB';
	// const CB_FLOAT_WEBGL1 = 'WEBGL_color_buffer_float';

	var CB_FLOAT_WEBGL2 = 'EXT_color_buffer_float'; // const CB_HALF_FLOAT_WEBGL1 = 'EXT_color_buffer_half_float';

	var RENDERBUFFER_FORMATS = (_RENDERBUFFER_FORMATS = {}, _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.DEPTH_COMPONENT16, {}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.DEPTH_COMPONENT24, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.DEPTH_COMPONENT32F, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.STENCIL_INDEX8, {}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.DEPTH_STENCIL, {}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.DEPTH24_STENCIL8, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.DEPTH32F_STENCIL8, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA4, {}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGB565, {}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGB5_A1, {}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R8, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R8UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R8I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R16UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R16I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R32UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R32I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG8, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG8UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG8I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG16UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG16I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG32UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG32I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGB8, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA8, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGB10_A2, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA8UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA8I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGB10_A2UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA16UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA16I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA32I, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA32UI, {
	  gl2: true
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R16F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG16F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA16F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R32F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RG32F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.RGBA32F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _defineProperty(_RENDERBUFFER_FORMATS, _constants.default.R11F_G11F_B10F, {
	  gl2: CB_FLOAT_WEBGL2
	}), _RENDERBUFFER_FORMATS);
	exports.RENDERBUFFER_FORMATS = RENDERBUFFER_FORMATS;

	function isFormatSupported(gl, format, formats) {
	  var info = formats[format];

	  if (!info) {
	    return false;
	  }

	  var value = (0, _webglUtils.isWebGL2)(gl) ? info.gl2 || info.gl1 : info.gl1;

	  if (typeof value === 'string') {
	    return gl.getExtension(value);
	  }

	  return value;
	}

	var Renderbuffer =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Renderbuffer, _Resource);

	  _createClass(Renderbuffer, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          format = _ref.format;

	      return !format || isFormatSupported(gl, format, RENDERBUFFER_FORMATS);
	    }
	  }, {
	    key: "getSamplesForFormat",
	    value: function getSamplesForFormat(gl, _ref2) {
	      var format = _ref2.format;
	      // Polyfilled to return [0] under WebGL1
	      return gl.getInternalformatParameter(GL_RENDERBUFFER, format, GL_SAMPLES);
	    }
	  }]);

	  function Renderbuffer(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Renderbuffer);

	    _this = _possibleConstructorReturn(this, (Renderbuffer.__proto__ || Object.getPrototypeOf(Renderbuffer)).call(this, gl, opts));

	    _this.initialize(opts);

	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  } // Creates and initializes a renderbuffer object's data store


	  _createClass(Renderbuffer, [{
	    key: "initialize",
	    value: function initialize(_ref3) {
	      var format = _ref3.format,
	          _ref3$width = _ref3.width,
	          width = _ref3$width === void 0 ? 1 : _ref3$width,
	          _ref3$height = _ref3.height,
	          height = _ref3$height === void 0 ? 1 : _ref3$height,
	          _ref3$samples = _ref3.samples,
	          samples = _ref3$samples === void 0 ? 0 : _ref3$samples;
	      (0, _assert.default)(format, 'Needs format');
	      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);

	      if (samples !== 0 && (0, _webglUtils.isWebGL2)(this.gl)) {
	        this.gl.renderbufferStorageMultisample(GL_RENDERBUFFER, samples, format, width, height);
	      } else {
	        this.gl.renderbufferStorage(GL_RENDERBUFFER, format, width, height);
	      } // this.gl.bindRenderbuffer(GL_RENDERBUFFER, null);


	      this.format = format;
	      this.width = width;
	      this.height = height;
	      this.samples = samples;
	      return this;
	    }
	  }, {
	    key: "resize",
	    value: function resize(_ref4) {
	      var width = _ref4.width,
	          height = _ref4.height;

	      // Don't resize if width/height haven't changed
	      if (width !== this.width || height !== this.height) {
	        return this.initialize({
	          width: width,
	          height: height,
	          format: this.format,
	          samples: this.samples
	        });
	      }

	      return this;
	    } // PRIVATE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createRenderbuffer();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteRenderbuffer(this.handle);
	    }
	  }, {
	    key: "_syncHandle",
	    value: function _syncHandle(handle) {
	      this.format = this.getParameter(GL_RENDERBUFFER_INTERNAL_FORMAT);
	      this.width = this.getParameter(GL_RENDERBUFFER_WIDTH);
	      this.height = this.getParameter(GL_RENDERBUFFER_HEIGHT);
	      this.samples = this.getParameter(GL_RENDERBUFFER_SAMPLES);
	    } // @param {Boolean} opt.autobind=true - method call will bind/unbind object
	    // @returns {GLenum|GLint} - depends on pname

	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname) {
	      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);
	      var value = this.gl.getRenderbufferParameter(GL_RENDERBUFFER, pname); // this.gl.bindRenderbuffer(GL_RENDERBUFFER, null);

	      return value;
	    }
	  }]);

	  return Renderbuffer;
	}(_resource.default);

	exports.default = Renderbuffer;
	//# sourceMappingURL=renderbuffer.js.map

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.clear = clear;
	exports.clearBuffer = clearBuffer;

	var _contextState = __webpack_require__(78);

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	// Should collapse during minification
	var GL_DEPTH_BUFFER_BIT = 0x00000100;
	var GL_STENCIL_BUFFER_BIT = 0x00000400;
	var GL_COLOR_BUFFER_BIT = 0x00004000;
	var GL_COLOR = 0x1800;
	var GL_DEPTH = 0x1801;
	var GL_STENCIL = 0x1802;
	var GL_DEPTH_STENCIL = 0x84F9; // Should disappear if asserts are removed

	var ERR_ARGUMENTS = 'clear: bad arguments'; // Optionally clears depth, color and stencil buffers

	function clear(gl) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$framebuffer = _ref.framebuffer,
	      framebuffer = _ref$framebuffer === void 0 ? null : _ref$framebuffer,
	      _ref$color = _ref.color,
	      color = _ref$color === void 0 ? null : _ref$color,
	      _ref$depth = _ref.depth,
	      depth = _ref$depth === void 0 ? null : _ref$depth,
	      _ref$stencil = _ref.stencil,
	      stencil = _ref$stencil === void 0 ? null : _ref$stencil;

	  var parameters = {};

	  if (framebuffer) {
	    parameters.framebuffer = framebuffer;
	  }

	  var clearFlags = 0;

	  if (color) {
	    clearFlags |= GL_COLOR_BUFFER_BIT;

	    if (color !== true) {
	      parameters.clearColor = color;
	    }
	  }

	  if (depth) {
	    clearFlags |= GL_DEPTH_BUFFER_BIT;

	    if (depth !== true) {
	      parameters.clearDepth = depth;
	    }
	  }

	  if (stencil) {
	    clearFlags |= GL_STENCIL_BUFFER_BIT;

	    if (depth !== true) {
	      parameters.clearStencil = depth;
	    }
	  }

	  (0, _assert.default)(clearFlags !== 0, ERR_ARGUMENTS); // Temporarily set any clear "colors" and call clear

	  (0, _contextState.withParameters)(gl, parameters, function () {
	    gl.clear(clearFlags);
	  });
	} // WebGL2 - clear a specific drawing buffer


	function clearBuffer(gl) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref2$framebuffer = _ref2.framebuffer,
	      framebuffer = _ref2$framebuffer === void 0 ? null : _ref2$framebuffer,
	      _ref2$buffer = _ref2.buffer,
	      buffer = _ref2$buffer === void 0 ? GL_COLOR : _ref2$buffer,
	      _ref2$drawBuffer = _ref2.drawBuffer,
	      drawBuffer = _ref2$drawBuffer === void 0 ? 0 : _ref2$drawBuffer,
	      _ref2$value = _ref2.value,
	      value = _ref2$value === void 0 ? [0, 0, 0, 0] : _ref2$value;

	  (0, _webglUtils.assertWebGL2Context)(gl);
	  (0, _contextState.withParameters)(gl, {
	    framebuffer: framebuffer
	  }, function () {
	    // Method selection per OpenGL ES 3 docs
	    switch (buffer) {
	      case GL_COLOR:
	        switch (value.constructor) {
	          case Int32Array:
	            gl.clearBufferiv(buffer, drawBuffer, value);
	            break;

	          case Uint32Array:
	            gl.clearBufferuiv(buffer, drawBuffer, value);
	            break;

	          case Float32Array:
	          default:
	            gl.clearBufferfv(buffer, drawBuffer, value);
	        }

	        break;

	      case GL_DEPTH:
	        gl.clearBufferfv(GL_DEPTH, 0, [value]);
	        break;

	      case GL_STENCIL:
	        gl.clearBufferiv(GL_STENCIL, 0, [value]);
	        break;

	      case GL_DEPTH_STENCIL:
	        var _value = _slicedToArray(value, 2),
	            depth = _value[0],
	            stencil = _value[1];

	        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
	        break;

	      default:
	        (0, _assert.default)(false, ERR_ARGUMENTS);
	    }
	  });
	}
	//# sourceMappingURL=clear.js.map

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.glFormatToComponents = glFormatToComponents;
	exports.glTypeToBytes = glTypeToBytes;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var GL_ALPHA = 0x1906;
	var GL_RGB = 0x1907;
	var GL_RGBA = 0x1908;
	var GL_UNSIGNED_BYTE = 0x1401;
	var GL_UNSIGNED_SHORT_4_4_4_4 = 0x8033;
	var GL_UNSIGNED_SHORT_5_5_5_1 = 0x8034;
	var GL_UNSIGNED_SHORT_5_6_5 = 0x8363;
	var GL_FLOAT = 0x1406; // Returns number of components in a specific readPixels WebGL format

	function glFormatToComponents(format) {
	  switch (format) {
	    case GL_ALPHA:
	      return 1;

	    case GL_RGB:
	      return 3;

	    case GL_RGBA:
	      return 4;
	    // TODO: Add support for additional WebGL2 formats

	    default:
	      (0, _assert.default)(false);
	      return 0;
	  }
	} // Return byte count for given readPixels WebGL type


	function glTypeToBytes(type) {
	  switch (type) {
	    case GL_UNSIGNED_BYTE:
	      return 1;

	    case GL_UNSIGNED_SHORT_5_6_5:
	    case GL_UNSIGNED_SHORT_4_4_4_4:
	    case GL_UNSIGNED_SHORT_5_5_5_1:
	      return 2;

	    case GL_FLOAT:
	      return 4;
	    // TODO: Add support for additional WebGL2 types

	    default:
	      (0, _assert.default)(false);
	      return 0;
	  }
	}
	//# sourceMappingURL=format-utils.js.map

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parseUniformName = parseUniformName;
	exports.getUniformSetter = getUniformSetter;
	exports.checkUniformValues = checkUniformValues;
	exports.areUniformsEqual = areUniformsEqual;
	exports.getUniformsTable = getUniformsTable;

	var _framebuffer = _interopRequireDefault(__webpack_require__(89));

	var _texture = _interopRequireDefault(__webpack_require__(88));

	var _sampler = _interopRequireDefault(__webpack_require__(95));

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _UNIFORM_SETTERS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	// Local constants, will be "collapsed" during minification
	// WebGL1
	var GL_FLOAT = 0x1406;
	var GL_FLOAT_VEC2 = 0x8B50;
	var GL_FLOAT_VEC3 = 0x8B51;
	var GL_FLOAT_VEC4 = 0x8B52;
	var GL_INT = 0x1404;
	var GL_INT_VEC2 = 0x8B53;
	var GL_INT_VEC3 = 0x8B54;
	var GL_INT_VEC4 = 0x8B55;
	var GL_BOOL = 0x8B56;
	var GL_BOOL_VEC2 = 0x8B57;
	var GL_BOOL_VEC3 = 0x8B58;
	var GL_BOOL_VEC4 = 0x8B59;
	var GL_FLOAT_MAT2 = 0x8B5A;
	var GL_FLOAT_MAT3 = 0x8B5B;
	var GL_FLOAT_MAT4 = 0x8B5C;
	var GL_SAMPLER_2D = 0x8B5E;
	var GL_SAMPLER_CUBE = 0x8B60; // WebGL2

	var GL_UNSIGNED_INT = 0x1405;
	var GL_UNSIGNED_INT_VEC2 = 0x8DC6;
	var GL_UNSIGNED_INT_VEC3 = 0x8DC7;
	var GL_UNSIGNED_INT_VEC4 = 0x8DC8;
	/* eslint-disable camelcase */

	var GL_FLOAT_MAT2x3 = 0x8B65;
	var GL_FLOAT_MAT2x4 = 0x8B66;
	var GL_FLOAT_MAT3x2 = 0x8B67;
	var GL_FLOAT_MAT3x4 = 0x8B68;
	var GL_FLOAT_MAT4x2 = 0x8B69;
	var GL_FLOAT_MAT4x3 = 0x8B6A;
	var GL_SAMPLER_3D = 0x8B5F;
	var GL_SAMPLER_2D_SHADOW = 0x8B62;
	var GL_SAMPLER_2D_ARRAY = 0x8DC1;
	var GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
	var GL_SAMPLER_CUBE_SHADOW = 0x8DC5;
	var GL_INT_SAMPLER_2D = 0x8DCA;
	var GL_INT_SAMPLER_3D = 0x8DCB;
	var GL_INT_SAMPLER_CUBE = 0x8DCC;
	var GL_INT_SAMPLER_2D_ARRAY = 0x8DCF;
	var GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
	var GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
	var GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
	var GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
	var UNIFORM_SETTERS = (_UNIFORM_SETTERS = {}, _defineProperty(_UNIFORM_SETTERS, GL_FLOAT, function (gl, location, value) {
	  return gl.uniform1f(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC2, function (gl, location, value) {
	  return gl.uniform2fv(location, toFloatArray(value, 2));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC3, function (gl, location, value) {
	  return gl.uniform3fv(location, toFloatArray(value, 3));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC4, function (gl, location, value) {
	  return gl.uniform4fv(location, toFloatArray(value, 4));
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC2, function (gl, location, value) {
	  return gl.uniform2iv(location, toIntArray(value, 2));
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC3, function (gl, location, value) {
	  return gl.uniform3iv(location, toIntArray(value, 3));
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC4, function (gl, location, value) {
	  return gl.uniform4iv(location, toIntArray(value, 4));
	}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC2, function (gl, location, value) {
	  return gl.uniform2iv(location, toIntArray(value, 2));
	}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC3, function (gl, location, value) {
	  return gl.uniform3iv(location, toIntArray(value, 3));
	}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC4, function (gl, location, value) {
	  return gl.uniform4iv(location, toIntArray(value, 4));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2, function (gl, location, value) {
	  return gl.uniformMatrix2fv(location, false, toFloatArray(value, 4));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3, function (gl, location, value) {
	  return gl.uniformMatrix3fv(location, false, toFloatArray(value, 9));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4, function (gl, location, value) {
	  return gl.uniformMatrix4fv(location, false, toFloatArray(value, 16));
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_CUBE, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT, function (gl, location, value) {
	  return gl.uniform1ui(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC2, function (gl, location, value) {
	  return gl.uniform2uiv(location, toUIntArray(value, 2));
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC3, function (gl, location, value) {
	  return gl.uniform3uiv(location, toUIntArray(value, 3));
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC4, function (gl, location, value) {
	  return gl.uniform4uiv(location, toUIntArray(value, 4));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2x3, function (gl, location, value) {
	  return gl.uniformMatrix2x3fv(location, false, toFloatArray(value, 6));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2x4, function (gl, location, value) {
	  return gl.uniformMatrix2x4fv(location, false, toFloatArray(value, 8));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3x2, function (gl, location, value) {
	  return gl.uniformMatrix3x2fv(location, false, toFloatArray(value, 6));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3x4, function (gl, location, value) {
	  return gl.uniformMatrix3x4fv(location, false, toFloatArray(value, 12));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4x2, function (gl, location, value) {
	  return gl.uniformMatrix4x2fv(location, false, toFloatArray(value, 8));
	}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4x3, function (gl, location, value) {
	  return gl.uniformMatrix4x3fv(location, false, toFloatArray(value, 12));
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_3D, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_SHADOW, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_ARRAY, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_ARRAY_SHADOW, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_CUBE_SHADOW, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_2D, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_3D, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_CUBE, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_2D_ARRAY, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_2D, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_3D, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_CUBE, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, function (gl, location, value) {
	  return gl.uniform1i(location, value);
	}), _UNIFORM_SETTERS); // Pre-allocated typed arrays for temporary conversion

	var FLOAT_ARRAY = {};
	var INT_ARRAY = {};
	var UINT_ARRAY = {};
	/* Functions to ensure the type of uniform values */

	function toTypedArray(value, uniformLength, Type, cache) {
	  var length = value.length;

	  if (length % uniformLength) {
	    _utils.log.warn("Uniform size should be multiples of ".concat(uniformLength), value)();
	  }

	  if (_instanceof(value, Type)) {
	    return value;
	  }

	  var result = cache[length];

	  if (!result) {
	    result = new Type(length);
	    cache[length] = result;
	  }

	  for (var i = 0; i < length; i++) {
	    result[i] = value[i];
	  }

	  return result;
	}

	function toFloatArray(value, uniformLength) {
	  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
	}

	function toIntArray(value, uniformLength) {
	  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
	}

	function toUIntArray(value, uniformLength) {
	  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
	}

	function parseUniformName(name) {
	  // name = name[name.length - 1] === ']' ?
	  // name.substr(0, name.length - 3) : name;
	  // if array name then clean the array brackets
	  var UNIFORM_NAME_REGEXP = /([^\[]*)(\[[0-9]+\])?/;
	  var matches = name.match(UNIFORM_NAME_REGEXP);

	  if (!matches || matches.length < 2) {
	    throw new Error("Failed to parse GLSL uniform name ".concat(name));
	  }

	  return {
	    name: matches[1],
	    length: matches[2] || 1,
	    isArray: Boolean(matches[2])
	  };
	} // Returns a Magic Uniform Setter

	/* eslint-disable complexity */


	function getUniformSetter(gl, location, info) {
	  var setter = UNIFORM_SETTERS[info.type];

	  if (!setter) {
	    throw new Error("Unknown GLSL uniform type ".concat(info.type));
	  }

	  return setter.bind(null, gl, location);
	} // Basic checks of uniform values without knowledge of program
	// To facilitate early detection of e.g. undefined values in JavaScript


	function checkUniformValues(uniforms, source) {
	  for (var uniformName in uniforms) {
	    var value = uniforms[uniformName];

	    if (!checkUniformValue(value)) {
	      // Add space to source
	      source = source ? "".concat(source, " ") : ''; // Value could be unprintable so write the object on console

	      console.error("".concat(source, " Bad uniform ").concat(uniformName), value); // eslint-disable-line

	      /* eslint-enable no-console */

	      throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
	    }
	  }

	  return true;
	} // TODO use type information during validation


	function checkUniformValue(value) {
	  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
	    return checkUniformArray(value);
	  } // Check if single value is a number


	  if (isFinite(value)) {
	    return true;
	  } else if (value === true || value === false) {
	    return true;
	  } else if (_instanceof(value, _texture.default) || _instanceof(value, _sampler.default)) {
	    return true;
	  } else if (_instanceof(value, _framebuffer.default)) {
	    return Boolean(value.texture);
	  }

	  return false;
	}

	function checkUniformArray(value) {
	  // Check that every element in array is a number, and at least 1 element
	  if (value.length === 0) {
	    return false;
	  }

	  var checkLength = Math.min(value.length, 16);

	  for (var i = 0; i < checkLength; ++i) {
	    if (!Number.isFinite(value[i])) {
	      return false;
	    }
	  }

	  return true;
	}
	/**
	 * Given two values of a uniform, returns `true` if they are equal
	 */


	function areUniformsEqual(uniform1, uniform2) {
	  if (Array.isArray(uniform1) || ArrayBuffer.isView(uniform1)) {
	    if (!uniform2) {
	      return false;
	    }

	    var len = uniform1.length;

	    if (uniform2.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      if (uniform1[i] !== uniform2[i]) {
	        return false;
	      }
	    }

	    return true;
	  }

	  return uniform1 === uniform2;
	} // Prepares a table suitable for console.table

	/* eslint-disable max-statements */


	function getUniformsTable() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      _ref$header = _ref.header,
	      header = _ref$header === void 0 ? 'Uniforms' : _ref$header,
	      program = _ref.program,
	      uniforms = _ref.uniforms,
	      _ref$undefinedOnly = _ref.undefinedOnly,
	      undefinedOnly = _ref$undefinedOnly === void 0 ? false : _ref$undefinedOnly;

	  (0, _assert.default)(program);
	  var SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
	  var PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list

	  var uniformLocations = program._uniformSetters;
	  var table = {}; // {[header]: {}};
	  // Add program's provided uniforms (in alphabetical order)

	  var uniformNames = Object.keys(uniformLocations).sort();
	  var count = 0; // First add non-underscored uniforms (assumed not coming from shader modules)

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = uniformNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var _uniformName = _step.value;

	      if (!_uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !_uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
	        if (addUniformToTable({
	          table: table,
	          header: header,
	          uniforms: uniforms,
	          uniformName: _uniformName,
	          undefinedOnly: undefinedOnly
	        })) {
	          count++;
	        }
	      }
	    } // add underscored uniforms (assumed from shader modules)

	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = uniformNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var _uniformName2 = _step2.value;

	      if (_uniformName2.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
	        if (addUniformToTable({
	          table: table,
	          header: header,
	          uniforms: uniforms,
	          uniformName: _uniformName2,
	          undefinedOnly: undefinedOnly
	        })) {
	          count++;
	        }
	      }
	    }
	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;

	  try {
	    for (var _iterator3 = uniformNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var _uniformName3 = _step3.value;

	      if (!table[_uniformName3]) {
	        if (addUniformToTable({
	          table: table,
	          header: header,
	          uniforms: uniforms,
	          uniformName: _uniformName3,
	          undefinedOnly: undefinedOnly
	        })) {
	          count++;
	        }
	      }
	    } // Create a table of unused uniforms

	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }

	  var unusedCount = 0;
	  var unusedTable = {};

	  if (!undefinedOnly) {
	    for (var uniformName in uniforms) {
	      var uniform = uniforms[uniformName];

	      if (!table[uniformName]) {
	        unusedCount++;
	        unusedTable[uniformName] = _defineProperty({
	          Type: "NOT USED: ".concat(uniform)
	        }, header, (0, _utils.formatValue)(uniform));
	      }
	    }
	  }

	  return {
	    table: table,
	    count: count,
	    unusedTable: unusedTable,
	    unusedCount: unusedCount
	  };
	} // Helper


	function addUniformToTable(_ref2) {
	  var table = _ref2.table,
	      header = _ref2.header,
	      uniforms = _ref2.uniforms,
	      uniformName = _ref2.uniformName,
	      undefinedOnly = _ref2.undefinedOnly;
	  var value = uniforms[uniformName];
	  var isDefined = isUniformDefined(value);

	  if (!undefinedOnly || !isDefined) {
	    var _table$uniformName;

	    table[uniformName] = (_table$uniformName = {}, _defineProperty(_table$uniformName, header, isDefined ? (0, _utils.formatValue)(value) : 'N/A'), _defineProperty(_table$uniformName, 'Uniform Type', isDefined ? value : 'NOT PROVIDED'), _table$uniformName);
	    return true;
	  }

	  return false;
	}

	function isUniformDefined(value) {
	  return value !== undefined && value !== null;
	}
	//# sourceMappingURL=uniforms.js.map

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglUtils = __webpack_require__(48);

	var _resource = _interopRequireDefault(__webpack_require__(83));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var Sampler =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Sampler, _Resource);

	  _createClass(Sampler, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      return (0, _webglUtils.isWebGL2)(gl);
	    }
	  }, {
	    key: "isHandle",
	    value: function isHandle(handle) {
	      return this.gl.isSampler(this.handle);
	    }
	  }]);

	  function Sampler(gl, opts) {
	    var _this;

	    _classCallCheck(this, Sampler);

	    (0, _webglUtils.assertWebGL2Context)(gl);
	    _this = _possibleConstructorReturn(this, (Sampler.__proto__ || Object.getPrototypeOf(Sampler)).call(this, gl, opts));
	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  }
	  /**
	   * Bind to the same texture unit as a texture to control sampling for that texture
	   * @param {GLuint} unit - texture unit index
	   * @return {Sampler} - returns self to enable chaining
	   */


	  _createClass(Sampler, [{
	    key: "bind",
	    value: function bind(unit) {
	      this.gl.bindSampler(unit, this.handle);
	      return this;
	    }
	    /**
	     * Bind to the same texture unit as a texture to control sampling for that texture
	     * @param {GLuint} unit - texture unit index
	     * @return {Sampler} - returns self to enable chaining
	     */

	  }, {
	    key: "unbind",
	    value: function unbind(unit) {
	      this.gl.bindSampler(unit, null);
	      return this;
	    } // RESOURCE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createSampler();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteSampler(this.handle);
	    }
	  }, {
	    key: "_getParameter",
	    value: function _getParameter(pname) {
	      var value = this.gl.getSamplerParameter(this.handle, pname);
	      return value;
	    }
	  }, {
	    key: "_setParameter",
	    value: function _setParameter(pname, param) {
	      // Apparently there are some conversion integer/float rules that made
	      // the WebGL committe expose two parameter setting functions in JavaScript.
	      // For now, pick the float version for parameters specified as GLfloat.
	      switch (pname) {
	        case _constants.default.TEXTURE_MIN_LOD:
	        case _constants.default.TEXTURE_MAX_LOD:
	          this.gl.samplerParameterf(this.handle, pname, param);
	          break;

	        default:
	          this.gl.samplerParameteri(this.handle, pname, param);
	          break;
	      }

	      return this;
	    }
	  }]);

	  return Sampler;
	}(_resource.default);

	exports.default = Sampler;
	//# sourceMappingURL=sampler.js.map

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getPrimitiveDrawMode = getPrimitiveDrawMode;
	exports.getPrimitiveCount = getPrimitiveCount;
	exports.getVertexCount = getVertexCount;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var GL_POINTS = 0x0;
	var GL_LINES = 0x1;
	var GL_LINE_LOOP = 0x2;
	var GL_LINE_STRIP = 0x3;
	var GL_TRIANGLES = 0x4;
	var GL_TRIANGLE_STRIP = 0x5;
	var GL_TRIANGLE_FAN = 0x6; // Counts the number of complete primitives given a number of vertices and a drawMode

	function getPrimitiveDrawMode(drawMode) {
	  switch (drawMode) {
	    case GL_POINTS:
	      return GL_POINTS;

	    case GL_LINES:
	      return GL_LINES;

	    case GL_LINE_STRIP:
	      return GL_LINES;

	    case GL_LINE_LOOP:
	      return GL_LINES;

	    case GL_TRIANGLES:
	      return GL_TRIANGLES;

	    case GL_TRIANGLE_STRIP:
	      return GL_TRIANGLES;

	    case GL_TRIANGLE_FAN:
	      return GL_TRIANGLES;

	    default:
	      (0, _assert.default)(false);
	      return 0;
	  }
	} // Counts the number of complete "primitives" given a number of vertices and a drawMode


	function getPrimitiveCount(_ref) {
	  var drawMode = _ref.drawMode,
	      vertexCount = _ref.vertexCount;

	  switch (drawMode) {
	    case GL_POINTS:
	    case GL_LINE_LOOP:
	      return vertexCount;

	    case GL_LINES:
	      return vertexCount / 2;

	    case GL_LINE_STRIP:
	      return vertexCount - 1;

	    case GL_TRIANGLES:
	      return vertexCount / 3;

	    case GL_TRIANGLE_STRIP:
	    case GL_TRIANGLE_FAN:
	      return vertexCount - 2;

	    default:
	      (0, _assert.default)(false);
	      return 0;
	  }
	} // Counts the number of vertices after splitting the vertex stream into separate "primitives"


	function getVertexCount(_ref2) {
	  var drawMode = _ref2.drawMode,
	      vertexCount = _ref2.vertexCount;
	  var primitiveCount = getPrimitiveCount({
	    drawMode: drawMode,
	    vertexCount: vertexCount
	  });

	  switch (getPrimitiveDrawMode(drawMode)) {
	    case GL_POINTS:
	      return primitiveCount;

	    case GL_LINES:
	      return primitiveCount * 2;

	    case GL_TRIANGLES:
	      return primitiveCount * 3;

	    default:
	      (0, _assert.default)(false);
	      return 0;
	  }
	}
	//# sourceMappingURL=attribute-utils.js.map

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _texture = _interopRequireDefault(__webpack_require__(88));

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var FACES = [_constants.default.TEXTURE_CUBE_MAP_POSITIVE_X, _constants.default.TEXTURE_CUBE_MAP_NEGATIVE_X, _constants.default.TEXTURE_CUBE_MAP_POSITIVE_Y, _constants.default.TEXTURE_CUBE_MAP_NEGATIVE_Y, _constants.default.TEXTURE_CUBE_MAP_POSITIVE_Z, _constants.default.TEXTURE_CUBE_MAP_NEGATIVE_Z];

	var TextureCube =
	/*#__PURE__*/
	function (_Texture) {
	  _inherits(TextureCube, _Texture);

	  function TextureCube(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, TextureCube);

	    _this = _possibleConstructorReturn(this, (TextureCube.__proto__ || Object.getPrototypeOf(TextureCube)).call(this, gl, Object.assign({}, opts, {
	      target: _constants.default.TEXTURE_CUBE_MAP
	    })));

	    _this.initialize(opts);

	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  }
	  /* eslint-disable max-len, max-statements */


	  _createClass(TextureCube, [{
	    key: "initialize",
	    value: function initialize() {
	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var _opts$format = opts.format,
	          format = _opts$format === void 0 ? _constants.default.RGBA : _opts$format,
	          _opts$mipmaps = opts.mipmaps,
	          mipmaps = _opts$mipmaps === void 0 ? true : _opts$mipmaps;
	      var _opts$width = opts.width,
	          width = _opts$width === void 0 ? 1 : _opts$width,
	          _opts$height = opts.height,
	          height = _opts$height === void 0 ? 1 : _opts$height,
	          _opts$type = opts.type,
	          type = _opts$type === void 0 ? _constants.default.UNSIGNED_BYTE : _opts$type,
	          dataFormat = opts.dataFormat; // Deduce width and height based on one of the faces

	      var _deduceParameters = this._deduceParameters({
	        format: format,
	        type: type,
	        dataFormat: dataFormat
	      });

	      type = _deduceParameters.type;
	      dataFormat = _deduceParameters.dataFormat;

	      var _deduceImageSize = this._deduceImageSize({
	        data: opts[_constants.default.TEXTURE_CUBE_MAP_POSITIVE_X],
	        width: width,
	        height: height
	      });

	      width = _deduceImageSize.width;
	      height = _deduceImageSize.height;
	      // Enforce cube
	      (0, _assert.default)(width === height); // Temporarily apply any pixel store paramaters and build textures
	      // withParameters(this.gl, opts, () => {
	      //   for (const face of CUBE_MAP_FACES) {
	      //     this.setImageData({
	      //       target: face,
	      //       data: opts[face],
	      //       width, height, format, type, dataFormat, border, mipmaps
	      //     });
	      //   }
	      // });

	      this.setCubeMapImageData(opts); // Called here so that GL.
	      // TODO - should genMipmap() be called on the cubemap or on the faces?

	      if (mipmaps) {
	        this.generateMipmap(opts);
	      } // Store opts for accessors


	      this.opts = opts;
	    }
	  }, {
	    key: "subImage",
	    value: function subImage(_ref) {
	      var face = _ref.face,
	          data = _ref.data,
	          _ref$x = _ref.x,
	          x = _ref$x === void 0 ? 0 : _ref$x,
	          _ref$y = _ref.y,
	          y = _ref$y === void 0 ? 0 : _ref$y,
	          _ref$mipmapLevel = _ref.mipmapLevel,
	          mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;
	      return this._subImage({
	        target: face,
	        data: data,
	        x: x,
	        y: y,
	        mipmapLevel: mipmapLevel
	      });
	    }
	    /* eslint-disable max-statements, max-len */

	  }, {
	    key: "setCubeMapImageData",
	    value: function setCubeMapImageData(_ref2) {
	      var width = _ref2.width,
	          height = _ref2.height,
	          pixels = _ref2.pixels,
	          data = _ref2.data,
	          _ref2$border = _ref2.border,
	          border = _ref2$border === void 0 ? 0 : _ref2$border,
	          _ref2$format = _ref2.format,
	          format = _ref2$format === void 0 ? _constants.default.RGBA : _ref2$format,
	          _ref2$type = _ref2.type,
	          type = _ref2$type === void 0 ? _constants.default.UNSIGNED_BYTE : _ref2$type,
	          _ref2$generateMipmap = _ref2.generateMipmap,
	          generateMipmap = _ref2$generateMipmap === void 0 ? false : _ref2$generateMipmap;
	      var gl = this.gl;
	      pixels = pixels || data;
	      this.bind();

	      if (this.width || this.height) {
	        for (var _i = 0; _i < FACES.length; _i++) {
	          var face = FACES[_i];
	          gl.texImage2D(face, 0, format, width, height, border, format, type, pixels[face]);
	        }
	      } else {
	        for (var _i2 = 0; _i2 < FACES.length; _i2++) {
	          var _face = FACES[_i2];
	          gl.texImage2D(_face, 0, format, format, type, pixels[_face]);
	        }
	      }
	    }
	  }, {
	    key: "bind",
	    value: function bind() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          index = _ref3.index;

	      if (index !== undefined) {
	        this.gl.activeTexture(_constants.default.TEXTURE0 + index);
	      }

	      this.gl.bindTexture(_constants.default.TEXTURE_CUBE_MAP, this.handle);
	      return index;
	    }
	  }, {
	    key: "unbind",
	    value: function unbind() {
	      this.gl.bindTexture(_constants.default.TEXTURE_CUBE_MAP, null);
	      return this;
	    }
	  }]);

	  return TextureCube;
	}(_texture.default);

	exports.default = TextureCube;
	TextureCube.FACES = FACES;
	//# sourceMappingURL=texture-cube.js.map

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.draw = draw;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* eslint-disable */
	// TODO - generic draw call
	// One of the good things about GL is that there are so many ways to draw things
	// A good thing about webGL is that there are so many ways to draw things,
	// e.g. depending on whether data is indexed and/or isInstanced.
	// This function unifies those into a single call with simple parameters
	// that have sane defaults.
	function draw(gl, _ref) {
	  var _ref$drawMode = _ref.drawMode,
	      drawMode = _ref$drawMode === void 0 ? _constants.default.TRIANGLES : _ref$drawMode,
	      vertexCount = _ref.vertexCount,
	      _ref$offset = _ref.offset,
	      offset = _ref$offset === void 0 ? 0 : _ref$offset,
	      _ref$isIndexed = _ref.isIndexed,
	      isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,
	      _ref$indexType = _ref.indexType,
	      indexType = _ref$indexType === void 0 ? _constants.default.UNSIGNED_SHORT : _ref$indexType,
	      _ref$isInstanced = _ref.isInstanced,
	      isInstanced = _ref$isInstanced === void 0 ? false : _ref$isInstanced,
	      _ref$instanceCount = _ref.instanceCount,
	      instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount;
	  (0, _webglUtils.assertWebGLContext)(gl);
	  var extension = gl.getExtension('ANGLE_instanced_arrays'); // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension

	  if (isInstanced) {
	    var webgl2 = isWebGL2(gl);

	    var _extension = gl.getExtension('ANGLE_instanced_arrays');

	    var context = webgl2 ? gl : _extension;
	    var suffix = webgl2 ? '' : 'ANGLE';
	    var drawElements = 'drawElementsInstanced' + suffix;
	    var drawArrays = 'drawArraysInstanced' + suffix;

	    if (isIndexed) {
	      context[drawElements](drawMode, vertexCount, indexType, offset, instanceCount);
	    } else {
	      context[drawArrays](drawMode, offset, vertexCount, instanceCount);
	    }
	  } else if (isIndexed) {
	    gl.drawElements(drawMode, vertexCount, indexType, offset);
	  } else {
	    gl.drawArrays(drawMode, offset, vertexCount);
	  }
	}
	//# sourceMappingURL=draw.js.map

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.readPixels = readPixels;
	exports.readPixelsToBuffer = readPixelsToBuffer;
	exports.blitFramebuffer = blitFramebuffer;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglContext = __webpack_require__(77);

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	/**
	 * Read pixels from a target
	 *
	 * Will read from the currently bound framebuffer, or the currently bound
	 *  drawing buffer - if context has been created with
	 *  preserveDrawingBuffers
	 *
	 * @param {WebGLRenderingContext} gl
	 * @param {Object} opts
	 * @param {Number} opts.x - leftmost coord to be read
	 * @param {Number} opts.y - bottommost (or topmost if sourceHeight supplied)
	 * @param {Number} opts.width=1 - width of area to be read
	 * @param {Number} opts.height=1 - height of area to be read
	 * @param {Number} opts.sourceHeight= - target height, implies top left coords
	 * @param {Number} opts.dataOffset=0 - WebGL2 only - offset into data array
	 * @param {Number} opts.format=GL.RBGA - Can be set to GL.RGB or GL.ALPHA
	 *
	 * @return {ArrayView} - types array, either passed in or autoallocated
	 */
	function readPixels(gl, _ref) {
	  var x = _ref.x,
	      y = _ref.y,
	      _ref$width = _ref.width,
	      width = _ref$width === void 0 ? 1 : _ref$width,
	      _ref$height = _ref.height,
	      height = _ref$height === void 0 ? 1 : _ref$height,
	      data = _ref.data,
	      _ref$dataOffset = _ref.dataOffset,
	      dataOffset = _ref$dataOffset === void 0 ? 0 : _ref$dataOffset,
	      _ref$type = _ref.type,
	      type = _ref$type === void 0 ? _constants.default.UNSIGNED_BYTE : _ref$type,
	      sourceHeight = _ref.sourceHeight,
	      _ref$format = _ref.format,
	      format = _ref$format === void 0 ? _constants.default.RGBA : _ref$format;
	  // Read color in the central pixel, to be mapped with picking colors
	  data = data || new Uint8Array(4 * width * height); // If source height is specified, a top left coordinate system is used

	  y = sourceHeight ? sourceHeight - y : y;

	  if (dataOffset) {
	    (0, _webglUtils.assertWebGL2Context)(gl);
	    gl.readPixels(x, y, width, height, format, type, data, dataOffset);
	  } else {
	    gl.readPixels(x, y, width, height, format, type, data);
	  }

	  return data;
	}
	/**
	 * Read pixels directly into webgl buffer
	 * NOTE: WebGL2 only
	 *
	 * @param {WebGLRenderingContext} gl
	 * @param {Object} options
	 * @return {WebGLBuffer} the passed in buffer
	 */


	function readPixelsToBuffer(gl, _ref2) {
	  var x = _ref2.x,
	      y = _ref2.y,
	      _ref2$width = _ref2.width,
	      width = _ref2$width === void 0 ? 1 : _ref2$width,
	      _ref2$height = _ref2.height,
	      height = _ref2$height === void 0 ? 1 : _ref2$height,
	      buffer = _ref2.buffer,
	      _ref2$dataOffset = _ref2.dataOffset,
	      dataOffset = _ref2$dataOffset === void 0 ? 0 : _ref2$dataOffset,
	      _ref2$type = _ref2.type,
	      type = _ref2$type === void 0 ? _constants.default.UNSIGNED_BYTE : _ref2$type,
	      sourceHeight = _ref2.sourceHeight,
	      _ref2$format = _ref2.format,
	      format = _ref2$format === void 0 ? _constants.default.RGBA : _ref2$format;
	  (0, _webglUtils.assertWebGL2Context)(gl); // If source height is specified, a top left coordinate system is used

	  y = sourceHeight ? sourceHeight - y : y;
	  gl.bindBuffer(_constants.default.PIXEL_PACK_BUFFER, buffer.handle);
	  gl.readPixels(x, y, width, height, format, type, dataOffset);
	  gl.bindBuffer(_constants.default.PIXEL_PACK_BUFFER, null);
	  return buffer;
	}
	/*
	* @param {} opt.filter
	 */


	function blitFramebuffer(gl, _ref3) {
	  var _ref3$source = _slicedToArray(_ref3.source, 4),
	      sourceX = _ref3$source[0],
	      sourceY = _ref3$source[1],
	      sourceWidth = _ref3$source[2],
	      sourceHeight = _ref3$source[3],
	      _ref3$dest = _slicedToArray(_ref3.dest, 4),
	      destX = _ref3$dest[0],
	      destY = _ref3$dest[1],
	      destWidth = _ref3$dest[2],
	      destHeight = _ref3$dest[3],
	      _ref3$mask = _ref3.mask,
	      mask = _ref3$mask === void 0 ? _constants.default.COLOR_BUFFER_BIT | _constants.default.DEPTH_BUFFER_BIT | _constants.default.STENCIL_BUFFER_BIT : _ref3$mask,
	      _ref3$filter = _ref3.filter,
	      filter = _ref3$filter === void 0 ? _constants.default.LINEAR : _ref3$filter;
	}
	//# sourceMappingURL=functions.js.map

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _webglUtils = __webpack_require__(48);

	var _queryManager = _interopRequireDefault(__webpack_require__(76));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var FenceSync =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(FenceSync, _Resource);

	  /*
	   * @class
	   * @param {WebGL2RenderingContext} gl
	   */
	  function FenceSync(gl, opts) {
	    var _this;

	    _classCallCheck(this, FenceSync);

	    (0, _webglUtils.assertWebGL2Context)(gl);
	    _this = _possibleConstructorReturn(this, (FenceSync.__proto__ || Object.getPrototypeOf(FenceSync)).call(this, gl, opts)); // query manager needs a promise field

	    _this.promise = null;
	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  }
	  /**
	   * The method is a no-op in the absence of the possibility of
	   * synchronizing between multiple GL contexts.
	   * Prevent commands from being added to GPU command queue.
	   * Note: commands can still be buffered in driver.
	   *
	   * @param {GLbitfield} flags
	   * @param {GLint64} timeout
	   * @return {Sync} status
	   */


	  _createClass(FenceSync, [{
	    key: "wait",
	    value: function wait() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$flags = _ref.flags,
	          flags = _ref$flags === void 0 ? 0 : _ref$flags,
	          _ref$timeout = _ref.timeout,
	          timeout = _ref$timeout === void 0 ? _constants.default.TIMEOUT_IGNORED : _ref$timeout;

	      this.gl.waitSync(this.handle, flags, timeout);
	      return this;
	    }
	    /**
	     * Block all CPU operations until fence is signalled
	     * @param {GLbitfield} flags
	     * @param {GLint64} timeout
	     * @return {GLenum} result
	     */

	  }, {
	    key: "clientWait",
	    value: function clientWait(_ref2) {
	      var _ref2$flags = _ref2.flags,
	          flags = _ref2$flags === void 0 ? _constants.default.SYNC_FLUSH_COMMANDS_BIT : _ref2$flags,
	          timeout = _ref2.timeout;
	      var result = this.gl.clientWaitSync(this.handle, flags, timeout); // TODO - map to boolean?

	      switch (result) {
	        case _constants.default.ALREADY_SIGNALED:
	          // Indicates that sync object was signaled when this method was called.
	          break;

	        case _constants.default.TIMEOUT_EXPIRED:
	          // Indicates that timeout time passed, sync object did not become signaled
	          break;

	        case _constants.default.CONDITION_SATISFIED:
	          // Indicates that sync object was signaled before timeout expired.
	          break;

	        case _constants.default.WAIT_FAILED:
	          // Indicates that an error occurred during execution.
	          break;

	        default:
	      }

	      return result;
	    }
	  }, {
	    key: "cancel",
	    value: function cancel() {
	      _queryManager.default.cancelQuery(this);
	    }
	  }, {
	    key: "isSignaled",
	    value: function isSignaled() {
	      return this.getParameter(_constants.default.SYNC_STATUS) === _constants.default.SIGNALED;
	    } // TODO - Query manager needs these?

	  }, {
	    key: "isResultAvailable",
	    value: function isResultAvailable() {
	      return this.isSignaled();
	    }
	  }, {
	    key: "getResult",
	    value: function getResult() {
	      return this.isSignaled();
	    }
	  }, {
	    key: "getParameter",
	    value: function getParameter(pname) {
	      return this.gl.getSyncParameter(this.handle, pname);
	    } // PRIVATE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.fenceSync(_constants.default.SYNC_GPU_COMMANDS_COMPLETE, 0);
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      _queryManager.default.deleteQuery(this);

	      this.gl.deleteSync(this.handle);
	    }
	  }]);

	  return FenceSync;
	}(_resource.default);

	exports.default = FenceSync;
	//# sourceMappingURL=fence-sync.js.map

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _contextFeatures = __webpack_require__(79);

	var _webglContext = __webpack_require__(77);

	var _webglUtils = __webpack_require__(48);

	var _queryManager = _interopRequireDefault(__webpack_require__(76));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var noop = function noop(x) {
	  return x;
	};

	var ERR_GPU_DISJOINT = 'Disjoint GPU operation invalidated timer queries';
	var ERR_TIMER_QUERY_NOT_SUPPORTED = 'Timer queries require "EXT_disjoint_timer_query" extension';
	var GL_QUERY_COUNTER_BITS_EXT = 0x8864; // # bits in query result for the given target.

	var GL_QUERY_RESULT = 0x8866; // Returns a GLuint containing the query result.

	var GL_QUERY_RESULT_AVAILABLE = 0x8867; // whether query result is available.

	var GL_TIME_ELAPSED_EXT = 0x88BF; // Elapsed time (in nanoseconds).

	var GL_TIMESTAMP_EXT = 0x8E28; // The current time.

	var GL_GPU_DISJOINT_EXT = 0x8FBB; // Whether GPU performed any disjoint operation.

	var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88; // #primitives written to feedback buffers

	var GL_ANY_SAMPLES_PASSED = 0x8C2F; // Occlusion query (if drawing passed depth test)

	var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A; // Occlusion query less accurate/faster version

	var Query =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(Query, _Resource);

	  _createClass(Query, null, [{
	    key: "isSupported",
	    // Returns true if Query is supported by the WebGL implementation
	    // Can also check whether timestamp queries are available.
	    value: function isSupported(gl) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref$queries = _ref.queries,
	          queries = _ref$queries === void 0 ? false : _ref$queries,
	          _ref$timers = _ref.timers,
	          timers = _ref$timers === void 0 ? false : _ref$timers,
	          _ref$timestamps = _ref.timestamps,
	          timestamps = _ref$timestamps === void 0 ? false : _ref$timestamps;

	      var webgl2 = (0, _webglUtils.isWebGL2)(gl);
	      var hasTimerQueries = (0, _contextFeatures.hasFeatures)(gl, _contextFeatures.FEATURES.TIMER_QUERY);
	      var supported = webgl2 || hasTimerQueries;

	      if (queries) {
	        supported = supported && webgl2;
	      }

	      if (timers) {
	        supported = supported && hasTimerQueries;
	      }

	      if (timestamps) {
	        (0, _webglContext.polyfillContext)(gl);
	        var queryCounterBits = gl.getQuery(GL_TIMESTAMP_EXT, GL_QUERY_COUNTER_BITS_EXT);
	        supported = supported && queryCounterBits > 0;
	      }

	      return supported;
	    } // Create a query class

	  }]);

	  function Query(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Query);

	    _this = _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).call(this, gl, opts));
	    var _opts$onComplete = opts.onComplete,
	        onComplete = _opts$onComplete === void 0 ? noop : _opts$onComplete,
	        _opts$onError = opts.onError,
	        onError = _opts$onError === void 0 ? noop : _opts$onError;
	    _this.target = null;
	    _this.onComplete = onComplete;
	    _this.onError = onError; // query manager needs a promise field

	    _this.promise = null;
	    Object.seal(_assertThisInitialized(_this));
	    return _this;
	  } // Shortcut for timer query (dependent on extension in both WebGL1 and 2)
	  // Measures GPU time delta between this call and a matching `end` call in the
	  // GPU instruction stream.


	  _createClass(Query, [{
	    key: "beginTimeElapsedQuery",
	    value: function beginTimeElapsedQuery() {
	      return this.begin(GL_TIME_ELAPSED_EXT);
	    } // Shortcut for occlusion queries

	  }, {
	    key: "beginOcclusionQuery",
	    value: function beginOcclusionQuery() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$conservative = _ref2.conservative,
	          conservative = _ref2$conservative === void 0 ? false : _ref2$conservative;

	      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
	    } // Shortcut for transformFeedbackQuery

	  }, {
	    key: "beginTransformFeedbackQuery",
	    value: function beginTransformFeedbackQuery() {
	      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
	    } // Generates a GPU time stamp when the GPU instruction stream reaches this instruction.
	    // To measure time deltas, two timestamp queries are needed.
	    // Note: timestamp() queries may not be available even when the timer query extension is.

	  }, {
	    key: "getTimestamp",
	    value: function getTimestamp() {
	      _queryManager.default.beginQuery(this, this.onComplete, this.onError);

	      try {
	        this.gl.queryCounter(this.handle, GL_TIMESTAMP_EXT);
	      } catch (error) {
	        _queryManager.default.rejectQuery(this, ERR_TIMER_QUERY_NOT_SUPPORTED);
	      }

	      return this;
	    } // Due to OpenGL API limitations, after calling `begin()` on one Query
	    // instance, `end()` must be called on that same instance before
	    // calling `begin()` on another query. While there can be multiple
	    // outstanding queries representing disjoint `begin()`/`end()` intervals.
	    // It is not possible to interleave or overlap `begin` and `end` calls.

	  }, {
	    key: "begin",
	    value: function begin(target) {
	      // - Triggering a new query when a Query is already tracking an
	      //   unresolved query causes that query to be cancelled.
	      _queryManager.default.beginQuery(this, this.onComplete, this.onError);

	      this.target = target;

	      try {
	        this.gl.beginQuery(this.target, this.handle);
	      } catch (error) {
	        _queryManager.default.rejectQuery(this, 'Query not supported');
	      }

	      return this;
	    } // ends the current query

	  }, {
	    key: "end",
	    value: function end() {
	      // Note: calling end does not affect the pending promise
	      if (this.target) {
	        this.ext.endQuery(this.target);
	        this.target = null;
	      }

	      return this;
	    } // Cancels a pending query

	  }, {
	    key: "cancel",
	    value: function cancel() {
	      this.end();

	      _queryManager.default.cancelQuery(this);

	      return this;
	    } // Returns true if the query result is available

	  }, {
	    key: "isResultAvailable",
	    value: function isResultAvailable() {
	      return this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
	    } // Returns the query result, converted to milliseconds to match JavaScript conventions.
	    // TODO - what about non-timer queries

	  }, {
	    key: "getResult",
	    value: function getResult() {
	      var result = this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT);
	      return Number.isFinite(result) ? result / 1e6 : 0;
	    }
	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return Query.isSupported(this.gl) ? this.gl.createQuery() : null;
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      _queryManager.default.deleteQuery(this);

	      this.gl.deleteQuery(this.handle);
	    }
	  }], [{
	    key: "poll",
	    value: function poll(gl) {
	      _queryManager.default.poll(gl);
	    }
	  }]);

	  return Query;
	}(_resource.default); // NOTE: This call lets the queryManager know how to detect disjoint GPU state
	// It will check dsjoint state on polls and before adding a new query
	// and reject any outstanding TimerQueries with our supplied error message.


	exports.default = Query;

	_queryManager.default.setInvalidator({
	  queryType: Query,
	  errorMessage: ERR_GPU_DISJOINT,
	  // Note: Querying the disjoint state resets it
	  checkInvalid: function checkInvalid(gl) {
	    return gl.getParameter(GL_GPU_DISJOINT_EXT);
	  }
	});
	//# sourceMappingURL=query.js.map

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webglUtils = __webpack_require__(48);

	var _contextState = __webpack_require__(78);

	var _texture = _interopRequireDefault(__webpack_require__(88));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var Texture3D =
	/*#__PURE__*/
	function (_Texture) {
	  _inherits(Texture3D, _Texture);

	  _createClass(Texture3D, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      return (0, _webglUtils.isWebGL2)(gl);
	    }
	    /**
	     * @classdesc
	     * 3D WebGL Texture
	     * Note: Constructor will initialize your texture.
	     *
	     * @class
	     * @param {WebGLRenderingContext} gl - gl context
	     * @param {Image|ArrayBuffer|null} opts= - named options
	     * @param {Image|ArrayBuffer|null} opts.data= - buffer
	     * @param {GLint} width - width of texture
	     * @param {GLint} height - height of texture
	     */

	  }]);

	  function Texture3D(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Texture3D);

	    (0, _webglUtils.assertWebGL2Context)(gl);
	    _this = _possibleConstructorReturn(this, (Texture3D.__proto__ || Object.getPrototypeOf(Texture3D)).call(this, gl, Object.assign({}, opts, {
	      target: opts.target || _constants.default.TEXTURE_3D
	    })));
	    _this.width = null;
	    _this.height = null;
	    _this.depth = null;
	    Object.seal(_assertThisInitialized(_this));

	    _this.setImageData(opts);

	    if (opts.generateMipmap) {
	      _this.generateMipmap();
	    }

	    return _this;
	  }

	  _createClass(Texture3D, [{
	    key: "initialize",
	    value: function initialize() {
	      var _this2 = this;

	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      this.opts = Object.assign({}, this.opts, opts);
	      var _opts = this.opts,
	          pixels = _opts.pixels,
	          settings = _opts.settings;

	      if (settings) {
	        (0, _contextState.withParameters)(settings, function () {
	          if (pixels) {
	            _this2.setImage3D(_this2.opts);
	          }
	        });
	        this.setParameters(opts);
	      }
	    } // WebGL2
	    // Image 3D copies from Typed Array or WebGLBuffer

	  }, {
	    key: "setImage3D",
	    value: function setImage3D(_ref) {
	      var _ref$level = _ref.level,
	          level = _ref$level === void 0 ? 0 : _ref$level,
	          _ref$internalformat = _ref.internalformat,
	          internalformat = _ref$internalformat === void 0 ? _constants.default.RGBA : _ref$internalformat,
	          width = _ref.width,
	          height = _ref.height,
	          _ref$depth = _ref.depth,
	          depth = _ref$depth === void 0 ? 1 : _ref$depth,
	          _ref$border = _ref.border,
	          border = _ref$border === void 0 ? 0 : _ref$border,
	          format = _ref.format,
	          _ref$type = _ref.type,
	          type = _ref$type === void 0 ? _constants.default.UNSIGNED_BYTE : _ref$type,
	          _ref$offset = _ref.offset,
	          offset = _ref$offset === void 0 ? 0 : _ref$offset,
	          pixels = _ref.pixels;

	      if (ArrayBuffer.isView(pixels)) {
	        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, pixels);
	        return;
	      }

	      if (_instanceof(pixels, _buffer.default)) {
	        this.gl.bindBuffer(_constants.default.PIXEL_UNPACK_BUFFER, pixels.handle);
	        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, offset);
	        this.gl.bindBuffer(_constants.default.PIXEL_UNPACK_BUFFER, pixels.handle);
	      }
	    }
	  }]);

	  return Texture3D;
	}(_texture.default);

	exports.default = Texture3D;
	//# sourceMappingURL=texture-3d.js.map

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _texture = _interopRequireDefault(__webpack_require__(88));

	var _webglUtils = __webpack_require__(48);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Texture2DArray =
	/*#__PURE__*/
	function (_Texture) {
	  _inherits(Texture2DArray, _Texture);

	  _createClass(Texture2DArray, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      return (0, _webglUtils.isWebGL2)(gl);
	    }
	  }]);

	  function Texture2DArray(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Texture2DArray);

	    _this = _possibleConstructorReturn(this, (Texture2DArray.__proto__ || Object.getPrototypeOf(Texture2DArray)).call(this, gl, opts));
	    throw new Error('Texture2DArray not yet implemented');
	    return _this;
	  }

	  return Texture2DArray;
	}(_texture.default);

	exports.default = Texture2DArray;
	//# sourceMappingURL=texture-2d-array.js.map

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _resource = _interopRequireDefault(__webpack_require__(83));

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;
	var GL_TRANSFORM_FEEDBACK = 0x8E22;

	var TranformFeedback =
	/*#__PURE__*/
	function (_Resource) {
	  _inherits(TranformFeedback, _Resource);

	  _createClass(TranformFeedback, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      return (0, _webglUtils.isWebGL2)(gl);
	    }
	  }, {
	    key: "isHandle",
	    value: function isHandle(handle) {
	      return this.gl.isTransformFeedback(this.handle);
	    }
	    /**
	     * @class
	     * @param {WebGL2RenderingContext} gl - context
	     * @param {Object} opts - options
	     */

	  }]);

	  function TranformFeedback(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, TranformFeedback);

	    (0, _webglUtils.assertWebGL2Context)(gl);
	    _this = _possibleConstructorReturn(this, (TranformFeedback.__proto__ || Object.getPrototypeOf(TranformFeedback)).call(this, gl, opts));
	    _this.buffers = {};
	    Object.seal(_assertThisInitialized(_this));

	    _this.initialize(opts);

	    return _this;
	  }

	  _createClass(TranformFeedback, [{
	    key: "initialize",
	    value: function initialize(_ref) {
	      var _ref$buffers = _ref.buffers,
	          buffers = _ref$buffers === void 0 ? {} : _ref$buffers,
	          _ref$varyingMap = _ref.varyingMap,
	          varyingMap = _ref$varyingMap === void 0 ? {} : _ref$varyingMap;
	      this.bindBuffers(buffers, {
	        clear: true,
	        varyingMap: varyingMap
	      });
	    }
	  }, {
	    key: "bindBuffers",
	    value: function bindBuffers() {
	      var buffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref2$clear = _ref2.clear,
	          clear = _ref2$clear === void 0 ? false : _ref2$clear,
	          _ref2$varyingMap = _ref2.varyingMap,
	          varyingMap = _ref2$varyingMap === void 0 ? {} : _ref2$varyingMap;

	      if (clear) {
	        this._unbindBuffers();

	        this.buffers = {};
	      }

	      for (var bufferName in buffers) {
	        var buffer = buffers[bufferName];
	        var index = Number.isFinite(Number(bufferName)) ? Number(bufferName) : varyingMap[bufferName];
	        (0, _assert.default)(Number.isFinite(index));
	        this.buffers[index] = buffer;
	      }
	    } // TODO: Activation is tightly coupled to the current program. Since we try to encapsulate
	    // program.use, should we move these methods (begin/pause/resume/end) to the Program?

	  }, {
	    key: "begin",
	    value: function begin(primitiveMode) {
	      this._bindBuffers();

	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
	      this.gl.beginTransformFeedback(primitiveMode);
	      return this;
	    }
	  }, {
	    key: "pause",
	    value: function pause() {
	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
	      this.gl.pauseTransformFeedback();
	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, null);

	      this._unbindBuffers();

	      return this;
	    }
	  }, {
	    key: "resume",
	    value: function resume() {
	      this._bindBuffers();

	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
	      this.gl.resumeTransformFeedback();
	      return this;
	    }
	  }, {
	    key: "end",
	    value: function end() {
	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
	      this.gl.endTransformFeedback();
	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, null);

	      this._unbindBuffers();

	      return this;
	    }
	  }, {
	    key: "bindBuffer",
	    value: function bindBuffer(_ref3) {
	      var index = _ref3.index,
	          buffer = _ref3.buffer,
	          _ref3$offset = _ref3.offset,
	          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,
	          size = _ref3.size;
	      // Need to avoid chrome bug where buffer that is already bound to a different target
	      // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
	      buffer.unbind();
	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);

	      if (size === undefined) {
	        this.gl.bindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, index, buffer.handle);
	      } else {
	        this.gl.bindBufferRange(GL_TRANSFORM_FEEDBACK_BUFFER, index, buffer.handle, offset, size);
	      }

	      return this;
	    }
	  }, {
	    key: "unbindBuffer",
	    value: function unbindBuffer(_ref4) {
	      var index = _ref4.index;
	      this.gl.bindTransformFeedback(GL_TRANSFORM_FEEDBACK, this.handle);
	      this.gl.bindBufferBase(GL_TRANSFORM_FEEDBACK_BUFFER, index, null);
	      return this;
	    } // PRIVATE METHODS
	    // See https://github.com/KhronosGroup/WebGL/issues/2346
	    // If it was true that having a buffer on an unused TF was a problem
	    // it would make the entire concept of transform feedback objects pointless.
	    // The whole point of them is like VertexArrayObjects.
	    // You set them up with all in outputs at init time and
	    // then in one call you can setup all the outputs just before drawing.
	    // Since the point of transform feedback is to generate data that will
	    // then be used as inputs to attributes it makes zero sense you'd
	    // have to unbind them from every unused transform feedback object
	    // before you could use them in an attribute. If that was the case
	    // there would be no reason to setup transform feedback objects ever.
	    // You'd always use the default because you'd always have to bind and
	    // unbind all the buffers.

	  }, {
	    key: "_bindBuffers",
	    value: function _bindBuffers() {
	      for (var bufferIndex in this.buffers) {
	        this.bindBuffer({
	          buffer: this.buffers[bufferIndex],
	          index: Number(bufferIndex)
	        });
	      }
	    }
	  }, {
	    key: "_unbindBuffers",
	    value: function _unbindBuffers() {
	      for (var bufferIndex in this.buffers) {
	        this.unbindBuffer({
	          buffer: this.buffers[bufferIndex],
	          index: Number(bufferIndex)
	        });
	      }
	    } // RESOURCE METHODS

	  }, {
	    key: "_createHandle",
	    value: function _createHandle() {
	      return this.gl.createTransformFeedback();
	    }
	  }, {
	    key: "_deleteHandle",
	    value: function _deleteHandle() {
	      this.gl.deleteTransformFeedback(this.handle);
	    }
	  }]);

	  return TranformFeedback;
	}(_resource.default);

	exports.default = TranformFeedback;
	//# sourceMappingURL=transform-feedback.js.map

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _UNIFORM_TYPES;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var ERR_ARGUMENT = 'UniformBufferLayout illegal argument'; // Local constants - these will "collapse" during minification

	var GL_INT = 0x1404;
	var GL_INT_VEC2 = 0x8B53;
	var GL_INT_VEC3 = 0x8B54;
	var GL_INT_VEC4 = 0x8B55;
	var GL_FLOAT = 0x1406;
	var GL_FLOAT_VEC2 = 0x8B50;
	var GL_FLOAT_VEC3 = 0x8B51;
	var GL_FLOAT_VEC4 = 0x8B52;
	var GL_BOOL = 0x8B56;
	var GL_BOOL_VEC2 = 0x8B57;
	var GL_BOOL_VEC3 = 0x8B58;
	var GL_BOOL_VEC4 = 0x8B59;
	var GL_UNSIGNED_INT = 0x1405;
	var GL_UNSIGNED_INT_VEC2 = 0x8DC6;
	var GL_UNSIGNED_INT_VEC3 = 0x8DC7;
	var GL_UNSIGNED_INT_VEC4 = 0x8DC8;
	var GL_FLOAT_MAT2 = 0x8B5A;
	var GL_FLOAT_MAT3 = 0x8B5B;
	var GL_FLOAT_MAT4 = 0x8B5C;
	var GL_FLOAT_MAT2x3 = 0x8B65;
	var GL_FLOAT_MAT2x4 = 0x8B66;
	var GL_FLOAT_MAT3x2 = 0x8B67;
	var GL_FLOAT_MAT3x4 = 0x8B68;
	var GL_FLOAT_MAT4x2 = 0x8B69;
	var GL_FLOAT_MAT4x3 = 0x8B6A; // Uniform table for std140

	var UNIFORM_TYPES = (_UNIFORM_TYPES = {}, _defineProperty(_UNIFORM_TYPES, GL_FLOAT, [GL_FLOAT, 1]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC2, [GL_FLOAT, 2]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC3, [GL_FLOAT, 3]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC4, [GL_FLOAT, 4]), _defineProperty(_UNIFORM_TYPES, GL_INT, [GL_INT, 1]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC2, [GL_INT, 2]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC3, [GL_INT, 3]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC4, [GL_INT, 4]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT, [GL_UNSIGNED_INT, 1]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC2, [GL_UNSIGNED_INT, 2]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC3, [GL_UNSIGNED_INT, 3]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC4, [GL_UNSIGNED_INT, 4]), _defineProperty(_UNIFORM_TYPES, GL_BOOL, [GL_FLOAT, 1]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC2, [GL_FLOAT, 2]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC3, [GL_FLOAT, 3]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC4, [GL_FLOAT, 4]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2x3, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2x4, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3x2, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3x4, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4, [GL_FLOAT, 16]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4x2, [GL_FLOAT, 16]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4x3, [GL_FLOAT, 16]), _UNIFORM_TYPES); // Std140 layout for uniforms

	var UniformBufferLayout =
	/*#__PURE__*/
	function () {
	  function UniformBufferLayout(layout) {
	    var _typedArray;

	    _classCallCheck(this, UniformBufferLayout);

	    this.layout = {};
	    this.size = 0; // Add layout (type, size and offset) definitions for each uniform in the layout

	    for (var key in layout) {
	      this._addUniform(key, layout[key]);
	    } // Allocate three typed arrays pointing at same memory


	    var data = new Float32Array(this.size);
	    this.typedArray = (_typedArray = {}, _defineProperty(_typedArray, GL_FLOAT, data), _defineProperty(_typedArray, GL_INT, new Int32Array(data.buffer)), _defineProperty(_typedArray, GL_UNSIGNED_INT, new Uint32Array(data.buffer)), _typedArray);
	  } // Get number of bytes needed for buffer allocation


	  _createClass(UniformBufferLayout, [{
	    key: "getBytes",
	    value: function getBytes() {
	      return this.size * 4;
	    } // Get the current data as Float32Array, for bufferSubData

	  }, {
	    key: "getData",
	    value: function getData() {
	      return this.typedArray[GL_FLOAT];
	    } // Get offset and data for one object (for bufferSubData)

	  }, {
	    key: "getSubData",
	    value: function getSubData(index) {
	      var data;
	      var offset;

	      if (index === undefined) {
	        data = this.data;
	        offset = 0;
	      } else {
	        var begin = this.offsets[index];
	        var end = begin + this.sizes[index];
	        data = this.data.subarray(begin, end);
	        offset = begin * 4;
	      }

	      return {
	        data: data,
	        offset: offset
	      };
	    } // Set a map of values

	  }, {
	    key: "setUniforms",
	    value: function setUniforms(values) {
	      for (var key in values) {
	        this._setValue(key, values[key]);
	      }

	      return this;
	    }
	  }, {
	    key: "_setValue",
	    value: function _setValue(key, value) {
	      var layout = this.layout[key];
	      (0, _assert.default)(layout, 'UniformLayoutStd140 illegal argument');
	      var typedArray = this.typedArray[layout.type];

	      if (layout.size === 1) {
	        // single value -> just set it
	        typedArray[layout.offset] = value;
	      } else {
	        // vector/matrix -> copy the supplied (typed) array, starting from offset
	        typedArray.set(value, layout.offset);
	      }
	    }
	  }, {
	    key: "_addUniform",
	    value: function _addUniform(key, uniformType) {
	      var definition = UNIFORM_TYPES[uniformType];
	      (0, _assert.default)(definition, ERR_ARGUMENT);

	      var _definition = _slicedToArray(definition, 2),
	          type = _definition[0],
	          count = _definition[1]; // First, align (bump) current offset to an even multiple of current object (1, 2, 4)


	      this.size = this._alignTo(this.size, count); // Use the aligned size as the offset of the current uniform.

	      var offset = this.size; // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset

	      this.size += count;
	      this.layout[key] = {
	        type: type,
	        size: count,
	        offset: offset
	      };
	    } // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)

	  }, {
	    key: "_alignTo",
	    value: function _alignTo(size, count) {
	      switch (count) {
	        case 1:
	          return size;
	        // Pad upwards to even multiple of 2

	        case 2:
	          return size + size % 2;
	        // Pad upwards to even multiple of 2

	        default:
	          return size + (4 - size % 4) % 4;
	        // Pad upwards to even multiple of 4
	      }
	    }
	  }]);

	  return UniformBufferLayout;
	}();

	exports.default = UniformBufferLayout;
	//# sourceMappingURL=uniform-buffer-layout.js.map

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _webgl = __webpack_require__(81);

	var _query = _interopRequireDefault(__webpack_require__(101));

	var _webglUtils = __webpack_require__(48);

	var _uniforms = __webpack_require__(94);

	var _geometry = __webpack_require__(107);

	var _object3d = _interopRequireDefault(__webpack_require__(108));

	var _shaders = __webpack_require__(179);

	var _shadertools = __webpack_require__(182);

	var _seerIntegration = __webpack_require__(188);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var MSG_INSTANCED_PARAM_DEPRECATED = "Warning: Model constructor: parameter \"instanced\" renamed to \"isInstanced\".\nThis will become a hard error in a future version of luma.gl.";
	var ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';
	var LOG_DRAW_PRIORITY = 2; // These old picking uniforms should be avoided and we should use picking module
	// and set uniforms using Model class 'updateModuleSettings()'

	var DEPRECATED_PICKING_UNIFORMS = ['renderPickingBuffer', 'pickingEnabled']; // Model abstract O3D Class

	var Model =
	/*#__PURE__*/
	function (_Object3D) {
	  _inherits(Model, _Object3D);

	  function Model(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Model);

	    _this = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this, opts));
	    (0, _assert.default)((0, _webglUtils.isWebGL)(gl));
	    _this.gl = gl;

	    _this.init(opts);

	    return _this;
	  }
	  /* eslint-disable max-statements  */

	  /* eslint-disable complexity  */


	  _createClass(Model, [{
	    key: "init",
	    value: function init() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$vs = _ref.vs,
	          vs = _ref$vs === void 0 ? null : _ref$vs,
	          _ref$fs = _ref.fs,
	          fs = _ref$fs === void 0 ? null : _ref$fs,
	          _ref$modules = _ref.modules,
	          modules = _ref$modules === void 0 ? null : _ref$modules,
	          _ref$defines = _ref.defines,
	          defines = _ref$defines === void 0 ? {} : _ref$defines,
	          _ref$moduleSettings = _ref.moduleSettings,
	          moduleSettings = _ref$moduleSettings === void 0 ? {} : _ref$moduleSettings,
	          defaultUniforms = _ref.defaultUniforms,
	          _ref$program = _ref.program,
	          program = _ref$program === void 0 ? null : _ref$program,
	          _ref$shaderCache = _ref.shaderCache,
	          shaderCache = _ref$shaderCache === void 0 ? null : _ref$shaderCache,
	          _ref$isInstanced = _ref.isInstanced,
	          isInstanced = _ref$isInstanced === void 0 ? false : _ref$isInstanced,
	          instanced = _ref.instanced,
	          _ref$vertexCount = _ref.vertexCount,
	          vertexCount = _ref$vertexCount === void 0 ? undefined : _ref$vertexCount,
	          _ref$instanceCount = _ref.instanceCount,
	          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,
	          drawMode = _ref.drawMode,
	          _ref$uniforms = _ref.uniforms,
	          uniforms = _ref$uniforms === void 0 ? {} : _ref$uniforms,
	          _ref$attributes = _ref.attributes,
	          attributes = _ref$attributes === void 0 ? {} : _ref$attributes,
	          _ref$geometry = _ref.geometry,
	          geometry = _ref$geometry === void 0 ? null : _ref$geometry,
	          _ref$pickable = _ref.pickable,
	          pickable = _ref$pickable === void 0 ? true : _ref$pickable,
	          _ref$pick = _ref.pick,
	          pick = _ref$pick === void 0 ? null : _ref$pick,
	          _ref$render = _ref.render,
	          render = _ref$render === void 0 ? null : _ref$render,
	          _ref$onBeforeRender = _ref.onBeforeRender,
	          onBeforeRender = _ref$onBeforeRender === void 0 ? function () {} : _ref$onBeforeRender,
	          _ref$onAfterRender = _ref.onAfterRender,
	          onAfterRender = _ref$onAfterRender === void 0 ? function () {} : _ref$onAfterRender,
	          _ref$varyings = _ref.varyings,
	          varyings = _ref$varyings === void 0 ? null : _ref$varyings,
	          _ref$bufferMode = _ref.bufferMode,
	          bufferMode = _ref$bufferMode === void 0 ? _constants.default.SEPARATE_ATTRIBS : _ref$bufferMode,
	          _ref$timerQueryEnable = _ref.timerQueryEnabled,
	          timerQueryEnabled = _ref$timerQueryEnable === void 0 ? false : _ref$timerQueryEnable;

	      this._initializeProgram({
	        vs: vs,
	        fs: fs,
	        modules: modules,
	        defines: defines,
	        moduleSettings: moduleSettings,
	        defaultUniforms: defaultUniforms,
	        program: program,
	        shaderCache: shaderCache,
	        varyings: varyings,
	        bufferMode: bufferMode
	      });

	      this.uniforms = {}; // Make sure we have some reasonable default uniforms in place

	      uniforms = Object.assign({}, this.program.defaultUniforms, uniforms);
	      this.setUniforms(uniforms); // Get all default uniforms

	      this.setUniforms(this.getModuleUniforms()); // Get unforms for supplied parameters

	      this.setUniforms(this.getModuleUniforms(moduleSettings));

	      if (instanced) {
	        /* global console */

	        /* eslint-disable no-console */
	        console.warn(MSG_INSTANCED_PARAM_DEPRECATED);
	        isInstanced = isInstanced || instanced;
	      } // All attributes


	      this._attributes = {}; // User defined attributes

	      this.attributes = {};
	      this.samplers = {};
	      this.userData = {};
	      this.drawParams = {};
	      this.dynamic = false;
	      this.needsRedraw = true; // Attributes and buffers

	      if (geometry) {
	        this.setGeometry(geometry);
	      }

	      this.setAttributes(attributes); // geometry might have set drawMode and vertexCount

	      if (drawMode !== undefined) {
	        this.drawMode = (0, _geometry.getDrawMode)(drawMode);
	      }

	      if (vertexCount !== undefined) {
	        this.vertexCount = vertexCount;
	      }

	      this.isInstanced = isInstanced;
	      this.instanceCount = instanceCount; // picking options

	      this.pickable = Boolean(pickable);

	      this.pick = pick || function () {
	        return false;
	      };

	      this.onBeforeRender = onBeforeRender;
	      this.onAfterRender = onAfterRender; // assert(program || program instanceof Program);

	      (0, _assert.default)(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
	      this.timerQueryEnabled = timerQueryEnabled && _query.default.isSupported(this.gl, {
	        timer: true
	      });
	      this.timeElapsedQuery = undefined;
	      this.lastQueryReturned = true;
	      this.stats = {
	        accumulatedFrameTime: 0,
	        averageFrameTime: 0,
	        profileFrameCount: 0
	      };
	    }
	    /* eslint-enable max-statements */

	  }, {
	    key: "delete",
	    value: function _delete() {
	      // delete all attributes created by this model
	      for (var key in this._attributes) {
	        if (this._attributes[key] !== this.attributes[key]) {
	          this._attributes[key].delete();
	        }
	      }

	      this.program.delete();
	      (0, _seerIntegration.removeModel)(this.id);
	    }
	  }, {
	    key: "destroy",
	    value: function destroy() {
	      this.delete();
	    }
	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw() {
	      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.needsRedraw = redraw;
	      return this;
	    }
	  }, {
	    key: "getNeedsRedraw",
	    value: function getNeedsRedraw() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
	          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? false : _ref2$clearRedrawFlag;

	      var redraw = false;
	      redraw = redraw || this.needsRedraw;
	      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;

	      if (this.geometry) {
	        redraw = redraw || this.geometry.getNeedsRedraw({
	          clearRedrawFlags: clearRedrawFlags
	        });
	      }

	      return redraw;
	    }
	  }, {
	    key: "setDrawMode",
	    value: function setDrawMode(drawMode) {
	      this.drawMode = (0, _geometry.getDrawMode)(drawMode);
	      return this;
	    }
	  }, {
	    key: "getDrawMode",
	    value: function getDrawMode() {
	      return this.drawMode;
	    }
	  }, {
	    key: "setVertexCount",
	    value: function setVertexCount(vertexCount) {
	      (0, _assert.default)(Number.isFinite(vertexCount));
	      this.vertexCount = vertexCount;
	      return this;
	    }
	  }, {
	    key: "getVertexCount",
	    value: function getVertexCount() {
	      return this.vertexCount;
	    }
	  }, {
	    key: "setInstanceCount",
	    value: function setInstanceCount(instanceCount) {
	      (0, _assert.default)(Number.isFinite(instanceCount));
	      this.instanceCount = instanceCount;
	      return this;
	    }
	  }, {
	    key: "getInstanceCount",
	    value: function getInstanceCount() {
	      return this.instanceCount;
	    }
	  }, {
	    key: "getProgram",
	    value: function getProgram() {
	      return this.program;
	    }
	  }, {
	    key: "setGeometry",
	    // TODO - just set attributes, don't hold on to geometry
	    value: function setGeometry(geometry) {
	      this.geometry = geometry;
	      this.vertexCount = geometry.getVertexCount();
	      this.drawMode = geometry.drawMode;

	      this._createBuffersFromAttributeDescriptors(this.geometry.getAttributes());

	      this.setNeedsRedraw();
	      return this;
	    }
	  }, {
	    key: "getAttributes",
	    value: function getAttributes() {
	      return this.attributes;
	    }
	  }, {
	    key: "setAttributes",
	    value: function setAttributes() {
	      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	      // Reutrn early if no attributes to set.
	      if ((0, _utils.isObjectEmpty)(attributes)) {
	        return this;
	      }

	      Object.assign(this.attributes, attributes);

	      this._createBuffersFromAttributeDescriptors(attributes);

	      this.setNeedsRedraw();
	      return this;
	    }
	  }, {
	    key: "getUniforms",
	    value: function getUniforms() {
	      return this.uniforms;
	    } // TODO - should actually set the uniforms

	  }, {
	    key: "setUniforms",
	    value: function setUniforms() {
	      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      // TODO: we are still setting these uniforms in deck.gl so we don't break any external
	      // application, these are marked deprecated in 5.0, remove them in deck.gl in 6.0.
	      // Disabling since it gets too noisy in console, these are documented as deprecated.
	      // this._checkForDeprecatedUniforms(uniforms);
	      var somethingChanged = false;

	      for (var key in uniforms) {
	        if (!(0, _uniforms.areUniformsEqual)(this.uniforms[key], uniforms[key])) {
	          somethingChanged = true;
	          break;
	        }
	      }

	      if (somethingChanged) {
	        (0, _webgl.checkUniformValues)(uniforms, this.id);
	        Object.assign(this.uniforms, uniforms);
	        this.setNeedsRedraw();
	      }

	      return this;
	    } // getModuleUniforms (already on object)

	  }, {
	    key: "updateModuleSettings",
	    value: function updateModuleSettings(opts) {
	      var uniforms = this.getModuleUniforms(opts);
	      return this.setUniforms(uniforms);
	    }
	  }, {
	    key: "draw",
	    value: function draw() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref3$moduleSettings = _ref3.moduleSettings,
	          moduleSettings = _ref3$moduleSettings === void 0 ? null : _ref3$moduleSettings,
	          _ref3$uniforms = _ref3.uniforms,
	          uniforms = _ref3$uniforms === void 0 ? {} : _ref3$uniforms,
	          _ref3$attributes = _ref3.attributes,
	          attributes = _ref3$attributes === void 0 ? {} : _ref3$attributes,
	          _ref3$samplers = _ref3.samplers,
	          samplers = _ref3$samplers === void 0 ? {} : _ref3$samplers,
	          _ref3$parameters = _ref3.parameters,
	          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters,
	          settings = _ref3.settings,
	          _ref3$framebuffer = _ref3.framebuffer,
	          framebuffer = _ref3$framebuffer === void 0 ? null : _ref3$framebuffer,
	          _ref3$vertexArray = _ref3.vertexArray,
	          vertexArray = _ref3$vertexArray === void 0 ? null : _ref3$vertexArray,
	          _ref3$transformFeedba = _ref3.transformFeedback,
	          transformFeedback = _ref3$transformFeedba === void 0 ? null : _ref3$transformFeedba;

	      if (settings) {
	        _utils.log.deprecated('settings', 'parameters')();

	        parameters = settings;
	      }

	      if (moduleSettings) {
	        this.updateModuleSettings(moduleSettings);
	      }

	      if (framebuffer) {
	        parameters = Object.assign(parameters, {
	          framebuffer: framebuffer
	        });
	      }

	      this.render(uniforms, attributes, samplers, transformFeedback, parameters, vertexArray);

	      if (framebuffer) {
	        framebuffer.log({
	          priority: LOG_DRAW_PRIORITY,
	          message: "Rendered to ".concat(framebuffer.id)
	        });
	      }

	      return this;
	    }
	    /* eslint-disable max-params  */

	  }, {
	    key: "render",
	    value: function render() {
	      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var samplers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var transformFeedback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	      var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
	      var vertexArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
	      (0, _seerIntegration.addModel)(this);
	      var resolvedUniforms = this.addViewUniforms(uniforms);
	      (0, _seerIntegration.getOverrides)(this.id, resolvedUniforms);
	      this.setUniforms(resolvedUniforms);
	      this.setAttributes(attributes);
	      Object.assign(this.samplers, samplers);

	      _utils.log.group(LOG_DRAW_PRIORITY, ">>> RENDERING MODEL ".concat(this.id), {
	        collapsed: _utils.log.priority <= 2
	      })();

	      this.setProgramState({
	        vertexArray: vertexArray
	      });

	      this._logAttributesAndUniforms(2, resolvedUniforms);

	      this.onBeforeRender();
	      var drawParams = this.drawParams;

	      if (drawParams.isInstanced && !this.isInstanced) {
	        _utils.log.warn('Found instanced attributes on non-instanced model')();
	      }

	      var isIndexed = drawParams.isIndexed,
	          indexType = drawParams.indexType;
	      var isInstanced = this.isInstanced,
	          instanceCount = this.instanceCount;

	      this._timerQueryStart();

	      this.program.draw({
	        parameters: parameters,
	        drawMode: this.getDrawMode(),
	        vertexCount: this.getVertexCount(),
	        vertexArray: vertexArray,
	        transformFeedback: transformFeedback,
	        isIndexed: isIndexed,
	        indexType: indexType,
	        isInstanced: isInstanced,
	        instanceCount: instanceCount
	      });

	      this._timerQueryEnd();

	      this.onAfterRender();
	      this.unsetProgramState();
	      this.setNeedsRedraw(false);

	      _utils.log.groupEnd(LOG_DRAW_PRIORITY, ">>> RENDERING MODEL ".concat(this.id))();

	      return this;
	    }
	    /* eslint-enable max-params  */

	  }, {
	    key: "setProgramState",
	    value: function setProgramState() {
	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref4$vertexArray = _ref4.vertexArray,
	          vertexArray = _ref4$vertexArray === void 0 ? null : _ref4$vertexArray;

	      var program = this.program;
	      program.use();
	      this.drawParams = {};
	      program.setAttributes(this._attributes, {
	        drawParams: this.drawParams
	      });
	      program.checkAttributeBindings({
	        vertexArray: vertexArray
	      });
	      program.setUniforms(this.uniforms, this.samplers);
	      return this;
	    }
	  }, {
	    key: "unsetProgramState",
	    value: function unsetProgramState() {
	      // Ensures all vertex attributes are disabled and ELEMENT_ARRAY_BUFFER
	      // is unbound
	      this.program.unsetBuffers();
	      return this;
	    } // DEPRECATED METHODS
	    // TODO - uniform names are too strongly linked camera <=> default shaders
	    // At least all special handling is collected here.

	  }, {
	    key: "addViewUniforms",
	    value: function addViewUniforms(uniforms) {
	      // TODO - special treatment of these parameters should be removed
	      var camera = uniforms.camera,
	          viewMatrix = uniforms.viewMatrix,
	          modelMatrix = uniforms.modelMatrix; // Camera exposes uniforms that can be used directly in shaders

	      var cameraUniforms = camera ? camera.getUniforms() : {};
	      var viewUniforms = viewMatrix ? this.getCoordinateUniforms(viewMatrix, modelMatrix) : {};
	      return Object.assign({}, uniforms, cameraUniforms, viewUniforms);
	    } // PRIVATE METHODS

	  }, {
	    key: "_initializeProgram",
	    value: function _initializeProgram(_ref5) {
	      var vs = _ref5.vs,
	          fs = _ref5.fs,
	          modules = _ref5.modules,
	          defines = _ref5.defines,
	          moduleSettings = _ref5.moduleSettings,
	          defaultUniforms = _ref5.defaultUniforms,
	          program = _ref5.program,
	          shaderCache = _ref5.shaderCache,
	          varyings = _ref5.varyings,
	          bufferMode = _ref5.bufferMode;

	      this.getModuleUniforms = function (x) {};

	      if (!program) {
	        // Assign default shaders if none are provided
	        if (!vs) {
	          vs = _shaders.MODULAR_SHADERS.vs;
	        }

	        if (!fs) {
	          fs = _shaders.MODULAR_SHADERS.fs;
	        }

	        var assembleResult = (0, _shadertools.assembleShaders)(this.gl, {
	          vs: vs,
	          fs: fs,
	          modules: modules,
	          defines: defines
	        });
	        vs = assembleResult.vs;
	        fs = assembleResult.fs;

	        if (shaderCache) {
	          program = shaderCache.getProgram(this.gl, {
	            vs: vs,
	            fs: fs,
	            id: this.id
	          });
	        } else {
	          program = new _webgl.Program(this.gl, {
	            vs: vs,
	            fs: fs,
	            varyings: varyings,
	            bufferMode: bufferMode
	          });
	        }

	        var getUniforms = assembleResult.getUniforms;

	        this.getModuleUniforms = getUniforms || function (x) {};
	      }

	      this.program = program;
	      (0, _assert.default)(_instanceof(this.program, _webgl.Program), 'Model needs a program');
	    }
	    /* eslint-enable complexity */

	  }, {
	    key: "_checkForDeprecatedUniforms",
	    value: function _checkForDeprecatedUniforms(uniforms) {
	      // deprecated picking uniforms
	      DEPRECATED_PICKING_UNIFORMS.forEach(function (uniform) {
	        if (uniform in uniforms) {
	          _utils.log.deprecated(uniform, 'use picking shader module and Model class updateModuleSettings()')();
	        }
	      });
	    }
	  }, {
	    key: "_timerQueryStart",
	    value: function _timerQueryStart() {
	      if (this.timerQueryEnabled === true) {
	        if (!this.timeElapsedQuery) {
	          this.timeElapsedQuery = new _query.default(this.gl);
	        }

	        if (this.lastQueryReturned) {
	          this.lastQueryReturned = false;
	          this.timeElapsedQuery.beginTimeElapsedQuery();
	        }
	      }
	    }
	  }, {
	    key: "_timerQueryEnd",
	    value: function _timerQueryEnd() {
	      if (this.timerQueryEnabled === true) {
	        this.timeElapsedQuery.end(); // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false
	        // should this be incorporated into Query object?

	        if (this.timeElapsedQuery.isResultAvailable()) {
	          this.lastQueryReturned = true;
	          var elapsedTime = this.timeElapsedQuery.getResult(); // Update stats (e.g. for seer)

	          this.stats.lastFrameTime = elapsedTime;
	          this.stats.accumulatedFrameTime += elapsedTime;
	          this.stats.profileFrameCount++;
	          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount; // Log stats

	          _utils.log.log(LOG_DRAW_PRIORITY, "GPU time ".concat(this.program.id, ": ").concat(this.stats.lastFrameTime, "ms average ").concat(this.stats.averageFrameTime, "ms accumulated: ").concat(this.stats.accumulatedFrameTime, "ms count: ").concat(this.stats.profileFrameCount))();
	        }
	      }
	    } // Makes sure buffers are created for all attributes
	    // and that the program is updated with those buffers
	    // TODO - do we need the separation between "attributes" and "buffers"
	    // couldn't apps just create buffers directly?

	  }, {
	    key: "_createBuffersFromAttributeDescriptors",
	    value: function _createBuffersFromAttributeDescriptors(attributes) {
	      var gl = this.program.gl;

	      for (var attributeName in attributes) {
	        var descriptor = attributes[attributeName];
	        var attribute = this._attributes[attributeName];

	        if (_instanceof(descriptor, _webgl.Attribute)) {
	          attribute = descriptor;
	        } else if (_instanceof(descriptor, _webgl.Buffer)) {
	          attribute = attribute || new _webgl.Attribute(gl, Object.assign({}, descriptor.layout, {
	            id: attributeName
	          }));
	          attribute.update({
	            isGeneric: false,
	            buffer: descriptor
	          });
	        } else if (attribute) {
	          attribute.update(descriptor);
	        } else {
	          attribute = new _webgl.Attribute(gl, descriptor);
	        }

	        this._attributes[attributeName] = attribute;
	      }

	      return this;
	    }
	  }, {
	    key: "_logAttributesAndUniforms",
	    value: function _logAttributesAndUniforms(priority) {
	      var uniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      if (_utils.log.priority >= priority) {
	        var attributeTable = this._getAttributesTable({
	          header: "".concat(this.id, " attributes"),
	          program: this.program,
	          attributes: this._attributes
	        });

	        _utils.log.table(priority, attributeTable)();

	        var _getUniformsTable = (0, _uniforms.getUniformsTable)({
	          header: "".concat(this.id, " uniforms"),
	          program: this.program,
	          uniforms: Object.assign({}, this.uniforms, uniforms)
	        }),
	            table = _getUniformsTable.table,
	            unusedTable = _getUniformsTable.unusedTable,
	            unusedCount = _getUniformsTable.unusedCount;

	        _utils.log.table(priority, table)();

	        _utils.log.log(priority, "".concat(unusedCount || 'No', " unused uniforms "), unusedTable)();
	      } else {
	        // Always log missing uniforms
	        var _getUniformsTable2 = (0, _uniforms.getUniformsTable)({
	          header: "".concat(this.id, " uniforms"),
	          program: this.program,
	          uniforms: Object.assign({}, this.uniforms, uniforms),
	          undefinedOnly: true
	        }),
	            _table = _getUniformsTable2.table,
	            count = _getUniformsTable2.count;

	        if (count > 0) {
	          _utils.log.table(priority, _table)();
	        }
	      }

	      (0, _seerIntegration.logModel)(this, uniforms);
	    } // Todo move to attributes manager

	  }, {
	    key: "_getAttributesTable",
	    value: function _getAttributesTable() {
	      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          attributes = _ref6.attributes,
	          _ref6$header = _ref6.header,
	          header = _ref6$header === void 0 ? 'Attributes' : _ref6$header,
	          instanced = _ref6.instanced,
	          program = _ref6.program;

	      (0, _assert.default)(program);
	      var attributeLocations = program._attributeToLocationMap;
	      var table = {}; // {[header]: {}};
	      // Add index if available

	      for (var attributeName in attributes) {
	        var attribute = attributes[attributeName];

	        if (attribute.isIndexed) {
	          this._createAttributeEntry(attribute, 'ELEMENT_ARRAY_BUFFER', header);
	        }
	      } // Add used attributes


	      for (var _attributeName in attributeLocations) {
	        var _attribute = attributes[_attributeName];
	        var location = attributeLocations[_attributeName];
	        table[_attributeName] = this._createAttributeEntry(_attribute, location, header);
	      } // Add any unused attributes


	      for (var _attributeName2 in attributes) {
	        var _attribute2 = attributes[_attributeName2];

	        if (!table[_attributeName2]) {
	          table[_attributeName2] = this._createAttributeEntry(_attribute2, null, header);
	        }
	      }

	      return table;
	    }
	  }, {
	    key: "_createAttributeEntry",
	    value: function _createAttributeEntry(attribute, location, header) {
	      var _ref7;

	      var round = function round(num) {
	        return Math.round(num * 10) / 10;
	      };

	      var type = 'NOT PROVIDED';
	      var instanced = 0;
	      var size = 'N/A';
	      var verts = 'N/A';
	      var bytes = 'N/A';
	      var value = 'N/A';

	      if (attribute && location === null) {
	        location = attribute.isIndexed ? 'ELEMENT_ARRAY_BUFFER' : 'NOT USED';
	      }

	      if (attribute) {
	        type = attribute.type;
	        instanced = attribute.instanced;
	        size = attribute.size;

	        if (attribute.externalBuffer) {
	          value = attribute.externalBuffer.data;
	          bytes = attribute.externalBuffer.bytes;
	          verts = bytes / value.BYTES_PER_ELEMENT;
	        } else if (attribute.value) {
	          value = attribute.value;
	          verts = round(value.length / size);
	          bytes = value.length * value.BYTES_PER_ELEMENT;
	        }
	      } // Generate a type name by dropping Array from Float32Array etc.


	      type = String(type).replace('Array', ''); // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array

	      var isInteger = type.indexOf('nt') !== -1;
	      return _ref7 = {}, _defineProperty(_ref7, header, (0, _utils.formatValue)(value, {
	        size: size,
	        isInteger: isInteger
	      })), _defineProperty(_ref7, 'Memory Size and Layout', "".concat(instanced ? 'I ' : 'P ', " ").concat(verts, " (x").concat(size, "=").concat(bytes, "bytes ").concat(type, ") loc=").concat(location)), _ref7;
	    } // DEPRECATED / REMOVED

	  }, {
	    key: "isPickable",
	    value: function isPickable() {
	      return this.pickable;
	    }
	  }, {
	    key: "setPickable",
	    value: function setPickable() {
	      var pickable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.pickable = Boolean(pickable);
	      return this;
	    }
	  }, {
	    key: "getGeometry",
	    value: function getGeometry() {
	      return this.geometry;
	    }
	  }, {
	    key: "varyingMap",
	    get: function get() {
	      return this.program.varyingMap;
	    }
	  }]);

	  return Model;
	}(_object3d.default);

	exports.default = Model;
	//# sourceMappingURL=model.js.map

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getDrawMode = getDrawMode;
	exports.default = exports.DRAW_MODE = void 0;

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Rendering primitives - specify how to extract primitives from vertices.
	// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants
	var DRAW_MODE = {
	  POINTS: 0x0000,
	  // draw single points.
	  LINES: 0x0001,
	  // draw lines. Each vertex connects to the one after it.
	  LINE_LOOP: 0x0002,
	  // draw lines. Each set of two vertices is treated as a separate line segment.
	  LINE_STRIP: 0x0003,
	  // draw a connected group of line segments from the first vertex to the last
	  TRIANGLES: 0x0004,
	  // draw triangles. Each set of three vertices creates a separate triangle.
	  TRIANGLE_STRIP: 0x0005,
	  // draw a connected group of triangles.
	  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.
	  // Each vertex connects to the previous and the first vertex in the fan.

	}; // Helper function to handle string draw modes - when using this library without WebGL constants

	exports.DRAW_MODE = DRAW_MODE;

	function getDrawMode(drawMode) {
	  var mode = typeof drawMode === 'string' ? DRAW_MODE[drawMode] || DRAW_MODE.TRIANGLES : drawMode;
	  (0, _assert.default)(mode >= 0 && mode <= DRAW_MODE.TRIANGLE_FAN, 'Illegal drawMode');
	  return mode;
	}

	var Geometry =
	/*#__PURE__*/
	function () {
	  function Geometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Geometry);

	    var id = opts.id,
	        _opts$drawMode = opts.drawMode,
	        drawMode = _opts$drawMode === void 0 ? DRAW_MODE.TRIANGLES : _opts$drawMode,
	        _opts$vertexCount = opts.vertexCount,
	        vertexCount = _opts$vertexCount === void 0 ? undefined : _opts$vertexCount,
	        attributes = opts.attributes;
	    this.id = id || (0, _utils.uid)(this.constructor.name);
	    this.drawMode = getDrawMode(drawMode);
	    this.vertexCount = vertexCount;
	    this.attributes = {};
	    this.needsRedraw = true;
	    this.userData = {};
	    Object.seal(this);

	    if (attributes) {
	      this.setAttributes(attributes);
	    }
	  }

	  _createClass(Geometry, [{
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw() {
	      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.needsRedraw = redraw;
	      return this;
	    }
	  }, {
	    key: "getNeedsRedraw",
	    value: function getNeedsRedraw() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$clearRedrawFlags = _ref.clearRedrawFlags,
	          clearRedrawFlags = _ref$clearRedrawFlags === void 0 ? false : _ref$clearRedrawFlags;

	      var redraw = false;
	      redraw = redraw || this.needsRedraw;
	      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
	      return redraw;
	    }
	  }, {
	    key: "setVertexCount",
	    value: function setVertexCount(vertexCount) {
	      this.vertexCount = vertexCount;
	    }
	  }, {
	    key: "getVertexCount",
	    value: function getVertexCount() {
	      if (this.vertexCount !== undefined) {
	        return this.vertexCount;
	      } else if (this.attributes.indices) {
	        return this.attributes.indices.value.length;
	      } else if (this.attributes.vertices) {
	        return this.attributes.vertices.value.length / 3;
	      } else if (this.attributes.positions) {
	        return this.attributes.positions.value.length / 3;
	      }

	      return false;
	    }
	  }, {
	    key: "hasAttribute",
	    value: function hasAttribute(attributeName) {
	      return Boolean(this.attributes[attributeName]);
	    }
	  }, {
	    key: "getAttribute",
	    value: function getAttribute(attributeName) {
	      var attribute = this.attributes[attributeName];
	      (0, _assert.default)(attribute);
	      return attribute.value;
	    }
	  }, {
	    key: "getArray",
	    value: function getArray(attributeName) {
	      var attribute = this.attributes[attributeName];
	      (0, _assert.default)(attribute);
	      return attribute.value;
	    }
	  }, {
	    key: "getAttributes",
	    value: function getAttributes() {
	      return this.attributes;
	    } // Attribute
	    // value: typed array
	    // type: indices, vertices, uvs
	    // size: elements per vertex
	    // target: WebGL buffer type (string or constant)

	  }, {
	    key: "setAttributes",
	    value: function setAttributes(attributes) {
	      for (var attributeName in attributes) {
	        var attribute = attributes[attributeName]; // Wrap "unwrapped" arrays and try to autodetect their type

	        attribute = ArrayBuffer.isView(attribute) ? {
	          value: attribute
	        } : attribute;
	        (0, _assert.default)(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));

	        this._autoDetectAttribute(attributeName, attribute);

	        this.attributes[attributeName] = Object.assign({}, attribute, {
	          instanced: attribute.instanced || 0
	        });
	      }

	      this.setNeedsRedraw();
	      return this;
	    } // Check for well known attribute names

	    /* eslint-disable default-case, complexity */

	  }, {
	    key: "_autoDetectAttribute",
	    value: function _autoDetectAttribute(attributeName, attribute) {
	      var category;

	      switch (attributeName) {
	        case 'indices':
	          category = category || 'indices';
	          break;

	        case 'texCoords':
	        case 'texCoord1':
	        case 'texCoord2':
	        case 'texCoord3':
	          category = 'uvs';
	          break;

	        case 'vertices':
	        case 'positions':
	        case 'normals':
	        case 'pickingColors':
	          category = 'vectors';
	          break;
	      } // Check for categorys


	      switch (category) {
	        case 'vectors':
	          attribute.size = attribute.size || 3;
	          break;

	        case 'uvs':
	          attribute.size = attribute.size || 2;
	          break;

	        case 'indices':
	          attribute.size = attribute.size || 1;
	          attribute.isIndexed = attribute.isIndexed === undefined ? true : attribute.isIndexed;
	          (0, _assert.default)(_instanceof(attribute.value, Uint16Array) || _instanceof(attribute.value, Uint32Array), 'attribute array for "indices" must be of integer type');
	          break;
	      }

	      (0, _assert.default)(attribute.size, "attribute ".concat(attributeName, " needs size"));
	    }
	    /* eslint-enable default-case, complexity */

	  }, {
	    key: "_print",
	    value: function _print(attributeName) {
	      return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
	    }
	  }]);

	  return Geometry;
	}();

	exports.default = Geometry;
	//# sourceMappingURL=geometry.js.map

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _utils = __webpack_require__(63);

	var _math = __webpack_require__(109);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var Object3D =
	/*#__PURE__*/
	function () {
	  function Object3D(_ref) {
	    var id = _ref.id,
	        _ref$display = _ref.display,
	        display = _ref$display === void 0 ? true : _ref$display;

	    _classCallCheck(this, Object3D);

	    // model position, rotation, scale and all in all matrix
	    this.position = new _math.Vector3();
	    this.rotation = new _math.Vector3();
	    this.scale = new _math.Vector3(1, 1, 1);
	    this.matrix = new _math.Matrix4(); // whether to display the object at all

	    this.id = id || (0, _utils.uid)(this.constructor.name);
	    this.display = true;
	    this.userData = {};
	  }

	  _createClass(Object3D, [{
	    key: "setPosition",
	    value: function setPosition(position) {
	      (0, _assert.default)(position.length === 3, 'setPosition requires vector argument');
	      this.position = position;
	      return this;
	    }
	  }, {
	    key: "setRotation",
	    value: function setRotation(rotation) {
	      (0, _assert.default)(rotation.length === 3, 'setRotation requires vector argument');
	      this.rotation = rotation;
	      return this;
	    }
	  }, {
	    key: "setScale",
	    value: function setScale(scale) {
	      (0, _assert.default)(scale.length === 3, 'setScale requires vector argument');
	      this.scale = scale;
	      return this;
	    }
	  }, {
	    key: "setMatrixComponents",
	    value: function setMatrixComponents(_ref2) {
	      var position = _ref2.position,
	          rotation = _ref2.rotation,
	          scale = _ref2.scale,
	          _ref2$update = _ref2.update,
	          update = _ref2$update === void 0 ? true : _ref2$update;

	      if (position) {
	        this.setPosition(position);
	      }

	      if (rotation) {
	        this.setRotation(rotation);
	      }

	      if (scale) {
	        this.setScale(scale);
	      }

	      if (update) {
	        this.updateMatrix();
	      }

	      return this;
	    }
	  }, {
	    key: "updateMatrix",
	    value: function updateMatrix() {
	      var pos = this.position;
	      var rot = this.rotation;
	      var scale = this.scale;
	      this.matrix.identity();
	      this.matrix.translate(pos);
	      this.matrix.rotateXYZ(rot);
	      this.matrix.scale(scale);
	      return this;
	    }
	  }, {
	    key: "update",
	    value: function update() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          position = _ref3.position,
	          rotation = _ref3.rotation,
	          scale = _ref3.scale;

	      if (position) {
	        this.setPosition(position);
	      }

	      if (rotation) {
	        this.setRotation(rotation);
	      }

	      if (scale) {
	        this.setScale(scale);
	      }

	      this.updateMatrix();
	      return this;
	    }
	  }, {
	    key: "getCoordinateUniforms",
	    value: function getCoordinateUniforms(viewMatrix, modelMatrix) {
	      // TODO - solve multiple class problem
	      // assert(viewMatrix instanceof Matrix4);
	      (0, _assert.default)(viewMatrix);
	      modelMatrix = modelMatrix || this.matrix;
	      var worldMatrix = new _math.Matrix4(viewMatrix).multiplyRight(modelMatrix);
	      var worldInverse = worldMatrix.invert();
	      var worldInverseTranspose = worldInverse.transpose();
	      return {
	        viewMatrix: viewMatrix,
	        modelMatrix: modelMatrix,
	        objectMatrix: modelMatrix,
	        worldMatrix: worldMatrix,
	        worldInverseMatrix: worldInverse,
	        worldInverseTransposeMatrix: worldInverseTranspose
	      };
	    } // TODO - copied code, not yet vetted

	  }, {
	    key: "transform",
	    value: function transform() {
	      if (!this.parent) {
	        this.endPosition.set(this.position);
	        this.endRotation.set(this.rotation);
	        this.endScale.set(this.scale);
	      } else {
	        var parent = this.parent;
	        this.endPosition.set(this.position.add(parent.endPosition));
	        this.endRotation.set(this.rotation.add(parent.endRotation));
	        this.endScale.set(this.scale.add(parent.endScale));
	      }

	      var ch = this.children;

	      for (var i = 0; i < ch.length; ++i) {
	        ch[i].transform();
	      }

	      return this;
	    }
	  }]);

	  return Object3D;
	}();

	exports.default = Object3D;
	//# sourceMappingURL=object-3d.js.map

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "Vector2", {
	  enumerable: true,
	  get: function get() {
	    return _vector.default;
	  }
	});
	Object.defineProperty(exports, "Vector3", {
	  enumerable: true,
	  get: function get() {
	    return _vector2.default;
	  }
	});
	Object.defineProperty(exports, "Vector4", {
	  enumerable: true,
	  get: function get() {
	    return _vector3.default;
	  }
	});
	Object.defineProperty(exports, "Matrix4", {
	  enumerable: true,
	  get: function get() {
	    return _matrix.default;
	  }
	});
	Object.defineProperty(exports, "Quaternion", {
	  enumerable: true,
	  get: function get() {
	    return _quaternion.default;
	  }
	});
	Object.defineProperty(exports, "config", {
	  enumerable: true,
	  get: function get() {
	    return _common.config;
	  }
	});
	Object.defineProperty(exports, "checkNumber", {
	  enumerable: true,
	  get: function get() {
	    return _common.checkNumber;
	  }
	});
	Object.defineProperty(exports, "configure", {
	  enumerable: true,
	  get: function get() {
	    return _common.configure;
	  }
	});
	Object.defineProperty(exports, "formatValue", {
	  enumerable: true,
	  get: function get() {
	    return _common.formatValue;
	  }
	});
	Object.defineProperty(exports, "isArray", {
	  enumerable: true,
	  get: function get() {
	    return _common.isArray;
	  }
	});
	Object.defineProperty(exports, "clone", {
	  enumerable: true,
	  get: function get() {
	    return _common.clone;
	  }
	});
	Object.defineProperty(exports, "radians", {
	  enumerable: true,
	  get: function get() {
	    return _common.radians;
	  }
	});
	Object.defineProperty(exports, "degrees", {
	  enumerable: true,
	  get: function get() {
	    return _common.degrees;
	  }
	});
	Object.defineProperty(exports, "sin", {
	  enumerable: true,
	  get: function get() {
	    return _common.sin;
	  }
	});
	Object.defineProperty(exports, "cos", {
	  enumerable: true,
	  get: function get() {
	    return _common.cos;
	  }
	});
	Object.defineProperty(exports, "tan", {
	  enumerable: true,
	  get: function get() {
	    return _common.tan;
	  }
	});
	Object.defineProperty(exports, "asin", {
	  enumerable: true,
	  get: function get() {
	    return _common.asin;
	  }
	});
	Object.defineProperty(exports, "acos", {
	  enumerable: true,
	  get: function get() {
	    return _common.acos;
	  }
	});
	Object.defineProperty(exports, "atan", {
	  enumerable: true,
	  get: function get() {
	    return _common.atan;
	  }
	});
	Object.defineProperty(exports, "clamp", {
	  enumerable: true,
	  get: function get() {
	    return _common.clamp;
	  }
	});
	Object.defineProperty(exports, "lerp", {
	  enumerable: true,
	  get: function get() {
	    return _common.lerp;
	  }
	});
	Object.defineProperty(exports, "equals", {
	  enumerable: true,
	  get: function get() {
	    return _common.equals;
	  }
	});
	exports.experimental = void 0;

	var _vector = _interopRequireDefault(__webpack_require__(110));

	var _vector2 = _interopRequireDefault(__webpack_require__(115));

	var _vector3 = _interopRequireDefault(__webpack_require__(124));

	var _matrix = _interopRequireDefault(__webpack_require__(125));

	var _quaternion = _interopRequireDefault(__webpack_require__(145));

	var _common = __webpack_require__(113);

	var _sphericalCoordinates = _interopRequireDefault(__webpack_require__(175));

	var _pose = _interopRequireDefault(__webpack_require__(176));

	var _euler = _interopRequireDefault(__webpack_require__(177));

	var _polygon = _interopRequireDefault(__webpack_require__(178));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// math.gl classes
	// math.gl "GLSL" functions
	var experimental = {
	  SphericalCoordinates: _sphericalCoordinates.default,
	  Euler: _euler.default,
	  Pose: _pose.default,
	  Polygon: _polygon.default
	};
	exports.experimental = experimental;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _vector = _interopRequireDefault(__webpack_require__(111));

	var _common = __webpack_require__(113);

	var _cross = _interopRequireDefault(__webpack_require__(114));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Vector2 =
	/*#__PURE__*/
	function (_Vector) {
	  _inherits(Vector2, _Vector);

	  // Creates a new, empty vec2
	  function Vector2() {
	    var _this;

	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	    _classCallCheck(this, Vector2);

	    _this = _possibleConstructorReturn(this, (Vector2.__proto__ || Object.getPrototypeOf(Vector2)).call(this));

	    if (Array.isArray(x) && arguments.length === 1) {
	      _this.copy(x);
	    } else {
	      _this.set(x, y);
	    }

	    return _this;
	  } // Getters/setters

	  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */


	  _createClass(Vector2, [{
	    key: "cross",

	    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
	    value: function cross(vector) {
	      (0, _cross.default)(this, this, vector);
	      return this.check();
	    }
	  }, {
	    key: "horizontalAngle",
	    value: function horizontalAngle() {
	      return Math.atan2(this.y, this.x);
	    }
	  }, {
	    key: "verticalAngle",
	    value: function verticalAngle() {
	      return Math.atan2(this.x, this.y);
	    }
	  }, {
	    key: "operation",
	    value: function operation(_operation) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      _operation.apply(void 0, [this, this].concat(args));

	      return this.check();
	    }
	  }, {
	    key: "ELEMENTS",
	    get: function get() {
	      return 2;
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }]);

	  return Vector2;
	}(_vector.default);

	exports.default = Vector2;
	//# sourceMappingURL=vector2.js.map

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _mathArray = _interopRequireDefault(__webpack_require__(112));

	var _common = __webpack_require__(113);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// import assert from 'assert';
	var assert = function assert(x, m) {
	  if (!x) {
	    throw new Error(m);
	  }
	};

	var Vector =
	/*#__PURE__*/
	function (_MathArray) {
	  _inherits(Vector, _MathArray);

	  function Vector() {
	    _classCallCheck(this, Vector);

	    return _possibleConstructorReturn(this, (Vector.__proto__ || Object.getPrototypeOf(Vector)).apply(this, arguments));
	  }

	  _createClass(Vector, [{
	    key: "len",
	    // ACCESSORS
	    // NOTE: `length` is a reserved word for Arrays, so we can't use `v.length()`
	    // Offer `len` and `magnitude`
	    value: function len() {
	      return Math.sqrt(this.lengthSquared());
	    }
	  }, {
	    key: "magnitude",
	    value: function magnitude() {
	      return Math.sqrt(this.lengthSquared());
	    }
	  }, {
	    key: "lengthSquared",
	    value: function lengthSquared() {
	      var length = 0;

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        length += this[i] * this[i];
	      }

	      return length;
	    }
	  }, {
	    key: "distance",
	    value: function distance(mathArray) {
	      return Math.sqrt(this.distanceSquared(mathArray));
	    }
	  }, {
	    key: "distanceSquared",
	    value: function distanceSquared(mathArray) {
	      var length = 0;

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        var dist = this[i] - mathArray[i];
	        length += dist * dist;
	      }

	      return (0, _common.checkNumber)(length);
	    }
	  }, {
	    key: "dot",
	    value: function dot(mathArray) {
	      var product = 0;

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        product += this[i] * mathArray[i];
	      }

	      return (0, _common.checkNumber)(product);
	    } // MODIFIERS

	  }, {
	    key: "normalize",
	    value: function normalize() {
	      var length = this.magnitude();

	      if (length !== 0) {
	        for (var i = 0; i < this.ELEMENTS; ++i) {
	          this[i] /= length;
	        }
	      }

	      return this.check();
	    } // negate() {
	    //   for (let i = 0; i < this.ELEMENTS; ++i) {
	    //     this[i] = -this[i];
	    //   }
	    //   return this.check();
	    // }
	    // inverse() {
	    //   for (let i = 0; i < this.ELEMENTS; ++i) {
	    //     this[i] = 1 / this[i];
	    //   }
	    //   return this.check();
	    // }

	  }, {
	    key: "add",
	    value: function add() {
	      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
	        vectors[_key] = arguments[_key];
	      }

	      for (var _i = 0; _i < vectors.length; _i++) {
	        var vector = vectors[_i];

	        for (var i = 0; i < this.ELEMENTS; ++i) {
	          this[i] += vector[i];
	        }
	      }

	      return this.check();
	    }
	  }, {
	    key: "subtract",
	    value: function subtract() {
	      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	        vectors[_key2] = arguments[_key2];
	      }

	      for (var _i2 = 0; _i2 < vectors.length; _i2++) {
	        var vector = vectors[_i2];

	        for (var i = 0; i < this.ELEMENTS; ++i) {
	          this[i] -= vector[i];
	        }
	      }

	      return this.check();
	    }
	  }, {
	    key: "multiply",
	    value: function multiply() {
	      for (var _len3 = arguments.length, vectors = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	        vectors[_key3] = arguments[_key3];
	      }

	      for (var _i3 = 0; _i3 < vectors.length; _i3++) {
	        var vector = vectors[_i3];

	        for (var i = 0; i < this.ELEMENTS; ++i) {
	          this[i] *= vector[i];
	        }
	      }

	      return this.check();
	    }
	  }, {
	    key: "divide",
	    value: function divide() {
	      for (var _len4 = arguments.length, vectors = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
	        vectors[_key4] = arguments[_key4];
	      }

	      for (var _i4 = 0; _i4 < vectors.length; _i4++) {
	        var vector = vectors[_i4];

	        for (var i = 0; i < this.ELEMENTS; ++i) {
	          this[i] /= vector[i];
	        }
	      }

	      return this.check();
	    }
	  }, {
	    key: "scale",
	    value: function scale(_scale) {
	      if (Array.isArray(_scale)) {
	        return this.multiply(_scale);
	      }

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] *= _scale;
	      }

	      return this.check();
	    }
	  }, {
	    key: "scaleAndAdd",
	    value: function scaleAndAdd(vector, scale) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = this[i] * scale + vector[i];
	      }

	      return this.check();
	    } // THREE.js compatibility

	  }, {
	    key: "lengthSq",
	    value: function lengthSq() {
	      return this.lengthSquared();
	    }
	  }, {
	    key: "distanceTo",
	    value: function distanceTo(vector) {
	      return this.distance(vector);
	    }
	  }, {
	    key: "distanceToSquared",
	    value: function distanceToSquared(vector) {
	      return this.distanceSquared(vector);
	    }
	  }, {
	    key: "getComponent",
	    value: function getComponent(i) {
	      assert(i >= 0 && i < this.ELEMENTS, 'index is out of range');
	      return (0, _common.checkNumber)(this[i]);
	    }
	  }, {
	    key: "setComponent",
	    value: function setComponent(i, value) {
	      assert(i >= 0 && i < this.ELEMENTS, 'index is out of range');
	      this[i] = value;
	      return this.check();
	    }
	  }, {
	    key: "addVectors",
	    value: function addVectors(a, b) {
	      return this.copy(a).add(b);
	    }
	  }, {
	    key: "subVectors",
	    value: function subVectors(a, b) {
	      return this.copy(a).subtract(b);
	    }
	  }, {
	    key: "multiplyVectors",
	    value: function multiplyVectors(a, b) {
	      return this.copy(a).multiply(b);
	    }
	  }, {
	    key: "addScaledVector",
	    value: function addScaledVector(a, b) {
	      return this.add(new this.constructor(a).multiplyScalar(b));
	    }
	  }]);

	  return Vector;
	}(_mathArray.default);

	exports.default = Vector;
	//# sourceMappingURL=vector.js.map

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _common = __webpack_require__(113);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _extendableBuiltin(cls) {
	  function ExtendableBuiltin() {
	    var instance = Reflect.construct(cls, Array.from(arguments));
	    Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
	    return instance;
	  }

	  ExtendableBuiltin.prototype = Object.create(cls.prototype, {
	    constructor: {
	      value: cls,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });

	  if (Object.setPrototypeOf) {
	    Object.setPrototypeOf(ExtendableBuiltin, cls);
	  } else {
	    ExtendableBuiltin.__proto__ = cls;
	  }

	  return ExtendableBuiltin;
	}

	var MathArray =
	/*#__PURE__*/
	function (_extendableBuiltin2) {
	  _inherits(MathArray, _extendableBuiltin2);

	  function MathArray() {
	    _classCallCheck(this, MathArray);

	    return _possibleConstructorReturn(this, (MathArray.__proto__ || Object.getPrototypeOf(MathArray)).apply(this, arguments));
	  }

	  _createClass(MathArray, [{
	    key: "clone",
	    value: function clone() {
	      return new this.constructor().copy(this).check();
	    }
	  }, {
	    key: "copy",
	    value: function copy(array) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = array[i];
	      }

	      return this.check();
	    }
	  }, {
	    key: "set",
	    value: function set() {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = (i < 0 || arguments.length <= i ? undefined : arguments[i]) || 0;
	      }

	      return this.check();
	    }
	  }, {
	    key: "fromArray",
	    value: function fromArray(array) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = array[i + offset];
	      }

	      return this.check();
	    }
	  }, {
	    key: "toString",
	    value: function toString() {
	      return this.formatString(_common.config);
	    }
	  }, {
	    key: "formatString",
	    value: function formatString(opts) {
	      var string = '';

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        string += (i > 0 ? ', ' : '') + (0, _common.formatValue)(this[i], opts);
	      }

	      return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
	    }
	  }, {
	    key: "toArray",
	    value: function toArray() {
	      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        array[offset + i] = this[i];
	      }

	      return array;
	    }
	  }, {
	    key: "toFloat32Array",
	    value: function toFloat32Array() {
	      return new Float32Array(this);
	    }
	  }, {
	    key: "equals",
	    value: function equals(array) {
	      if (!array || this.length !== array.length) {
	        return false;
	      }

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        if (!(0, _common.equals)(this[i], array[i])) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "exactEquals",
	    value: function exactEquals(array) {
	      if (!array || this.length !== array.length) {
	        return false;
	      }

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        if (this[i] !== array[i]) {
	          return false;
	        }
	      }

	      return true;
	    } // Modifiers

	  }, {
	    key: "negate",
	    value: function negate() {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = -this[i];
	      }

	      return this.check();
	    }
	  }, {
	    key: "inverse",
	    value: function inverse() {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = 1 / this[i];
	      }

	      return this.check();
	    }
	  }, {
	    key: "lerp",
	    value: function lerp(a, b, t) {
	      if (t === undefined) {
	        t = b;
	        b = a;
	        a = this; // eslint-disable-line
	      }

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        var ai = a[i];
	        this[i] = ai + t * (b[i] - ai);
	      }

	      return this.check();
	    }
	  }, {
	    key: "min",
	    value: function min(vector) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = Math.min(vector[i], this[i]);
	      }

	      return this.check();
	    }
	  }, {
	    key: "max",
	    value: function max(vector) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = Math.max(vector[i], this[i]);
	      }

	      return this.check();
	    }
	  }, {
	    key: "clamp",
	    value: function clamp(minVector, maxVector) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
	      }

	      return this.check();
	    } // Debug checks

	  }, {
	    key: "validate",
	    value: function validate() {
	      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
	      var valid = array && array.length === this.ELEMENTS;

	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        valid = valid && Number.isFinite(array[i]);
	      }

	      return valid;
	    }
	  }, {
	    key: "check",
	    value: function check() {
	      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;

	      if (_common.config.debug && !this.validate(array)) {
	        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
	      }

	      return this;
	    } // three.js compatibility

	  }, {
	    key: "sub",
	    value: function sub(a) {
	      return this.subtract(a);
	    }
	  }, {
	    key: "setScalar",
	    value: function setScalar(a) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = a;
	      }

	      return this.check();
	    }
	  }, {
	    key: "addScalar",
	    value: function addScalar(a) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] += a;
	      }

	      return this.check();
	    }
	  }, {
	    key: "subScalar",
	    value: function subScalar(a) {
	      return this.addScalar(-a);
	    }
	  }, {
	    key: "multiplyScalar",
	    value: function multiplyScalar(a) {
	      return this.scale(a);
	    }
	  }, {
	    key: "divideScalar",
	    value: function divideScalar(a) {
	      return this.scale(1 / a);
	    }
	  }, {
	    key: "clampScalar",
	    value: function clampScalar(min, max) {
	      for (var i = 0; i < this.ELEMENTS; ++i) {
	        this[i] = Math.min(Math.max(this[i], min), max);
	      }

	      return this.check();
	    }
	  }]);

	  return MathArray;
	}(_extendableBuiltin(Array));

	exports.default = MathArray;
	//# sourceMappingURL=math-array.js.map

/***/ }),
/* 113 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.configure = configure;
	exports.checkNumber = checkNumber;
	exports.formatValue = formatValue;
	exports.formatAngle = formatAngle;
	exports.isArray = isArray;
	exports.clone = clone;
	exports.radians = radians;
	exports.degrees = degrees;
	exports.sin = sin;
	exports.cos = cos;
	exports.tan = tan;
	exports.asin = asin;
	exports.acos = acos;
	exports.atan = atan;
	exports.clamp = clamp;
	exports.lerp = lerp;
	exports.equals = equals;
	exports.config = void 0;
	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	/* eslint-disable no-shadow */
	// TODO - remove
	var config = {};
	exports.config = config;
	config.EPSILON = 1e-12;
	config.debug = true;
	config.precision = 4;
	config.printTypes = false;
	config.printDegrees = false;
	config.printRowMajor = true;

	function configure(options) {
	  if ('epsilon' in options) {
	    config.EPSILON = options.epsilon;
	  }

	  if ('debug' in options) {
	    config.debug = options.debug;
	  }
	}

	function checkNumber(value) {
	  if (!Number.isFinite(value)) {
	    throw new Error("Invalid number ".concat(value));
	  }

	  return value;
	}

	function round(value) {
	  return Math.round(value / config.EPSILON) * config.EPSILON;
	}

	function formatValue(value) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$precision = _ref.precision,
	      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;

	  value = round(value);
	  return parseFloat(value.toPrecision(precision));
	}

	function formatAngle(value) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref2$precision = _ref2.precision,
	      precision = _ref2$precision === void 0 ? config.precision || 4 : _ref2$precision,
	      _ref2$printDegrees = _ref2.printDegrees,
	      printDegrees = _ref2$printDegrees === void 0 ? config.printAngles : _ref2$printDegrees;

	  value = printDegrees ? degrees(value) : value;
	  value = round(value);
	  return "".concat(parseFloat(value.toPrecision(precision))).concat(printDegrees ? '°' : '');
	} // Returns true if value is either an array or a typed array
	// Note: does not return true for ArrayBuffers and DataViews


	function isArray(value) {
	  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;
	} // If the array has a clone function, calls it, otherwise returns a copy


	function clone(array) {
	  return array.clone ? array.clone() : new Array(array);
	} // If the argument value is an array, applies the func element wise,
	// otherwise applies func to the argument value


	function map(value, func) {
	  if (isArray(value)) {
	    var result = clone(value);

	    for (var i = 0; i < result.length; ++i) {
	      result[i] = func(result[i], i, result);
	    }

	    return result;
	  }

	  return func(value);
	} //
	// GLSL math function equivalents
	// Works on both single values and vectors
	//


	function radians(degrees) {
	  return map(degrees, function (degrees) {
	    return degrees / 180 * Math.PI;
	  });
	} // GLSL equivalent: Works on single values and vectors


	function degrees(radians) {
	  return map(radians, function (radians) {
	    return radians * 180 / Math.PI;
	  });
	} // GLSL equivalent: Works on single values and vectors


	function sin(radians) {
	  return map(radians, function (angle) {
	    return Math.sin(angle);
	  });
	} // GLSL equivalent: Works on single values and vectors


	function cos(radians) {
	  return map(radians, function (angle) {
	    return Math.cos(angle);
	  });
	} // GLSL equivalent: Works on single values and vectors


	function tan(radians) {
	  return map(radians, function (angle) {
	    return Math.tan(angle);
	  });
	} // GLSL equivalent: Works on single values and vectors


	function asin(radians) {
	  return map(radians, function (angle) {
	    return Math.asin(angle);
	  });
	} // GLSL equivalent: Works on single values and vectors


	function acos(radians) {
	  return map(radians, function (angle) {
	    return Math.acos(angle);
	  });
	} // GLSL equivalent: Works on single values and vectors


	function atan(radians) {
	  return map(radians, function (angle) {
	    return Math.atan(angle);
	  });
	}

	function clamp(value, min, max) {
	  return map(value, function (value) {
	    return Math.max(min, Math.min(max, value));
	  });
	} // Interpolate between two numbers or two arrays


	function lerp(a, b, t) {
	  if (Array.isArray(a)) {
	    return a.map(function (ai, i) {
	      return lerp(ai, b[i], t);
	    });
	  }

	  return t * b + (1 - t) * a;
	}

	function equals(a, b) {
	  if (Array.isArray(a) && Array.isArray(b)) {
	    if (a === b) {
	      return true;
	    }

	    if (a.length !== b.length) {
	      return false;
	    }

	    for (var i = 0; i < a.length; ++i) {
	      if (!equals(a[i], b[i])) {
	        return false;
	      }
	    }

	    return true;
	  }

	  return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
	}
	//# sourceMappingURL=common.js.map

/***/ }),
/* 114 */
/***/ (function(module, exports) {

	module.exports = cross

	/**
	 * Computes the cross product of two vec2's
	 * Note that the cross product must by definition produce a 3D vector
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec3} out
	 */
	function cross(out, a, b) {
	    var z = a[0] * b[1] - a[1] * b[0]
	    out[0] = out[1] = 0
	    out[2] = z
	    return out
	}

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _vector = _interopRequireDefault(__webpack_require__(111));

	var _common = __webpack_require__(113);

	var _angle = _interopRequireDefault(__webpack_require__(116));

	var _cross = _interopRequireDefault(__webpack_require__(120));

	var _rotateX = _interopRequireDefault(__webpack_require__(121));

	var _rotateY = _interopRequireDefault(__webpack_require__(122));

	var _rotateZ = _interopRequireDefault(__webpack_require__(123));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ORIGIN = [0, 0, 0];

	var Vector3 =
	/*#__PURE__*/
	function (_Vector) {
	  _inherits(Vector3, _Vector);

	  // Creates a new vec3, either empty, or from an array or from values
	  function Vector3() {
	    var _this;

	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    _classCallCheck(this, Vector3);

	    _this = _possibleConstructorReturn(this, (Vector3.__proto__ || Object.getPrototypeOf(Vector3)).call(this));

	    if (Array.isArray(x) && arguments.length === 1) {
	      _this.copy(x);
	    } else {
	      _this.set(x, y, z);
	    }

	    return _this;
	  } // Getters/setters

	  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */


	  _createClass(Vector3, [{
	    key: "angle",

	    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */
	    value: function angle(vector) {
	      return (0, _angle.default)(this, vector);
	    } // MODIFIERS

	  }, {
	    key: "cross",
	    value: function cross(vector) {
	      (0, _cross.default)(this, this, vector);
	      return this.check();
	    }
	  }, {
	    key: "rotateX",
	    value: function rotateX(_ref) {
	      var radians = _ref.radians,
	          _ref$origin = _ref.origin,
	          origin = _ref$origin === void 0 ? ORIGIN : _ref$origin;
	      (0, _rotateX.default)(this, this, origin, radians);
	      return this.check();
	    }
	  }, {
	    key: "rotateY",
	    value: function rotateY(_ref2) {
	      var radians = _ref2.radians,
	          _ref2$origin = _ref2.origin,
	          origin = _ref2$origin === void 0 ? ORIGIN : _ref2$origin;
	      (0, _rotateY.default)(this, this, origin, radians);
	      return this.check();
	    }
	  }, {
	    key: "rotateZ",
	    value: function rotateZ(_ref3) {
	      var radians = _ref3.radians,
	          _ref3$origin = _ref3.origin,
	          origin = _ref3$origin === void 0 ? ORIGIN : _ref3$origin;
	      (0, _rotateZ.default)(this, this, origin, radians);
	      return this.check();
	    }
	  }, {
	    key: "operation",
	    value: function operation(_operation) {
	      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      _operation.apply(void 0, [this, this].concat(args));

	      return this.check();
	    }
	  }, {
	    key: "ELEMENTS",
	    get: function get() {
	      return 3;
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "z",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    }
	  }]);

	  return Vector3;
	}(_vector.default);

	exports.default = Vector3;
	//# sourceMappingURL=vector3.js.map

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = angle

	var fromValues = __webpack_require__(117)
	var normalize = __webpack_require__(118)
	var dot = __webpack_require__(119)

	/**
	 * Get the angle between two 3D vectors
	 * @param {vec3} a The first operand
	 * @param {vec3} b The second operand
	 * @returns {Number} The angle in radians
	 */
	function angle(a, b) {
	    var tempA = fromValues(a[0], a[1], a[2])
	    var tempB = fromValues(b[0], b[1], b[2])
	 
	    normalize(tempA, tempA)
	    normalize(tempB, tempB)
	 
	    var cosine = dot(tempA, tempB)

	    if(cosine > 1.0){
	        return 0
	    } else {
	        return Math.acos(cosine)
	    }     
	}


/***/ }),
/* 117 */
/***/ (function(module, exports) {

	module.exports = fromValues;

	/**
	 * Creates a new vec3 initialized with the given values
	 *
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @returns {vec3} a new 3D vector
	 */
	function fromValues(x, y, z) {
	    var out = new Float32Array(3)
	    out[0] = x
	    out[1] = y
	    out[2] = z
	    return out
	}

/***/ }),
/* 118 */
/***/ (function(module, exports) {

	module.exports = normalize;

	/**
	 * Normalize a vec3
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a vector to normalize
	 * @returns {vec3} out
	 */
	function normalize(out, a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2]
	    var len = x*x + y*y + z*z
	    if (len > 0) {
	        //TODO: evaluate use of glm_invsqrt here?
	        len = 1 / Math.sqrt(len)
	        out[0] = a[0] * len
	        out[1] = a[1] * len
	        out[2] = a[2] * len
	    }
	    return out
	}

/***/ }),
/* 119 */
/***/ (function(module, exports) {

	module.exports = dot;

	/**
	 * Calculates the dot product of two vec3's
	 *
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot(a, b) {
	    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
	}

/***/ }),
/* 120 */
/***/ (function(module, exports) {

	module.exports = cross;

	/**
	 * Computes the cross product of two vec3's
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function cross(out, a, b) {
	    var ax = a[0], ay = a[1], az = a[2],
	        bx = b[0], by = b[1], bz = b[2]

	    out[0] = ay * bz - az * by
	    out[1] = az * bx - ax * bz
	    out[2] = ax * by - ay * bx
	    return out
	}

/***/ }),
/* 121 */
/***/ (function(module, exports) {

	module.exports = rotateX;

	/**
	 * Rotate a 3D vector around the x-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateX(out, a, b, c){
	    var by = b[1]
	    var bz = b[2]

	    // Translate point to the origin
	    var py = a[1] - by
	    var pz = a[2] - bz

	    var sc = Math.sin(c)
	    var cc = Math.cos(c)

	    // perform rotation and translate to correct position
	    out[0] = a[0]
	    out[1] = by + py * cc - pz * sc
	    out[2] = bz + py * sc + pz * cc

	    return out
	}


/***/ }),
/* 122 */
/***/ (function(module, exports) {

	module.exports = rotateY;

	/**
	 * Rotate a 3D vector around the y-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateY(out, a, b, c){
	    var bx = b[0]
	    var bz = b[2]

	    // translate point to the origin
	    var px = a[0] - bx
	    var pz = a[2] - bz
	    
	    var sc = Math.sin(c)
	    var cc = Math.cos(c)
	  
	    // perform rotation and translate to correct position
	    out[0] = bx + pz * sc + px * cc
	    out[1] = a[1]
	    out[2] = bz + pz * cc - px * sc
	  
	    return out
	}


/***/ }),
/* 123 */
/***/ (function(module, exports) {

	module.exports = rotateZ;

	/**
	 * Rotate a 3D vector around the z-axis
	 * @param {vec3} out The receiving vec3
	 * @param {vec3} a The vec3 point to rotate
	 * @param {vec3} b The origin of the rotation
	 * @param {Number} c The angle of rotation
	 * @returns {vec3} out
	 */
	function rotateZ(out, a, b, c){
	    var bx = b[0]
	    var by = b[1]

	    //Translate point to the origin
	    var px = a[0] - bx
	    var py = a[1] - by
	  
	    var sc = Math.sin(c)
	    var cc = Math.cos(c)

	    // perform rotation and translate to correct position
	    out[0] = bx + px * cc - py * sc
	    out[1] = by + px * sc + py * cc
	    out[2] = a[2]
	  
	    return out
	}


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _vector = _interopRequireDefault(__webpack_require__(111));

	var _common = __webpack_require__(113);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Vector4 =
	/*#__PURE__*/
	function (_Vector) {
	  _inherits(Vector4, _Vector);

	  // Creates a new, empty vec4
	  function Vector4() {
	    var _this;

	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    _classCallCheck(this, Vector4);

	    _this = _possibleConstructorReturn(this, (Vector4.__proto__ || Object.getPrototypeOf(Vector4)).call(this));

	    if (Array.isArray(x) && arguments.length === 1) {
	      _this.copy(x);
	    } else {
	      _this.set(x, y, z, w);
	    }

	    return _this;
	  } // Getters/setters

	  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */


	  _createClass(Vector4, [{
	    key: "applyMatrix4",

	    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */
	    // three.js compatibility
	    value: function applyMatrix4(m) {
	      m.transformVector(this, this);
	      return this;
	    }
	  }, {
	    key: "ELEMENTS",
	    get: function get() {
	      return 4;
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "z",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "w",
	    get: function get() {
	      return this[3];
	    },
	    set: function set(value) {
	      return this[3] = (0, _common.checkNumber)(value);
	    }
	  }]);

	  return Vector4;
	}(_vector.default);

	exports.default = Vector4;
	//# sourceMappingURL=vector4.js.map

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.validateMatrix4 = validateMatrix4;
	exports.default = void 0;

	var _mathArray = _interopRequireDefault(__webpack_require__(112));

	var _common = __webpack_require__(113);

	var _vector = _interopRequireDefault(__webpack_require__(110));

	var _vector2 = _interopRequireDefault(__webpack_require__(115));

	var _vector3 = _interopRequireDefault(__webpack_require__(124));

	var _determinant = _interopRequireDefault(__webpack_require__(126));

	var _fromQuat = _interopRequireDefault(__webpack_require__(127));

	var _frustum = _interopRequireDefault(__webpack_require__(128));

	var _lookAt = _interopRequireDefault(__webpack_require__(129));

	var _ortho = _interopRequireDefault(__webpack_require__(131));

	var _perspective = _interopRequireDefault(__webpack_require__(132));

	var _transpose = _interopRequireDefault(__webpack_require__(133));

	var _invert = _interopRequireDefault(__webpack_require__(134));

	var _multiply = _interopRequireDefault(__webpack_require__(135));

	var _rotate = _interopRequireDefault(__webpack_require__(136));

	var _scale = _interopRequireDefault(__webpack_require__(137));

	var _translate = _interopRequireDefault(__webpack_require__(138));

	var _transformMat = _interopRequireDefault(__webpack_require__(139));

	var _transformMat2 = _interopRequireDefault(__webpack_require__(140));

	var _transformMat3 = _interopRequireDefault(__webpack_require__(141));

	var _rotateX = _interopRequireDefault(__webpack_require__(142));

	var _rotateY = _interopRequireDefault(__webpack_require__(143));

	var _rotateZ = _interopRequireDefault(__webpack_require__(144));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

	function validateMatrix4(m) {
	  return m.length === 16 && Number.isFinite(m[0]) && Number.isFinite(m[1]) && Number.isFinite(m[2]) && Number.isFinite(m[3]) && Number.isFinite(m[4]) && Number.isFinite(m[5]) && Number.isFinite(m[6]) && Number.isFinite(m[7]) && Number.isFinite(m[8]) && Number.isFinite(m[9]) && Number.isFinite(m[10]) && Number.isFinite(m[11]) && Number.isFinite(m[12]) && Number.isFinite(m[13]) && Number.isFinite(m[14]) && Number.isFinite(m[15]);
	}

	function validateVector(v, length) {
	  if (v.length !== length) {
	    return false;
	  }

	  return v.every(Number.isFinite);
	}

	var Matrix4 =
	/*#__PURE__*/
	function (_MathArray) {
	  _inherits(Matrix4, _MathArray);

	  function Matrix4() {
	    var _this;

	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }

	    _classCallCheck(this, Matrix4);

	    _this = _possibleConstructorReturn(this, (Matrix4.__proto__ || Object.getPrototypeOf(Matrix4)).call(this));

	    if (Array.isArray(args[0]) && arguments.length === 1) {
	      _this.copy(args[0]);
	    } else {
	      _this.identity();
	    }

	    return _this;
	  }

	  _createClass(Matrix4, [{
	    key: "setRowMajor",

	    /* eslint-disable max-params */
	    // accepts row major order, stores as column major
	    value: function setRowMajor() {
	      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	      var m01 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var m02 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      var m03 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	      var m10 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
	      var m12 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
	      var m13 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
	      var m20 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
	      var m21 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
	      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
	      var m23 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
	      var m30 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
	      var m31 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
	      var m32 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
	      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
	      this[0] = m00;
	      this[1] = m10;
	      this[2] = m20;
	      this[3] = m30;
	      this[4] = m01;
	      this[5] = m11;
	      this[6] = m21;
	      this[7] = m31;
	      this[8] = m02;
	      this[9] = m12;
	      this[10] = m22;
	      this[11] = m32;
	      this[12] = m03;
	      this[13] = m13;
	      this[14] = m23;
	      this[15] = m33;
	      return this.check();
	    } // accepts column major order, stores in column major order

	  }, {
	    key: "setColumnMajor",
	    value: function setColumnMajor() {
	      var m00 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
	      var m10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var m20 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      var m30 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	      var m01 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
	      var m11 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
	      var m21 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
	      var m31 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
	      var m02 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
	      var m12 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
	      var m22 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
	      var m32 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
	      var m03 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
	      var m13 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
	      var m23 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 0;
	      var m33 = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 1;
	      this[0] = m00;
	      this[1] = m10;
	      this[2] = m20;
	      this[3] = m30;
	      this[4] = m01;
	      this[5] = m11;
	      this[6] = m21;
	      this[7] = m31;
	      this[8] = m02;
	      this[9] = m12;
	      this[10] = m22;
	      this[11] = m32;
	      this[12] = m03;
	      this[13] = m13;
	      this[14] = m23;
	      this[15] = m33;
	      return this.check();
	    }
	    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

	  }, {
	    key: "copy",
	    value: function copy(array) {
	      return this.setColumnMajor.apply(this, _toConsumableArray(array));
	    } // Sets exact values (column major)

	  }, {
	    key: "set",
	    value: function set() {
	      return this.setColumnMajor.apply(this, arguments);
	    } // By default assumes row major indices

	  }, {
	    key: "getElement",
	    value: function getElement(i, j) {
	      var columnMajor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
	      return columnMajor ? this[i][j] : this[j][i];
	    } // By default assumes row major indices

	  }, {
	    key: "setElement",
	    value: function setElement(i, j, value) {
	      var columnMajor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

	      if (columnMajor) {
	        this[j][i] = (0, _common.checkNumber)(value);
	      } else {
	        this[j][i] = (0, _common.checkNumber)(value);
	      }

	      return this;
	    }
	    /* eslint-enable max-params */
	    // toString() {
	    //   if (config.printRowMajor) {
	    //     mat4_str(this);
	    //   } else {
	    //     mat4_str(this);
	    //   }
	    // }
	    // Accessors

	  }, {
	    key: "determinant",
	    value: function determinant() {
	      return (0, _determinant.default)(this);
	    } // Constructors

	  }, {
	    key: "identity",
	    value: function identity() {
	      return this.copy(IDENTITY);
	    } // Calculates a 4x4 matrix from the given quaternion
	    // q quat  Quaternion to create matrix from

	  }, {
	    key: "fromQuaternion",
	    value: function fromQuaternion(q) {
	      (0, _fromQuat.default)(this, q);
	      return this.check();
	    } // Generates a frustum matrix with the given bounds
	    // left  Number  Left bound of the frustum
	    // right Number  Right bound of the frustum
	    // bottom  Number  Bottom bound of the frustum
	    // top Number  Top bound of the frustum
	    // near  Number  Near bound of the frustum
	    // far Number  Far bound of the frustum

	  }, {
	    key: "frustum",
	    value: function frustum(_ref) {
	      var left = _ref.left,
	          right = _ref.right,
	          bottom = _ref.bottom,
	          top = _ref.top,
	          near = _ref.near,
	          far = _ref.far;
	      (0, _frustum.default)(this, left, right, bottom, top, near, far);
	      return this.check();
	    } // Generates a look-at matrix with the given eye position, focal point,
	    // and up axis
	    // eye vec3  Position of the viewer
	    // center  vec3  Point the viewer is looking at
	    // up  vec3  vec3 pointing up

	  }, {
	    key: "lookAt",
	    value: function lookAt(_ref2) {
	      var eye = _ref2.eye,
	          _ref2$center = _ref2.center,
	          center = _ref2$center === void 0 ? [0, 0, 0] : _ref2$center,
	          _ref2$up = _ref2.up,
	          up = _ref2$up === void 0 ? [0, 1, 0] : _ref2$up;
	      (0, _lookAt.default)(this, eye, center, up);
	      return this.check();
	    } // Generates a orthogonal projection matrix with the given bounds
	    // from "traditional" view space parameters
	    // left  number  Left bound of the frustum
	    // right number  Right bound of the frustum
	    // bottom  number  Bottom bound of the frustum
	    // top number  Top bound of the frustum
	    // near  number  Near bound of the frustum
	    // far number  Far bound of the frustum

	  }, {
	    key: "ortho",
	    value: function ortho(_ref3) {
	      var left = _ref3.left,
	          right = _ref3.right,
	          bottom = _ref3.bottom,
	          top = _ref3.top,
	          _ref3$near = _ref3.near,
	          near = _ref3$near === void 0 ? 0.1 : _ref3$near,
	          _ref3$far = _ref3.far,
	          far = _ref3$far === void 0 ? 500 : _ref3$far;
	      (0, _ortho.default)(this, left, right, bottom, top, near, far);
	      return this.check();
	    } // Generates an orthogonal projection matrix with the same parameters
	    // as a perspective matrix (plus focalDistance)
	    // fovy  number  Vertical field of view in radians
	    // aspect  number  Aspect ratio. typically viewport width/height
	    // focalDistance distance in the view frustum used for extent calculations
	    // near  number  Near bound of the frustum
	    // far number  Far bound of the frustum

	  }, {
	    key: "orthographic",
	    value: function orthographic(_ref4) {
	      var _ref4$fovy = _ref4.fovy,
	          fovy = _ref4$fovy === void 0 ? 45 * Math.PI / 180 : _ref4$fovy,
	          _ref4$aspect = _ref4.aspect,
	          aspect = _ref4$aspect === void 0 ? 1 : _ref4$aspect,
	          _ref4$focalDistance = _ref4.focalDistance,
	          focalDistance = _ref4$focalDistance === void 0 ? 1 : _ref4$focalDistance,
	          _ref4$near = _ref4.near,
	          near = _ref4$near === void 0 ? 0.1 : _ref4$near,
	          _ref4$far = _ref4.far,
	          far = _ref4$far === void 0 ? 500 : _ref4$far;

	      if (fovy > Math.PI * 2) {
	        throw Error('radians');
	      }

	      var halfY = fovy / 2;
	      var top = focalDistance * Math.tan(halfY); // focus_plane is the distance from the camera

	      var right = top * aspect;
	      return new Matrix4().ortho({
	        left: -right,
	        right: right,
	        bottom: -top,
	        top: top,
	        near: near,
	        far: far
	      });
	    } // Generates a perspective projection matrix with the given bounds
	    // fovy  number  Vertical field of view in radians
	    // aspect  number  Aspect ratio. typically viewport width/height
	    // near  number  Near bound of the frustum
	    // far number  Far bound of the frustum

	  }, {
	    key: "perspective",
	    value: function perspective() {
	      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          fovy = _ref5.fovy,
	          _ref5$fov = _ref5.fov,
	          fov = _ref5$fov === void 0 ? 45 * Math.PI / 180 : _ref5$fov,
	          _ref5$aspect = _ref5.aspect,
	          aspect = _ref5$aspect === void 0 ? 1 : _ref5$aspect,
	          _ref5$near = _ref5.near,
	          near = _ref5$near === void 0 ? 0.1 : _ref5$near,
	          _ref5$far = _ref5.far,
	          far = _ref5$far === void 0 ? 500 : _ref5$far;

	      fovy = fovy || fov;

	      if (fovy > Math.PI * 2) {
	        throw Error('radians');
	      }

	      (0, _perspective.default)(this, fovy, aspect, near, far);
	      return this.check();
	    } // Modifiers

	  }, {
	    key: "transpose",
	    value: function transpose() {
	      (0, _transpose.default)(this, this);
	      return this.check();
	    }
	  }, {
	    key: "invert",
	    value: function invert() {
	      (0, _invert.default)(this, this);
	      return this.check();
	    } // Operations

	  }, {
	    key: "multiplyLeft",
	    value: function multiplyLeft(a) {
	      (0, _multiply.default)(this, a, this);
	      return this.check();
	    }
	  }, {
	    key: "multiplyRight",
	    value: function multiplyRight(a) {
	      (0, _multiply.default)(this, this, a);
	      return this.check();
	    } // Rotates a matrix by the given angle around the X axis

	  }, {
	    key: "rotateX",
	    value: function rotateX(radians) {
	      (0, _rotateX.default)(this, this, radians); // mat4_rotate(this, this, radians, [1, 0, 0]);

	      return this.check();
	    } // Rotates a matrix by the given angle around the Y axis.

	  }, {
	    key: "rotateY",
	    value: function rotateY(radians) {
	      (0, _rotateY.default)(this, this, radians); // mat4_rotate(this, this, radians, [0, 1, 0]);

	      return this.check();
	    } // Rotates a matrix by the given angle around the Z axis.

	  }, {
	    key: "rotateZ",
	    value: function rotateZ(radians) {
	      (0, _rotateZ.default)(this, this, radians); // mat4_rotate(this, this, radians, [0, 0, 1]);

	      return this.check();
	    }
	  }, {
	    key: "rotateXYZ",
	    value: function rotateXYZ(_ref6) {
	      var _ref7 = _slicedToArray(_ref6, 3),
	          rx = _ref7[0],
	          ry = _ref7[1],
	          rz = _ref7[2];

	      return this.rotateX(rx).rotateY(ry).rotateZ(rz);
	    }
	  }, {
	    key: "rotateAxis",
	    value: function rotateAxis(radians, axis) {
	      (0, _rotate.default)(this, this, radians, axis);
	      return this.check();
	    }
	  }, {
	    key: "scale",
	    value: function scale(vec) {
	      (0, _scale.default)(this, this, vec);
	      return this.check();
	    }
	  }, {
	    key: "translate",
	    value: function translate(vec) {
	      (0, _translate.default)(this, this, vec);
	      return this.check();
	    }
	  }, {
	    key: "transformVector2",
	    value: function transformVector2(vector, out) {
	      // out = out || [0, 0];
	      out = out || new _vector.default();
	      (0, _transformMat.default)(out, vector, this);
	      validateVector(out, 2);
	      return out;
	    }
	  }, {
	    key: "transformVector3",
	    value: function transformVector3(vector, out) {
	      // out = out || [0, 0, 0];
	      out = out || new _vector2.default();
	      (0, _transformMat2.default)(out, vector, this);
	      validateVector(out, 3);
	      return out;
	    }
	  }, {
	    key: "transformVector4",
	    value: function transformVector4(vector, out) {
	      // out = out || [0, 0, 0, 0];
	      out = out || new _vector3.default();
	      (0, _transformMat3.default)(out, vector, this);
	      validateVector(out, 4);
	      return out.check();
	    } // Transforms any 2, 3 or 4 element vector
	    // returns a newly minted Vector2, Vector3 or Vector4

	  }, {
	    key: "transformVector",
	    value: function transformVector(vector, out) {
	      switch (vector.length) {
	        case 2:
	          return this.transformVector2(vector, out);

	        case 3:
	          return this.transformVector3(vector, out);

	        case 4:
	          return this.transformVector4(vector, out);

	        default:
	          throw new Error('Illegal vector');
	      }
	    }
	  }, {
	    key: "transformDirection",
	    value: function transformDirection(vector, out) {
	      return this._transformVector(vector, out, 0);
	    }
	  }, {
	    key: "transformPoint",
	    value: function transformPoint(vector, out) {
	      return this._transformVector(vector, out, 1);
	    }
	  }, {
	    key: "_transformVector",
	    value: function _transformVector(vector, out, w) {
	      switch (vector.length) {
	        case 2:
	          out = out || new _vector.default(); // out = out || [0, 0];

	          (0, _transformMat3.default)(out, [vector[0], vector[1], 0, w], this);
	          out.length = 2;
	          validateVector(out, 2);
	          break;

	        case 3:
	          out = out || new _vector2.default(); // out = out || [0, 0, 0];

	          (0, _transformMat3.default)(out, [vector[0], vector[1], vector[2], w], this);
	          out.length = 3;
	          validateVector(out, 3);
	          break;

	        case 4:
	          if (Boolean(w) !== Boolean(vector[3])) {
	            throw new Error('math.gl: Matrix4.transformPoint - invalid vector');
	          }

	          out = out || new _vector3.default(); // out = out || [0, 0, 0, 0];

	          (0, _transformMat3.default)(out, vector, this);
	          validateVector(out, 4);
	          break;

	        default:
	          throw new Error('Illegal vector');
	      }

	      return out;
	    } // three.js compatibility

	  }, {
	    key: "makeRotationX",
	    value: function makeRotationX(radians) {
	      return this.identity().rotateX(radians);
	    }
	  }, {
	    key: "makeTranslation",
	    value: function makeTranslation(x, y, z) {
	      return this.identity().translate([x, y, z]);
	    }
	  }, {
	    key: "ELEMENTS",
	    get: function get() {
	      return 16;
	    }
	  }]);

	  return Matrix4;
	}(_mathArray.default);

	exports.default = Matrix4;
	//# sourceMappingURL=matrix4.js.map

/***/ }),
/* 126 */
/***/ (function(module, exports) {

	module.exports = determinant;

	/**
	 * Calculates the determinant of a mat4
	 *
	 * @param {mat4} a the source matrix
	 * @returns {Number} determinant of a
	 */
	function determinant(a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32;

	    // Calculate the determinant
	    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
	};

/***/ }),
/* 127 */
/***/ (function(module, exports) {

	module.exports = fromQuat;

	/**
	 * Creates a matrix from a quaternion rotation.
	 *
	 * @param {mat4} out mat4 receiving operation result
	 * @param {quat4} q Rotation quaternion
	 * @returns {mat4} out
	 */
	function fromQuat(out, q) {
	    var x = q[0], y = q[1], z = q[2], w = q[3],
	        x2 = x + x,
	        y2 = y + y,
	        z2 = z + z,

	        xx = x * x2,
	        yx = y * x2,
	        yy = y * y2,
	        zx = z * x2,
	        zy = z * y2,
	        zz = z * z2,
	        wx = w * x2,
	        wy = w * y2,
	        wz = w * z2;

	    out[0] = 1 - yy - zz;
	    out[1] = yx + wz;
	    out[2] = zx - wy;
	    out[3] = 0;

	    out[4] = yx - wz;
	    out[5] = 1 - xx - zz;
	    out[6] = zy + wx;
	    out[7] = 0;

	    out[8] = zx + wy;
	    out[9] = zy - wx;
	    out[10] = 1 - xx - yy;
	    out[11] = 0;

	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;

	    return out;
	};

/***/ }),
/* 128 */
/***/ (function(module, exports) {

	module.exports = frustum;

	/**
	 * Generates a frustum matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {Number} left Left bound of the frustum
	 * @param {Number} right Right bound of the frustum
	 * @param {Number} bottom Bottom bound of the frustum
	 * @param {Number} top Top bound of the frustum
	 * @param {Number} near Near bound of the frustum
	 * @param {Number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function frustum(out, left, right, bottom, top, near, far) {
	    var rl = 1 / (right - left),
	        tb = 1 / (top - bottom),
	        nf = 1 / (near - far);
	    out[0] = (near * 2) * rl;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = (near * 2) * tb;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = (right + left) * rl;
	    out[9] = (top + bottom) * tb;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (far * near * 2) * nf;
	    out[15] = 0;
	    return out;
	};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	var identity = __webpack_require__(130);

	module.exports = lookAt;

	/**
	 * Generates a look-at matrix with the given eye position, focal point, and up axis
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {vec3} eye Position of the viewer
	 * @param {vec3} center Point the viewer is looking at
	 * @param {vec3} up vec3 pointing up
	 * @returns {mat4} out
	 */
	function lookAt(out, eye, center, up) {
	    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
	        eyex = eye[0],
	        eyey = eye[1],
	        eyez = eye[2],
	        upx = up[0],
	        upy = up[1],
	        upz = up[2],
	        centerx = center[0],
	        centery = center[1],
	        centerz = center[2];

	    if (Math.abs(eyex - centerx) < 0.000001 &&
	        Math.abs(eyey - centery) < 0.000001 &&
	        Math.abs(eyez - centerz) < 0.000001) {
	        return identity(out);
	    }

	    z0 = eyex - centerx;
	    z1 = eyey - centery;
	    z2 = eyez - centerz;

	    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
	    z0 *= len;
	    z1 *= len;
	    z2 *= len;

	    x0 = upy * z2 - upz * z1;
	    x1 = upz * z0 - upx * z2;
	    x2 = upx * z1 - upy * z0;
	    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
	    if (!len) {
	        x0 = 0;
	        x1 = 0;
	        x2 = 0;
	    } else {
	        len = 1 / len;
	        x0 *= len;
	        x1 *= len;
	        x2 *= len;
	    }

	    y0 = z1 * x2 - z2 * x1;
	    y1 = z2 * x0 - z0 * x2;
	    y2 = z0 * x1 - z1 * x0;

	    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
	    if (!len) {
	        y0 = 0;
	        y1 = 0;
	        y2 = 0;
	    } else {
	        len = 1 / len;
	        y0 *= len;
	        y1 *= len;
	        y2 *= len;
	    }

	    out[0] = x0;
	    out[1] = y0;
	    out[2] = z0;
	    out[3] = 0;
	    out[4] = x1;
	    out[5] = y1;
	    out[6] = z1;
	    out[7] = 0;
	    out[8] = x2;
	    out[9] = y2;
	    out[10] = z2;
	    out[11] = 0;
	    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
	    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
	    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
	    out[15] = 1;

	    return out;
	};

/***/ }),
/* 130 */
/***/ (function(module, exports) {

	module.exports = identity;

	/**
	 * Set a mat4 to the identity matrix
	 *
	 * @param {mat4} out the receiving matrix
	 * @returns {mat4} out
	 */
	function identity(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = 1;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 1;
	    out[11] = 0;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = 0;
	    out[15] = 1;
	    return out;
	};

/***/ }),
/* 131 */
/***/ (function(module, exports) {

	module.exports = ortho;

	/**
	 * Generates a orthogonal projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} left Left bound of the frustum
	 * @param {number} right Right bound of the frustum
	 * @param {number} bottom Bottom bound of the frustum
	 * @param {number} top Top bound of the frustum
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function ortho(out, left, right, bottom, top, near, far) {
	    var lr = 1 / (left - right),
	        bt = 1 / (bottom - top),
	        nf = 1 / (near - far);
	    out[0] = -2 * lr;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = -2 * bt;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = 2 * nf;
	    out[11] = 0;
	    out[12] = (left + right) * lr;
	    out[13] = (top + bottom) * bt;
	    out[14] = (far + near) * nf;
	    out[15] = 1;
	    return out;
	};

/***/ }),
/* 132 */
/***/ (function(module, exports) {

	module.exports = perspective;

	/**
	 * Generates a perspective projection matrix with the given bounds
	 *
	 * @param {mat4} out mat4 frustum matrix will be written into
	 * @param {number} fovy Vertical field of view in radians
	 * @param {number} aspect Aspect ratio. typically viewport width/height
	 * @param {number} near Near bound of the frustum
	 * @param {number} far Far bound of the frustum
	 * @returns {mat4} out
	 */
	function perspective(out, fovy, aspect, near, far) {
	    var f = 1.0 / Math.tan(fovy / 2),
	        nf = 1 / (near - far);
	    out[0] = f / aspect;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 0;
	    out[4] = 0;
	    out[5] = f;
	    out[6] = 0;
	    out[7] = 0;
	    out[8] = 0;
	    out[9] = 0;
	    out[10] = (far + near) * nf;
	    out[11] = -1;
	    out[12] = 0;
	    out[13] = 0;
	    out[14] = (2 * far * near) * nf;
	    out[15] = 0;
	    return out;
	};

/***/ }),
/* 133 */
/***/ (function(module, exports) {

	module.exports = transpose;

	/**
	 * Transpose the values of a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function transpose(out, a) {
	    // If we are transposing ourselves we can skip a few steps but have to cache some values
	    if (out === a) {
	        var a01 = a[1], a02 = a[2], a03 = a[3],
	            a12 = a[6], a13 = a[7],
	            a23 = a[11];

	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a01;
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a02;
	        out[9] = a12;
	        out[11] = a[14];
	        out[12] = a03;
	        out[13] = a13;
	        out[14] = a23;
	    } else {
	        out[0] = a[0];
	        out[1] = a[4];
	        out[2] = a[8];
	        out[3] = a[12];
	        out[4] = a[1];
	        out[5] = a[5];
	        out[6] = a[9];
	        out[7] = a[13];
	        out[8] = a[2];
	        out[9] = a[6];
	        out[10] = a[10];
	        out[11] = a[14];
	        out[12] = a[3];
	        out[13] = a[7];
	        out[14] = a[11];
	        out[15] = a[15];
	    }
	    
	    return out;
	};

/***/ }),
/* 134 */
/***/ (function(module, exports) {

	module.exports = invert;

	/**
	 * Inverts a mat4
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the source matrix
	 * @returns {mat4} out
	 */
	function invert(out, a) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

	        b00 = a00 * a11 - a01 * a10,
	        b01 = a00 * a12 - a02 * a10,
	        b02 = a00 * a13 - a03 * a10,
	        b03 = a01 * a12 - a02 * a11,
	        b04 = a01 * a13 - a03 * a11,
	        b05 = a02 * a13 - a03 * a12,
	        b06 = a20 * a31 - a21 * a30,
	        b07 = a20 * a32 - a22 * a30,
	        b08 = a20 * a33 - a23 * a30,
	        b09 = a21 * a32 - a22 * a31,
	        b10 = a21 * a33 - a23 * a31,
	        b11 = a22 * a33 - a23 * a32,

	        // Calculate the determinant
	        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

	    if (!det) { 
	        return null; 
	    }
	    det = 1.0 / det;

	    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
	    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
	    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
	    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
	    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
	    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
	    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
	    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
	    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
	    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
	    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
	    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
	    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
	    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
	    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
	    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

	    return out;
	};

/***/ }),
/* 135 */
/***/ (function(module, exports) {

	module.exports = multiply;

	/**
	 * Multiplies two mat4's
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the first operand
	 * @param {mat4} b the second operand
	 * @returns {mat4} out
	 */
	function multiply(out, a, b) {
	    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
	        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
	        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
	        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

	    // Cache only the current line of the second matrix
	    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
	    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
	    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
	    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

	    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
	    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
	    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
	    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
	    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
	    return out;
	};

/***/ }),
/* 136 */
/***/ (function(module, exports) {

	module.exports = rotate;

	/**
	 * Rotates a mat4 by the given angle
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @param {vec3} axis the axis to rotate around
	 * @returns {mat4} out
	 */
	function rotate(out, a, rad, axis) {
	    var x = axis[0], y = axis[1], z = axis[2],
	        len = Math.sqrt(x * x + y * y + z * z),
	        s, c, t,
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23,
	        b00, b01, b02,
	        b10, b11, b12,
	        b20, b21, b22;

	    if (Math.abs(len) < 0.000001) { return null; }
	    
	    len = 1 / len;
	    x *= len;
	    y *= len;
	    z *= len;

	    s = Math.sin(rad);
	    c = Math.cos(rad);
	    t = 1 - c;

	    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	    // Construct the elements of the rotation matrix
	    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
	    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
	    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

	    // Perform rotation-specific matrix multiplication
	    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
	    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
	    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
	    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
	    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
	    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
	    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
	    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
	    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
	    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
	    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
	    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }
	    return out;
	};

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	module.exports = scale;

	/**
	 * Scales the mat4 by the dimensions in the given vec3
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to scale
	 * @param {vec3} v the vec3 to scale the matrix by
	 * @returns {mat4} out
	 **/
	function scale(out, a, v) {
	    var x = v[0], y = v[1], z = v[2];

	    out[0] = a[0] * x;
	    out[1] = a[1] * x;
	    out[2] = a[2] * x;
	    out[3] = a[3] * x;
	    out[4] = a[4] * y;
	    out[5] = a[5] * y;
	    out[6] = a[6] * y;
	    out[7] = a[7] * y;
	    out[8] = a[8] * z;
	    out[9] = a[9] * z;
	    out[10] = a[10] * z;
	    out[11] = a[11] * z;
	    out[12] = a[12];
	    out[13] = a[13];
	    out[14] = a[14];
	    out[15] = a[15];
	    return out;
	};

/***/ }),
/* 138 */
/***/ (function(module, exports) {

	module.exports = translate;

	/**
	 * Translate a mat4 by the given vector
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to translate
	 * @param {vec3} v vector to translate by
	 * @returns {mat4} out
	 */
	function translate(out, a, v) {
	    var x = v[0], y = v[1], z = v[2],
	        a00, a01, a02, a03,
	        a10, a11, a12, a13,
	        a20, a21, a22, a23;

	    if (a === out) {
	        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
	        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
	        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
	        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
	    } else {
	        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
	        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
	        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

	        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
	        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
	        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

	        out[12] = a00 * x + a10 * y + a20 * z + a[12];
	        out[13] = a01 * x + a11 * y + a21 * z + a[13];
	        out[14] = a02 * x + a12 * y + a22 * z + a[14];
	        out[15] = a03 * x + a13 * y + a23 * z + a[15];
	    }

	    return out;
	};

/***/ }),
/* 139 */
/***/ (function(module, exports) {

	module.exports = transformMat4

	/**
	 * Transforms the vec2 with a mat4
	 * 3rd vector component is implicitly '0'
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec2} out
	 */
	function transformMat4(out, a, m) {
	    var x = a[0], 
	        y = a[1]
	    out[0] = m[0] * x + m[4] * y + m[12]
	    out[1] = m[1] * x + m[5] * y + m[13]
	    return out
	}

/***/ }),
/* 140 */
/***/ (function(module, exports) {

	module.exports = transformMat4;

	/**
	 * Transforms the vec3 with a mat4.
	 * 4th vector component is implicitly '1'
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec3} out
	 */
	function transformMat4(out, a, m) {
	    var x = a[0], y = a[1], z = a[2],
	        w = m[3] * x + m[7] * y + m[11] * z + m[15]
	    w = w || 1.0
	    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
	    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
	    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
	    return out
	}

/***/ }),
/* 141 */
/***/ (function(module, exports) {

	module.exports = transformMat4

	/**
	 * Transforms the vec4 with a mat4.
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to transform
	 * @param {mat4} m matrix to transform with
	 * @returns {vec4} out
	 */
	function transformMat4 (out, a, m) {
	  var x = a[0], y = a[1], z = a[2], w = a[3]
	  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w
	  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w
	  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w
	  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w
	  return out
	}


/***/ }),
/* 142 */
/***/ (function(module, exports) {

	module.exports = rotateX;

	/**
	 * Rotates a matrix by the given angle around the X axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateX(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[0]  = a[0];
	        out[1]  = a[1];
	        out[2]  = a[2];
	        out[3]  = a[3];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[4] = a10 * c + a20 * s;
	    out[5] = a11 * c + a21 * s;
	    out[6] = a12 * c + a22 * s;
	    out[7] = a13 * c + a23 * s;
	    out[8] = a20 * c - a10 * s;
	    out[9] = a21 * c - a11 * s;
	    out[10] = a22 * c - a12 * s;
	    out[11] = a23 * c - a13 * s;
	    return out;
	};

/***/ }),
/* 143 */
/***/ (function(module, exports) {

	module.exports = rotateY;

	/**
	 * Rotates a matrix by the given angle around the Y axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateY(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a20 = a[8],
	        a21 = a[9],
	        a22 = a[10],
	        a23 = a[11];

	    if (a !== out) { // If the source and destination differ, copy the unchanged rows
	        out[4]  = a[4];
	        out[5]  = a[5];
	        out[6]  = a[6];
	        out[7]  = a[7];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c - a20 * s;
	    out[1] = a01 * c - a21 * s;
	    out[2] = a02 * c - a22 * s;
	    out[3] = a03 * c - a23 * s;
	    out[8] = a00 * s + a20 * c;
	    out[9] = a01 * s + a21 * c;
	    out[10] = a02 * s + a22 * c;
	    out[11] = a03 * s + a23 * c;
	    return out;
	};

/***/ }),
/* 144 */
/***/ (function(module, exports) {

	module.exports = rotateZ;

	/**
	 * Rotates a matrix by the given angle around the Z axis
	 *
	 * @param {mat4} out the receiving matrix
	 * @param {mat4} a the matrix to rotate
	 * @param {Number} rad the angle to rotate the matrix by
	 * @returns {mat4} out
	 */
	function rotateZ(out, a, rad) {
	    var s = Math.sin(rad),
	        c = Math.cos(rad),
	        a00 = a[0],
	        a01 = a[1],
	        a02 = a[2],
	        a03 = a[3],
	        a10 = a[4],
	        a11 = a[5],
	        a12 = a[6],
	        a13 = a[7];

	    if (a !== out) { // If the source and destination differ, copy the unchanged last row
	        out[8]  = a[8];
	        out[9]  = a[9];
	        out[10] = a[10];
	        out[11] = a[11];
	        out[12] = a[12];
	        out[13] = a[13];
	        out[14] = a[14];
	        out[15] = a[15];
	    }

	    // Perform axis-specific matrix multiplication
	    out[0] = a00 * c + a10 * s;
	    out[1] = a01 * c + a11 * s;
	    out[2] = a02 * c + a12 * s;
	    out[3] = a03 * c + a13 * s;
	    out[4] = a10 * c - a00 * s;
	    out[5] = a11 * c - a01 * s;
	    out[6] = a12 * c - a02 * s;
	    out[7] = a13 * c - a03 * s;
	    return out;
	};

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.validateQuaternion = validateQuaternion;
	exports.default = void 0;

	var _mathArray = _interopRequireDefault(__webpack_require__(112));

	var _common = __webpack_require__(113);

	var _fromMat = _interopRequireDefault(__webpack_require__(146));

	var _identity = _interopRequireDefault(__webpack_require__(147));

	var _length = _interopRequireDefault(__webpack_require__(148));

	var _squaredLength = _interopRequireDefault(__webpack_require__(150));

	var _dot = _interopRequireDefault(__webpack_require__(152));

	var _rotationTo = _interopRequireDefault(__webpack_require__(154));

	var _add = _interopRequireDefault(__webpack_require__(159));

	var _calculateW = _interopRequireDefault(__webpack_require__(161));

	var _conjugate = _interopRequireDefault(__webpack_require__(162));

	var _invert = _interopRequireDefault(__webpack_require__(163));

	var _lerp = _interopRequireDefault(__webpack_require__(164));

	var _multiply = _interopRequireDefault(__webpack_require__(166));

	var _normalize = _interopRequireDefault(__webpack_require__(156));

	var _rotateX = _interopRequireDefault(__webpack_require__(167));

	var _rotateY = _interopRequireDefault(__webpack_require__(168));

	var _rotateZ = _interopRequireDefault(__webpack_require__(169));

	var _scale = _interopRequireDefault(__webpack_require__(170));

	var _set = _interopRequireDefault(__webpack_require__(172));

	var _setAxisAngle = _interopRequireDefault(__webpack_require__(158));

	var _slerp = _interopRequireDefault(__webpack_require__(174));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var IDENTITY_QUATERNION = [0, 0, 0, 1];

	function validateQuaternion(q) {
	  return q.length === 4 && Number.isFinite(q[0]) && Number.isFinite(q[1]) && Number.isFinite(q[2]) && Number.isFinite(q[3]);
	}

	var Quaternion =
	/*#__PURE__*/
	function (_MathArray) {
	  _inherits(Quaternion, _MathArray);

	  // Creates a new identity quat
	  function Quaternion() {
	    var _this;

	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

	    _classCallCheck(this, Quaternion);

	    _this = _possibleConstructorReturn(this, (Quaternion.__proto__ || Object.getPrototypeOf(Quaternion)).call(this));

	    if (Array.isArray(x) && arguments.length === 1) {
	      _this.copy(x);
	    } else {
	      _this.set(x, y, z, w);
	    }

	    return _this;
	  } // Creates a quaternion from the given 3x3 rotation matrix.
	  // NOTE: The resultant quaternion is not normalized, so you should
	  // be sure to renormalize the quaternion yourself where necessary.


	  _createClass(Quaternion, [{
	    key: "fromMatrix3",
	    value: function fromMatrix3(m) {
	      (0, _fromMat.default)(this, m);
	      return this.check();
	    } // Creates a new quat initialized with the given values

	  }, {
	    key: "fromValues",
	    value: function fromValues(x, y, z, w) {
	      return this.set(x, y, z, w);
	    } // Set a quat to the identity quaternion

	  }, {
	    key: "identity",
	    value: function identity() {
	      (0, _identity.default)(this);
	      return this.check();
	    } // Getters/setters

	    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */

	  }, {
	    key: "length",

	    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */
	    // Calculates the length of a quat
	    value: function length() {
	      return (0, _length.default)(this);
	    } // Calculates the squared length of a quat

	  }, {
	    key: "squaredLength",
	    value: function squaredLength(a) {
	      return (0, _squaredLength.default)(this);
	    } // Calculates the dot product of two quat's
	    // @return {Number}

	  }, {
	    key: "dot",
	    value: function dot(a, b) {
	      if (b !== undefined) {
	        throw new Error('Quaternion.dot only takes one argument');
	      }

	      return (0, _dot.default)(this, a);
	    } // Gets the rotation axis and angle for a given quaternion.
	    // If a quaternion is created with setAxisAngle, this method will
	    // return the same values as providied in the original parameter
	    // list OR functionally equivalent values.
	    // Example: The quaternion formed by axis [0, 0, 1] and angle -90
	    // is the same as the quaternion formed by [0, 0, 1] and 270.
	    // This method favors the latter.
	    // @return {{[x,y,z], Number}}
	    // getAxisAngle() {
	    //   const axis = [];
	    //   const angle = quat_getAxisAngle(axis, this);
	    //   return {axis, angle};
	    // }
	    // MODIFIERS
	    // Sets a quaternion to represent the shortest rotation from one vector
	    // to another. Both vectors are assumed to be unit length.

	  }, {
	    key: "rotationTo",
	    value: function rotationTo(vectorA, vectorB) {
	      (0, _rotationTo.default)(this, vectorA, vectorB);
	      return this.check();
	    } // Sets the specified quaternion with values corresponding to the given axes.
	    // Each axis is a vec3 and is expected to be unit length and perpendicular
	    // to all other specified axes.
	    // setAxes() {
	    //   Number
	    // }
	    // Performs a spherical linear interpolation with two control points
	    // sqlerp() {
	    //   Number;
	    // }
	    // Adds two quat's

	  }, {
	    key: "add",
	    value: function add(a, b) {
	      if (b !== undefined) {
	        throw new Error('Quaternion.add only takes one argument');
	      }

	      (0, _add.default)(this, a);
	      return this.check();
	    } // Calculates the W component of a quat from the X, Y, and Z components.
	    // Any existing W component will be ignored.

	  }, {
	    key: "calculateW",
	    value: function calculateW() {
	      (0, _calculateW.default)(this, this);
	      return this.check();
	    } // Calculates the conjugate of a quat If the quaternion is normalized,
	    // this function is faster than quat_inverse and produces the same result.

	  }, {
	    key: "conjugate",
	    value: function conjugate() {
	      (0, _conjugate.default)(this, this);
	      return this.check();
	    } // Calculates the inverse of a quat

	  }, {
	    key: "invert",
	    value: function invert() {
	      (0, _invert.default)(this, this);
	      return this.check();
	    } // Performs a linear interpolation between two quat's

	  }, {
	    key: "lerp",
	    value: function lerp(a, b, t) {
	      (0, _lerp.default)(this, a, b, t);
	      return this.check();
	    } // Multiplies two quat's

	  }, {
	    key: "multiply",
	    value: function multiply(a, b) {
	      if (b !== undefined) {
	        throw new Error('Quaternion.multiply only takes one argument');
	      }

	      (0, _multiply.default)(this, this, b);
	      return this.check();
	    } // Normalize a quat

	  }, {
	    key: "normalize",
	    value: function normalize() {
	      (0, _normalize.default)(this, this);
	      return this.check();
	    } // Rotates a quaternion by the given angle about the X axis

	  }, {
	    key: "rotateX",
	    value: function rotateX(rad) {
	      (0, _rotateX.default)(this, this, rad);
	      return this.check();
	    } // Rotates a quaternion by the given angle about the Y axis

	  }, {
	    key: "rotateY",
	    value: function rotateY(rad) {
	      (0, _rotateY.default)(this, this, rad);
	      return this.check();
	    } // Rotates a quaternion by the given angle about the Z axis

	  }, {
	    key: "rotateZ",
	    value: function rotateZ(rad) {
	      (0, _rotateZ.default)(this, this, rad);
	      return this.check();
	    } // Scales a quat by a scalar number

	  }, {
	    key: "scale",
	    value: function scale(b) {
	      (0, _scale.default)(this, this, b);
	      return this.check();
	    } // Set the components of a quat to the given values

	  }, {
	    key: "set",
	    value: function set(i, j, k, l) {
	      (0, _set.default)(this, i, j, k, l);
	      return this.check();
	    } // Sets a quat from the given angle and rotation axis, then returns it.

	  }, {
	    key: "setAxisAngle",
	    value: function setAxisAngle(axis, rad) {
	      (0, _setAxisAngle.default)(this, axis, rad);
	      return this.check();
	    } // Performs a spherical linear interpolation between two quat

	  }, {
	    key: "slerp",
	    value: function slerp(_ref) {
	      var _ref$start = _ref.start,
	          start = _ref$start === void 0 ? IDENTITY_QUATERNION : _ref$start,
	          target = _ref.target,
	          ratio = _ref.ratio;
	      (0, _slerp.default)(this, start, target, ratio);
	      return this.check();
	    }
	  }, {
	    key: "ELEMENTS",
	    get: function get() {
	      return 4;
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "z",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "w",
	    get: function get() {
	      return this[3];
	    },
	    set: function set(value) {
	      return this[3] = (0, _common.checkNumber)(value);
	    }
	  }]);

	  return Quaternion;
	}(_mathArray.default);

	exports.default = Quaternion;
	//# sourceMappingURL=quaternion.js.map

/***/ }),
/* 146 */
/***/ (function(module, exports) {

	module.exports = fromMat3

	/**
	 * Creates a quaternion from the given 3x3 rotation matrix.
	 *
	 * NOTE: The resultant quaternion is not normalized, so you should be sure
	 * to renormalize the quaternion yourself where necessary.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {mat3} m rotation matrix
	 * @returns {quat} out
	 * @function
	 */
	function fromMat3 (out, m) {
	  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
	  // article "Quaternion Calculus and Fast Animation".
	  var fTrace = m[0] + m[4] + m[8]
	  var fRoot

	  if (fTrace > 0.0) {
	    // |w| > 1/2, may as well choose w > 1/2
	    fRoot = Math.sqrt(fTrace + 1.0)  // 2w
	    out[3] = 0.5 * fRoot
	    fRoot = 0.5 / fRoot  // 1/(4w)
	    out[0] = (m[5] - m[7]) * fRoot
	    out[1] = (m[6] - m[2]) * fRoot
	    out[2] = (m[1] - m[3]) * fRoot
	  } else {
	    // |w| <= 1/2
	    var i = 0
	    if (m[4] > m[0]) {
	      i = 1
	    }
	    if (m[8] > m[i * 3 + i]) {
	      i = 2
	    }
	    var j = (i + 1) % 3
	    var k = (i + 2) % 3

	    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0)
	    out[i] = 0.5 * fRoot
	    fRoot = 0.5 / fRoot
	    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot
	    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot
	    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot
	  }

	  return out
	}


/***/ }),
/* 147 */
/***/ (function(module, exports) {

	module.exports = identity

	/**
	 * Set a quat to the identity quaternion
	 *
	 * @param {quat} out the receiving quaternion
	 * @returns {quat} out
	 */
	function identity (out) {
	  out[0] = 0
	  out[1] = 0
	  out[2] = 0
	  out[3] = 1
	  return out
	}


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Calculates the length of a quat
	 *
	 * @param {quat} a vector to calculate length of
	 * @returns {Number} length of a
	 * @function
	 */
	module.exports = __webpack_require__(149)


/***/ }),
/* 149 */
/***/ (function(module, exports) {

	module.exports = length

	/**
	 * Calculates the length of a vec4
	 *
	 * @param {vec4} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length (a) {
	  var x = a[0],
	    y = a[1],
	    z = a[2],
	    w = a[3]
	  return Math.sqrt(x * x + y * y + z * z + w * w)
	}


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Calculates the squared length of a quat
	 *
	 * @param {quat} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 * @function
	 */
	module.exports = __webpack_require__(151)


/***/ }),
/* 151 */
/***/ (function(module, exports) {

	module.exports = squaredLength

	/**
	 * Calculates the squared length of a vec4
	 *
	 * @param {vec4} a vector to calculate squared length of
	 * @returns {Number} squared length of a
	 */
	function squaredLength (a) {
	  var x = a[0],
	    y = a[1],
	    z = a[2],
	    w = a[3]
	  return x * x + y * y + z * z + w * w
	}


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Calculates the dot product of two quat's
	 *
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {Number} dot product of a and b
	 * @function
	 */
	module.exports = __webpack_require__(153)


/***/ }),
/* 153 */
/***/ (function(module, exports) {

	module.exports = dot

	/**
	 * Calculates the dot product of two vec4's
	 *
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {Number} dot product of a and b
	 */
	function dot (a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
	}


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	var vecDot = __webpack_require__(119)
	var vecCross = __webpack_require__(120)
	var vecLength = __webpack_require__(155)
	var vecNormalize = __webpack_require__(118)

	var quatNormalize = __webpack_require__(156)
	var quatAxisAngle = __webpack_require__(158)

	module.exports = rotationTo

	var tmpvec3 = [0, 0, 0]
	var xUnitVec3 = [1, 0, 0]
	var yUnitVec3 = [0, 1, 0]

	/**
	 * Sets a quaternion to represent the shortest rotation from one
	 * vector to another.
	 *
	 * Both vectors are assumed to be unit length.
	 *
	 * @param {quat} out the receiving quaternion.
	 * @param {vec3} a the initial vector
	 * @param {vec3} b the destination vector
	 * @returns {quat} out
	 */
	function rotationTo (out, a, b) {
	  var dot = vecDot(a, b)
	  if (dot < -0.999999) {
	    vecCross(tmpvec3, xUnitVec3, a)
	    if (vecLength(tmpvec3) < 0.000001) {
	      vecCross(tmpvec3, yUnitVec3, a)
	    }
	    vecNormalize(tmpvec3, tmpvec3)
	    quatAxisAngle(out, tmpvec3, Math.PI)
	    return out
	  } else if (dot > 0.999999) {
	    out[0] = 0
	    out[1] = 0
	    out[2] = 0
	    out[3] = 1
	    return out
	  } else {
	    vecCross(tmpvec3, a, b)
	    out[0] = tmpvec3[0]
	    out[1] = tmpvec3[1]
	    out[2] = tmpvec3[2]
	    out[3] = 1 + dot
	    return quatNormalize(out, out)
	  }
	}


/***/ }),
/* 155 */
/***/ (function(module, exports) {

	module.exports = length;

	/**
	 * Calculates the length of a vec3
	 *
	 * @param {vec3} a vector to calculate length of
	 * @returns {Number} length of a
	 */
	function length(a) {
	    var x = a[0],
	        y = a[1],
	        z = a[2]
	    return Math.sqrt(x*x + y*y + z*z)
	}

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Normalize a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quaternion to normalize
	 * @returns {quat} out
	 * @function
	 */
	module.exports = __webpack_require__(157)


/***/ }),
/* 157 */
/***/ (function(module, exports) {

	module.exports = normalize

	/**
	 * Normalize a vec4
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a vector to normalize
	 * @returns {vec4} out
	 */
	function normalize (out, a) {
	  var x = a[0],
	    y = a[1],
	    z = a[2],
	    w = a[3]
	  var len = x * x + y * y + z * z + w * w
	  if (len > 0) {
	    len = 1 / Math.sqrt(len)
	    out[0] = x * len
	    out[1] = y * len
	    out[2] = z * len
	    out[3] = w * len
	  }
	  return out
	}


/***/ }),
/* 158 */
/***/ (function(module, exports) {

	module.exports = setAxisAngle

	/**
	 * Sets a quat from the given angle and rotation axis,
	 * then returns it.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {vec3} axis the axis around which to rotate
	 * @param {Number} rad the angle in radians
	 * @returns {quat} out
	 **/
	function setAxisAngle (out, axis, rad) {
	  rad = rad * 0.5
	  var s = Math.sin(rad)
	  out[0] = s * axis[0]
	  out[1] = s * axis[1]
	  out[2] = s * axis[2]
	  out[3] = Math.cos(rad)
	  return out
	}


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Adds two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 * @function
	 */
	module.exports = __webpack_require__(160)


/***/ }),
/* 160 */
/***/ (function(module, exports) {

	module.exports = add

	/**
	 * Adds two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function add (out, a, b) {
	  out[0] = a[0] + b[0]
	  out[1] = a[1] + b[1]
	  out[2] = a[2] + b[2]
	  out[3] = a[3] + b[3]
	  return out
	}


/***/ }),
/* 161 */
/***/ (function(module, exports) {

	module.exports = calculateW

	/**
	 * Calculates the W component of a quat from the X, Y, and Z components.
	 * Assumes that quaternion is 1 unit in length.
	 * Any existing W component will be ignored.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate W component of
	 * @returns {quat} out
	 */
	function calculateW (out, a) {
	  var x = a[0], y = a[1], z = a[2]

	  out[0] = x
	  out[1] = y
	  out[2] = z
	  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z))
	  return out
	}


/***/ }),
/* 162 */
/***/ (function(module, exports) {

	module.exports = conjugate

	/**
	 * Calculates the conjugate of a quat
	 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate conjugate of
	 * @returns {quat} out
	 */
	function conjugate (out, a) {
	  out[0] = -a[0]
	  out[1] = -a[1]
	  out[2] = -a[2]
	  out[3] = a[3]
	  return out
	}


/***/ }),
/* 163 */
/***/ (function(module, exports) {

	module.exports = invert

	/**
	 * Calculates the inverse of a quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a quat to calculate inverse of
	 * @returns {quat} out
	 */
	function invert (out, a) {
	  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
	    dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,
	    invDot = dot ? 1.0 / dot : 0

	  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

	  out[0] = -a0 * invDot
	  out[1] = -a1 * invDot
	  out[2] = -a2 * invDot
	  out[3] = a3 * invDot
	  return out
	}


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Performs a linear interpolation between two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 * @function
	 */
	module.exports = __webpack_require__(165)


/***/ }),
/* 165 */
/***/ (function(module, exports) {

	module.exports = lerp

	/**
	 * Performs a linear interpolation between two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec4} out
	 */
	function lerp (out, a, b, t) {
	  var ax = a[0],
	    ay = a[1],
	    az = a[2],
	    aw = a[3]
	  out[0] = ax + t * (b[0] - ax)
	  out[1] = ay + t * (b[1] - ay)
	  out[2] = az + t * (b[2] - az)
	  out[3] = aw + t * (b[3] - aw)
	  return out
	}


/***/ }),
/* 166 */
/***/ (function(module, exports) {

	module.exports = multiply

	/**
	 * Multiplies two quat's
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @returns {quat} out
	 */
	function multiply (out, a, b) {
	  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	    bx = b[0], by = b[1], bz = b[2], bw = b[3]

	  out[0] = ax * bw + aw * bx + ay * bz - az * by
	  out[1] = ay * bw + aw * by + az * bx - ax * bz
	  out[2] = az * bw + aw * bz + ax * by - ay * bx
	  out[3] = aw * bw - ax * bx - ay * by - az * bz
	  return out
	}


/***/ }),
/* 167 */
/***/ (function(module, exports) {

	module.exports = rotateX

	/**
	 * Rotates a quaternion by the given angle about the X axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	function rotateX (out, a, rad) {
	  rad *= 0.5

	  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	    bx = Math.sin(rad), bw = Math.cos(rad)

	  out[0] = ax * bw + aw * bx
	  out[1] = ay * bw + az * bx
	  out[2] = az * bw - ay * bx
	  out[3] = aw * bw - ax * bx
	  return out
	}


/***/ }),
/* 168 */
/***/ (function(module, exports) {

	module.exports = rotateY

	/**
	 * Rotates a quaternion by the given angle about the Y axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	function rotateY (out, a, rad) {
	  rad *= 0.5

	  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	    by = Math.sin(rad), bw = Math.cos(rad)

	  out[0] = ax * bw - az * by
	  out[1] = ay * bw + aw * by
	  out[2] = az * bw + ax * by
	  out[3] = aw * bw - ay * by
	  return out
	}


/***/ }),
/* 169 */
/***/ (function(module, exports) {

	module.exports = rotateZ

	/**
	 * Rotates a quaternion by the given angle about the Z axis
	 *
	 * @param {quat} out quat receiving operation result
	 * @param {quat} a quat to rotate
	 * @param {number} rad angle (in radians) to rotate
	 * @returns {quat} out
	 */
	function rotateZ (out, a, rad) {
	  rad *= 0.5

	  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	    bz = Math.sin(rad), bw = Math.cos(rad)

	  out[0] = ax * bw + ay * bz
	  out[1] = ay * bw - ax * bz
	  out[2] = az * bw + aw * bz
	  out[3] = aw * bw - az * bz
	  return out
	}


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Scales a quat by a scalar number
	 *
	 * @param {quat} out the receiving vector
	 * @param {quat} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {quat} out
	 * @function
	 */
	module.exports = __webpack_require__(171)


/***/ }),
/* 171 */
/***/ (function(module, exports) {

	module.exports = scale

	/**
	 * Scales a vec4 by a scalar number
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the vector to scale
	 * @param {Number} b amount to scale the vector by
	 * @returns {vec4} out
	 */
	function scale (out, a, b) {
	  out[0] = a[0] * b
	  out[1] = a[1] * b
	  out[2] = a[2] * b
	  out[3] = a[3] * b
	  return out
	}


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * Set the components of a quat to the given values
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {quat} out
	 * @function
	 */
	module.exports = __webpack_require__(173)


/***/ }),
/* 173 */
/***/ (function(module, exports) {

	module.exports = set

	/**
	 * Set the components of a vec4 to the given values
	 *
	 * @param {vec4} out the receiving vector
	 * @param {Number} x X component
	 * @param {Number} y Y component
	 * @param {Number} z Z component
	 * @param {Number} w W component
	 * @returns {vec4} out
	 */
	function set (out, x, y, z, w) {
	  out[0] = x
	  out[1] = y
	  out[2] = z
	  out[3] = w
	  return out
	}


/***/ }),
/* 174 */
/***/ (function(module, exports) {

	module.exports = slerp

	/**
	 * Performs a spherical linear interpolation between two quat
	 *
	 * @param {quat} out the receiving quaternion
	 * @param {quat} a the first operand
	 * @param {quat} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {quat} out
	 */
	function slerp (out, a, b, t) {
	  // benchmarks:
	  //    http://jsperf.com/quaternion-slerp-implementations

	  var ax = a[0], ay = a[1], az = a[2], aw = a[3],
	    bx = b[0], by = b[1], bz = b[2], bw = b[3]

	  var omega, cosom, sinom, scale0, scale1

	  // calc cosine
	  cosom = ax * bx + ay * by + az * bz + aw * bw
	  // adjust signs (if necessary)
	  if (cosom < 0.0) {
	    cosom = -cosom
	    bx = -bx
	    by = -by
	    bz = -bz
	    bw = -bw
	  }
	  // calculate coefficients
	  if ((1.0 - cosom) > 0.000001) {
	    // standard case (slerp)
	    omega = Math.acos(cosom)
	    sinom = Math.sin(omega)
	    scale0 = Math.sin((1.0 - t) * omega) / sinom
	    scale1 = Math.sin(t * omega) / sinom
	  } else {
	    // "from" and "to" quaternions are very close
	    //  ... so we can do a linear interpolation
	    scale0 = 1.0 - t
	    scale1 = t
	  }
	  // calculate final values
	  out[0] = scale0 * ax + scale1 * bx
	  out[1] = scale0 * ay + scale1 * by
	  out[2] = scale0 * az + scale1 * bz
	  out[3] = scale0 * aw + scale1 * bw

	  return out
	}


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _common = __webpack_require__(113);

	var _vector = _interopRequireDefault(__webpack_require__(115));

	var _length = _interopRequireDefault(__webpack_require__(155));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// import assert from 'assert';
	// TODO - import epsilon
	var EPSILON = 0.000001;
	var EARTH_RADIUS_METERS = 6.371e6; // Todo [rho, theta, phi] ?

	var SphericalCoordinates =
	/*#__PURE__*/
	function () {
	  /**
	   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	   * The poles (phi) are at the positive and negative y axis.
	   * The equator starts at positive z.
	   * @class
	   * @param {Number} phi=0 - rotation around X (latitude)
	   * @param {Number} theta=0 - rotation around Y (longitude)
	   * @param {Number} radius=1 - Distance from center
	   */

	  /* eslint-disable complexity */
	  function SphericalCoordinates() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        phi = _ref.phi,
	        theta = _ref.theta,
	        radius = _ref.radius,
	        bearing = _ref.bearing,
	        pitch = _ref.pitch,
	        altitude = _ref.altitude,
	        _ref$radiusScale = _ref.radiusScale,
	        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;

	    _classCallCheck(this, SphericalCoordinates);

	    if (arguments.length === 0) {
	      this.phi = 0;
	      this.theta = 0;
	      this.radius = 1;
	    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {
	      this.phi = phi || 0; // up / down towards top and bottom pole

	      this.theta = theta || 0; // around the equator of the sphere
	    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {
	      this.bearing = bearing || 0; // up / down towards top and bottom pole

	      this.pitch = pitch || 0; // around the equator of the sphere
	    }

	    this.radius = radius || 1; // radial distance from center

	    this.radiusScale = radiusScale || 1; // Used by lngLatZ

	    this.check();
	  }
	  /* eslint-enable complexity */


	  _createClass(SphericalCoordinates, [{
	    key: "toString",
	    value: function toString() {
	      return this.formatString(_common.config);
	    }
	  }, {
	    key: "formatString",
	    value: function formatString(_ref2) {
	      var printTypes = _ref2.printTypes,
	          printDegrees = _ref2.printDegrees;
	      var f = _common.formatValue;
	      return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
	    }
	  }, {
	    key: "equals",
	    value: function equals(other) {
	      return (0, _common.equals)(this.radius, other.radius) && (0, _common.equals)(this.theta, other.theta) && (0, _common.equals)(this.phi, other.phi);
	    }
	  }, {
	    key: "exactEquals",
	    value: function exactEquals(other) {
	      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
	    }
	    /* eslint-disable brace-style */
	    // Cartographic (bearing 0 north, pitch 0 look from above)

	  }, {
	    key: "set",

	    /* eslint-enable brace-style */
	    value: function set(radius, phi, theta) {
	      this.radius = radius;
	      this.phi = phi;
	      this.theta = theta;
	      return this.check();
	    }
	  }, {
	    key: "clone",
	    value: function clone() {
	      return new this.constructor().copy(this);
	    }
	  }, {
	    key: "copy",
	    value: function copy(other) {
	      this.radius = other.radius;
	      this.phi = other.phi;
	      this.theta = other.theta;
	      return this.check();
	    }
	  }, {
	    key: "fromLngLatZ",
	    value: function fromLngLatZ(_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 3),
	          lng = _ref4[0],
	          lat = _ref4[1],
	          z = _ref4[2];

	      this.radius = 1 + z / this.radiusScale;
	      this.phi = (0, _common.radians)(lat);
	      this.theta = (0, _common.radians)(lng);
	    }
	  }, {
	    key: "fromVector3",
	    value: function fromVector3(v) {
	      this.radius = (0, _length.default)(v);

	      if (this.radius === 0) {
	        this.theta = 0;
	        this.phi = 0;
	      } else {
	        this.theta = Math.atan2(v[0], v[1]); // equator angle around y-up axis

	        this.phi = Math.acos((0, _common.clamp)(v[2] / this.radius, -1, 1)); // polar angle
	      }

	      return this.check();
	    }
	  }, {
	    key: "toVector3",
	    value: function toVector3() {
	      return new _vector.default(0, 0, this.radius).rotateX({
	        radians: this.theta
	      }).rotateZ({
	        radians: this.phi
	      });
	    } // restrict phi to be betwee EPS and PI-EPS

	  }, {
	    key: "makeSafe",
	    value: function makeSafe() {
	      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
	    }
	  }, {
	    key: "check",
	    value: function check() {
	      // this.makeSafe();
	      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
	        throw new Error('SphericalCoordinates: some fields set to invalid numbers');
	      }

	      return this;
	    }
	  }, {
	    key: "bearing",
	    get: function get() {
	      return 180 - (0, _common.degrees)(this.phi);
	    },
	    set: function set(v) {
	      this.phi = Math.PI - (0, _common.radians)(v);
	    }
	  }, {
	    key: "pitch",
	    get: function get() {
	      return (0, _common.degrees)(this.theta);
	    },
	    set: function set(v) {
	      this.theta = (0, _common.radians)(v);
	    } // get pitch() { return 90 - degrees(this.phi); }
	    // set pitch(v) { this.phi = radians(v) + Math.PI / 2; }
	    // get altitude() { return this.radius - 1; } // relative altitude
	    // lnglatZ coordinates

	  }, {
	    key: "longitude",
	    get: function get() {
	      return (0, _common.degrees)(this.phi);
	    }
	  }, {
	    key: "latitude",
	    get: function get() {
	      return (0, _common.degrees)(this.theta);
	    }
	  }, {
	    key: "lng",
	    get: function get() {
	      return (0, _common.degrees)(this.phi);
	    }
	  }, {
	    key: "lat",
	    get: function get() {
	      return (0, _common.degrees)(this.theta);
	    }
	  }, {
	    key: "z",
	    get: function get() {
	      return (this.radius - 1) * this.radiusScale;
	    }
	  }]);

	  return SphericalCoordinates;
	}();

	exports.default = SphericalCoordinates;
	//# sourceMappingURL=spherical-coordinates.js.map

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _matrix = _interopRequireDefault(__webpack_require__(125));

	var _vector = _interopRequireDefault(__webpack_require__(115));

	var _euler = _interopRequireDefault(__webpack_require__(177));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var Pose =
	/*#__PURE__*/
	function () {
	  /**
	   * A pose contains both rotation and rotations.
	   * Note that every single pose defines its own coordinate system
	   * (with the position of the pose in the origin, and zero rotations).
	   * These "pose relative" coordinate will be centered on the defining
	   * pose's position and with with the defining pose's orientation
	   * aligned with axis.
	   */
	  function Pose(_ref) {
	    var _ref$x = _ref.x,
	        x = _ref$x === void 0 ? 0 : _ref$x,
	        _ref$y = _ref.y,
	        y = _ref$y === void 0 ? 0 : _ref$y,
	        _ref$z = _ref.z,
	        z = _ref$z === void 0 ? 0 : _ref$z,
	        _ref$roll = _ref.roll,
	        roll = _ref$roll === void 0 ? 0 : _ref$roll,
	        _ref$pitch = _ref.pitch,
	        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
	        _ref$yaw = _ref.yaw,
	        yaw = _ref$yaw === void 0 ? 0 : _ref$yaw;

	    _classCallCheck(this, Pose);

	    this.position = new _vector.default(x, y, z);
	    this.orientation = new _euler.default(roll, pitch, yaw, _euler.default.RollPitchYaw);
	  }
	  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */


	  _createClass(Pose, [{
	    key: "getPosition",

	    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */
	    value: function getPosition() {
	      return this.position;
	    }
	  }, {
	    key: "getOrientation",
	    value: function getOrientation() {
	      return this.orientation;
	    }
	    /*
	     * Returns a 4x4 matrix that transforms a coordinates (in the same
	     * coordinate system as this pose) into the "pose-relative" coordinate
	     * system defined by this pose.
	     * The pose relative coordinates with have origin in the position of this
	     * pose, and axis will be aligned with the rotation of this pose.
	     */

	  }, {
	    key: "getTransformationMatrix",
	    value: function getTransformationMatrix() {
	      // setup precomputations for the sin/cos of the angles
	      var sr = Math.sin(this.roll);
	      var sp = Math.sin(this.pitch);
	      var sw = Math.sin(this.yaw);
	      var cr = Math.cos(this.roll);
	      var cp = Math.cos(this.pitch);
	      var cw = Math.cos(this.yaw);
	      var matrix = new _matrix.default().setRowMajor(cw * cp, // 0,0
	      -sw * cr + cw * sp * sr, // 0,1
	      sw * sr + cw * sp * cr, // 0,2
	      this.x, // 0,3
	      sw * cp, // 1,0
	      cw * cr + sw * sp * sr, // 1,1
	      -cw * sr + sw * sp * cr, // 1,2
	      this.y, // 1,3
	      -sp, // 2,0
	      cp * sr, // 2,1
	      cp * cr, // 2,2
	      this.z, // 2,3
	      0, 0, 0, 1);
	      return matrix;
	    }
	    /*
	     * Given a second pose that represent the same object in a second coordinate
	     * system, this method returns a 4x4 matrix that transforms coordinates in the
	     * second coordinate system into the coordinate system of this pose.
	     */

	  }, {
	    key: "getTransformationMatrixFromPose",
	    value: function getTransformationMatrixFromPose(pose) {
	      return new _matrix.default().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
	    }
	    /*
	     * Given a second pose that represent the same object in a second coordinate
	     * system, this method returns a 4x4 matrix that transforms coordinates in the
	     * coordinate system of this pose into the coordinate system of the second pose.
	     *
	     * Note: This method returns the inverse of that returned by
	     * this.getTransformationMatrixFromPose(pose)
	     */

	  }, {
	    key: "getTransformationMatrixToPose",
	    value: function getTransformationMatrixToPose(pose) {
	      return new _matrix.default().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
	    }
	  }, {
	    key: "x",
	    get: function get() {
	      return this.position.x;
	    },
	    set: function set(value) {
	      return this.position.x = value;
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this.position.y;
	    },
	    set: function set(value) {
	      return this.position.y = value;
	    }
	  }, {
	    key: "z",
	    get: function get() {
	      return this.position.z;
	    },
	    set: function set(value) {
	      return this.position.z = value;
	    }
	  }, {
	    key: "roll",
	    get: function get() {
	      return this.orientation.roll;
	    },
	    set: function set(value) {
	      return this.orientation.roll = value;
	    }
	  }, {
	    key: "pitch",
	    get: function get() {
	      return this.orientation.pitch;
	    },
	    set: function set(value) {
	      return this.orientation.pitch = value;
	    }
	  }, {
	    key: "yaw",
	    get: function get() {
	      return this.orientation.yaw;
	    },
	    set: function set(value) {
	      return this.orientation.yaw = value;
	    }
	  }]);

	  return Pose;
	}();

	exports.default = Pose;
	//# sourceMappingURL=pose.js.map

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _mathArray = _interopRequireDefault(__webpack_require__(112));

	var _common = __webpack_require__(113);

	var _matrix = _interopRequireDefault(__webpack_require__(125));

	var _quaternion = _interopRequireDefault(__webpack_require__(145));

	var _vector = _interopRequireDefault(__webpack_require__(115));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	// Internal constants
	var ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
	var ALMOST_ONE = 0.99999;

	function validateOrder(value) {
	  return value >= 0 && value < 6;
	}

	function checkOrder(value) {
	  if (value < 0 && value >= 6) {
	    throw new Error(ERR_UNKNOWN_ORDER);
	  }

	  return value;
	}

	var Euler =
	/*#__PURE__*/
	function (_MathArray) {
	  _inherits(Euler, _MathArray);

	  _createClass(Euler, [{
	    key: "ELEMENTS",
	    get: function get() {
	      return 4;
	    }
	    /* eslint-enable no-multi-spaces, brace-style, no-return-assign */

	    /*
	     * Number|Number[], Number, Number, Number
	     */

	  }], [{
	    key: "rotationOrder",
	    value: function rotationOrder(order) {
	      return Euler.RotationOrders[order];
	    }
	  }, {
	    key: "ZYX",
	    // static XYZ = 0;
	    // static YZX = 1;
	    // static ZXY = 2;
	    // static XZY = 3;
	    // static YXZ = 4;
	    // static ZYX = 5;
	    // static RollPitchYaw = 0;
	    // static DefaultOrder = 0;
	    // Constants

	    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
	    get: function get() {
	      return 0;
	    }
	  }, {
	    key: "YXZ",
	    get: function get() {
	      return 1;
	    }
	  }, {
	    key: "XZY",
	    get: function get() {
	      return 2;
	    }
	  }, {
	    key: "ZXY",
	    get: function get() {
	      return 3;
	    }
	  }, {
	    key: "YZX",
	    get: function get() {
	      return 4;
	    }
	  }, {
	    key: "XYZ",
	    get: function get() {
	      return 5;
	    }
	  }, {
	    key: "RollPitchYaw",
	    get: function get() {
	      return 0;
	    }
	  }, {
	    key: "DefaultOrder",
	    get: function get() {
	      return Euler.ZYX;
	    }
	  }, {
	    key: "RotationOrders",
	    get: function get() {
	      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
	    }
	  }]);

	  function Euler() {
	    var _this;

	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;

	    _classCallCheck(this, Euler);

	    _this = _possibleConstructorReturn(this, (Euler.__proto__ || Object.getPrototypeOf(Euler)).call(this));

	    if (arguments.length > 0 && Array.isArray(arguments[0])) {
	      var _this2;

	      (_this2 = _this).fromVector3.apply(_this2, arguments);
	    } else {
	      _this.set(x, y, z, order);
	    }

	    return _this;
	  } // If copied array does contain fourth element, preserves currently set order


	  _createClass(Euler, [{
	    key: "copy",
	    value: function copy(array) {
	      for (var i = 0; i < 3; ++i) {
	        this[i] = array[i];
	      }

	      this[3] = Number.isFinite(array[3]) || this.order;
	      return this.check();
	    } // Sets the three angles, and optionally sets the rotation order
	    // If order is not specified, preserves currently set order

	  }, {
	    key: "set",
	    value: function set() {
	      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	      var order = arguments.length > 3 ? arguments[3] : undefined;
	      this[0] = x;
	      this[1] = y;
	      this[2] = z;
	      this[3] = Number.isFinite(order) ? order : this[3];
	      return this.check();
	    }
	  }, {
	    key: "validate",
	    value: function validate() {
	      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
	    } // Does not copy the orientation element

	  }, {
	    key: "toArray",
	    value: function toArray() {
	      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      array[offset] = this[0];
	      array[offset + 1] = this[1];
	      array[offset + 2] = this[2];
	      return array;
	    } // Copies the orientation element

	  }, {
	    key: "toArray4",
	    value: function toArray4() {
	      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      array[offset] = this[0];
	      array[offset + 1] = this[1];
	      array[offset + 2] = this[2];
	      array[offset + 3] = this[3];
	      return array;
	    }
	  }, {
	    key: "toVector3",
	    value: function toVector3(optionalResult) {
	      if (optionalResult) {
	        return optionalResult.set(this[0], this[1], this[2]);
	      }

	      return new _vector.default(this[0], this[1], this[2]);
	    }
	    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
	    // x, y, z angle notation (note: only corresponds to axis in XYZ orientation)

	  }, {
	    key: "fromVector3",

	    /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
	    // Constructors
	    value: function fromVector3(v, order) {
	      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
	    } // TODO - with and without 4th element

	  }, {
	    key: "fromArray",
	    value: function fromArray(array) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      this[0] = array[0 + offset];
	      this[1] = array[1 + offset];
	      this[2] = array[2 + offset];

	      if (array[3] !== undefined) {
	        this[3] = array[3];
	      }

	      return this.check();
	    } // Common ZYX rotation order

	  }, {
	    key: "fromRollPitchYaw",
	    value: function fromRollPitchYaw(roll, pitch, yaw) {
	      return this.set(roll, pitch, yaw, Euler.ZYX);
	    }
	  }, {
	    key: "fromQuaternion",
	    value: function fromQuaternion(q, order) {
	      this._fromRotationMatrix(_matrix.default.fromQuaternion(q), order);

	      return this.check();
	    }
	  }, {
	    key: "fromRotationMatrix",
	    value: function fromRotationMatrix(m) {
	      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

	      this._fromRotationMatrix(m, order);

	      return this.check();
	    } // ACCESSORS
	    // @return {Matrix4} a rotation matrix corresponding to rotations
	    //   per the specified euler angles

	  }, {
	    key: "getRotationMatrix",
	    value: function getRotationMatrix() {
	      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _matrix.default();

	      this._getRotationMatrix(m);

	      return m;
	    }
	  }, {
	    key: "getQuaternion",
	    value: function getQuaternion() {
	      var q = new _quaternion.default();

	      switch (this[4]) {
	        case Euler.XYZ:
	          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

	        case Euler.YXZ:
	          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

	        case Euler.ZXY:
	          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

	        case Euler.ZYX:
	          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

	        case Euler.YZX:
	          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

	        case Euler.XZY:
	          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

	        default:
	          throw new Error(ERR_UNKNOWN_ORDER);
	      }
	    } // INTERNAL METHODS
	    // Concersion from Euler to rotation matrix and from matrix to Euler
	    // Adapted from three.js under MIT license
	    // // WARNING: this discards revolution information -bhouston
	    // reorder(newOrder) {
	    //   const q = new Quaternion().setFromEuler(this);
	    //   return this.setFromQuaternion(q, newOrder);

	    /* eslint-disable complexity, max-statements, one-var */

	  }, {
	    key: "_fromRotationMatrix",
	    value: function _fromRotationMatrix(m) {
	      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;
	      // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	      var te = m.elements;
	      var m11 = te[0],
	          m12 = te[4],
	          m13 = te[8];
	      var m21 = te[1],
	          m22 = te[5],
	          m23 = te[9];
	      var m31 = te[2],
	          m32 = te[6],
	          m33 = te[10];
	      order = order || this[3];

	      switch (order) {
	        case Euler.XYZ:
	          this[1] = Math.asin((0, _common.clamp)(m13, -1, 1));

	          if (Math.abs(m13) < ALMOST_ONE) {
	            this[0] = Math.atan2(-m23, m33);
	            this[2] = Math.atan2(-m12, m11);
	          } else {
	            this[0] = Math.atan2(m32, m22);
	            this[2] = 0;
	          }

	          break;

	        case Euler.YXZ:
	          this[0] = Math.asin(-(0, _common.clamp)(m23, -1, 1));

	          if (Math.abs(m23) < ALMOST_ONE) {
	            this[1] = Math.atan2(m13, m33);
	            this[2] = Math.atan2(m21, m22);
	          } else {
	            this[1] = Math.atan2(-m31, m11);
	            this[2] = 0;
	          }

	          break;

	        case Euler.ZXY:
	          this[0] = Math.asin((0, _common.clamp)(m32, -1, 1));

	          if (Math.abs(m32) < ALMOST_ONE) {
	            this[1] = Math.atan2(-m31, m33);
	            this[2] = Math.atan2(-m12, m22);
	          } else {
	            this[1] = 0;
	            this[2] = Math.atan2(m21, m11);
	          }

	          break;

	        case Euler.ZYX:
	          this[1] = Math.asin(-(0, _common.clamp)(m31, -1, 1));

	          if (Math.abs(m31) < ALMOST_ONE) {
	            this[0] = Math.atan2(m32, m33);
	            this[2] = Math.atan2(m21, m11);
	          } else {
	            this[0] = 0;
	            this[2] = Math.atan2(-m12, m22);
	          }

	          break;

	        case Euler.YZX:
	          this[2] = Math.asin((0, _common.clamp)(m21, -1, 1));

	          if (Math.abs(m21) < ALMOST_ONE) {
	            this[0] = Math.atan2(-m23, m22);
	            this[1] = Math.atan2(-m31, m11);
	          } else {
	            this[0] = 0;
	            this[1] = Math.atan2(m13, m33);
	          }

	          break;

	        case Euler.XZY:
	          this[2] = Math.asin(-(0, _common.clamp)(m12, -1, 1));

	          if (Math.abs(m12) < ALMOST_ONE) {
	            this[0] = Math.atan2(m32, m22);
	            this[1] = Math.atan2(m13, m11);
	          } else {
	            this[0] = Math.atan2(-m23, m33);
	            this[1] = 0;
	          }

	          break;

	        default:
	          throw new Error(ERR_UNKNOWN_ORDER);
	      }

	      this[3] = order;
	      return this;
	    }
	  }, {
	    key: "_getRotationMatrix",
	    value: function _getRotationMatrix() {
	      var te = new _matrix.default();
	      var x = this.x,
	          y = this.y,
	          z = this.z;
	      var a = Math.cos(x);
	      var c = Math.cos(y);
	      var e = Math.cos(z);
	      var b = Math.sin(x);
	      var d = Math.sin(y);
	      var f = Math.sin(z);

	      switch (this[3]) {
	        case Euler.XYZ:
	          {
	            var ae = a * e,
	                af = a * f,
	                be = b * e,
	                bf = b * f;
	            te[0] = c * e;
	            te[4] = -c * f;
	            te[8] = d;
	            te[1] = af + be * d;
	            te[5] = ae - bf * d;
	            te[9] = -b * c;
	            te[2] = bf - ae * d;
	            te[6] = be + af * d;
	            te[10] = a * c;
	            break;
	          }

	        case Euler.YXZ:
	          {
	            var ce = c * e,
	                cf = c * f,
	                de = d * e,
	                df = d * f;
	            te[0] = ce + df * b;
	            te[4] = de * b - cf;
	            te[8] = a * d;
	            te[1] = a * f;
	            te[5] = a * e;
	            te[9] = -b;
	            te[2] = cf * b - de;
	            te[6] = df + ce * b;
	            te[10] = a * c;
	            break;
	          }

	        case Euler.ZXY:
	          {
	            var _ce = c * e,
	                _cf = c * f,
	                _de = d * e,
	                _df = d * f;

	            te[0] = _ce - _df * b;
	            te[4] = -a * f;
	            te[8] = _de + _cf * b;
	            te[1] = _cf + _de * b;
	            te[5] = a * e;
	            te[9] = _df - _ce * b;
	            te[2] = -a * d;
	            te[6] = b;
	            te[10] = a * c;
	            break;
	          }

	        case Euler.ZYX:
	          {
	            var _ae = a * e,
	                _af = a * f,
	                _be = b * e,
	                _bf = b * f;

	            te[0] = c * e;
	            te[4] = _be * d - _af;
	            te[8] = _ae * d + _bf;
	            te[1] = c * f;
	            te[5] = _bf * d + _ae;
	            te[9] = _af * d - _be;
	            te[2] = -d;
	            te[6] = b * c;
	            te[10] = a * c;
	            break;
	          }

	        case Euler.YZX:
	          {
	            var ac = a * c,
	                ad = a * d,
	                bc = b * c,
	                bd = b * d;
	            te[0] = c * e;
	            te[4] = bd - ac * f;
	            te[8] = bc * f + ad;
	            te[1] = f;
	            te[5] = a * e;
	            te[9] = -b * e;
	            te[2] = -d * e;
	            te[6] = ad * f + bc;
	            te[10] = ac - bd * f;
	            break;
	          }

	        case Euler.XZY:
	          {
	            var _ac = a * c,
	                _ad = a * d,
	                _bc = b * c,
	                _bd = b * d;

	            te[0] = c * e;
	            te[4] = -f;
	            te[8] = d * e;
	            te[1] = _ac * f + _bd;
	            te[5] = a * e;
	            te[9] = _ad * f - _bc;
	            te[2] = _bc * f - _ad;
	            te[6] = b * e;
	            te[10] = _bd * f + _ac;
	            break;
	          }

	        default:
	          throw new Error(ERR_UNKNOWN_ORDER);
	      } // last column


	      te[3] = 0;
	      te[7] = 0;
	      te[11] = 0; // bottom row

	      te[12] = 0;
	      te[13] = 0;
	      te[14] = 0;
	      te[15] = 1;
	      return this;
	    }
	    /* eslint-enable complexity, max-statements, one-var */

	  }, {
	    key: "x",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "y",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "z",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    } // alpha, beta, gamma angle notation

	  }, {
	    key: "alpha",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "beta",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "gamma",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    } // phi, theta, psi angle notation

	  }, {
	    key: "phi",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "theta",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "psi",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    } // roll, pitch, yaw angle notation

	  }, {
	    key: "roll",
	    get: function get() {
	      return this[0];
	    },
	    set: function set(value) {
	      return this[0] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "pitch",
	    get: function get() {
	      return this[1];
	    },
	    set: function set(value) {
	      return this[1] = (0, _common.checkNumber)(value);
	    }
	  }, {
	    key: "yaw",
	    get: function get() {
	      return this[2];
	    },
	    set: function set(value) {
	      return this[2] = (0, _common.checkNumber)(value);
	    } // rotation order, in all three angle notations

	  }, {
	    key: "order",
	    get: function get() {
	      return this[3];
	    },
	    set: function set(value) {
	      return this[3] = checkOrder(value);
	    }
	  }]);

	  return Euler;
	}(_mathArray.default);

	exports.default = Euler;
	//# sourceMappingURL=euler.js.map

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _common = __webpack_require__(113);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var Polygon =
	/*#__PURE__*/
	function () {
	  function Polygon(points) {
	    _classCallCheck(this, Polygon);

	    this.points = points;
	    this.isClosed = (0, _common.equals)(this.points[this.points.length - 1], this.points[0]);
	    Object.freeze(this);
	  } // https://en.wikipedia.org/wiki/Shoelace_formula


	  _createClass(Polygon, [{
	    key: "getSignedArea",
	    value: function getSignedArea() {
	      var area = 0;
	      this.forEachSegment(function (p1, p2) {
	        // the "cancelling" cross-products: (p1.x + p2.x) * (p1.y - p2.y)
	        area += (p1[0] + p2[0]) * (p1[1] - p2[1]);
	      });
	      return area / 2;
	    }
	  }, {
	    key: "getArea",
	    value: function getArea() {
	      return Math.abs(this.getSignedArea());
	    }
	  }, {
	    key: "getWindingDirection",
	    value: function getWindingDirection() {
	      return Math.sign(this.getSignedArea());
	    }
	  }, {
	    key: "forEachSegment",
	    value: function forEachSegment(visitor) {
	      var length = this.points.length;

	      for (var i = 0; i < length - 1; i++) {
	        visitor(this.points[i], this.points[i + 1], i, i + 1);
	      }

	      if (this.isPolygon && !this.isClosed()) {
	        // Call function with points and indices
	        visitor(this.points[length - 1], this.points[0], length - 1, 0);
	      }
	    }
	  }]);

	  return Polygon;
	}();

	exports.default = Polygon;
	//# sourceMappingURL=polygon.js.map

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MODULAR_SHADERS = void 0;

	var _modularVertex = _interopRequireDefault(__webpack_require__(180));

	var _modularFragment = _interopRequireDefault(__webpack_require__(181));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Default Shaders
	// A set of base shaders that leverage the shader module system,
	// dynamically enabling features depending on which modules are included
	var MODULAR_SHADERS = {
	  vs: _modularVertex.default,
	  fs: _modularFragment.default,
	  defaultUniforms: {}
	};
	exports.MODULAR_SHADERS = MODULAR_SHADERS;
	//# sourceMappingURL=index.js.map

/***/ }),
/* 180 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var _default = "#define SHADER_NAME luma_modular_vertex\n\n// object attributes\nattribute vec3 positions;\nattribute vec3 normals;\nattribute vec4 colors;\nattribute vec2 texCoords;\nattribute vec3 pickingColors;\n\nvoid main(void) {\n\n  // Set up position\n#ifdef MODULE_GEOMETRY\n  geometry_setPosition(positions);\n  geometry_setNormal(normals);\n#endif\n\n#ifdef MODULE_PROJECT\n  project_setPositionAndNormal_Model(positions, normals);\n  gl_Position = project_model_to_clipspace(positions);\n#endif\n\n  // Set up depth\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n\n#ifdef MODULE_DIFFUSE\n  diffuse_setTextureCoordinate(texCoords);\n#endif\n\n  // Set up color calculations\n#ifdef MODULE_MATERIAL\n  material_setDiffuseColor(colors);\n  material_setDiffuseTextureCoordinates(texCoords);\n#endif\n\n#ifdef MODULE_LIGHTING\n  lighting_setPositionAndNormal(positions, normals);\n  lighting_apply_light(positions);\n  lighting_apply_reflection(positions);\n#endif\n\n#ifdef MODULE_PICKING\n  picking_setPickingColor(pickingColors);\n#endif\n\n}\n";
	exports.default = _default;
	//# sourceMappingURL=modular-vertex.glsl.js.map

/***/ }),
/* 181 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var _default = "#define SHADER_NAME luma-modular-fragment\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n// varyings\nvarying vec4 vColor;\n\nvoid main(){\n  gl_FragColor = vec4(1., 0., 1., 1.);\n\n#ifdef MODULE_DIFFUSE\n  gl_FragColor = diffuse_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth(gl_Position);\n#endif\n}\n";
	exports.default = _default;
	//# sourceMappingURL=modular-fragment.glsl.js.map

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "registerShaderModules", {
	  enumerable: true,
	  get: function get() {
	    return _shaderModules.registerShaderModules;
	  }
	});
	Object.defineProperty(exports, "assembleShaders", {
	  enumerable: true,
	  get: function get() {
	    return _assembleShaders.assembleShaders;
	  }
	});
	Object.defineProperty(exports, "ShaderCache", {
	  enumerable: true,
	  get: function get() {
	    return _shaderCache.default;
	  }
	});

	var _shaderModules = __webpack_require__(183);

	var _assembleShaders = __webpack_require__(184);

	var _shaderCache = _interopRequireDefault(__webpack_require__(187));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.registerShaderModules = registerShaderModules;
	exports.setDefaultShaderModules = setDefaultShaderModules;
	exports.getShaderModule = getShaderModule;
	exports.resolveModules = resolveModules;
	exports.getShaderDependencies = getShaderDependencies;
	exports.getDependencyGraph = getDependencyGraph;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var shaderModules = {};
	var defaultShaderModules = [];
	/**
	 * Registers an array of shader modules
	 * @param {Object[]} shaderModuleList - Array of shader modules
	 */

	function registerShaderModules(shaderModuleList) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$ignoreMultipleRe = _ref.ignoreMultipleRegistrations,
	      ignoreMultipleRegistrations = _ref$ignoreMultipleRe === void 0 ? false : _ref$ignoreMultipleRe;

	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = shaderModuleList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var shaderModule = _step.value;
	      registerShaderModule(shaderModule, {
	        ignoreMultipleRegistrations: ignoreMultipleRegistrations
	      });
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }
	}
	/**
	 * Registers an array of default shader modules. These will be concatenated
	 * automatically at the end of any shader module list passed to
	 * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)
	 * @param {Object[]} modules - Array of shader modules
	 */


	function setDefaultShaderModules(modules) {
	  defaultShaderModules = modules;
	} // Looks up a moduleName among registered modules and returns definition.
	// If "inline" module, returns it directly


	function getShaderModule(moduleOrName) {
	  // Check if "inline" module
	  if (typeof moduleOrName !== 'string') {
	    var _shaderModule = moduleOrName;
	    (0, _assert.default)(typeof _shaderModule.name === 'string');
	    registerShaderModule(_shaderModule, {
	      ignoreMultipleRegistrations: true
	    });
	    return _shaderModule;
	  } // Look up module


	  var shaderModule = shaderModules[moduleOrName];

	  if (!shaderModule) {
	    // console.log(`${moduleOrName} not in registered modules:`, shaderModules);
	    (0, _assert.default)(false, "Unknown shader module ".concat(moduleOrName));
	  }

	  return shaderModule;
	} // registers any supplied modules and returns a list of module names


	function resolveModules(modules) {
	  var moduleNames = modules.map(function (module) {
	    if (typeof module !== 'string') {
	      registerShaderModules([module], {
	        ignoreMultipleRegistrations: true
	      });
	      return module.name;
	    }

	    return module;
	  });
	  return getShaderDependencies(moduleNames);
	}
	/**
	 * Takes a list of shader module names and returns a new list of
	 * shader module names that includes all dependencies, sorted so
	 * that modules that are dependencies of other modules come first.
	 *
	 * If the shader glsl code from the returned modules is concatenated
	 * in the reverse order, it is guaranteed that all functions be resolved and
	 * that all function and variable definitions come before use.
	 *
	 * @param {String[]} modules - Array of modules (inline modules or module names)
	 * @return {String[]} - Array of modules
	 */


	function getShaderDependencies(modules) {
	  modules = modules.concat(defaultShaderModules);
	  var result = {};
	  getDependencyGraph({
	    modules: modules,
	    level: 0,
	    result: result
	  }); // Return a reverse sort so that dependencies come before the modules that use them

	  return Object.keys(result).sort(function (a, b) {
	    return result[b] - result[a];
	  });
	}
	/**
	 * Recursively checks module dpendencies to calculate dependency
	 * level of each module.
	 *
	 * @param {String[]} modules - Array of modules
	 * @param {Number} level - Current level
	 * @return {result} - Map of module name to its level
	 */
	// Adds another level of dependencies to the result map


	function getDependencyGraph(_ref2) {
	  var modules = _ref2.modules,
	      level = _ref2.level,
	      result = _ref2.result;

	  if (level >= 5) {
	    throw new Error('Possible loop in shader dependency graph');
	  } // Update level on all current modules


	  var _iteratorNormalCompletion2 = true;
	  var _didIteratorError2 = false;
	  var _iteratorError2 = undefined;

	  try {
	    for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	      var moduleOrName = _step2.value;
	      var shaderModule = getShaderModule(moduleOrName);

	      if (result[shaderModule.name] === undefined || result[shaderModule.name] < level) {
	        result[shaderModule.name] = level;
	      }
	    } // Recurse

	  } catch (err) {
	    _didIteratorError2 = true;
	    _iteratorError2 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	        _iterator2.return();
	      }
	    } finally {
	      if (_didIteratorError2) {
	        throw _iteratorError2;
	      }
	    }
	  }

	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;

	  try {
	    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var _moduleOrName = _step3.value;

	      var _shaderModule2 = getShaderModule(_moduleOrName);

	      if (_shaderModule2.dependencies) {
	        getDependencyGraph({
	          modules: _shaderModule2.dependencies,
	          level: level + 1,
	          result: result
	        });
	      }
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }

	  return result;
	} // PRIVATE API


	function parseDeprecationDefinitions() {
	  var deprecations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	  deprecations.forEach(function (def) {
	    switch (def.type) {
	      case 'function':
	        def.regex = new RegExp("\\b".concat(def.old, "\\("));
	        break;

	      default:
	        def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
	    }
	  });
	  return deprecations;
	}

	function registerShaderModule(shaderModule, _ref3) {
	  var _ref3$ignoreMultipleR = _ref3.ignoreMultipleRegistrations,
	      ignoreMultipleRegistrations = _ref3$ignoreMultipleR === void 0 ? false : _ref3$ignoreMultipleR;
	  (0, _assert.default)(shaderModule.name, 'shader module has no name');

	  if (!ignoreMultipleRegistrations && shaderModules[shaderModule.name]) {
	    // TODO - instead verify that definition is not changing...
	    throw new Error("shader module ".concat(shaderModule.name, " already registered"));
	  }

	  shaderModules[shaderModule.name] = shaderModule;
	  shaderModule.dependencies = shaderModule.dependencies || [];
	  shaderModule.deprecations = parseDeprecationDefinitions(shaderModule.deprecations);
	}
	//# sourceMappingURL=shader-modules.js.map

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.assembleShaders = assembleShaders;

	var _shaderModules = __webpack_require__(183);

	var _platformDefines = __webpack_require__(185);

	var _moduleInjectors = __webpack_require__(186);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _utils = __webpack_require__(63);

	var _SHADER_TYPE, _MODULE_INJECTORS;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	var VERTEX_SHADER = 'vs';
	var FRAGMENT_SHADER = 'fs';
	var SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, 'vertex'), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);
	var MODULE_INJECTORS = (_MODULE_INJECTORS = {}, _defineProperty(_MODULE_INJECTORS, VERTEX_SHADER, _moduleInjectors.MODULE_INJECTORS_VS), _defineProperty(_MODULE_INJECTORS, FRAGMENT_SHADER, _moduleInjectors.MODULE_INJECTORS_FS), _MODULE_INJECTORS); // Precision prologue to inject before functions are injected in shader
	// TODO - extract any existing prologue in the fragment source and move it up...

	var FRAGMENT_SHADER_PROLOGUE = "#ifdef GL_ES\nprecision highp float;\n#endif\n\n"; // Generate "glslify-compatible" SHADER_NAME defines
	// These are understood by the GLSL error parsing function
	// If id is provided and no SHADER_NAME constant is present in source, create one

	function getShaderName(_ref) {
	  var id = _ref.id,
	      source = _ref.source,
	      type = _ref.type;
	  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
	  return injectShaderName ? "\n#define SHADER_NAME ".concat(id, "_").concat(SHADER_TYPE[type], "\n\n") : '';
	} // Generates application defines from an object


	function getApplicationDefines() {
	  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var count = 0;
	  var sourceText = '';

	  for (var define in defines) {
	    if (count === 0) {
	      sourceText += '\n// APPLICATION DEFINES\n';
	    }

	    count++;
	    sourceText += "#define ".concat(define.toUpperCase(), " ").concat(defines[define], "\n");
	  }

	  if (count === 0) {
	    sourceText += '\n';
	  }

	  return sourceText;
	} // Warn about deprecated uniforms or functions


	function checkDeprecation(moduleName, shaderSource) {
	  var shaderModule = (0, _shaderModules.getShaderModule)(moduleName);
	  shaderModule.deprecations.forEach(function (def) {
	    if (def.regex.test(shaderSource)) {
	      if (def.deprecated) {
	        _utils.log.deprecated(def.old, def.new)();
	      } else {
	        _utils.log.removed(def.old, def.new)();
	      }
	    }
	  });
	} // Extracts the source code chunk for the specified shader type from the named shader module


	function getModuleSource(moduleName, type) {
	  var shaderModule = (0, _shaderModules.getShaderModule)(moduleName);
	  var moduleSource;

	  switch (type) {
	    case VERTEX_SHADER:
	      moduleSource = shaderModule.vs || shaderModule.vertexShader;
	      break;

	    case FRAGMENT_SHADER:
	      moduleSource = shaderModule.fs || shaderModule.fragmentShader;
	      break;

	    default:
	      (0, _assert.default)(false);
	  }

	  if (typeof moduleSource !== 'string') {
	    return '';
	  }

	  return "#define MODULE_".concat(moduleName.toUpperCase(), "\n").concat(moduleSource, "// END MODULE_").concat(moduleName, "\n\n");
	} // Pulls together complete source code for either a vertex or a fragment shader
	// adding prologues, requested module chunks, and any final injections.


	function assembleShader(gl, _ref2) {
	  var id = _ref2.id,
	      source = _ref2.source,
	      type = _ref2.type,
	      _ref2$modules = _ref2.modules,
	      modules = _ref2$modules === void 0 ? [] : _ref2$modules,
	      _ref2$defines = _ref2.defines,
	      defines = _ref2$defines === void 0 ? {} : _ref2$defines;
	  (0, _assert.default)(typeof source === 'string', 'shader source must be a string');
	  var sourceLines = source.split('\n');
	  var versionLine = '';
	  var coreSource = source; // Extract any version directive string from source.
	  // TODO : keep all pre-processor statements at the begining of the shader.

	  if (sourceLines[0].indexOf('#version ') === 0) {
	    versionLine = sourceLines[0];
	    coreSource = sourceLines.slice(1).join('\n');
	  } // Add platform defines (use these to work around platform-specific bugs and limitations)
	  // Add common defines (GLSL version compatibility, feature detection)
	  // Add precision declaration for fragment shaders


	  var assembledSource = "".concat(getShaderName({
	    id: id,
	    source: source,
	    type: type
	  }), "\n").concat((0, _platformDefines.getPlatformShaderDefines)(gl), "\n").concat((0, _platformDefines.getVersionDefines)(gl), "\n").concat(getApplicationDefines(defines), "\n").concat(type === FRAGMENT_SHADER ? FRAGMENT_SHADER_PROLOGUE : '', "\n"); // Add source of dependent modules in resolved order

	  var inject = false;
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var moduleName = _step.value;

	      switch (moduleName) {
	        case 'inject':
	          inject = true;
	          break;

	        default:
	          checkDeprecation(moduleName, coreSource); // Add the module source, and a #define that declares it presence

	          assembledSource += getModuleSource(moduleName, type);
	      }
	    } // Add the version directive and actual source of this shader

	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  assembledSource = versionLine + assembledSource + coreSource; // Finally, if requested, insert an automatic module injector chunk

	  if (inject) {
	    assembledSource.replace('}\s*$', MODULE_INJECTORS);
	  }

	  return assembledSource;
	} // Returns a combined `getUniforms` covering the options for all the modules,
	// the created function will pass on options to the inidividual `getUniforms`
	// function of each shader module and combine the results into one object that
	// can be passed to setUniforms.


	function assembleGetUniforms(modules) {
	  return function getUniforms(opts) {
	    var uniforms = {};
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;

	    try {
	      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	        var moduleName = _step2.value;
	        var shaderModule = (0, _shaderModules.getShaderModule)(moduleName); // `modules` is already sorted by dependency level. This guarantees that
	        // modules have access to the uniforms that are generated by their dependencies.

	        var moduleUniforms = shaderModule.getUniforms ? shaderModule.getUniforms(opts, uniforms) : {};
	        Object.assign(uniforms, moduleUniforms);
	      }
	    } catch (err) {
	      _didIteratorError2 = true;
	      _iteratorError2 = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	          _iterator2.return();
	        }
	      } finally {
	        if (_didIteratorError2) {
	          throw _iteratorError2;
	        }
	      }
	    }

	    return uniforms;
	  };
	} // Returns a map with module names as keys, resolving to their module definitions
	// The presence of a key indicates that the module is available in this program,
	// whether directly included, or through a dependency of some other module


	function assembleModuleMap(modules) {
	  var result = {};
	  var _iteratorNormalCompletion3 = true;
	  var _didIteratorError3 = false;
	  var _iteratorError3 = undefined;

	  try {
	    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	      var moduleName = _step3.value;
	      var shaderModule = (0, _shaderModules.getShaderModule)(moduleName);
	      result[moduleName] = shaderModule;
	    }
	  } catch (err) {
	    _didIteratorError3 = true;
	    _iteratorError3 = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	        _iterator3.return();
	      }
	    } finally {
	      if (_didIteratorError3) {
	        throw _iteratorError3;
	      }
	    }
	  }

	  return result;
	}
	/**
	 * Apply set of modules
	 */


	function assembleShaders(gl) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var vs = opts.vs,
	      fs = opts.fs;
	  var modules = (0, _shaderModules.resolveModules)(opts.modules || []);
	  return {
	    gl: gl,
	    vs: assembleShader(gl, Object.assign({}, opts, {
	      source: vs,
	      type: VERTEX_SHADER,
	      modules: modules
	    })),
	    fs: assembleShader(gl, Object.assign({}, opts, {
	      source: fs,
	      type: FRAGMENT_SHADER,
	      modules: modules
	    })),
	    getUniforms: assembleGetUniforms(modules),
	    modules: assembleModuleMap(modules)
	  };
	}
	//# sourceMappingURL=assemble-shaders.js.map

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.checkRendererVendor = checkRendererVendor;
	exports.getPlatformShaderDefines = getPlatformShaderDefines;
	exports.getVersionDefines = getVersionDefines;

	var _webgl = __webpack_require__(81);

	var _contextFeatures = __webpack_require__(79);

	function checkRendererVendor(debugInfo, gpuVendor) {
	  var vendor = debugInfo.vendor,
	      renderer = debugInfo.renderer;
	  var result;

	  switch (gpuVendor) {
	    case 'nvidia':
	      result = vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i);
	      break;

	    case 'intel':
	      result = vendor.match(/INTEL/i) || renderer.match(/INTEL/i);
	      break;

	    case 'amd':
	      result = vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i);
	      break;

	    default:
	      result = false;
	  }

	  return result;
	}

	function getPlatformShaderDefines(gl) {
	  /* eslint-disable */
	  var platformDefines = '';
	  var debugInfo = (0, _webgl.getContextInfo)(gl);

	  if (checkRendererVendor(debugInfo, 'nvidia')) {
	    platformDefines += "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
	  } else if (checkRendererVendor(debugInfo, 'intel')) {
	    platformDefines += "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
	  } else if (checkRendererVendor(debugInfo, 'amd')) {
	    // AMD Does not eliminate fp64 code
	    platformDefines += "#define AMD_GPU\n";
	  } else {
	    // We don't know what GPU it is, could be that the GPU driver or
	    // browser is not implementing UNMASKED_RENDERER constant and not
	    // reporting a correct name
	    platformDefines += "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
	  }

	  return platformDefines;
	}

	function getVersionDefines(gl) {
	  var versionDefines = "// Defines for shader portability\n#if (__VERSION__ > 120)\n# define attribute in\n# define varying out\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n#else\n// # define in attribute\n// # define out varying\n#endif // __VERSION\n";

	  if ((0, _contextFeatures.hasFeature)(gl, _contextFeatures.FEATURES.GLSL_FRAG_DEPTH)) {
	    versionDefines += "// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
	  }

	  if ((0, _contextFeatures.hasFeature)(gl, _contextFeatures.FEATURES.GLSL_DERIVATIVES) && (0, _contextFeatures.canCompileGLGSExtension)(gl, _contextFeatures.FEATURES.GLSL_DERIVATIVES)) {
	    versionDefines += "// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define DERIVATIVES\n#endif\n";
	  }

	  if ((0, _contextFeatures.hasFeature)(gl, _contextFeatures.FEATURES.GLSL_FRAG_DATA)) {
	    versionDefines += "// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define DRAW_BUFFERS\n#endif\n";
	  }

	  if ((0, _contextFeatures.hasFeature)(gl, _contextFeatures.FEATURES.GLSL_TEXTURE_LOD)) {
	    versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n# define TEXTURE_LOD\n#define texture2DLod texture2DLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define texture2DProjLod texture2DProjLodEXT\n#define textureCubeLod textureCubeLodEXT\n#define texture2DGrad texture2DGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define texture2DProjGrad texture2DProjGradEXT\n#define textureCubeGrad textureCubeGradEXT\n#endif\n";
	  }

	  return versionDefines;
	}
	//# sourceMappingURL=platform-defines.js.map

/***/ }),
/* 186 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.MODULE_INJECTORS_FS = exports.MODULE_INJECTORS_VS = void 0;
	var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
	exports.MODULE_INJECTORS_VS = MODULE_INJECTORS_VS;
	var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";
	exports.MODULE_INJECTORS_FS = MODULE_INJECTORS_FS;
	//# sourceMappingURL=module-injectors.js.map

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _shader = __webpack_require__(85);

	var _program = _interopRequireDefault(__webpack_require__(86));

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var ShaderCache =
	/*#__PURE__*/
	function () {
	  /**
	   * A cache of compiled shaders, keyed by shader source strings.
	   * Compilation of long shaders can be time consuming.
	   * By using this class, the application can ensure that each shader
	   * is only compiled once.
	   */
	  function ShaderCache() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        gl = _ref.gl,
	        _ref$_cachePrograms = _ref._cachePrograms,
	        _cachePrograms = _ref$_cachePrograms === void 0 ? false : _ref$_cachePrograms;

	    _classCallCheck(this, ShaderCache);

	    (0, _assert.default)(gl);
	    this.gl = gl;
	    this.vertexShaders = {};
	    this.fragmentShaders = {};
	    this.programs = {};
	    this._cachePrograms = _cachePrograms;
	  }
	  /**
	   * Deletes shader references
	   * @return {ShaderCache} - returns this for chaining
	   */


	  _createClass(ShaderCache, [{
	    key: "delete",
	    value: function _delete() {
	      // TODO - requires reference counting to avoid deleting shaders in use
	      return this;
	    }
	    /**
	     * Returns a compiled `VertexShader` object corresponding to the supplied
	     * GLSL source code string, if possible from cache.
	     *
	     * @param {WebGLRenderingContext} gl - gl context
	     * @param {String} source - Source code for shader
	     * @return {VertexShader} - a compiled vertex shader
	     */

	  }, {
	    key: "getVertexShader",
	    value: function getVertexShader(gl, source) {
	      (0, _assert.default)(typeof source === 'string');
	      (0, _assert.default)(this._compareContexts(gl, this.gl));
	      var shader = this.vertexShaders[source];

	      if (!shader) {
	        shader = new _shader.VertexShader(gl, source);
	        this.vertexShaders[source] = shader;
	      }

	      return shader;
	    }
	    /**
	     * Returns a compiled `VertexShader` object corresponding to the supplied
	     * GLSL source code string, if possible from cache.
	     * @param {WebGLRenderingContext} gl - gl context
	     * @param {String} source - Source code for shader
	     * @return {FragmentShader} - a compiled fragment shader, possibly from chache
	     */

	  }, {
	    key: "getFragmentShader",
	    value: function getFragmentShader(gl, source) {
	      (0, _assert.default)(typeof source === 'string');
	      (0, _assert.default)(this._compareContexts(gl, this.gl));
	      var shader = this.fragmentShaders[source];

	      if (!shader) {
	        shader = new _shader.FragmentShader(gl, source);
	        this.fragmentShaders[source] = shader;
	      }

	      return shader;
	    } // Retrive Shaders from cache if exists, otherwise create new instance.

	  }, {
	    key: "getProgram",
	    value: function getProgram(gl, opts) {
	      (0, _assert.default)(this._compareContexts(gl, this.gl));
	      (0, _assert.default)(typeof opts.vs === 'string');
	      (0, _assert.default)(typeof opts.fs === 'string');
	      (0, _assert.default)(typeof opts.id === 'string');

	      var cacheKey = this._getProgramKey(opts);

	      var program = this.programs[cacheKey];

	      if (program) {
	        this._resetProgram(program);

	        return program;
	      }

	      program = this._createNewProgram(gl, opts); // Check if program can be cached
	      // Program caching is experimental and expects
	      // each Model to have a unique-id (wich is used in key generation)

	      if (this._cachePrograms && this._checkProgramProp(program)) {
	        program._isCached = true;
	        this.programs[cacheKey] = program;
	      }

	      return program;
	    }
	  }, {
	    key: "_getProgramKey",
	    value: function _getProgramKey(opts) {
	      return "".concat(opts.id, "-").concat(opts.vs, "-").concat(opts.fs);
	    }
	  }, {
	    key: "_checkProgramProp",
	    value: function _checkProgramProp(program) {
	      // Check for transform feedback props (varyings, etc), we can't key such programs for now
	      return !program.varyings;
	    }
	  }, {
	    key: "_createNewProgram",
	    value: function _createNewProgram(gl, opts) {
	      var vs = opts.vs,
	          fs = opts.fs;
	      var vertexShader = this.getVertexShader(gl, vs);
	      var fragmentShader = this.getFragmentShader(gl, fs);
	      return new _program.default(this.gl, Object.assign({}, opts, {
	        vs: vertexShader,
	        fs: fragmentShader
	      }));
	    }
	  }, {
	    key: "_resetProgram",
	    value: function _resetProgram(program, opts) {
	      program.reset();
	    } // Handle debug contexts

	  }, {
	    key: "_compareContexts",
	    value: function _compareContexts(gl1, gl2) {
	      return (gl1.gl || gl1) === (gl2.gl || gl2);
	    }
	  }]);

	  return ShaderCache;
	}();

	exports.default = ShaderCache;
	//# sourceMappingURL=shader-cache.js.map

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getOverrides = exports.setOverride = exports.removeModel = exports.logModel = exports.addModel = void 0;

	var _seer = _interopRequireDefault(__webpack_require__(189));

	var _globals = __webpack_require__(50);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var models = {};
	/**
	 * Add a model to our cache indexed by id
	 */

	var addModel = function addModel(model) {
	  if (models[model.id]) {
	    return;
	  }

	  models[model.id] = model;

	  _seer.default.listItem('luma.gl', model.id);
	};
	/**
	 * Log a model uniforms and attributes.
	 */


	exports.addModel = addModel;

	var logModel = function logModel(model, uniforms) {
	  if (!_seer.default.isReady() || _seer.default.throttle("luma.gl:".concat(model.id), 1E3)) {
	    return;
	  }

	  var attributesObject = model.geometry ? Object.assign({}, model.geometry.attributes, model.attributes) : model.attributes;
	  var uniformsObject = Object.assign({}, model.uniforms, uniforms);

	  _seer.default.multiUpdate('luma.gl', model.id, [{
	    path: 'objects.uniforms',
	    data: uniformsObject
	  }, {
	    path: 'objects.attributes',
	    data: attributesObject
	  }]);
	};
	/**
	 * Remove a previously set model from the cache
	 */


	exports.logModel = logModel;

	var removeModel = function removeModel(id) {
	  delete models[id];

	  _seer.default.deleteItem('luma.gl', id);
	};
	/**
	 * Recursively traverse an object given a path of properties and set the given value
	 */


	exports.removeModel = removeModel;

	var recursiveSet = function recursiveSet(obj, path, value) {
	  if (!obj) {
	    return;
	  }

	  if (path.length > 1) {
	    recursiveSet(obj[path[0]], path.slice(1), value);
	  } else {
	    obj[path[0]] = value;
	  }
	};

	var overrides = new Map();
	/**
	 * Create an override on the specify layer, indexed by a valuePath array.
	 * Do nothing in case Seer as not been initialized to prevent any preformance drawback.
	 */

	var setOverride = function setOverride(id, valuePath, value) {
	  if (!_globals.window.__SEER_INITIALIZED__) {
	    return;
	  }

	  if (!overrides.has(id)) {
	    overrides.set(id, new Map());
	  }

	  var uniforms = overrides.get(id);
	  uniforms.set(valuePath, value);
	};
	/**
	 * Apply overrides to a specific model's uniforms
	 */


	exports.setOverride = setOverride;

	var getOverrides = function getOverrides(id, uniforms) {
	  if (!_globals.window.__SEER_INITIALIZED__ || !id) {
	    return;
	  }

	  var overs = overrides.get(id);

	  if (!overs) {
	    return;
	  }

	  overs.forEach(function (value, valuePath) {
	    recursiveSet(uniforms, valuePath, value);
	  });
	};
	/**
	 * Listen for luma.gl edit events
	 */


	exports.getOverrides = getOverrides;

	_seer.default.listenFor('luma.gl', function (payload) {
	  var model = models[payload.itemKey];

	  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {
	    return;
	  }

	  var valuePath = payload.valuePath.slice(1);
	  setOverride(payload.itemKey, valuePath, payload.value);
	  var uniforms = model.getUniforms();
	  recursiveSet(uniforms, valuePath, payload.value);
	  model.setUniforms(uniforms);
	});
	//# sourceMappingURL=seer-integration.js.map

/***/ }),
/* 189 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var isBrowser = typeof window !== 'undefined' && window.addEventListener;

	var timers = new Map();

	/**
	 * Ready check for Seer initialization
	 *
	 * @returns {Boolean}
	 */
	var isReady = function isReady() {
	  return isBrowser && window.__SEER_INITIALIZED__;
	};

	/**
	 * Utility method allowing to throttle a user action based on a key and a minimun delay.
	 *
	 * @param key {String} A unique key
	 * @param delay {Number} The minimal delay to throttle
	 * @returns {Boolean}
	 */
	var throttle = function throttle(key, delay) {
	  var time = timers.get(key);
	  var now = Date.now();
	  if (time && now - time < delay) {
	    return true;
	  }
	  timers.set(key, now);
	  return false;
	};

	var replacer = function replacer(seen) {
	  return function (key, value) {
	    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {
	      return;
	    }
	    seen.add(value);
	    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');
	    if (isArray) {
	      return Array.prototype.slice.call(value, 0, 20);
	    }
	    return value;
	  };
	};

	/**
	 * Low-level api leveraging window.postMessage
	 *
	 * @param type {String} The action type
	 * @param payload {Any} The action payload
	 */
	var send = function send(type) {
	  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  if (!isBrowser || !isReady()) {
	    return;
	  }

	  var seen = new Set();
	  var payload = JSON.stringify(data, replacer(seen));

	  try {
	    window.postMessage({ type: type, payload: payload, source: 'seer-agent' }, '*');
	  } catch (e) {
	    if (throttle('seer-log', 2E3)) {
	      return;
	    }
	    console.log(e); // eslint-disable-line
	  }
	};

	var listeners = new Map();

	var listener = function listener(message) {
	  if (!message || !message.data || message.data.source !== 'seer-core') {
	    return;
	  }
	  var _message$data = message.data,
	      type = _message$data.type,
	      payload = _message$data.payload;


	  var typeListeners = listeners.get(type);
	  if (typeListeners) {
	    typeListeners.forEach(function (cb) {
	      return cb(payload);
	    });
	  }
	};

	/**
	 * Initilize window listener. There will be only one for the whole process
	 * to prevent too many registrations.
	 *
	 * This method will be called automatically if you use the `listenFor` method.
	 */
	var init = function init() {
	  if (!isBrowser || window.__SEER_LISTENER__) {
	    return;
	  }
	  window.addEventListener('message', listener);
	  window.__SEER_LISTENER__ = true;
	};

	/**
	 * Clean listener. Can be useful in case you want to unregister upcoming events
	 * or liberate memory.
	 */
	var clean = function clean() {
	  if (!isBrowser || !window.__SEER_LISTENER__) {
	    return;
	  }
	  window.removeEventListener('message', listener);
	  delete window.__SEER_LISTENER__;
	};

	/**
	 * Create a listener that will be called upon events of the given key.
	 *
	 * @param key {String} The unique tab key
	 * @param cb {Function} A callback that will receive the message payload
	 */
	var listenFor = function listenFor(type, cb) {
	  if (!isBrowser) {
	    return;
	  }
	  if (!type || !cb) {
	    throw new Error('Please provide a type and callback');
	  }
	  if (!listeners.has(type)) {
	    listeners.set(type, []);
	  }
	  if (!window.__SEER_LISTENER__) {
	    init();
	  }
	  listeners.get(type).push(cb);
	};

	/**
	 * Remove an identity listener
	 *
	 * @param cb {Function} The callback to remove
	 */
	var removeListener = function removeListener(cb) {
	  listeners.forEach(function (typeListeners, key) {
	    listeners.set(key, typeListeners.filter(function (l) {
	      return l !== cb;
	    }));
	  });
	};

	/**
	 * Creates a new indexed list.
	 * It works by index to get O(1) accessing and performance.
	 *
	 * @param key {String} The key of the tab
	 * @param data {Object} The indexed object
	 */
	var list = function list(key, data) {
	  return send('LIST', { key: key, data: data });
	};

	/**
	 * Creates an element in the indexed list, based on the itemKey.
	 *
	 * @param key {String} The key of the tab
	 * @param itemKey {String} The key of the item
	 * @param data {Any} The value of the item
	 */
	var listItem = function listItem(key, itemKey) {
	  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  return send('LIST_ITEM', { key: key, itemKey: itemKey, data: data });
	};

	/**
	 * Update an item property, can be deeply nested.
	 *
	 * @param key {String} The key of the tab
	 * @param itemKey {String} The key of the item
	 * @param path {String} The path of the variable you want to update
	 * @param data {Object} The new value
	 */
	var updateItem = function updateItem(key, itemKey, path, data) {
	  return send('UPDATE_ITEM', { key: key, itemKey: itemKey, path: path, data: data });
	};

	/**
	 * Similar to updateItem, but allows to pass an array with {path,data} pairs for
	 * multiple update of the same item without having to send multiple messages.
	 *
	 * @param key {String} The key of the tab
	 * @param itemKey {String} The key of the item
	 * @param array {Array} The array of updates
	 * @param array.path {String} The path for this update
	 * @param array.data {Object} The value of this update
	 */
	var multiUpdate = function multiUpdate(key, itemKey, array) {
	  return send('MULTI_UPDATE_ITEM', { key: key, itemKey: itemKey, array: array });
	};

	/**
	 * Remove a specific item in a specific tab.
	 *
	 * @param key {String} They key of the tab
	 * @param itemKey {String} The key of the item
	 */
	var deleteItem = function deleteItem(key, itemKey) {
	  return send('DELETE_ITEM', { key: key, itemKey: itemKey });
	};

	/**
	 * Will create a log message to an item, that will be displayde with the current time.
	 *
	 * @param key {String} The key of the tab
	 * @param itemKey {String} The key of the item
	 * @param msg {String} The message to display
	 */
	var addLog = function addLog(key, itemKey, msg) {
	  return send('ADD_LOG', { key: key, itemKey: itemKey, msg: msg });
	};

	exports.default = {

	  send: send,
	  throttle: throttle,
	  isReady: isReady,

	  list: list,
	  listItem: listItem,
	  updateItem: updateItem,
	  multiUpdate: multiUpdate,
	  deleteItem: deleteItem,
	  addLog: addLog,

	  listeners: listeners,
	  listenFor: listenFor,
	  removeListener: removeListener,
	  init: init,
	  clean: clean

	};


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _webglContext = __webpack_require__(77);

	var _debugContext = __webpack_require__(74);

	var _webglUtils = __webpack_require__(48);

	var _utils = __webpack_require__(63);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _webgl = __webpack_require__(81);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var DEFAULT_GL_OPTIONS = {
	  preserveDrawingBuffer: true
	};

	var AnimationLoop =
	/*#__PURE__*/
	function () {
	  /*
	   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
	   */
	  function AnimationLoop() {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, AnimationLoop);

	    var _props$onCreateContex = props.onCreateContext,
	        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {
	      return (0, _webglContext.createGLContext)(opts);
	    } : _props$onCreateContex,
	        _props$onInitialize = props.onInitialize,
	        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,
	        _props$onRender = props.onRender,
	        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,
	        _props$onFinalize = props.onFinalize,
	        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,
	        _props$offScreen = props.offScreen,
	        offScreen = _props$offScreen === void 0 ? false : _props$offScreen,
	        _props$gl = props.gl,
	        gl = _props$gl === void 0 ? null : _props$gl,
	        _props$glOptions = props.glOptions,
	        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,
	        _props$debug = props.debug,
	        debug = _props$debug === void 0 ? false : _props$debug,
	        _props$createFramebuf = props.createFramebuffer,
	        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,
	        _props$autoResizeView = props.autoResizeViewport,
	        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,
	        _props$autoResizeDraw = props.autoResizeDrawingBuffer,
	        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw;
	    var _props$useDevicePixel = props.useDevicePixels,
	        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;

	    if ('useDevicePixelRatio' in props) {
	      _utils.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

	      useDevicePixels = props.useDevicePixelRatio;
	    }

	    this.props = {
	      onCreateContext: onCreateContext,
	      onInitialize: onInitialize,
	      onRender: onRender,
	      onFinalize: onFinalize,
	      gl: gl,
	      glOptions: glOptions,
	      debug: debug,
	      createFramebuffer: createFramebuffer
	    }; // state

	    this.gl = gl;
	    this.offScreen = offScreen;
	    this.needsRedraw = null;
	    this.setProps({
	      autoResizeViewport: autoResizeViewport,
	      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
	      useDevicePixels: useDevicePixels
	    }); // Bind methods

	    this.start = this.start.bind(this);
	    this.stop = this.stop.bind(this);
	    this._renderFrame = this._renderFrame.bind(this);
	    return this;
	  }

	  _createClass(AnimationLoop, [{
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw(reason) {
	      (0, _assert.default)(typeof reason === 'string');
	      this.needsRedraw = this.needsRedraw || reason;
	      return this;
	    }
	  }, {
	    key: "setProps",
	    value: function setProps(props) {
	      if ('autoResizeViewport' in props) {
	        this.autoResizeViewport = props.autoResizeViewport;
	      }

	      if ('autoResizeDrawingBuffer' in props) {
	        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
	      }

	      if ('useDevicePixels' in props) {
	        this.useDevicePixels = props.useDevicePixels;
	      }

	      return this;
	    } // Starts a render loop if not already running
	    // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)

	  }, {
	    key: "start",
	    value: function start() {
	      var _this = this;

	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      this._stopped = false; // console.debug(`Starting ${this.constructor.name}`);

	      if (!this._animationFrameId) {
	        // Wait for start promise before rendering frame
	        this._startPromise = _webglContext.pageLoadPromise.then(function () {
	          if (_this._stopped) {
	            return null;
	          } // Create the WebGL context


	          _this._createWebGLContext(opts);

	          _this._createFramebuffer(); // Initialize the callback data


	          _this._initializeCallbackData();

	          _this._updateCallbackData(); // Default viewport setup, in case onInitialize wants to render


	          _this._resizeCanvasDrawingBuffer();

	          _this._resizeViewport(); // Note: onIntialize can return a promise (in case it needs to load resources)


	          return _this.props.onInitialize(_this._callbackData);
	        }).then(function (appContext) {
	          if (!_this._stopped) {
	            _this._addCallbackData(appContext || {});

	            if (appContext !== false && !_this._animationFrameId) {
	              _this._animationFrameId = (0, _webglUtils.requestAnimationFrame)(_this._renderFrame);
	            }
	          }
	        });
	      }

	      return this;
	    } // Stops a render loop if already running, finalizing

	  }, {
	    key: "stop",
	    value: function stop() {
	      // console.debug(`Stopping ${this.constructor.name}`);
	      if (this._animationFrameId) {
	        this._finalizeCallbackData();

	        (0, _webglUtils.cancelAnimationFrame)(this._animationFrameId);
	        this._animationFrameId = null;
	        this._stopped = true;
	      }

	      return this;
	    } // DEPRECATED METHODS
	    // Update parameters

	  }, {
	    key: "setViewParameters",
	    value: function setViewParameters(_ref) {
	      var _ref$autoResizeDrawin = _ref.autoResizeDrawingBuffer,
	          autoResizeDrawingBuffer = _ref$autoResizeDrawin === void 0 ? true : _ref$autoResizeDrawin,
	          _ref$autoResizeCanvas = _ref.autoResizeCanvas,
	          autoResizeCanvas = _ref$autoResizeCanvas === void 0 ? true : _ref$autoResizeCanvas,
	          _ref$autoResizeViewpo = _ref.autoResizeViewport,
	          autoResizeViewport = _ref$autoResizeViewpo === void 0 ? true : _ref$autoResizeViewpo,
	          _ref$useDevicePixels = _ref.useDevicePixels,
	          useDevicePixels = _ref$useDevicePixels === void 0 ? true : _ref$useDevicePixels,
	          _ref$useDevicePixelRa = _ref.useDevicePixelRatio,
	          useDevicePixelRatio = _ref$useDevicePixelRa === void 0 ? null : _ref$useDevicePixelRa;

	      _utils.log.deprecated('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();

	      this.autoResizeViewport = autoResizeViewport;
	      this.autoResizeCanvas = autoResizeCanvas;
	      this.autoResizeDrawingBuffer = autoResizeDrawingBuffer;
	      this.useDevicePixels = useDevicePixels;

	      if (useDevicePixelRatio !== null) {
	        _utils.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

	        this.useDevicePixels = useDevicePixelRatio;
	      }

	      return this;
	    } // PRIVATE METHODS

	  }, {
	    key: "_setupFrame",
	    value: function _setupFrame() {
	      if (this._onSetupFrame) {
	        // call callback
	        this._onSetupFrame(this._callbackData); // end callback

	      } else {
	        this._resizeCanvasDrawingBuffer();

	        this._resizeViewport();

	        this._resizeFramebuffer();
	      }
	    }
	    /**
	     * @private
	     * Handles a render loop frame - updates context and calls the application
	     * callback
	     */

	  }, {
	    key: "_renderFrame",
	    value: function _renderFrame() {
	      if (this._stopped) {
	        return;
	      }

	      this._setupFrame();

	      this._updateCallbackData(); // call callback


	      this.props.onRender(this._callbackData); // end callback

	      if (this.offScreen) {
	        // commit returns a Promise
	        this.gl.commit().then(this._renderFrame);
	      } else {
	        // Request another render frame (now )
	        this._animationFrameId = (0, _webglUtils.requestAnimationFrame)(this._renderFrame);
	      }
	    } // Initialize the  object that will be passed to app callbacks

	  }, {
	    key: "_initializeCallbackData",
	    value: function _initializeCallbackData() {
	      this._callbackData = {
	        gl: this.gl,
	        canvas: this.gl.canvas,
	        framebuffer: this.framebuffer,
	        stop: this.stop,
	        // Initial values
	        useDevicePixels: this.useDevicePixels,
	        needsRedraw: null,
	        tick: 0,
	        tock: 0
	      };
	    } // Update the context object that will be passed to app callbacks

	  }, {
	    key: "_updateCallbackData",
	    value: function _updateCallbackData() {
	      // CallbackData width and height represent drawing buffer width and height
	      var width = this.gl.drawingBufferWidth;
	      var height = this.gl.drawingBufferHeight;

	      if (width !== this._callbackData.width || height !== this._callbackData.height) {
	        this.setNeedsRedraw('drawing buffer resized');
	      }

	      this._callbackData.width = width;
	      this._callbackData.height = height;
	      this._callbackData.aspect = width / height;
	      this._callbackData.needsRedraw = this.needsRedraw;
	      this._callbackData.offScreen = this.offScreen; // Update redraw reason

	      this._callbackData.needsRedraw = this.needsRedraw;
	      this.needsRedraw = null; // Increment tick

	      this._callbackData.tick++;
	    }
	  }, {
	    key: "_finalizeCallbackData",
	    value: function _finalizeCallbackData() {
	      // call callback
	      this.props.onFinalize(this._callbackData); // end callback
	    } // Add application's data to the app context object

	  }, {
	    key: "_addCallbackData",
	    value: function _addCallbackData(appContext) {
	      if (_typeof(appContext) === 'object' && appContext !== null) {
	        this._callbackData = Object.assign({}, this._callbackData, appContext);
	      }
	    } // Either uses supplied or existing context, or calls provided callback to create one

	  }, {
	    key: "_createWebGLContext",
	    value: function _createWebGLContext(opts) {
	      // Create the WebGL context if necessary
	      opts = Object.assign({}, opts, DEFAULT_GL_OPTIONS, this.props.glOptions);
	      this.gl = this.props.gl || this.props.onCreateContext(opts);

	      if (!(0, _webglUtils.isWebGL)(this.gl)) {
	        throw new Error('AnimationLoop.onCreateContext - illegal context returned');
	      }

	      if (this.props.debug) {
	        this.gl = (0, _debugContext.makeDebugContext)(this.gl);
	      } // Reset the WebGL context.


	      (0, _webglContext.resetParameters)(this.gl);
	    } // Default viewport setup

	  }, {
	    key: "_resizeViewport",
	    value: function _resizeViewport() {
	      if (this.autoResizeViewport) {
	        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
	      }
	    } // Resize the render buffer of the canvas to match canvas client size
	    // Optionally multiplying with devicePixel ratio

	  }, {
	    key: "_resizeCanvasDrawingBuffer",
	    value: function _resizeCanvasDrawingBuffer() {
	      if (this.autoResizeDrawingBuffer) {
	        (0, _webglContext.resizeGLContext)(this.gl, {
	          useDevicePixels: this.useDevicePixels
	        });
	      }
	    } // TBD - deprecated?

	  }, {
	    key: "_createFramebuffer",
	    value: function _createFramebuffer() {
	      // Setup default framebuffer
	      if (this.props.createFramebuffer) {
	        this.framebuffer = new _webgl.Framebuffer(this.gl);
	      }
	    }
	  }, {
	    key: "_resizeFramebuffer",
	    value: function _resizeFramebuffer() {
	      if (this.framebuffer) {
	        this.framebuffer.resize({
	          width: this.gl.drawingBufferWidth,
	          height: this.gl.drawingBufferHeight
	        });
	      }
	    }
	  }]);

	  return AnimationLoop;
	}();

	exports.default = AnimationLoop;
	//# sourceMappingURL=animation-loop.js.map

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _animationLoop = _interopRequireDefault(__webpack_require__(190));

	var _webglContext = __webpack_require__(77);

	var _webglUtils = __webpack_require__(48);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var AnimationLoopProxy =
	/*#__PURE__*/
	function () {
	  _createClass(AnimationLoopProxy, null, [{
	    key: "createWorker",
	    // Create the script for the rendering worker.
	    // @param opts {object} - options to construct an AnimationLoop instance
	    value: function createWorker(opts) {
	      return function (self) {
	        self.animationLoop = new _animationLoop.default(Object.assign({}, opts, {
	          offScreen: true,
	          // Prevent the animation loop from trying to access DOM properties
	          useDevicePixels: false,
	          autoResizeDrawingBuffer: false
	        }));
	        self.canvas = null;
	        self.addEventListener('message', function (evt) {
	          var animationLoop = self.animationLoop;

	          switch (evt.data.command) {
	            case 'start':
	              self.canvas = evt.data.opts.canvas;
	              animationLoop.start(evt.data.opts);
	              break;

	            case 'stop':
	              animationLoop.stop();
	              break;

	            case 'resize':
	              self.canvas.width = evt.data.width;
	              self.canvas.height = evt.data.height;
	              break;

	            default:
	          }
	        });
	      };
	    }
	    /*
	     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
	     */

	  }]);

	  function AnimationLoopProxy(_ref) {
	    var worker = _ref.worker,
	        _ref$onInitialize = _ref.onInitialize,
	        onInitialize = _ref$onInitialize === void 0 ? function () {} : _ref$onInitialize,
	        _ref$onFinalize = _ref.onFinalize,
	        onFinalize = _ref$onFinalize === void 0 ? function () {} : _ref$onFinalize,
	        _ref$useDevicePixels = _ref.useDevicePixels,
	        useDevicePixels = _ref$useDevicePixels === void 0 ? true : _ref$useDevicePixels,
	        _ref$autoResizeDrawin = _ref.autoResizeDrawingBuffer,
	        autoResizeDrawingBuffer = _ref$autoResizeDrawin === void 0 ? true : _ref$autoResizeDrawin;

	    _classCallCheck(this, AnimationLoopProxy);

	    this.props = {
	      worker: worker,
	      onInitialize: onInitialize,
	      onFinalize: onFinalize,
	      autoResizeDrawingBuffer: autoResizeDrawingBuffer,
	      useDevicePixels: useDevicePixels
	    }; // state

	    this.canvas = null;
	    this.width = null;
	    this.height = null;
	    this._stopped = true;
	    this._animationFrameId = null;
	    this._startPromise = null; // bind methods

	    this._updateFrame = this._updateFrame.bind(this);
	  }
	  /* Public methods */
	  // Starts a render loop if not already running


	  _createClass(AnimationLoopProxy, [{
	    key: "start",
	    value: function start() {
	      var _this = this;

	      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	      this._stopped = false; // console.debug(`Starting ${this.constructor.name}`);

	      if (!this._animationFrameId) {
	        // Wait for start promise before rendering frame
	        this._startPromise = (0, _webglContext.getPageLoadPromise)().then(function () {
	          _this._createAndTransferCanvas(opts);

	          return _this.props.onInitialize(_this);
	        }).then(function () {
	          if (!_this._stopped) {
	            _this._animationFrameId = (0, _webglUtils.requestAnimationFrame)(_this._updateFrame);
	          }
	        });
	      }

	      return this;
	    } // Stops a render loop if already running, finalizing

	  }, {
	    key: "stop",
	    value: function stop() {
	      if (this._animationFrameId) {
	        (0, _webglUtils.cancelAnimationFrame)(this._animationFrameId);
	        this._animationFrameId = null;
	        this._stopped = true;
	        this.props.onFinalize(this);
	      }

	      this.props.worker.postMessage({
	        command: 'stop'
	      });
	      return this;
	    } // PRIVATE METHODS

	  }, {
	    key: "_updateFrame",
	    value: function _updateFrame() {
	      this._resizeCanvasDrawingBuffer();

	      this._animationFrameId = (0, _webglUtils.requestAnimationFrame)(this._updateFrame);
	    }
	  }, {
	    key: "_createAndTransferCanvas",
	    value: function _createAndTransferCanvas(opts) {
	      // Create a canvas on the main thread
	      var screenCanvas = (0, _webglContext.createCanvas)(opts); // Create an offscreen canvas controlling the main canvas

	      if (!screenCanvas.transferControlToOffscreen) {
	        onError('OffscreenCanvas is not available. Enable Experimental canvas features in chrome://flags'); // eslint-disable-line
	      }

	      var offscreenCanvas = screenCanvas.transferControlToOffscreen(); // Transfer the offscreen canvas to the worker

	      this.props.worker.postMessage({
	        command: 'start',
	        opts: Object.assign({}, opts, {
	          canvas: offscreenCanvas
	        })
	      }, [offscreenCanvas]); // store the main canvas on the local thread

	      this.canvas = screenCanvas;
	    }
	  }, {
	    key: "_resizeCanvasDrawingBuffer",
	    value: function _resizeCanvasDrawingBuffer() {
	      if (this.props.autoResizeDrawingBuffer) {
	        var devicePixelRatio = this.props.useDevicePixels ? window.devicePixelRatio || 1 : 1;
	        var width = this.canvas.clientWidth * devicePixelRatio;
	        var height = this.canvas.clientHeight * devicePixelRatio;

	        if (this.width !== width || this.height !== height) {
	          this.width = width;
	          this.height = height;
	          this.props.worker.postMessage({
	            command: 'resize',
	            width: width,
	            height: height
	          });
	        }
	      }
	    }
	  }]);

	  return AnimationLoopProxy;
	}();

	exports.default = AnimationLoopProxy;
	//# sourceMappingURL=animation-loop-proxy.js.map

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = pickModels;

	var _webgl = __webpack_require__(81);

	var _utils = __webpack_require__(63);

	var _group = _interopRequireDefault(__webpack_require__(193));

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	var ILLEGAL_ARG = 'Illegal argument to pick';

	function getDevicePixelRatio() {
	  return typeof window !== 'undefined' ? window.devicePixelRatio : 1;
	}

	function pickModels(gl, _ref) {
	  var models = _ref.models,
	      position = _ref.position,
	      _ref$uniforms = _ref.uniforms,
	      uniforms = _ref$uniforms === void 0 ? {} : _ref$uniforms,
	      _ref$parameters = _ref.parameters,
	      parameters = _ref$parameters === void 0 ? {} : _ref$parameters,
	      settings = _ref.settings,
	      _ref$useDevicePixelRa = _ref.useDevicePixelRatio,
	      useDevicePixelRatio = _ref$useDevicePixelRa === void 0 ? null : _ref$useDevicePixelRa,
	      _ref$useDevicePixels = _ref.useDevicePixels,
	      useDevicePixels = _ref$useDevicePixels === void 0 ? true : _ref$useDevicePixels,
	      framebuffer = _ref.framebuffer;
	  (0, _assert.default)((0, _webgl.isWebGL)(gl), ILLEGAL_ARG);
	  (0, _assert.default)(framebuffer, ILLEGAL_ARG);
	  (0, _assert.default)(position, ILLEGAL_ARG);

	  if (useDevicePixelRatio !== null) {
	    _utils.log.deprecated('useDevicePixelRatio', 'useDevicePixels')();

	    useDevicePixels = useDevicePixelRatio;
	  }

	  var _position = _slicedToArray(position, 2),
	      x = _position[0],
	      y = _position[1]; // Match our picking framebuffer with the size of the canvas drawing buffer


	  framebuffer.resize({
	    width: gl.canvas.width,
	    height: gl.canvas.height
	  }); // Compensate for devicePixelRatio
	  // Note: this assumes the canvas framebuffer has been matched

	  var dpr = useDevicePixels ? getDevicePixelRatio() : 1; // Reverse the y coordinate

	  var deviceX = x * dpr;
	  var deviceY = gl.canvas.height - y * dpr; // return withParameters(gl, {
	  //   // framebuffer,
	  //   // // We are only interested in one pixel, no need to render anything else
	  //   // scissorTest: {x: deviceX, y: deviceY, w: 1, h: 1}
	  // }, () => {

	  var group = new _group.default({
	    children: models
	  });
	  return group.traverseReverse(function (model) {
	    if (model.isPickable()) {
	      // Clear the frame buffer
	      (0, _webgl.clear)(gl, {
	        framebuffer: framebuffer,
	        color: true,
	        depth: true
	      }); // Render picking colors

	      /* eslint-disable camelcase */

	      model.setUniforms({
	        picking_uActive: 1
	      });
	      model.draw({
	        uniforms: uniforms,
	        parameters: parameters,
	        settings: settings,
	        framebuffer: framebuffer
	      });
	      model.setUniforms({
	        picking_uActive: 0
	      }); // Sample Read color in the central pixel, to be mapped as a picking color

	      var color = framebuffer.readPixels({
	        x: deviceX,
	        y: deviceY,
	        width: 1,
	        height: 1,
	        format: gl.RGBA,
	        type: gl.UNSIGNED_BYTE
	      });
	      var isPicked = color[0] !== 0 || color[1] !== 0 || color[2] !== 0; // Add the information to the stack

	      if (isPicked) {
	        return {
	          model: model,
	          color: color,
	          x: x,
	          y: y,
	          deviceX: deviceX,
	          deviceY: deviceY
	        };
	      }
	    }

	    return null;
	  }); // });
	}
	//# sourceMappingURL=pick-models.js.map

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _object3d = _interopRequireDefault(__webpack_require__(108));

	var _math = __webpack_require__(109);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Group =
	/*#__PURE__*/
	function (_Object3D) {
	  _inherits(Group, _Object3D);

	  function Group() {
	    var _this;

	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Group);

	    var _opts$children = opts.children,
	        children = _opts$children === void 0 ? [] : _opts$children;
	    children.every(function (child) {
	      return (0, _assert.default)(_instanceof(child, _object3d.default));
	    });
	    _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, opts));
	    _this.children = children;
	    return _this;
	  } // Unpacks arrays and nested arrays of children


	  _createClass(Group, [{
	    key: "add",
	    value: function add() {
	      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {
	        children[_key] = arguments[_key];
	      }

	      for (var _i = 0; _i < children.length; _i++) {
	        var child = children[_i];

	        if (Array.isArray(child)) {
	          this.add.apply(this, _toConsumableArray(child));
	        } else {
	          this.children.push(child);
	        }
	      }

	      return this;
	    }
	  }, {
	    key: "remove",
	    value: function remove(child) {
	      var children = this.children;
	      var indexOf = children.indexOf(child);

	      if (indexOf > -1) {
	        children.splice(indexOf, 1);
	      }

	      return this;
	    }
	  }, {
	    key: "removeAll",
	    value: function removeAll() {
	      this.children = [];
	      return this;
	    } // If visitor returns a truthy value, traversal will be aborted and that value
	    // will be returned from `traverse`. Otherwise `traverse` will return null.

	  }, {
	    key: "traverse",
	    value: function traverse(visitor) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref$modelMatrix = _ref.modelMatrix,
	          modelMatrix = _ref$modelMatrix === void 0 ? new _math.Matrix4() : _ref$modelMatrix;

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var child = _step.value;
	          var matrix = child.matrix;
	          modelMatrix = modelMatrix.multiplyRight(matrix);
	          var result = void 0;

	          if (_instanceof(child, Group)) {
	            result = child.traverse(visitor, {
	              modelMatrix: modelMatrix
	            });
	          } else {
	            // child.setUniforms({modelMatrix});
	            result = visitor(child, {});
	          } // Abort if a result was returned


	          if (result) {
	            return result;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return null;
	    } // If visitor returns a truthy value, traversal will be aborted and that value
	    // will be returned from `traverseReverse`. Otherwise `traverseReverse` will return null.

	  }, {
	    key: "traverseReverse",
	    value: function traverseReverse(visitor) {
	      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref2$modelMatrix = _ref2.modelMatrix,
	          modelMatrix = _ref2$modelMatrix === void 0 ? new _math.Matrix4() : _ref2$modelMatrix;

	      for (var i = this.children.length - 1; i >= 0; --i) {
	        var child = this.children[i];
	        var matrix = child.matrix;
	        modelMatrix = modelMatrix.multiplyRight(matrix);
	        var result = void 0;

	        if (_instanceof(child, Group)) {
	          result = child.traverseReverse(visitor, {
	            modelMatrix: modelMatrix
	          });
	        } else {
	          // child.setUniforms({modelMatrix});
	          result = visitor(child, {});
	        } // Abort if a result was returned


	        if (result) {
	          return result;
	        }
	      }

	      return null;
	    }
	  }]);

	  return Group;
	}(_object3d.default);

	exports.default = Group;
	//# sourceMappingURL=group.js.map

/***/ }),
/* 194 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.encodePickingColor = encodePickingColor;
	exports.decodePickingColor = decodePickingColor;
	exports.getNullPickingColor = getNullPickingColor;

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	var NULL_PICKING_COLOR = new Uint8Array([0, 0, 0]); // Encodes an index as a Uint8Array([r, g, b]) format picking color

	function encodePickingColor(i) {
	  return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 16 & 255];
	} // Decodes a picking color in [r, g, b] format to an index


	function decodePickingColor(color) {
	  // assert(color instanceof Uint8Array);
	  var _color = _slicedToArray(color, 3),
	      i1 = _color[0],
	      i2 = _color[1],
	      i3 = _color[2]; // 1 was added to seperate from no selection


	  var index = i1 + i2 * 256 + i3 * 65536 - 1;
	  return index;
	} // Return picking color representing no item at that pixel


	function getNullPickingColor() {
	  return NULL_PICKING_COLOR;
	}
	//# sourceMappingURL=picking-colors.js.map

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "addEvents", {
	  enumerable: true,
	  get: function get() {
	    return _addEvents.addEvents;
	  }
	});

	var _addEvents = __webpack_require__(196);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 196 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.get = get;
	exports.getWheel = getWheel;
	exports.getKey = getKey;
	exports.isRightClick = isRightClick;
	exports.getPos = getPos;
	exports.stop = _stop;
	exports.addEvents = addEvents;
	exports.removeEvents = removeEvents;
	exports.Keys = exports.EventsProxy = void 0;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// event.js
	// Handle keyboard/mouse/touch events in the Canvas
	// TODO - this will not work under node

	/* eslint-disable dot-notation, max-statements, no-loop-func */

	/* global window, document */
	function noop() {}

	var KEYS = {
	  enter: 13,
	  up: 38,
	  down: 40,
	  left: 37,
	  right: 39,
	  esc: 27,
	  space: 32,
	  backspace: 8,
	  tab: 9,
	  delete: 46
	}; // returns an O3D object or false otherwise.

	function toO3D(n) {
	  return n !== true ? n : false;
	} // Returns an element position


	function _getPos(elem) {
	  var bbox = elem.getBoundingClientRect();
	  return {
	    x: bbox.left,
	    y: bbox.top,
	    bbox: bbox
	  };
	} // event object wrapper


	function get(e, win) {
	  win = win || window;
	  return e || win.event;
	}

	function getWheel(e) {
	  return e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
	}

	function getKey(e) {
	  var code = e.which || e.keyCode;
	  var key = keyOf(code); // onkeydown

	  var fKey = code - 111;

	  if (fKey > 0 && fKey < 13) {
	    key = "f".concat(fKey);
	  }

	  key = key || String.fromCharCode(code).toLowerCase();
	  return {
	    code: code,
	    key: key,
	    shift: e.shiftKey,
	    control: e.ctrlKey,
	    alt: e.altKey,
	    meta: e.metaKey
	  };
	}

	function isRightClick(e) {
	  return e.which === 3 || e.button === 2;
	}

	function getPos(e, win) {
	  // get mouse position
	  win = win || window;
	  e = e || win.event;
	  var doc = win.document;
	  doc = doc.documentElement || doc.body; // TODO(nico): make touch event handling better

	  if (e.touches && e.touches.length) {
	    var touchesPos = [];
	    var l = e.touches.length;
	    var evt;

	    for (var i = 0; i < l; ++i) {
	      evt = e.touches[i];
	      touchesPos.push({
	        x: evt.pageX || evt.clientX + doc.scrollLeft,
	        y: evt.pageY || evt.clientY + doc.scrollTop
	      });
	    }

	    return touchesPos;
	  }

	  var page = {
	    x: e.pageX || e.clientX + doc.scrollLeft,
	    y: e.pageY || e.clientY + doc.scrollTop
	  };
	  return [page];
	}

	function _stop(e) {
	  if (e.stopPropagation) {
	    e.stopPropagation();
	  }

	  e.cancelBubble = true;

	  if (e.preventDefault) {
	    e.preventDefault();
	  } else {
	    e.returnValue = false;
	  }
	}

	var EventsProxy =
	/*#__PURE__*/
	function () {
	  function EventsProxy(domElem, opt) {
	    _classCallCheck(this, EventsProxy);

	    this.scene = opt.scene;
	    this.domElem = domElem;
	    this.pos = _getPos(domElem);
	    this.opt = this.callbacks = opt;
	    this.size = {
	      width: domElem.width || domElem.offsetWidth,
	      height: domElem.height || domElem.offsetHeight
	    };
	    this.attachEvents();
	  }

	  _createClass(EventsProxy, [{
	    key: "attachEvents",
	    value: function attachEvents() {
	      var _this = this;

	      var domElem = this.domElem;
	      var opt = this.opt;

	      if (opt.disableContextMenu) {
	        domElem.oncontextmenu = function () {
	          return false;
	        };
	      }

	      if (opt.enableMouse) {
	        ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout'].forEach(function (action) {
	          domElem.addEventListener(action, function (e, win) {
	            _this[action](_this.eventInfo(action, e, win));
	          }, false);
	        }); // "well, this is embarrassing..."

	        var type = '';

	        if (!document.getBoxObjectFor && window.mozInnerScreenX === null) {
	          type = 'mousewheel';
	        } else {
	          type = 'DOMMouseScroll';
	        }

	        domElem.addEventListener(type, function (e, win) {
	          _this['mousewheel'](_this.eventInfo('mousewheel', e, win));
	        }, false);
	      }

	      if (opt.enableTouch) {
	        ['touchstart', 'touchmove', 'touchend'].forEach(function (action) {
	          domElem.addEventListener(action, function (e, win) {
	            _this[action](_this.eventInfo(action, e, win));
	          }, false);
	        });
	      }

	      if (opt.enableKeyboard) {
	        ['keydown', 'keyup'].forEach(function (action) {
	          document.addEventListener(action, function (e, win) {
	            _this[action](_this.eventInfo(action, e, win));
	          }, false);
	        });
	      }
	    }
	  }, {
	    key: "eventInfo",
	    value: function eventInfo(type, e, win) {
	      var domElem = this.domElem;
	      var scene = this.scene;
	      var opt = this.opt;
	      var size = this.getSize();
	      var relative = opt.relative;
	      var centerOrigin = opt.centerOrigin;

	      var pos = opt.cachePosition && this.pos || _getPos(domElem);

	      var ge = get(e, win);
	      var epos = getPos(e, win);
	      var origPos = {
	        x: epos[0].x,
	        y: epos[0].y
	      };
	      var evt = {};
	      var x;
	      var y; // get Position

	      for (var i = 0, l = epos.length; i < l; ++i) {
	        x = epos[i].x;
	        y = epos[i].y;

	        if (relative) {
	          x -= pos.x;
	          y -= pos.y;

	          if (centerOrigin) {
	            x -= size.width / 2;
	            y -= size.height / 2; // y axis now points to the top of the screen

	            y *= -1;
	          }
	        }

	        epos[i].x = x;
	        epos[i].y = y;
	      }

	      switch (type) {
	        case 'mousewheel':
	          evt.wheel = getWheel(ge);
	          break;

	        case 'keydown':
	        case 'keyup':
	          Object.assign(evt, getKey(ge));
	          break;

	        case 'mouseup':
	          evt.isRightClick = isRightClick(ge);
	          break;

	        default:
	          break;
	      }

	      var cacheTarget;
	      Object.assign(evt, {
	        x: epos[0].x,
	        y: epos[0].y,
	        posArray: epos,
	        cache: false,
	        // stop event propagation
	        stop: function stop() {
	          _stop(ge);
	        },
	        // get the target element of the event
	        getTarget: function getTarget() {
	          if (cacheTarget) {
	            return cacheTarget;
	          }

	          return cacheTarget = opt.picking && scene.pick(origPos.x - pos.x, origPos.y - pos.y) || true;
	        }
	      }); // wrap native event

	      evt.event = ge;
	      return evt;
	    }
	  }, {
	    key: "getSize",
	    value: function getSize() {
	      if (this.cacheSize) {
	        return this.size;
	      }

	      var domElem = this.domElem;
	      return {
	        width: domElem.width || domElem.offsetWidth,
	        height: domElem.height || domElem.offsetHeight
	      };
	    }
	  }, {
	    key: "mouseup",
	    value: function mouseup(e) {
	      if (!this.moved) {
	        if (e.isRightClick) {
	          this.callbacks.onRightClick(e, this.hovered);
	        } else {
	          this.callbacks.onClick(e, toO3D(this.pressed));
	        }
	      }

	      if (this.pressed) {
	        if (this.moved) {
	          this.callbacks.onDragEnd(e, toO3D(this.pressed));
	        } else {
	          this.callbacks.onDragCancel(e, toO3D(this.pressed));
	        }

	        this.pressed = this.moved = false;
	      }
	    }
	  }, {
	    key: "mouseout",
	    value: function mouseout(e) {
	      // mouseout canvas
	      var rt = e.relatedTarget;
	      var domElem = this.domElem;

	      while (rt && rt.parentNode) {
	        if (domElem === rt.parentNode) {
	          return;
	        }

	        rt = rt.parentNode;
	      }

	      if (this.hovered) {
	        this.callbacks.onMouseLeave(e, this.hovered);
	        this.hovered = false;
	      }

	      if (this.pressed && this.moved) {
	        this.callbacks.onDragEnd(e);
	        this.pressed = this.moved = false;
	      }
	    }
	  }, {
	    key: "mouseover",
	    value: function mouseover(e) {}
	  }, {
	    key: "mousemove",
	    value: function mousemove(e) {
	      if (this.pressed) {
	        this.moved = true;
	        this.callbacks.onDragMove(e, toO3D(this.pressed));
	        return;
	      }

	      if (this.hovered) {
	        var target = toO3D(e.getTarget());

	        if (!target || target.hash !== this.hash) {
	          this.callbacks.onMouseLeave(e, this.hovered);
	          this.hovered = target;
	          this.hash = target;

	          if (target) {
	            this.hash = target.hash;
	            this.callbacks.onMouseEnter(e, this.hovered);
	          }
	        } else {
	          this.callbacks.onMouseMove(e, this.hovered);
	        }
	      } else {
	        this.hovered = toO3D(e.getTarget());
	        this.hash = this.hovered;

	        if (this.hovered) {
	          this.hash = this.hovered.hash;
	          this.callbacks.onMouseEnter(e, this.hovered);
	        }
	      }

	      if (!this.opt.picking) {
	        this.callbacks.onMouseMove(e);
	      }
	    }
	  }, {
	    key: "mousewheel",
	    value: function mousewheel(e) {
	      this.callbacks.onMouseWheel(e);
	    }
	  }, {
	    key: "mousedown",
	    value: function mousedown(e) {
	      this.pressed = e.getTarget();
	      this.callbacks.onDragStart(e, toO3D(this.pressed));
	    }
	  }, {
	    key: "touchstart",
	    value: function touchstart(e) {
	      this.touched = e.getTarget();
	      this.touchedLastPosition = {
	        x: e.x,
	        y: e.y
	      };
	      this.callbacks.onTouchStart(e, toO3D(this.touched));
	    }
	  }, {
	    key: "touchmove",
	    value: function touchmove(e) {
	      if (this.touched) {
	        this.touchMoved = true;
	        this.callbacks.onTouchMove(e, toO3D(this.touched));
	      }
	    }
	  }, {
	    key: "touchend",
	    value: function touchend(e) {
	      if (this.touched) {
	        if (this.touchMoved) {
	          this.callbacks.onTouchEnd(e, toO3D(this.touched));
	        } else {
	          e.x = isNaN(e.x) ? this.touchedLastPosition.x : e.x;
	          e.y = isNaN(e.y) ? this.touchedLastPosition.y : e.y;
	          this.callbacks.onTap(e, toO3D(this.touched));
	          this.callbacks.onTouchCancel(e, toO3D(this.touched));
	        }

	        this.touched = this.touchMoved = false;
	      }
	    }
	  }, {
	    key: "keydown",
	    value: function keydown(e) {
	      this.callbacks.onKeyDown(e);
	    }
	  }, {
	    key: "keyup",
	    value: function keyup(e) {
	      this.callbacks.onKeyUp(e);
	    }
	  }]);

	  return EventsProxy;
	}();

	exports.EventsProxy = EventsProxy;
	Object.assign(EventsProxy.prototype, {
	  hovered: false,
	  pressed: false,
	  touched: false,
	  touchedLastPosition: {
	    x: 0,
	    y: 0
	  },
	  touchMoved: false,
	  moved: false
	});
	var DEFAULT_OPTS = {
	  cachePosition: true,
	  cacheSize: true,
	  relative: true,
	  centerOrigin: true,
	  disableContextMenu: true,
	  bind: false,
	  picking: false,
	  enableTouch: true,
	  enableMouse: true,
	  enableKeyboard: true,
	  onClick: noop,
	  onRightClick: noop,
	  onDragStart: noop,
	  onDragMove: noop,
	  onDragEnd: noop,
	  onDragCancel: noop,
	  onTouchStart: noop,
	  onTouchMove: noop,
	  onTouchEnd: noop,
	  onTouchCancel: noop,
	  onTap: noop,
	  onMouseMove: noop,
	  onMouseEnter: noop,
	  onMouseLeave: noop,
	  onMouseWheel: noop,
	  onKeyDown: noop,
	  onKeyUp: noop
	};
	var Keys = KEYS;
	exports.Keys = Keys;

	function keyOf(code) {
	  var keyMap = Keys;

	  for (var name in keyMap) {
	    if (keyMap[name] === code) {
	      return name;
	    }
	  }

	  return null;
	}

	function addEvents(domElement) {
	  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  opt = Object.assign({}, DEFAULT_OPTS, opt);
	  var bind = opt.bind;

	  if (bind) {
	    for (var name in opt) {
	      if (name.match(/^on[a-zA-Z0-9]+$/)) {
	        (function (fname, fn) {
	          opt[fname] = function f() {
	            fn.apply(bind, Array.prototype.slice.call(arguments));
	          };
	        })(name, opt[name]);
	      }
	    }
	  }

	  return new EventsProxy(domElement, opt);
	}

	function removeEvents(domElement) {
	  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  opt = Object.assign({}, DEFAULT_OPTS, opt);
	  var bind = opt.bind;

	  if (bind) {
	    for (var name in opt) {
	      if (name.match(/^on[a-zA-Z0-9]+$/)) {
	        (function (fname, fn) {
	          opt[fname] = function f() {
	            fn.apply(bind, Array.prototype.slice.call(arguments));
	          };
	        })(name, opt[name]);
	      }
	    }
	  }

	  return new EventsProxy(domElement, opt);
	}
	//# sourceMappingURL=add-events.js.map

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _truncatedConeGeometry = _interopRequireDefault(__webpack_require__(198));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var ConeGeometry =
	/*#__PURE__*/
	function (_TruncatedConeGeometr) {
	  _inherits(ConeGeometry, _TruncatedConeGeometr);

	  function ConeGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, ConeGeometry);

	    var _opts$radius = opts.radius,
	        radius = _opts$radius === void 0 ? 1 : _opts$radius,
	        _opts$cap = opts.cap,
	        cap = _opts$cap === void 0 ? true : _opts$cap;
	    return _possibleConstructorReturn(this, (ConeGeometry.__proto__ || Object.getPrototypeOf(ConeGeometry)).call(this, Object.assign({}, opts, {
	      topRadius: 0,
	      topCap: Boolean(cap),
	      bottomCap: Boolean(cap),
	      bottomRadius: radius
	    })));
	  }

	  return ConeGeometry;
	}(_truncatedConeGeometry.default);

	exports.default = ConeGeometry;
	//# sourceMappingURL=cone-geometry.js.map

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var INDEX_OFFSETS = {
	  x: [2, 0, 1],
	  y: [0, 1, 2],
	  z: [1, 2, 0]
	};

	var TruncatedConeGeometry =
	/*#__PURE__*/
	function (_Geometry) {
	  _inherits(TruncatedConeGeometry, _Geometry);

	  // Primitives inspired by TDL http://code.google.com/p/webglsamples/,
	  // copyright 2011 Google Inc. new BSD License
	  // (http://www.opensource.org/licenses/bsd-license.php).

	  /* eslint-disable max-statements, complexity */
	  function TruncatedConeGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, TruncatedConeGeometry);

	    var _opts$bottomRadius = opts.bottomRadius,
	        bottomRadius = _opts$bottomRadius === void 0 ? 0 : _opts$bottomRadius,
	        _opts$topRadius = opts.topRadius,
	        topRadius = _opts$topRadius === void 0 ? 0 : _opts$topRadius,
	        _opts$height = opts.height,
	        height = _opts$height === void 0 ? 1 : _opts$height,
	        _opts$nradial = opts.nradial,
	        nradial = _opts$nradial === void 0 ? 10 : _opts$nradial,
	        _opts$nvertical = opts.nvertical,
	        nvertical = _opts$nvertical === void 0 ? 10 : _opts$nvertical,
	        _opts$verticalAxis = opts.verticalAxis,
	        verticalAxis = _opts$verticalAxis === void 0 ? 'y' : _opts$verticalAxis,
	        _opts$topCap = opts.topCap,
	        topCap = _opts$topCap === void 0 ? false : _opts$topCap,
	        _opts$bottomCap = opts.bottomCap,
	        bottomCap = _opts$bottomCap === void 0 ? false : _opts$bottomCap;
	    var extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
	    var numVertices = (nradial + 1) * (nvertical + 1 + extra);
	    var slant = Math.atan2(bottomRadius - topRadius, height);
	    var msin = Math.sin;
	    var mcos = Math.cos;
	    var mpi = Math.PI;
	    var cosSlant = mcos(slant);
	    var sinSlant = msin(slant);
	    var start = topCap ? -2 : 0;
	    var end = nvertical + (bottomCap ? 2 : 0);
	    var vertsAroundEdge = nradial + 1;
	    var positions = new Float32Array(numVertices * 3);
	    var normals = new Float32Array(numVertices * 3);
	    var texCoords = new Float32Array(numVertices * 2);
	    var indices = new Uint16Array(nradial * (nvertical + extra) * 6);
	    var indexOffset = INDEX_OFFSETS[verticalAxis];
	    var i3 = 0;
	    var i2 = 0;

	    for (var i = start; i <= end; i++) {
	      var v = i / nvertical;
	      var y = height * v;
	      var ringRadius = void 0;

	      if (i < 0) {
	        y = 0;
	        v = 1;
	        ringRadius = bottomRadius;
	      } else if (i > nvertical) {
	        y = height;
	        v = 1;
	        ringRadius = topRadius;
	      } else {
	        ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
	      }

	      if (i === -2 || i === nvertical + 2) {
	        ringRadius = 0;
	        v = 0;
	      }

	      y -= height / 2;

	      for (var j = 0; j < vertsAroundEdge; j++) {
	        var sin = msin(j * mpi * 2 / nradial);
	        var cos = mcos(j * mpi * 2 / nradial);
	        positions[i3 + indexOffset[0]] = sin * ringRadius;
	        positions[i3 + indexOffset[1]] = y;
	        positions[i3 + indexOffset[2]] = cos * ringRadius;
	        normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
	        normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
	        normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;
	        texCoords[i2 + 0] = j / nradial;
	        texCoords[i2 + 1] = v;
	        i2 += 2;
	        i3 += 3;
	      }
	    }

	    for (var _i = 0; _i < nvertical + extra; _i++) {
	      for (var _j = 0; _j < nradial; _j++) {
	        var index = (_i * nradial + _j) * 6;
	        indices[index + 0] = vertsAroundEdge * (_i + 0) + 0 + _j;
	        indices[index + 1] = vertsAroundEdge * (_i + 0) + 1 + _j;
	        indices[index + 2] = vertsAroundEdge * (_i + 1) + 1 + _j;
	        indices[index + 3] = vertsAroundEdge * (_i + 0) + 0 + _j;
	        indices[index + 4] = vertsAroundEdge * (_i + 1) + 1 + _j;
	        indices[index + 5] = vertsAroundEdge * (_i + 1) + 0 + _j;
	      }
	    }

	    return _possibleConstructorReturn(this, (TruncatedConeGeometry.__proto__ || Object.getPrototypeOf(TruncatedConeGeometry)).call(this, Object.assign({}, opts, {
	      attributes: {
	        positions: positions,
	        normals: normals,
	        texCoords: texCoords,
	        indices: indices
	      }
	    })));
	  }

	  return TruncatedConeGeometry;
	}(_geometry.default);

	exports.default = TruncatedConeGeometry;
	//# sourceMappingURL=truncated-cone-geometry.js.map

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	var _utils = __webpack_require__(63);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CubeGeometry =
	/*#__PURE__*/
	function (_Geometry) {
	  _inherits(CubeGeometry, _Geometry);

	  function CubeGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, CubeGeometry);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('cube-geometry') : _opts$id;
	    return _possibleConstructorReturn(this, (CubeGeometry.__proto__ || Object.getPrototypeOf(CubeGeometry)).call(this, Object.assign({}, opts, {
	      id: id,
	      attributes: getCubeAttributes()
	    })));
	  }

	  return CubeGeometry;
	}(_geometry.default);
	/* eslint-disable no-multi-spaces, indent */


	exports.default = CubeGeometry;
	var CUBE_INDICES = new Uint16Array([0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23]);
	var CUBE_POSITIONS = new Float32Array([-1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, 1, -1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1, 1, -1]);
	var CUBE_NORMALS = new Float32Array([// Front face
	0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, // Back face
	0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, // Top face
	0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // Bottom face
	0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, // Right face
	1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, // Left face
	-1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0]);
	var CUBE_TEX_COORDS = new Float32Array([// Front face
	0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // Back face
	1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // Top face
	0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, // Bottom face
	1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // Right face
	1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // Left face
	0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]);
	/* eslint-enable no-multi-spaces, indent */

	function getCubeAttributes() {
	  return {
	    indices: new Uint16Array(CUBE_INDICES),
	    positions: new Float32Array(CUBE_POSITIONS),
	    normals: new Float32Array(CUBE_NORMALS),
	    texCoords: new Float32Array(CUBE_TEX_COORDS)
	  };
	}
	//# sourceMappingURL=cube-geometry.js.map

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _truncatedConeGeometry = _interopRequireDefault(__webpack_require__(198));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CylinderGeometry =
	/*#__PURE__*/
	function (_TruncatedConeGeometr) {
	  _inherits(CylinderGeometry, _TruncatedConeGeometr);

	  function CylinderGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, CylinderGeometry);

	    var _opts$radius = opts.radius,
	        radius = _opts$radius === void 0 ? 1 : _opts$radius;
	    return _possibleConstructorReturn(this, (CylinderGeometry.__proto__ || Object.getPrototypeOf(CylinderGeometry)).call(this, Object.assign({}, opts, {
	      bottomRadius: radius,
	      topRadius: radius
	    })));
	  }

	  return CylinderGeometry;
	}(_truncatedConeGeometry.default);

	exports.default = CylinderGeometry;
	//# sourceMappingURL=cylinder-geometry.js.map

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/* eslint-disable comma-spacing, max-statements, complexity */
	var ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
	var ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

	var IcoSphereGeometry =
	/*#__PURE__*/
	function (_Geometry) {
	  _inherits(IcoSphereGeometry, _Geometry);

	  function IcoSphereGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, IcoSphereGeometry);

	    var _opts$iterations = opts.iterations,
	        iterations = _opts$iterations === void 0 ? 0 : _opts$iterations;
	    var PI = Math.PI;
	    var PI2 = PI * 2;
	    var positions = ICO_POSITIONS.concat();
	    var indices = ICO_INDICES.concat();
	    positions.push();
	    indices.push();

	    var getMiddlePoint = function () {
	      var pointMemo = {};
	      return function (i1, i2) {
	        i1 *= 3;
	        i2 *= 3;
	        var mini = i1 < i2 ? i1 : i2;
	        var maxi = i1 > i2 ? i1 : i2;
	        var key = "".concat(mini, "|").concat(maxi);

	        if (key in pointMemo) {
	          return pointMemo[key];
	        }

	        var x1 = positions[i1];
	        var y1 = positions[i1 + 1];
	        var z1 = positions[i1 + 2];
	        var x2 = positions[i2];
	        var y2 = positions[i2 + 1];
	        var z2 = positions[i2 + 2];
	        var xm = (x1 + x2) / 2;
	        var ym = (y1 + y2) / 2;
	        var zm = (z1 + z2) / 2;
	        var len = Math.sqrt(xm * xm + ym * ym + zm * zm);
	        xm /= len;
	        ym /= len;
	        zm /= len;
	        positions.push(xm, ym, zm);
	        return pointMemo[key] = positions.length / 3 - 1;
	      };
	    }();

	    for (var i = 0; i < iterations; i++) {
	      var indices2 = [];

	      for (var j = 0; j < indices.length; j += 3) {
	        var a = getMiddlePoint(indices[j + 0], indices[j + 1]);
	        var b = getMiddlePoint(indices[j + 1], indices[j + 2]);
	        var c = getMiddlePoint(indices[j + 2], indices[j + 0]);
	        indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
	      }

	      indices = indices2;
	    } // Calculate texCoords and normals


	    var normals = new Array(indices.length * 3);
	    var texCoords = new Array(indices.length * 2);
	    var l = indices.length;

	    for (var _i = l - 3; _i >= 0; _i -= 3) {
	      var i1 = indices[_i + 0];
	      var i2 = indices[_i + 1];
	      var i3 = indices[_i + 2];
	      var in1 = i1 * 3;
	      var in2 = i2 * 3;
	      var in3 = i3 * 3;
	      var iu1 = i1 * 2;
	      var iu2 = i2 * 2;
	      var iu3 = i3 * 2;
	      var x1 = positions[in1 + 0];
	      var y1 = positions[in1 + 1];
	      var z1 = positions[in1 + 2];
	      var theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
	      var phi1 = Math.atan2(y1, x1) + PI;
	      var v1 = theta1 / PI;
	      var u1 = 1 - phi1 / PI2;
	      var x2 = positions[in2 + 0];
	      var y2 = positions[in2 + 1];
	      var z2 = positions[in2 + 2];
	      var theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
	      var phi2 = Math.atan2(y2, x2) + PI;
	      var v2 = theta2 / PI;
	      var u2 = 1 - phi2 / PI2;
	      var x3 = positions[in3 + 0];
	      var y3 = positions[in3 + 1];
	      var z3 = positions[in3 + 2];
	      var theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
	      var phi3 = Math.atan2(y3, x3) + PI;
	      var v3 = theta3 / PI;
	      var u3 = 1 - phi3 / PI2;
	      var vec1 = [x3 - x2, y3 - y2, z3 - z2];
	      var vec2 = [x1 - x2, y1 - y2, z1 - z2];
	      var normal = new _math.Vector3(vec1).cross(vec2).normalize();
	      var newIndex = void 0;

	      if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {
	        positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
	        newIndex = positions.length / 3 - 1;
	        indices.push(newIndex);
	        texCoords[newIndex * 2 + 0] = 1;
	        texCoords[newIndex * 2 + 1] = v1;
	        normals[newIndex * 3 + 0] = normal.x;
	        normals[newIndex * 3 + 1] = normal.y;
	        normals[newIndex * 3 + 2] = normal.z;
	        positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
	        newIndex = positions.length / 3 - 1;
	        indices.push(newIndex);
	        texCoords[newIndex * 2 + 0] = 1;
	        texCoords[newIndex * 2 + 1] = v2;
	        normals[newIndex * 3 + 0] = normal.x;
	        normals[newIndex * 3 + 1] = normal.y;
	        normals[newIndex * 3 + 2] = normal.z;
	        positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
	        newIndex = positions.length / 3 - 1;
	        indices.push(newIndex);
	        texCoords[newIndex * 2 + 0] = 1;
	        texCoords[newIndex * 2 + 1] = v3;
	        normals[newIndex * 3 + 0] = normal.x;
	        normals[newIndex * 3 + 1] = normal.y;
	        normals[newIndex * 3 + 2] = normal.z;
	      }

	      normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
	      normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
	      normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;
	      texCoords[iu1 + 0] = u1;
	      texCoords[iu1 + 1] = v1;
	      texCoords[iu2 + 0] = u2;
	      texCoords[iu2 + 1] = v2;
	      texCoords[iu3 + 0] = u3;
	      texCoords[iu3 + 1] = v3;
	    }

	    return _possibleConstructorReturn(this, (IcoSphereGeometry.__proto__ || Object.getPrototypeOf(IcoSphereGeometry)).call(this, Object.assign({}, opts, {
	      attributes: {
	        positions: new Float32Array(positions),
	        normals: new Float32Array(normals),
	        texCoords: new Float32Array(texCoords),
	        indices: new Uint16Array(indices)
	      }
	    })));
	  }

	  return IcoSphereGeometry;
	}(_geometry.default);

	exports.default = IcoSphereGeometry;
	//# sourceMappingURL=ico-sphere-geometry.js.map

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	var _utils = __webpack_require__(63);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var PlaneGeometry =
	/*#__PURE__*/
	function (_Geometry) {
	  _inherits(PlaneGeometry, _Geometry);

	  // Primitives inspired by TDL http://code.google.com/p/webglsamples/,
	  // copyright 2011 Google Inc. new BSD License
	  // (http://www.opensource.org/licenses/bsd-license.php).

	  /* eslint-disable max-statements, complexity */

	  /* eslint-disable complexity, max-statements */
	  function PlaneGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, PlaneGeometry);

	    var _opts$type = opts.type,
	        type = _opts$type === void 0 ? 'x,y' : _opts$type,
	        _opts$offset = opts.offset,
	        offset = _opts$offset === void 0 ? 0 : _opts$offset,
	        _opts$flipCull = opts.flipCull,
	        flipCull = _opts$flipCull === void 0 ? false : _opts$flipCull,
	        _opts$unpack = opts.unpack,
	        unpack = _opts$unpack === void 0 ? false : _opts$unpack,
	        _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('plane-geometry') : _opts$id;
	    var coords = type.split(','); // width, height

	    var c1len = opts["".concat(coords[0], "len")];
	    var c2len = opts["".concat(coords[1], "len")]; // subdivisionsWidth, subdivisionsDepth

	    var subdivisions1 = opts["n".concat(coords[0])] || 1;
	    var subdivisions2 = opts["n".concat(coords[1])] || 1;
	    var numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);
	    var positions = new Float32Array(numVertices * 3);
	    var normals = new Float32Array(numVertices * 3);
	    var texCoords = new Float32Array(numVertices * 2);

	    if (flipCull) {
	      c1len = -c1len;
	    }

	    var i2 = 0;
	    var i3 = 0;

	    for (var z = 0; z <= subdivisions2; z++) {
	      for (var x = 0; x <= subdivisions1; x++) {
	        var u = x / subdivisions1;
	        var v = z / subdivisions2;
	        texCoords[i2 + 0] = flipCull ? 1 - u : u;
	        texCoords[i2 + 1] = v;

	        switch (type) {
	          case 'x,y':
	            positions[i3 + 0] = c1len * u - c1len * 0.5;
	            positions[i3 + 1] = c2len * v - c2len * 0.5;
	            positions[i3 + 2] = offset;
	            normals[i3 + 0] = 0;
	            normals[i3 + 1] = 0;
	            normals[i3 + 2] = flipCull ? 1 : -1;
	            break;

	          case 'x,z':
	            positions[i3 + 0] = c1len * u - c1len * 0.5;
	            positions[i3 + 1] = offset;
	            positions[i3 + 2] = c2len * v - c2len * 0.5;
	            normals[i3 + 0] = 0;
	            normals[i3 + 1] = flipCull ? 1 : -1;
	            normals[i3 + 2] = 0;
	            break;

	          case 'y,z':
	            positions[i3 + 0] = offset;
	            positions[i3 + 1] = c1len * u - c1len * 0.5;
	            positions[i3 + 2] = c2len * v - c2len * 0.5;
	            normals[i3 + 0] = flipCull ? 1 : -1;
	            normals[i3 + 1] = 0;
	            normals[i3 + 2] = 0;
	            break;

	          default:
	            break;
	        }

	        i2 += 2;
	        i3 += 3;
	      }
	    }

	    var numVertsAcross = subdivisions1 + 1;
	    var indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

	    for (var _z = 0; _z < subdivisions2; _z++) {
	      for (var _x = 0; _x < subdivisions1; _x++) {
	        var index = (_z * subdivisions1 + _x) * 6; // Make triangle 1 of quad.

	        indices[index + 0] = (_z + 0) * numVertsAcross + _x;
	        indices[index + 1] = (_z + 1) * numVertsAcross + _x;
	        indices[index + 2] = (_z + 0) * numVertsAcross + _x + 1; // Make triangle 2 of quad.

	        indices[index + 3] = (_z + 1) * numVertsAcross + _x;
	        indices[index + 4] = (_z + 1) * numVertsAcross + _x + 1;
	        indices[index + 5] = (_z + 0) * numVertsAcross + _x + 1;
	      }
	    } // Optionally, unpack indexed geometry


	    if (unpack) {
	      var positions2 = new Float32Array(indices.length * 3);
	      var normals2 = new Float32Array(indices.length * 3);
	      var texCoords2 = new Float32Array(indices.length * 2);

	      for (var _x2 = 0; _x2 < indices.length; ++_x2) {
	        var _index = indices[_x2];
	        positions2[_x2 * 3 + 0] = positions[_index * 3 + 0];
	        positions2[_x2 * 3 + 1] = positions[_index * 3 + 1];
	        positions2[_x2 * 3 + 2] = positions[_index * 3 + 2];
	        normals2[_x2 * 3 + 0] = normals[_index * 3 + 0];
	        normals2[_x2 * 3 + 1] = normals[_index * 3 + 1];
	        normals2[_x2 * 3 + 2] = normals[_index * 3 + 2];
	        texCoords2[_x2 * 2 + 0] = texCoords[_index * 2 + 0];
	        texCoords2[_x2 * 2 + 1] = texCoords[_index * 2 + 1];
	      }

	      positions = positions2;
	      normals = normals2;
	      texCoords = texCoords2;
	      indices = undefined;
	    }

	    var attributes = {
	      positions: positions,
	      normals: normals,
	      texCoords: texCoords
	    };

	    if (indices) {
	      attributes.indices = indices;
	    }

	    return _possibleConstructorReturn(this, (PlaneGeometry.__proto__ || Object.getPrototypeOf(PlaneGeometry)).call(this, Object.assign({}, opts, {
	      attributes: attributes,
	      id: id
	    })));
	  }

	  return PlaneGeometry;
	}(_geometry.default);

	exports.default = PlaneGeometry;
	//# sourceMappingURL=plane-geometry.js.map

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	var _utils = __webpack_require__(63);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SphereGeometry =
	/*#__PURE__*/
	function (_Geometry) {
	  _inherits(SphereGeometry, _Geometry);

	  function SphereGeometry() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, SphereGeometry);

	    var _opts$nlat = opts.nlat,
	        nlat = _opts$nlat === void 0 ? 10 : _opts$nlat,
	        _opts$nlong = opts.nlong,
	        nlong = _opts$nlong === void 0 ? 10 : _opts$nlong,
	        _opts$radius = opts.radius,
	        radius = _opts$radius === void 0 ? 1 : _opts$radius,
	        _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('sphere-geometry') : _opts$id;
	    return _possibleConstructorReturn(this, (SphereGeometry.__proto__ || Object.getPrototypeOf(SphereGeometry)).call(this, Object.assign({}, opts, {
	      id: id,
	      attributes: getSphereAttributes(nlat, nlong, radius)
	    })));
	  }

	  return SphereGeometry;
	}(_geometry.default); // Primitives inspired by TDL http://code.google.com/p/webglsamples/,
	// copyright 2011 Google Inc. new BSD License
	// (http://www.opensource.org/licenses/bsd-license.php).

	/* eslint-disable max-statements, complexity */


	exports.default = SphereGeometry;

	function getSphereAttributes(nlat, nlong, radius) {
	  var startLat = 0;
	  var endLat = Math.PI;
	  var latRange = endLat - startLat;
	  var startLong = 0;
	  var endLong = 2 * Math.PI;
	  var longRange = endLong - startLong;
	  var numVertices = (nlat + 1) * (nlong + 1);

	  if (typeof radius === 'number') {
	    var value = radius;

	    radius = function radius(n1, n2, n3, u, v) {
	      return value;
	    };
	  }

	  var positions = new Float32Array(numVertices * 3);
	  var normals = new Float32Array(numVertices * 3);
	  var texCoords = new Float32Array(numVertices * 2);
	  var indices = new Uint16Array(nlat * nlong * 6); // Create positions, normals and texCoords

	  for (var y = 0; y <= nlat; y++) {
	    for (var x = 0; x <= nlong; x++) {
	      var u = x / nlong;
	      var v = y / nlat;
	      var index = x + y * (nlong + 1);
	      var i2 = index * 2;
	      var i3 = index * 3;
	      var theta = longRange * u;
	      var phi = latRange * v;
	      var sinTheta = Math.sin(theta);
	      var cosTheta = Math.cos(theta);
	      var sinPhi = Math.sin(phi);
	      var cosPhi = Math.cos(phi);
	      var ux = cosTheta * sinPhi;
	      var uy = cosPhi;
	      var uz = sinTheta * sinPhi;
	      var r = radius(ux, uy, uz, u, v);
	      positions[i3 + 0] = r * ux;
	      positions[i3 + 1] = r * uy;
	      positions[i3 + 2] = r * uz;
	      normals[i3 + 0] = ux;
	      normals[i3 + 1] = uy;
	      normals[i3 + 2] = uz;
	      texCoords[i2 + 0] = u;
	      texCoords[i2 + 1] = v;
	    }
	  } // Create indices


	  var numVertsAround = nlat + 1;

	  for (var _x = 0; _x < nlat; _x++) {
	    for (var _y = 0; _y < nlong; _y++) {
	      var _index = (_x * nlong + _y) * 6;

	      indices[_index + 0] = _y * numVertsAround + _x;
	      indices[_index + 1] = _y * numVertsAround + _x + 1;
	      indices[_index + 2] = (_y + 1) * numVertsAround + _x;
	      indices[_index + 3] = (_y + 1) * numVertsAround + _x;
	      indices[_index + 4] = _y * numVertsAround + _x + 1;
	      indices[_index + 5] = (_y + 1) * numVertsAround + _x + 1;
	    }
	  }

	  return {
	    positions: positions,
	    indices: indices,
	    normals: normals,
	    texCoords: texCoords
	  };
	}
	//# sourceMappingURL=sphere-geometry.js.map

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = __webpack_require__(205);

	var _core = __webpack_require__(206);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Cone =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(Cone, _Model);

	  function Cone(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Cone);

	    return _possibleConstructorReturn(this, (Cone.__proto__ || Object.getPrototypeOf(Cone)).call(this, gl, Object.assign({}, opts, {
	      geometry: new _geometry.ConeGeometry(opts)
	    })));
	  }

	  return Cone;
	}(_core.Model);

	exports.default = Cone;
	//# sourceMappingURL=cone.js.map

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "Geometry", {
	  enumerable: true,
	  get: function get() {
	    return _geometry.default;
	  }
	});
	Object.defineProperty(exports, "ConeGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _coneGeometry.default;
	  }
	});
	Object.defineProperty(exports, "CubeGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _cubeGeometry.default;
	  }
	});
	Object.defineProperty(exports, "CylinderGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _cylinderGeometry.default;
	  }
	});
	Object.defineProperty(exports, "IcoSphereGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _icoSphereGeometry.default;
	  }
	});
	Object.defineProperty(exports, "PlaneGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _planeGeometry.default;
	  }
	});
	Object.defineProperty(exports, "SphereGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _sphereGeometry.default;
	  }
	});
	Object.defineProperty(exports, "TruncatedConeGeometry", {
	  enumerable: true,
	  get: function get() {
	    return _truncatedConeGeometry.default;
	  }
	});

	var _geometry = _interopRequireDefault(__webpack_require__(107));

	var _coneGeometry = _interopRequireDefault(__webpack_require__(197));

	var _cubeGeometry = _interopRequireDefault(__webpack_require__(199));

	var _cylinderGeometry = _interopRequireDefault(__webpack_require__(200));

	var _icoSphereGeometry = _interopRequireDefault(__webpack_require__(201));

	var _planeGeometry = _interopRequireDefault(__webpack_require__(202));

	var _sphereGeometry = _interopRequireDefault(__webpack_require__(203));

	var _truncatedConeGeometry = _interopRequireDefault(__webpack_require__(198));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "AnimationLoop", {
	  enumerable: true,
	  get: function get() {
	    return _animationLoop.default;
	  }
	});
	Object.defineProperty(exports, "AnimationLoopProxy", {
	  enumerable: true,
	  get: function get() {
	    return _animationLoopProxy.default;
	  }
	});
	Object.defineProperty(exports, "Model", {
	  enumerable: true,
	  get: function get() {
	    return _model.default;
	  }
	});

	var _animationLoop = _interopRequireDefault(__webpack_require__(190));

	var _animationLoopProxy = _interopRequireDefault(__webpack_require__(191));

	var _model = _interopRequireDefault(__webpack_require__(106));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = __webpack_require__(205);

	var _core = __webpack_require__(206);

	var _utils = __webpack_require__(63);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Cube =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(Cube, _Model);

	  function Cube(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Cube);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('cube') : _opts$id;
	    return _possibleConstructorReturn(this, (Cube.__proto__ || Object.getPrototypeOf(Cube)).call(this, gl, Object.assign({}, opts, {
	      id: id,
	      geometry: new _geometry.CubeGeometry(opts)
	    })));
	  }

	  return Cube;
	}(_core.Model);

	exports.default = Cube;
	//# sourceMappingURL=cube.js.map

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = __webpack_require__(205);

	var _model = _interopRequireDefault(__webpack_require__(106));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Cylinder =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(Cylinder, _Model);

	  function Cylinder(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Cylinder);

	    return _possibleConstructorReturn(this, (Cylinder.__proto__ || Object.getPrototypeOf(Cylinder)).call(this, gl, Object.assign({}, opts, {
	      geometry: new _geometry.CylinderGeometry(opts)
	    })));
	  }

	  return Cylinder;
	}(_model.default);

	exports.default = Cylinder;
	//# sourceMappingURL=cylinder.js.map

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _core = __webpack_require__(206);

	var _geometry = __webpack_require__(205);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var IcoSphere =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(IcoSphere, _Model);

	  function IcoSphere(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, IcoSphere);

	    return _possibleConstructorReturn(this, (IcoSphere.__proto__ || Object.getPrototypeOf(IcoSphere)).call(this, gl, Object.assign({}, opts, {
	      geometry: new _geometry.IcoSphereGeometry(opts)
	    })));
	  }

	  return IcoSphere;
	}(_core.Model);

	exports.default = IcoSphere;
	//# sourceMappingURL=ico-sphere.js.map

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = __webpack_require__(205);

	var _model = _interopRequireDefault(__webpack_require__(106));

	var _utils = __webpack_require__(63);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Plane =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(Plane, _Model);

	  function Plane(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Plane);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('plane') : _opts$id;
	    return _possibleConstructorReturn(this, (Plane.__proto__ || Object.getPrototypeOf(Plane)).call(this, gl, Object.assign({}, opts, {
	      id: id,
	      geometry: new _geometry.PlaneGeometry(opts)
	    })));
	  }

	  return Plane;
	}(_model.default);

	exports.default = Plane;
	//# sourceMappingURL=plane.js.map

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _core = __webpack_require__(206);

	var _geometry = __webpack_require__(205);

	var _utils = __webpack_require__(63);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var Sphere =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(Sphere, _Model);

	  function Sphere(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Sphere);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? (0, _utils.uid)('sphere') : _opts$id;
	    return _possibleConstructorReturn(this, (Sphere.__proto__ || Object.getPrototypeOf(Sphere)).call(this, gl, Object.assign({}, opts, {
	      id: id,
	      geometry: new _geometry.SphereGeometry(opts)
	    })));
	  }

	  return Sphere;
	}(_core.Model);

	exports.default = Sphere;
	//# sourceMappingURL=sphere.js.map

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _geometry = __webpack_require__(205);

	var _core = __webpack_require__(206);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var TruncatedCone =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(TruncatedCone, _Model);

	  function TruncatedCone(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, TruncatedCone);

	    return _possibleConstructorReturn(this, (TruncatedCone.__proto__ || Object.getPrototypeOf(TruncatedCone)).call(this, gl, Object.assign({}, opts, {
	      geometry: new _geometry.TruncatedConeGeometry(opts)
	    })));
	  }

	  return TruncatedCone;
	}(_core.Model);

	exports.default = TruncatedCone;
	//# sourceMappingURL=truncated-cone.js.map

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _core = __webpack_require__(206);

	var _geometry = __webpack_require__(205);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var CLIPSPACE_QUAD_VERTEX_SHADER = "attribute vec2 aClipSpacePosition;\nattribute vec2 aTexCoord;\nattribute vec2 aCoordinate;\n\nvarying vec2 position;\nvarying vec2 coordinate;\nvarying vec2 uv;\n\nvoid main(void) {\n  gl_Position = vec4(aClipSpacePosition, 0., 1.);\n  position = aClipSpacePosition;\n  coordinate = aCoordinate;\n  uv = aTexCoord;\n}\n";
	/* eslint-disable indent, no-multi-spaces */

	var POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];

	var ClipSpaceQuad =
	/*#__PURE__*/
	function (_Model) {
	  _inherits(ClipSpaceQuad, _Model);

	  function ClipSpaceQuad(gl, opts) {
	    var _this;

	    _classCallCheck(this, ClipSpaceQuad);

	    var TEX_COORDS = POSITIONS.map(function (coord) {
	      return coord === -1 ? 0 : coord;
	    });
	    _this = _possibleConstructorReturn(this, (ClipSpaceQuad.__proto__ || Object.getPrototypeOf(ClipSpaceQuad)).call(this, gl, Object.assign({}, opts, {
	      vs: CLIPSPACE_QUAD_VERTEX_SHADER,
	      geometry: new _geometry.Geometry({
	        drawMode: _constants.default.TRIANGLE_STRIP,
	        vertexCount: 4,
	        attributes: {
	          aClipSpacePosition: {
	            size: 2,
	            value: new Float32Array(POSITIONS)
	          },
	          aTexCoord: {
	            size: 2,
	            value: new Float32Array(TEX_COORDS)
	          },
	          aCoordinate: {
	            size: 2,
	            value: new Float32Array(TEX_COORDS)
	          }
	        }
	      })
	    })));

	    _this.setVertexCount(4);

	    return _this;
	  }

	  return ClipSpaceQuad;
	}(_core.Model);

	exports.default = ClipSpaceQuad;
	//# sourceMappingURL=clip-space-quad.js.map

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "setPathPrefix", {
	  enumerable: true,
	  get: function get() {
	    return _browserLoad.setPathPrefix;
	  }
	});
	Object.defineProperty(exports, "loadFile", {
	  enumerable: true,
	  get: function get() {
	    return _browserLoad.loadFile;
	  }
	});
	Object.defineProperty(exports, "loadImage", {
	  enumerable: true,
	  get: function get() {
	    return _browserLoad.loadImage;
	  }
	});
	Object.defineProperty(exports, "loadFiles", {
	  enumerable: true,
	  get: function get() {
	    return _loadFiles.loadFiles;
	  }
	});
	Object.defineProperty(exports, "loadImages", {
	  enumerable: true,
	  get: function get() {
	    return _loadFiles.loadImages;
	  }
	});
	Object.defineProperty(exports, "loadTextures", {
	  enumerable: true,
	  get: function get() {
	    return _loadFiles.loadTextures;
	  }
	});
	Object.defineProperty(exports, "loadProgram", {
	  enumerable: true,
	  get: function get() {
	    return _loadFiles.loadProgram;
	  }
	});
	Object.defineProperty(exports, "loadModel", {
	  enumerable: true,
	  get: function get() {
	    return _loadFiles.loadModel;
	  }
	});
	Object.defineProperty(exports, "parseModel", {
	  enumerable: true,
	  get: function get() {
	    return _loadFiles.parseModel;
	  }
	});

	var _browserLoad = __webpack_require__(215);

	var _loadFiles = __webpack_require__(217);
	//# sourceMappingURL=index.js.map

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.setPathPrefix = setPathPrefix;
	exports.loadFile = loadFile;
	exports.loadImage = loadImage;

	var _browserRequestFile = __webpack_require__(216);

	var pathPrefix = '';
	/*
	 * Set a relative path prefix
	 */

	function setPathPrefix(prefix) {
	  pathPrefix = prefix;
	}

	function loadFile(url, opts) {
	  if (typeof url !== 'string' && !opts) {
	    // TODO - warn for deprecated mode
	    opts = url;
	    url = opts.url;
	  }

	  opts.url = pathPrefix ? pathPrefix + url : url;
	  return (0, _browserRequestFile.requestFile)(opts);
	}
	/* global Image */

	/*
	 * Loads images asynchronously
	 * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'
	 * returns a promise tracking the load
	 */


	function loadImage(url, opts) {
	  url = pathPrefix ? pathPrefix + url : url;
	  return new Promise(function (resolve, reject) {
	    try {
	      var image = new Image();

	      image.onload = function () {
	        return resolve(image);
	      };

	      image.onerror = function () {
	        return reject(new Error("Could not load image ".concat(url, ".")));
	      };

	      image.crossOrigin = opts && opts.crossOrigin || 'anonymous';
	      image.src = url;
	    } catch (error) {
	      reject(error);
	    }
	  });
	}
	//# sourceMappingURL=browser-load.js.map

/***/ }),
/* 216 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.requestFile = requestFile;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Supports loading (requesting) assets with XHR (XmlHttpRequest)

	/* eslint-disable guard-for-in, complexity, no-try-catch */

	/* global XMLHttpRequest */
	function noop() {}

	var XHR_STATES = {
	  UNINITIALIZED: 0,
	  LOADING: 1,
	  LOADED: 2,
	  INTERACTIVE: 3,
	  COMPLETED: 4
	};

	var XHR =
	/*#__PURE__*/
	function () {
	  function XHR(_ref) {
	    var url = _ref.url,
	        _ref$path = _ref.path,
	        path = _ref$path === void 0 ? null : _ref$path,
	        _ref$method = _ref.method,
	        method = _ref$method === void 0 ? 'GET' : _ref$method,
	        _ref$asynchronous = _ref.asynchronous,
	        asynchronous = _ref$asynchronous === void 0 ? true : _ref$asynchronous,
	        _ref$noCache = _ref.noCache,
	        noCache = _ref$noCache === void 0 ? false : _ref$noCache,
	        _ref$sendAsBinary = _ref.sendAsBinary,
	        sendAsBinary = _ref$sendAsBinary === void 0 ? false : _ref$sendAsBinary,
	        _ref$responseType = _ref.responseType,
	        responseType = _ref$responseType === void 0 ? false : _ref$responseType,
	        _ref$onProgress = _ref.onProgress,
	        onProgress = _ref$onProgress === void 0 ? noop : _ref$onProgress,
	        _ref$onError = _ref.onError,
	        onError = _ref$onError === void 0 ? noop : _ref$onError,
	        _ref$onAbort = _ref.onAbort,
	        onAbort = _ref$onAbort === void 0 ? noop : _ref$onAbort,
	        _ref$onComplete = _ref.onComplete,
	        onComplete = _ref$onComplete === void 0 ? noop : _ref$onComplete;

	    _classCallCheck(this, XHR);

	    this.url = path ? path.join(path, url) : url;
	    this.method = method;
	    this.async = asynchronous;
	    this.noCache = noCache;
	    this.sendAsBinary = sendAsBinary;
	    this.responseType = responseType;
	    this.req = new XMLHttpRequest();

	    this.req.onload = function (e) {
	      return onComplete(e);
	    };

	    this.req.onerror = function (e) {
	      return onError(e);
	    };

	    this.req.onabort = function (e) {
	      return onAbort(e);
	    };

	    this.req.onprogress = function (e) {
	      if (e.lengthComputable) {
	        onProgress(e, Math.round(e.loaded / e.total * 100));
	      } else {
	        onProgress(e, -1);
	      }
	    };
	  }

	  _createClass(XHR, [{
	    key: "setRequestHeader",
	    value: function setRequestHeader(header, value) {
	      this.req.setRequestHeader(header, value);
	      return this;
	    } // /* eslint-disable max-statements */

	  }, {
	    key: "sendAsync",
	    value: function sendAsync() {
	      var _this = this;

	      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.body || null;
	      return new Promise(function (resolve, reject) {
	        try {
	          var req = _this.req,
	              method = _this.method,
	              noCache = _this.noCache,
	              sendAsBinary = _this.sendAsBinary,
	              responseType = _this.responseType;
	          var url = noCache ? _this.url + (_this.url.indexOf('?') >= 0 ? '&' : '?') + Date.now() : _this.url;
	          req.open(method, url, _this.async);

	          if (responseType) {
	            req.responseType = responseType;
	          }

	          if (_this.async) {
	            req.onreadystatechange = function (e) {
	              if (req.readyState === XHR_STATES.COMPLETED) {
	                if (req.status === 200) {
	                  resolve(req.responseType ? req.response : req.responseText);
	                } else {
	                  reject(new Error("".concat(req.status, ": ").concat(url)));
	                }
	              }
	            };
	          }

	          if (sendAsBinary) {
	            req.sendAsBinary(body);
	          } else {
	            req.send(body);
	          }

	          if (!_this.async) {
	            if (req.status === 200) {
	              resolve(req.responseType ? req.response : req.responseText);
	            } else {
	              reject(new Error("".concat(req.status, ": ").concat(url)));
	            }
	          }
	        } catch (error) {
	          reject(error);
	        }
	      });
	    }
	    /* eslint-enable max-statements */

	  }]);

	  return XHR;
	}();

	function requestFile(opts) {
	  var xhr = new XHR(opts);
	  return xhr.sendAsync();
	}
	//# sourceMappingURL=browser-request-file.js.map

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.loadTexture = loadTexture;
	exports.loadFiles = loadFiles;
	exports.loadImages = loadImages;
	exports.loadTextures = loadTextures;
	exports.loadProgram = loadProgram;
	exports.loadModel = loadModel;
	exports.parseModel = parseModel;

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _browserLoad = __webpack_require__(215);

	var _webgl = __webpack_require__(81);

	var _core = __webpack_require__(206);

	var _geometry = __webpack_require__(205);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function noop() {}

	function loadTexture(gl, url) {
	  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	  var urls = opts.urls,
	      _opts$onProgress = opts.onProgress,
	      onProgress = _opts$onProgress === void 0 ? noop : _opts$onProgress;
	  (0, _assert.default)(typeof url === 'string', 'loadTexture: url must be string');
	  return loadImages(Object.assign({
	    urls: urls,
	    onProgress: onProgress
	  }, opts)).then(function (images) {
	    return images.map(function (img, i) {
	      return new _webgl.Texture2D(gl, Object.assign({
	        id: urls[i]
	      }, opts, {
	        data: img
	      }));
	    });
	  });
	}
	/*
	 * Loads (Requests) multiple files asynchronously
	 */


	function loadFiles() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var urls = opts.urls,
	      _opts$onProgress2 = opts.onProgress,
	      onProgress = _opts$onProgress2 === void 0 ? noop : _opts$onProgress2;
	  (0, _assert.default)(urls.every(function (url) {
	    return typeof url === 'string';
	  }), 'loadImages: {urls} must be array of strings');
	  var count = 0;
	  return Promise.all(urls.map(function (url) {
	    var promise = (0, _browserLoad.loadFile)(Object.assign({
	      url: url
	    }, opts));
	    promise.then(function (file) {
	      return onProgress({
	        progress: ++count / urls.length,
	        count: count,
	        total: urls.length,
	        url: url
	      });
	    });
	    return promise;
	  }));
	}
	/*
	 * Loads (requests) multiple images asynchronously
	 */


	function loadImages() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	  var urls = opts.urls,
	      _opts$onProgress3 = opts.onProgress,
	      onProgress = _opts$onProgress3 === void 0 ? noop : _opts$onProgress3;
	  (0, _assert.default)(urls.every(function (url) {
	    return typeof url === 'string';
	  }), 'loadImages: {urls} must be array of strings');
	  var count = 0;
	  return Promise.all(urls.map(function (url) {
	    var promise = (0, _browserLoad.loadImage)(url, opts);
	    promise.then(function (file) {
	      return onProgress({
	        progress: ++count / urls.length,
	        count: count,
	        total: urls.length,
	        url: url
	      });
	    });
	    return promise;
	  }));
	}

	function loadTextures(gl) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var urls = opts.urls,
	      _opts$onProgress4 = opts.onProgress,
	      onProgress = _opts$onProgress4 === void 0 ? noop : _opts$onProgress4;
	  (0, _assert.default)(urls.every(function (url) {
	    return typeof url === 'string';
	  }), 'loadTextures: {urls} must be array of strings');
	  return loadImages(Object.assign({
	    urls: urls,
	    onProgress: onProgress
	  }, opts)).then(function (images) {
	    return images.map(function (img, i) {
	      var params = Array.isArray(opts.parameters) ? opts.parameters[i] : opts.parameters;
	      params = params === undefined ? {} : params;
	      return new _webgl.Texture2D(gl, Object.assign({
	        id: urls[i]
	      }, params, {
	        data: img
	      }));
	    });
	  });
	}

	function loadProgram(gl) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var vs = opts.vs,
	      fs = opts.fs,
	      _opts$onProgress5 = opts.onProgress,
	      onProgress = _opts$onProgress5 === void 0 ? noop : _opts$onProgress5;
	  return loadFiles(Object.assign({
	    urls: [vs, fs],
	    onProgress: onProgress
	  }, opts)).then(function (_ref) {
	    var _ref2 = _slicedToArray(_ref, 2),
	        vsText = _ref2[0],
	        fsText = _ref2[1];

	    return new _webgl.Program(gl, Object.assign({
	      vs: vsText,
	      fs: fsText
	    }, opts));
	  });
	} // Loads a simple JSON format


	function loadModel(gl) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var url = opts.url,
	      _opts$onProgress6 = opts.onProgress,
	      onProgress = _opts$onProgress6 === void 0 ? noop : _opts$onProgress6;
	  return loadFiles(Object.assign({
	    urls: [url],
	    onProgress: onProgress
	  }, opts)).then(function (_ref3) {
	    var _ref4 = _slicedToArray(_ref3, 1),
	        file = _ref4[0];

	    return parseModel(gl, Object.assign({
	      file: file
	    }, opts));
	  });
	}

	function parseModel(gl) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var file = opts.file,
	      _opts$program = opts.program,
	      program = _opts$program === void 0 ? new _webgl.Program(gl) : _opts$program;
	  var json = typeof file === 'string' ? parseJSON(file) : file; // Remove any attributes so that we can create a geometry
	  // TODO - change format to put these in geometry sub object?

	  var attributes = {};
	  var modelOptions = {};

	  for (var key in json) {
	    var value = json[key];

	    if (Array.isArray(value)) {
	      attributes[key] = key === 'indices' ? new Uint16Array(value) : new Float32Array(value);
	    } else {
	      modelOptions[key] = value;
	    }
	  }

	  return new _core.Model(gl, Object.assign({
	    program: program,
	    geometry: new _geometry.Geometry({
	      attributes: attributes
	    })
	  }, modelOptions, opts));
	}

	function parseJSON(file) {
	  try {
	    return JSON.parse(file);
	  } catch (error) {
	    throw new Error("Failed to parse JSON: ".concat(error));
	  }
	}
	//# sourceMappingURL=load-files.js.map

/***/ }),
/* 218 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 0.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 0.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
	var _default = {
	  name: 'fp32',
	  vs: fp32shader,
	  fs: null
	};
	exports.default = _default;
	//# sourceMappingURL=fp32.js.map

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "fp64ify", {
	  enumerable: true,
	  get: function get() {
	    return _fp64Utils.fp64ify;
	  }
	});
	Object.defineProperty(exports, "fp64LowPart", {
	  enumerable: true,
	  get: function get() {
	    return _fp64Utils.fp64LowPart;
	  }
	});
	Object.defineProperty(exports, "fp64ifyMatrix4", {
	  enumerable: true,
	  get: function get() {
	    return _fp64Utils.fp64ifyMatrix4;
	  }
	});
	exports.fp64fs = exports.fp64arithmetic = exports.default = void 0;

	var _fp64Utils = __webpack_require__(220);

	var _fp64Arithmetic = _interopRequireDefault(__webpack_require__(221));

	var _fp64Functions = _interopRequireDefault(__webpack_require__(222));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var fp64shader = "".concat(_fp64Arithmetic.default, "\n").concat(_fp64Functions.default);
	var _default = {
	  name: 'fp64',
	  vs: fp64shader,
	  fs: null,
	  fp64ify: _fp64Utils.fp64ify,
	  fp64LowPart: _fp64Utils.fp64LowPart,
	  fp64ifyMatrix4: _fp64Utils.fp64ifyMatrix4
	}; // Arithmetic only

	exports.default = _default;
	var fp64arithmetic = {
	  name: 'fp64-arithmetic',
	  vs: "".concat(_fp64Arithmetic.default),
	  fs: null
	}; // Fragment shader fp64

	exports.fp64arithmetic = fp64arithmetic;
	var fp64fs = {
	  name: 'fp64-fs',
	  vs: null,
	  fs: fp64shader
	};
	exports.fp64fs = fp64fs;
	//# sourceMappingURL=fp64.js.map

/***/ }),
/* 220 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.fp64ify = fp64ify;
	exports.fp64LowPart = fp64LowPart;
	exports.fp64ifyMatrix4 = fp64ifyMatrix4;

	/**
	 * Calculate WebGL 64 bit float
	 * @param a {number} - the input float number
	 * @param out {array, optional} - the output array. If not supplied, a new array is created.
	 * @param startIndex {integer, optional} - the index in the output array to fill from. Default 0.
	 * @returns {array} - the fp64 representation of the input number
	 */
	function fp64ify(a) {
	  var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
	  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  var hiPart = Math.fround(a);
	  var loPart = a - hiPart;
	  out[startIndex] = hiPart;
	  out[startIndex + 1] = loPart;
	  return out;
	}
	/**
	 * Calculate the low part of a WebGL 64 bit float
	 * @param a {number} - the input float number
	 * @returns {number} - the lower 32 bit of the number
	 */


	function fp64LowPart(a) {
	  return a - Math.fround(a);
	}
	/**
	 * Calculate WebGL 64 bit matrix (transposed "Float64Array")
	 * @param matrix {Matrix4} - the input matrix
	 * @returns {array} - the fp64 representation of the input matrix
	 */


	function fp64ifyMatrix4(matrix) {
	  // Transpose the projection matrix to column major for GLSL.
	  var matrixFP64 = new Float32Array(32);

	  for (var i = 0; i < 4; ++i) {
	    for (var j = 0; j < 4; ++j) {
	      var index = i * 4 + j;
	      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
	    }
	  }

	  return matrixFP64;
	}
	//# sourceMappingURL=fp64-utils.js.map

/***/ }),
/* 221 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "uniform float ONE;\n\n/*\nAbout LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n\nThe purpose of this workaround is to prevent shader compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' from.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be 1 only at runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\n// Divide float number to high and low floats to extend fraction bits\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * ONE - (t - a);\n  float a_lo = a * ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\n\n// Divide float number again when high float uses too many fraction bits\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\n\n// Special sum operation when a > b\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * ONE;\n  float err = b - (sum - a) * ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\n\n// General sum operation\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * ONE - a) * ONE;\n  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *\n    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n";
	exports.default = _default;
	//# sourceMappingURL=fp64-arithmetic.glsl.js.map

/***/ }),
/* 222 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);\nconst vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);\nconst vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);\nconst vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);\nconst vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);\nconst vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);\nconst vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);\nconst vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);\nconst vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);\nconst vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);\n\nconst vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);\nconst vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);\nconst vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);\nconst vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);\n\nconst vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);\nconst vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);\nconst vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);\nconst vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);\n\nconst vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!\nconst vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!\nconst vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!\nconst vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!\nconst vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!\nconst vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!\nconst vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!\nconst vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!\n\nfloat nint(float d) {\n    if (d == floor(d)) return d;\n    return floor(d + 0.5);\n}\n\nvec2 nint_fp64(vec2 a) {\n    float hi = nint(a.x);\n    float lo;\n    vec2 tmp;\n    if (hi == a.x) {\n        lo = nint(a.y);\n        tmp = quickTwoSum(hi, lo);\n    } else {\n        lo = 0.0;\n        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {\n            hi -= 1.0;\n        }\n        tmp = vec2(hi, lo);\n    }\n    return tmp;\n}\n\n/* k_power controls how much range reduction we would like to have\nRange reduction uses the following method:\nassume a = k_power * r + m * log(2), k and m being integers.\nSet k_power = 4 (we can choose other k to trade accuracy with performance.\nwe only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;\n*/\n\nvec2 exp_fp64(vec2 a) {\n  // We need to make sure these two numbers match\n  // as bit-wise shift is not available in GLSL 1.0\n  const int k_power = 4;\n  const float k = 16.0;\n\n  const float inv_k = 1.0 / k;\n\n  if (a.x <= -88.0) return vec2(0.0, 0.0);\n  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);\n  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);\n  if (a.x == 1.0 && a.y == 0.0) return E_FP64;\n\n  float m = floor(a.x / LOG2_FP64.x + 0.5);\n  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;\n  vec2 s, t, p;\n\n  p = mul_fp64(r, r);\n  s = sum_fp64(r, p * 0.5);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);\n\n  s = sum_fp64(s, t);\n  p = mul_fp64(p, r);\n  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);\n\n  // s = sum_fp64(s, t);\n  // p = mul_fp64(p, r);\n  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);\n\n  s = sum_fp64(s, t);\n\n\n  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.\n  for (int i = 0; i < k_power; i++) {\n    s = sum_fp64(s * 2.0, mul_fp64(s, s));\n  }\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = sum_fp64(s, vec2(ONE, 0.0));\n#else\n  s = sum_fp64(s, vec2(1.0, 0.0));\n#endif\n\n  return s * pow(2.0, m);\n//   return r;\n}\n\nvec2 log_fp64(vec2 a)\n{\n  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n  vec2 x = vec2(log(a.x), 0.0);\n  vec2 s;\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n  s = vec2(ONE, 0.0);\n#else\n  s = vec2(1.0, 0.0);\n#endif\n\n  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);\n  return x;\n}\n\nvec2 sin_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(0.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  s = a;\n  r = a;\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvec2 cos_taylor_fp64(vec2 a) {\n  vec2 r, s, t, x;\n\n  if (a.x == 0.0 && a.y == 0.0) {\n    return vec2(1.0, 0.0);\n  }\n\n  x = -mul_fp64(a, a);\n  r = x;\n  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);\n  s = sum_fp64(s, t);\n\n  r = mul_fp64(r, x);\n  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);\n  s = sum_fp64(s, t);\n\n  /* keep the following commented code in case we need them\n  for extra accuracy from the Taylor expansion*/\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);\n  // s = sum_fp64(s, t);\n\n  // r = mul_fp64(r, x);\n  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);\n  // s = sum_fp64(s, t);\n\n  return s;\n}\n\nvoid sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {\n  if (a.x == 0.0 && a.y == 0.0) {\n    sin_t = vec2(0.0, 0.0);\n    cos_t = vec2(1.0, 0.0);\n  }\n\n  sin_t = sin_taylor_fp64(a);\n  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));\n}\n\nvec2 sin_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return sin_taylor_fp64(t);\n        } else if (j == 1) {\n            return cos_taylor_fp64(t);\n        } else if (j == -1) {\n            return -cos_taylor_fp64(t);\n        } else {\n            return -sin_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 cos_fp64(vec2 a) {\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(1.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n\n    if (k == 0) {\n        if (j == 0) {\n            return cos_taylor_fp64(t);\n        } else if (j == 1) {\n            return -sin_taylor_fp64(t);\n        } else if (j == -1) {\n            return sin_taylor_fp64(t);\n        } else {\n            return -cos_taylor_fp64(t);\n        }\n    }\n\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n    if (abs(float(abs_k) - 1.0) < 0.5) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs(float(abs_k) - 2.0) < 0.5) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs(float(abs_k) - 3.0) < 0.5) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs(float(abs_k) - 4.0) < 0.5) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#else\n    if (abs_k == 1) {\n        u = COS_TABLE_0_FP64;\n        v = SIN_TABLE_0_FP64;\n    } else if (abs_k == 2) {\n        u = COS_TABLE_1_FP64;\n        v = SIN_TABLE_1_FP64;\n    } else if (abs_k == 3) {\n        u = COS_TABLE_2_FP64;\n        v = SIN_TABLE_2_FP64;\n    } else if (abs_k == 4) {\n        u = COS_TABLE_3_FP64;\n        v = SIN_TABLE_3_FP64;\n    }\n#endif\n\n    vec2 sin_t, cos_t;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    vec2 result = vec2(0.0, 0.0);\n    if (j == 0) {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    } else if (j == 1) {\n        if (k > 0) {\n            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));\n        }\n    } else if (j == -1) {\n        if (k > 0) {\n            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        } else {\n            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n        }\n    } else {\n        if (k > 0) {\n            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));\n        } else {\n            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    return result;\n}\n\nvec2 tan_fp64(vec2 a) {\n    vec2 sin_a;\n    vec2 cos_a;\n\n    if (a.x == 0.0 && a.y == 0.0) {\n        return vec2(0.0, 0.0);\n    }\n\n    // 2pi range reduction\n    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));\n    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));\n\n    vec2 t;\n    float q = floor(r.x / PI_2_FP64.x + 0.5);\n    int j = int(q);\n\n\n    if (j < -2 || j > 2) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    }\n\n    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));\n\n    q = floor(t.x / PI_16_FP64.x + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    // We just can't get PI/16 * 3.0 very accurately.\n    // so let's just store it\n    if (abs_k > 4) {\n        return vec2(0.0 / 0.0, 0.0 / 0.0);\n    } else {\n        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));\n    }\n\n\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n\n    vec2 sin_t, cos_t;\n    vec2 s, c;\n    sincos_taylor_fp64(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#else\n        if (abs_k == 1) {\n            u = COS_TABLE_0_FP64;\n            v = SIN_TABLE_0_FP64;\n        } else if (abs_k == 2) {\n            u = COS_TABLE_1_FP64;\n            v = SIN_TABLE_1_FP64;\n        } else if (abs_k == 3) {\n            u = COS_TABLE_2_FP64;\n            v = SIN_TABLE_2_FP64;\n        } else if (abs_k == 4) {\n            u = COS_TABLE_3_FP64;\n            v = SIN_TABLE_3_FP64;\n        }\n#endif\n        if (k > 0) {\n            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        } else {\n            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));\n            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return div_fp64(sin_a, cos_a);\n}\n\nvec2 radians_fp64(vec2 degree) {\n  return mul_fp64(degree, PI_180_FP64);\n}\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\n// Vector functions\n// vec2 functions\nvoid vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sum_fp64(a[0], b[0]);\n    out_val[1] = sum_fp64(a[1], b[1]);\n}\n\nvoid vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = sub_fp64(a[0], b[0]);\n    out_val[1] = sub_fp64(a[1], b[1]);\n}\n\nvoid vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = mul_fp64(a[0], b[0]);\n    out_val[1] = mul_fp64(a[1], b[1]);\n}\n\nvoid vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {\n    out_val[0] = div_fp64(a[0], b[0]);\n    out_val[1] = div_fp64(a[1], b[1]);\n}\n\nvoid vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {\n  vec2 range[2];\n  vec2_sub_fp64(y, x, range);\n  vec2 portion[2];\n  portion[0] = range[0] * a;\n  portion[1] = range[1] * a;\n  vec2_sum_fp64(x, portion, out_val);\n}\n\nvec2 vec2_length_fp64(vec2 x[2]) {\n  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));\n}\n\nvoid vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {\n  vec2 length = vec2_length_fp64(x);\n  vec2 length_vec2[2];\n  length_vec2[0] = length;\n  length_vec2[1] = length;\n\n  vec2_div_fp64(x, length_vec2, out_val);\n}\n\nvec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {\n  vec2 diff[2];\n  vec2_sub_fp64(x, y, diff);\n  return vec2_length_fp64(diff);\n}\n\nvec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {\n  vec2 v[2];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n\n  return sum_fp64(v[0], v[1]);\n}\n\n// vec3 functions\nvoid vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {\n  for (int i = 0; i < 3; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvec2 vec3_length_fp64(vec2 x[3]) {\n  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),\n    mul_fp64(x[2], x[2])));\n}\n\nvec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {\n  vec2 diff[3];\n  vec3_sub_fp64(x, y, diff);\n  return vec3_length_fp64(diff);\n}\n\n// vec4 functions\nvoid vec4_fp64(vec4 a, out vec2 out_val[4]) {\n  out_val[0].x = a[0];\n  out_val[0].y = 0.0;\n\n  out_val[1].x = a[1];\n  out_val[1].y = 0.0;\n\n  out_val[2].x = a[2];\n  out_val[2].y = 0.0;\n\n  out_val[3].x = a[3];\n  out_val[3].y = 0.0;\n}\n\nvoid vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {\n  out_val[0] = mul_fp64(a[0], b);\n  out_val[1] = mul_fp64(a[1], b);\n  out_val[2] = mul_fp64(a[2], b);\n  out_val[3] = mul_fp64(a[3], b);\n}\n\nvoid vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {\n  for (int i = 0; i < 4; i++) {\n    out_val[i] = sum_fp64(a[i], b[i]);\n  }\n}\n\nvoid vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {\n  vec2 v[4];\n\n  v[0] = mul_fp64(a[0], b[0]);\n  v[1] = mul_fp64(a[1], b[1]);\n  v[2] = mul_fp64(a[2], b[2]);\n  v[3] = mul_fp64(a[3], b[3]);\n\n  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));\n}\n\nvoid mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {\n  vec2 tmp[4];\n\n  for (int i = 0; i < 4; i++)\n  {\n    for (int j = 0; j < 4; j++)\n    {\n      tmp[j] = b[j + i * 4];\n    }\n    vec4_dot_fp64(a, tmp, out_val[i]);\n  }\n}\n";
	exports.default = _default;
	//# sourceMappingURL=fp64-functions.glsl.js.map

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _math = __webpack_require__(109);

	var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	var DEFAULT_MODULE_OPTIONS = {
	  modelMatrix: IDENTITY_MATRIX,
	  viewMatrix: IDENTITY_MATRIX,
	  projectionMatrix: IDENTITY_MATRIX,
	  cameraPositionWorld: [0, 0, 0]
	};

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
	  var prevUniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  // const viewProjectionInverse = viewProjection.invert();
	  // viewInverseMatrix: view.invert(),
	  // viewProjectionInverseMatrix: viewProjectionInverse
	  var uniforms = {};

	  if (opts.modelMatrix !== undefined) {
	    uniforms.modelMatrix = opts.modelMatrix;
	  }

	  if (opts.viewMatrix !== undefined) {
	    uniforms.viewMatrix = opts.viewMatrix;
	  }

	  if (opts.projectionMatrix !== undefined) {
	    uniforms.projectionMatrix = opts.projectionMatrix;
	  }

	  if (opts.cameraPositionWorld !== undefined) {
	    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
	  } // COMPOSITE UNIFORMS


	  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
	    uniforms.viewProjectionMatrix = new _math.Matrix4(opts.projectionMatrix).multiplyRight(opts.viewMatrix);
	  }

	  return uniforms;
	}

	var common = "varying vec4 project_vPositionWorld;\nvarying vec3 project_vNormalWorld;\n\nvec4 project_getPosition_World() {\n  return project_vPositionWorld;\n}\n\nvec3 project_getNormal_World() {\n  return project_vNormalWorld;\n}\n";
	var vs = "".concat(common, "\n\n// Unprefixed uniforms\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewProjectionMatrix;\nuniform vec3 cameraPositionWorld;\n\nstruct World {\n  vec3 position;\n  vec3 normal;\n};\n\nWorld world;\n\nvoid project_setPosition(vec4 position) {\n  project_vPositionWorld = position;\n}\n\nvoid project_setNormal(vec3 normal) {\n  project_vNormalWorld = normal;\n}\n\nvoid project_setPositionAndNormal_World(vec3 position, vec3 normal) {\n  world.position = position;\n  world.normal = normal;\n}\n\nvoid project_setPositionAndNormal_Model(vec3 position, vec3 normal) {\n  world.position = (modelMatrix * vec4(position, 1.)).xyz;\n  world.normal = mat3(modelMatrix) * normal;\n}\n\nvec4 project_model_to_clipspace(vec4 position) {\n  return viewProjectionMatrix * modelMatrix * position;\n}\n\nvec4 project_model_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);\n}\n\nvec4 project_world_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_view_to_clipspace(vec3 position) {\n  return projectionMatrix * vec4(position, 1.);\n}\n\nvec4 project_to_clipspace(vec3 position) {\n  return viewProjectionMatrix * vec4(position, 1.);\n}\n");
	var fs = "\n".concat(common);
	var _default = {
	  name: 'project',
	  getUniforms: getUniforms,
	  vs: vs,
	  fs: fs
	};
	exports.default = _default;
	//# sourceMappingURL=project.js.map

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getUniforms = getUniforms;
	exports.default = exports.config = exports.name = exports.fragmentShader = exports.vertexShader = void 0;

	var _math = __webpack_require__(109);

	var _lightingCommon = _interopRequireDefault(__webpack_require__(225));

	var _lightingVertex = _interopRequireDefault(__webpack_require__(226));

	var _lightingFragment = _interopRequireDefault(__webpack_require__(227));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	var vertexShader = "".concat(_lightingCommon.default, "\n").concat(_lightingVertex.default, "\n");
	exports.vertexShader = vertexShader;
	var fragmentShader = "".concat(_lightingCommon.default, "\n").concat(_lightingFragment.default, "\n");
	exports.fragmentShader = fragmentShader;
	var name = 'lighting';
	exports.name = name;
	var config = {
	  MAX_POINT_LIGHTS: 4
	}; // Setup the lighting system: ambient, directional, point lights.

	exports.config = config;

	function getUniforms(_ref) {
	  var _ref$lightingEnable = _ref.lightingEnable,
	      lightingEnable = _ref$lightingEnable === void 0 ? false : _ref$lightingEnable,
	      _ref$lightingAmbientC = _ref.lightingAmbientColor,
	      lightingAmbientColor = _ref$lightingAmbientC === void 0 ? [0.2, 0.2, 0.2] : _ref$lightingAmbientC,
	      _ref$lightingDirectio = _ref.lightingDirection,
	      lightingDirection = _ref$lightingDirectio === void 0 ? [1, 1, 1] : _ref$lightingDirectio,
	      _ref$lightingDirectio2 = _ref.lightingDirectionalColor,
	      lightingDirectionalColor = _ref$lightingDirectio2 === void 0 ? [0, 0, 0] : _ref$lightingDirectio2,
	      _ref$lightingPointLig = _ref.lightingPointLights,
	      lightingPointLights = _ref$lightingPointLig === void 0 ? [] : _ref$lightingPointLig;
	  // Set light uniforms. Ambient, directional and point lights.
	  return Object.assign({
	    lightingEnable: lightingEnable,
	    // Ambient
	    lightingAmbientColor: lightingAmbientColor
	  }, getDirectionalUniforms(lightingDirection), getPointUniforms(lightingPointLights));
	}

	function getDirectionalUniforms(_ref2) {
	  var color = _ref2.color,
	      direction = _ref2.direction;
	  // Normalize lighting direction vector
	  var dir = new _math.Vector3(direction.x, direction.y, direction.z).normalize().scale(-1, -1, -1);
	  return {
	    directionalColor: [color.r, color.g, color.b],
	    lightingDirection: [dir.x, dir.y, dir.z]
	  };
	}

	function getPointUniforms(points) {
	  points = _instanceof(points, Array) ? points : [points];
	  var numberPoints = points.length;
	  var pointLocations = [];
	  var pointColors = [];
	  var enableSpecular = [];
	  var pointSpecularColors = [];
	  var _iteratorNormalCompletion = true;
	  var _didIteratorError = false;
	  var _iteratorError = undefined;

	  try {
	    for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	      var point = _step.value;
	      var position = point.position,
	          color = point.color,
	          diffuse = point.diffuse,
	          specular = point.specular;
	      var pointColor = color || diffuse;
	      pointLocations.push(position.x, position.y, position.z);
	      pointColors.push(pointColor.r, pointColor.g, pointColor.b); // Add specular color

	      enableSpecular.push(Number(Boolean(specular)));

	      if (specular) {
	        pointSpecularColors.push(specular.r, specular.g, specular.b);
	      } else {
	        pointSpecularColors.push(0, 0, 0);
	      }
	    }
	  } catch (err) {
	    _didIteratorError = true;
	    _iteratorError = err;
	  } finally {
	    try {
	      if (!_iteratorNormalCompletion && _iterator.return != null) {
	        _iterator.return();
	      }
	    } finally {
	      if (_didIteratorError) {
	        throw _iteratorError;
	      }
	    }
	  }

	  return {
	    numberPoints: numberPoints,
	    pointLocation: pointLocations,
	    pointColor: pointColors,
	    enableSpecular: enableSpecular,
	    pointSpecularColor: pointSpecularColors
	  };
	}

	var _default = {
	  name: name,
	  vs: vertexShader,
	  fs: fragmentShader,
	  getUniforms: getUniforms
	};
	exports.default = _default;
	//# sourceMappingURL=lighting.js.map

/***/ }),
/* 225 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var _default = "  // empty\n";
	exports.default = _default;
	//# sourceMappingURL=lighting-common.glsl.js.map

/***/ }),
/* 226 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var _default = "#define LIGHT_MAX 4\n\n/*\n// lighting configuration\nuniform bool enableLights;\nuniform vec3 ambientColor;\nuniform vec3 directionalColor;\nuniform vec3 lightingDirection;\n\n// point lights configuration\nuniform vec3 pointLocation[LIGHT_MAX];\nuniform vec3 pointColor[LIGHT_MAX];\nuniform int numberPoints;\n\n// reflection / refraction configuration\nuniform bool useReflection;\n*/\n\nuniform bool lighting_uEnableLights;\nuniform vec3 lighting_uAmbientColor;\nuniform vec3 lighting_uDirection;\nuniform vec3 lighting_uDirectionalColor;\n\n// point lights configuration\nuniform int  lighting_uPointCount;\nuniform vec3 lighting_uPointLocation[LIGHT_MAX];\nuniform vec3 lighting_uPointColor[LIGHT_MAX];\n\n// reflection / refraction configuration\nuniform bool lighting_uEnableReflections;\n\n// varyings\nvarying vec4 lighting_vPosition;\nvarying vec4 lighting_vNormal;\nvarying vec3 lighting_vColor;\nvarying vec3 lighting_vLightWeighting;\nvarying vec3 lighting_vReflection;\n\nvoid lighting_setPositionAndNormal(vec3 position, vec3 normal) {\n  lighting_vPosition = worldMatrix * vec4(position, 1.);\n  lighting_vNormal = worldInverseTransposeMatrix * vec4(normal, 1.);;\n}\n\nvoid lighting__getLightWeigting() {\n  float directionalLightWeighting = max(dot(lighting_vNormal.xyz, lighting_uDirection), 0.);\n  vec3 pointWeight = vec3(0., 0., 0.);\n  for (int i = 0; i < LIGHT_MAX; i++) {\n    if (i < numberPoints) {\n      vec4 mvLightPosition = viewMatrix * vec4(lighting_uPointLocation[i], 1.);\n      vec3 pointLightDirection = normalize(mvLightPosition.xyz - lighting_vPosition.xyz);\n      pointWeight += max(dot(lighting_vNormal.xyz, pointLightDirection), 0.) * pointColor[i];\n     } else {\n       break;\n     }\n   }\n   return ambientColor + (directionalColor * directionalLightWeighting) + pointWeight;\n}\n\nvoid lighting_apply(vec3 position, vec3 normal) {\n  lighting_setPositionAndNormal(position, normal);\n\n  // lighting code\n  if(!lighting_uEnableLights) {\n    lighting_vLightWeighting = vec3(1., 1., 1.);\n  } else {\n    lighting_vLightWeighting = lighting__getLightWeighting();\n  }\n}\n\nvoid lighting_set_reflection(vec3 position) {\n    // refraction / reflection code\n  if (lighting_uEnableReflections) {\n    lighting_vReflection = (viewInverseMatrix[3] - (worldMatrix * vec4(position, 1.))).xyz;\n  } else {\n    lighting_vReflection = vec3(1., 1., 1.);\n  }\n}\n";
	exports.default = _default;
	//# sourceMappingURL=lighting-vertex.glsl.js.map

/***/ }),
/* 227 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var _default = "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define LIGHT_MAX 4\n\nvarying vec3 lighting_vLightWeighting;\n\nvec4 lighting_apply(vec4 color) {\n  // set color from texture\n  return vec4(color.rgb * lighting_vLightWeighting, color.a);\n}\n\n// spec-map.fs\n\nuniform mat4 viewMatrix;\n\n\nvarying vec4 lighting_vColor;\nvarying vec4 lighting_vTransformedNormal;\nvarying vec4 lighting_vPosition;\n\nuniform float shininess;\nuniform bool enableSpecularMap;\nuniform bool enableLights;\n\nuniform vec3 ambientColor;\nuniform vec3 directionalColor;\nuniform vec3 lightingDirection;\n\nuniform vec3 lighting_uPointLocation[LIGHT_MAX];\nuniform vec3 lighting_uPointColor[LIGHT_MAX];\nuniform float lighting_uPointSpecularEnable[LIGHT_MAX];\nuniform vec3 lighting_uPointSpecularColor[LIGHT_MAX];\nuniform int numberPoints;\n\n\nvec3 lighting__calculate_light_weighting() {\n\treturn lighting__calculate_light_weighting(shininess);\n}\n\nvec3 lighting__calculate_light_weighting(shininess) {\n  vec3 normal = vTransformedNormal.xyz;\n  vec3 eyeDirection = normalize(-vPosition.xyz);\n\n  vec3 specularLight = vec3(0., 0., 0.);\n  vec3 diffuseLight = vec3(0., 0., 0.);\n\n  for (int i = 0; i < LIGHT_MAX; i++) {\n    if (i < numberPoints) {\n      vec3 transformedPointLocation = (viewMatrix * vec4(lighting_uPointLocation[i], 1.0)).xyz;\n      vec3 lightDirection = normalize(transformedPointLocation - vPosition.xyz);\n\n      if (lighting_uPointSpecularEnable > 0.) {\n        vec3 reflectionDirection = reflect(-lightDirection, normal);\n        float specularLightWeighting =\n          pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininessVal);\n        specularLight += specularLightWeighting * lighting_uPointSpecularColor[i];\n      }\n\n      float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\n      diffuseLight += diffuseLightWeighting * lighting_uPointColor[i];\n    } else {\n      break;\n    }\n  }\n\n  return ambientColor + diffuseLight + specularLight;\n}\n\nvoid lighting_filterColor(fragmentColor) {\n  if (!lighting_enable) {\n  \treturn fragmentColor;\n  } else {\n  \tvec3 lightWeighting = lighting__calculate_light_weighting();\n  \treturn vec4(fragmentColor.rgb * lightWeighting, fragmentColor.a);\n  }\n}\n\n// render-tex.fs\n\nuniform vec3 material_uAmbientColor;\nuniform vec3 material_uDiffuseColor;\nuniform vec3 material_uSpecularColor;\nuniform vec3 material_uEmissiveColor;\n\nuniform bool hasTexture1;\nuniform sampler2D sampler1;\n\nuniform mat4 viewMatrix;\n\nvoid apply_lighting(color) {\n  vec3 ambientLightWeighting = ambientColor;\n\n  vec3 normal = vTransformedNormal.xyz;\n  vec3 eyeDirection = normalize(-vPosition.xyz);\n\n  vec3 specularLight = vec3(0.0, 0.0, 0.0);\n  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n\n  for (int i = 0; i < LIGHT_MAX; i++) {\n    if (i < numberPoints) {\n      vec3 transformedPointLocation = (viewMatrix * vec4(pointLocation[i], 1.0)).xyz;\n      vec3 lightDirection = normalize(transformedPointLocation - vPosition.xyz);\n\n      if (enableSpecularHighlights) {\n        vec3 reflectionDirection = reflect(-lightDirection, normal);\n        float specularLightWeighting =\n          pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininess);\n        specularLight += specularLightWeighting * pointSpecularColor[i];\n      }\n\n      float diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\n      diffuseLight += diffuseLightWeighting * pointColor[i];\n    } else {\n        break;\n    }\n  }\n\n  vec3 matAmbientColor = material_uAmbientColor * color.rgb;\n  vec3 matDiffuseColor = material_uDiffuseColor * color.rgb;\n  vec3 matSpecularColor = material_uSpecularColor * color.rgb;\n  vec3 matEmissiveColor = material_uEmissiveColor * color.rgb;\n  gl_FragColor = vec4(\n    matAmbientColor * ambientLightWeighting\n    + matDiffuseColor * diffuseLightWeighting\n    + matSpecularColor * specularLightWeighting\n    + matEmissiveColor,\n    color.a\n  );\n}\n\n/// frag-lighting\n\n  vec3 lightWeighting;\n  if (!enableLights) {\n    lightWeighting = vec3(1.0, 1.0, 1.0);\n  } else {\n    vec3 lightDirection;\n    float specularLightWeighting = 0.0;\n    float diffuseLightWeighting = 0.0;\n    vec3  specularLight = vec3(0.0, 0.0, 0.0);\n    vec3  diffuseLight = vec3(0.0, 0.0, 0.0);\n\n    vec3 transformedPointLocation;\n    vec3 normal = vTransformedNormal.xyz;\n\n    vec3 eyeDirection = normalize(-vPosition.xyz);\n    vec3 reflectionDirection;\n\n    vec3 pointWeight = vec3(0.0, 0.0, 0.0);\n\n    for (int i = 0; i < LIGHT_MAX; i++) {\n      if (i < numberPoints) {\n        transformedPointLocation = (viewMatrix * vec4(pointLocation[i], 1.0)).xyz;\n        lightDirection = normalize(transformedPointLocation - vPosition.xyz);\n\n        if (enableSpecular[i] > 0.0) {\n          reflectionDirection = reflect(-lightDirection, normal);\n          specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), shininess);\n          specularLight += specularLightWeighting * pointSpecularColor[i];\n        }\n\n        diffuseLightWeighting = max(dot(normal, lightDirection), 0.0);\n        diffuseLight += diffuseLightWeighting * pointColor[i];\n      } else {\n        break;\n      }\n    }\n\n    lightWeighting = ambientColor + diffuseLight + specularLight;\n  }\n\n// reflection / refraction configs\nuniform float reflection;\nuniform float refraction;\n\n///\n  // has cube texture then apply reflection\n  // if (hasTextureCube1) {\n  //   vec3 nReflection = normalize(vReflection);\n  //   vec3 reflectionValue;\n  //   if (refraction > 0.0) {\n  //    reflectionValue = refract(nReflection, vNormal.xyz, refraction);\n  //   } else {\n  //    reflectionValue = -reflect(nReflection, vNormal.xyz);\n  //   }\n\n  //   // TODO(nico): check whether this is right.\n  //   vec4 cubeColor = textureCube(samplerCube1,\n  //       vec3(-reflectionValue.x, -reflectionValue.y, reflectionValue.z));\n  //   gl_FragColor = vec4(mix(gl_FragColor.xyz, cubeColor.xyz, reflection), 1.0);\n  // }\n";
	exports.default = _default;
	//# sourceMappingURL=lighting-fragment.glsl.js.map

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _project = _interopRequireDefault(__webpack_require__(223));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Cheap lighting - single directional light, single dot product, one uniform

	/* eslint-disable camelcase */
	var DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);
	var DEFAULT_MODULE_OPTIONS = {
	  lightDirection: DEFAULT_LIGHT_DIRECTION
	};

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
	  var uniforms = {};

	  if (opts.lightDirection) {
	    uniforms.dirlight_uLightDirection = opts.lightDirection;
	  }

	  return uniforms;
	} // TODO - reuse normal from geometry module


	var vs = null;
	var fs = "uniform vec3 dirlight_uLightDirection;\n\n/*\n * Returns color attenuated by angle from light source\n */\nvec4 dirlight_filterColor(vec4 color) {\n  vec3 normal = project_getNormal_World();\n  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));\n  return vec4(color.rgb * d, color.a);\n}\n";
	var _default = {
	  name: 'dirlight',
	  vs: vs,
	  fs: fs,
	  getUniforms: getUniforms,
	  dependencies: [_project.default]
	};
	exports.default = _default;
	//# sourceMappingURL=dirlight.js.map

/***/ }),
/* 229 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
	var DEFAULT_MODULE_OPTIONS = {
	  pickingSelectedColor: null,
	  //  Set to a picking color to visually highlight that item
	  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
	  // Color of visual highlight of "selected" item
	  pickingThreshold: 1.0,
	  pickingActive: false // Set to true when rendering to off-screen "picking" buffer

	};
	/* eslint-disable camelcase */

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
	  var uniforms = {};

	  if (opts.pickingSelectedColor !== undefined) {
	    if (opts.pickingSelectedColor === null) {
	      uniforms.picking_uSelectedColorValid = 0;
	    } else {
	      var selectedColor = [opts.pickingSelectedColor[0], opts.pickingSelectedColor[1], opts.pickingSelectedColor[2]];
	      uniforms.picking_uSelectedColorValid = 1;
	      uniforms.picking_uSelectedColor = selectedColor;
	    }
	  }

	  if (opts.pickingHighlightColor !== undefined) {
	    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;
	  } // TODO - major hack - decide on normalization and remove


	  if (opts.pickingThreshold !== undefined) {
	    uniforms.picking_uThreshold = opts.pickingThreshold;
	  }

	  if (opts.pickingActive !== undefined) {
	    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;
	  }

	  return uniforms;
	}

	var vs = "uniform vec3 picking_uSelectedColor;\nuniform float picking_uThreshold;\nuniform bool picking_uSelectedColorValid;\n\nvarying vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&\n    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&\n    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n  picking_vRGBcolor_Aselected.a =\n    float(isVertexPicked(pickingColor));\n\n  // Stores the picking color so that the fragment shader can render it during picking\n  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;\n}\n";
	var fs = "uniform bool picking_uActive; // true during rendering to offscreen picking buffer\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nvarying vec4 picking_vRGBcolor_Aselected;\n\nconst float COLOR_SCALE = 1. / 255.;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  bool selected = bool(picking_vRGBcolor_Aselected.a);\n  return selected ? (picking_uHighlightColor * COLOR_SCALE) : color;\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;\n  if (picking_uActive && length(pickingColor) < 0.001) {\n    discard;\n  }\n  return picking_uActive ? vec4(pickingColor, 1.0) : color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
	var _default = {
	  name: 'picking',
	  vs: vs,
	  fs: fs,
	  getUniforms: getUniforms
	};
	exports.default = _default;
	//# sourceMappingURL=picking.js.map

/***/ }),
/* 230 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Minimal texture (diffuse map) support

	/* eslint-disable camelcase */
	var DEFAULT_MODULE_OPTIONS = {
	  diffuseTexture: null,
	  diffuseColor: [0.5, 0.5, 0.5, 1]
	};

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
	  var uniforms = {};

	  if (opts.diffuseTexture !== undefined) {
	    uniforms.diffuse_uHasTexture = Boolean(opts.diffuseTexture);
	    uniforms.diffuse_uTexture = opts.diffuseTexture;
	  }

	  if (opts.diffuseColor !== undefined) {
	    uniforms.diffuse_uColor = opts.diffuseColor;
	  }

	  return uniforms;
	}

	var vs = "varying vec2 diffuse_vTexCoord;\n\n/* Set the UV coordinate from attributes */\nvoid diffuse_setTextureCoordinate(vec2 uv) {\n  diffuse_vTexCoord = uv;\n}\n";
	var fs = "uniform vec4 diffuse_uColor;\nuniform bool diffuse_uHasTexture;\nuniform sampler2D diffuse_uTexture;\n\nvarying vec2 diffuse_vTexCoord;\n\n// Gets diffuse color of material from uniform\n// If we have a standard (diffuse) texture, set color to texture\n// return (vec4) - rgba\n//\nvec4 diffuse_getColor() {\n  vec2 texCoord = diffuse_vTexCoord;\n  return diffuse_uHasTexture ?\n    texture2D(diffuse_uTexture, vec2(texCoord.s, texCoord.t)) :\n    diffuse_uColor;\n}\n\nvec4 diffuse_filterColor(vec4 color) {\n  return diffuse_getColor();\n}\n";
	var _default = {
	  name: 'diffuse',
	  getUniforms: getUniforms,
	  vs: vs,
	  fs: fs
	};
	exports.default = _default;
	//# sourceMappingURL=diffuse.js.map

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _buffer = _interopRequireDefault(__webpack_require__(82));

	var _transformFeedback = _interopRequireDefault(__webpack_require__(104));

	var _model = _interopRequireDefault(__webpack_require__(106));

	var _webglUtils = __webpack_require__(48);

	var _assert = _interopRequireDefault(__webpack_require__(58));

	var _utils = __webpack_require__(63);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var PASS_THROUGH_FS = "void main()\n{\n}\n";

	var Transform =
	/*#__PURE__*/
	function () {
	  _createClass(Transform, null, [{
	    key: "isSupported",
	    value: function isSupported(gl) {
	      // For now WebGL2 only
	      return (0, _webglUtils.isWebGL2)(gl);
	    }
	  }]);

	  function Transform(gl) {
	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Transform);

	    (0, _webglUtils.assertWebGL2Context)(gl);
	    this.gl = gl;
	    this.model = null;
	    this._buffersSwapable = false;
	    this.currentIndex = 0;
	    this.sourceBuffers = new Array(2);
	    this.destinationBuffers = new Array(2);
	    this.transformFeedbacks = new Array(2);
	    this._buffersToDelete = [];
	    this.initialize(opts);
	    Object.seal(this);
	  } // Delete owned resources.


	  _createClass(Transform, [{
	    key: "delete",
	    value: function _delete() {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._buffersToDelete[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var buffer = _step.value;
	          buffer.delete();
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      this.model.delete();
	    }
	  }, {
	    key: "initialize",
	    value: function initialize(_ref) {
	      var _ref$sourceBuffers = _ref.sourceBuffers,
	          sourceBuffers = _ref$sourceBuffers === void 0 ? null : _ref$sourceBuffers,
	          _ref$destinationBuffe = _ref.destinationBuffers,
	          destinationBuffers = _ref$destinationBuffe === void 0 ? null : _ref$destinationBuffe,
	          _ref$vs = _ref.vs,
	          vs = _ref$vs === void 0 ? null : _ref$vs,
	          _ref$sourceDestinatio = _ref.sourceDestinationMap,
	          sourceDestinationMap = _ref$sourceDestinatio === void 0 ? null : _ref$sourceDestinatio,
	          _ref$varyings = _ref.varyings,
	          varyings = _ref$varyings === void 0 ? null : _ref$varyings,
	          _ref$drawMode = _ref.drawMode,
	          drawMode = _ref$drawMode === void 0 ? _constants.default.POINTS : _ref$drawMode,
	          _ref$elementCount = _ref.elementCount,
	          elementCount = _ref$elementCount === void 0 ? null : _ref$elementCount;
	      (0, _assert.default)(sourceBuffers && vs && varyings && elementCount); // If destinationBuffers are not provided, sourceDestinationMap must be provided
	      // to create destinaitonBuffers with layout of corresponding source buffer.

	      (0, _assert.default)(destinationBuffers || sourceDestinationMap);

	      if (sourceDestinationMap) {
	        this.sourceDestinationMap = sourceDestinationMap;
	        this._buffersSwapable = true;
	      }

	      var index = 0;
	      this.varyings = [];
	      this.varyingMap = {};
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = varyings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var varying = _step2.value;
	          this.varyings[index] = varying;
	          this.varyingMap[varying] = index;
	          index++;
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      this._bindBuffers({
	        sourceBuffers: sourceBuffers,
	        destinationBuffers: destinationBuffers
	      });

	      this._buildModel({
	        vs: vs,
	        drawMode: drawMode,
	        elementCount: elementCount
	      });
	    } // Update some or all buffer bindings.

	  }, {
	    key: "update",
	    value: function update(_ref2) {
	      var _ref2$sourceBuffers = _ref2.sourceBuffers,
	          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,
	          _ref2$destinationBuff = _ref2.destinationBuffers,
	          destinationBuffers = _ref2$destinationBuff === void 0 ? null : _ref2$destinationBuff,
	          _ref2$elementCount = _ref2.elementCount,
	          elementCount = _ref2$elementCount === void 0 ? this.elementCount : _ref2$elementCount;

	      if (!sourceBuffers && !destinationBuffers) {
	        _utils.log.warn('Transform : no buffers updated')();

	        return this;
	      }

	      this.model.setVertexCount(elementCount);
	      var currentIndex = this.currentIndex,
	          varyingMap = this.varyingMap,
	          _buffersSwapable = this._buffersSwapable,
	          transformFeedbacks = this.transformFeedbacks;

	      for (var bufferName in destinationBuffers) {
	        (0, _assert.default)(_instanceof(destinationBuffers[bufferName], _buffer.default));
	      }

	      Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);
	      Object.assign(this.destinationBuffers[currentIndex], destinationBuffers);
	      transformFeedbacks[currentIndex].bindBuffers(this.destinationBuffers[currentIndex], {
	        varyingMap: varyingMap
	      });

	      if (_buffersSwapable) {
	        var nextIndex = (currentIndex + 1) % 2;

	        for (var sourceBufferName in this.sourceDestinationMap) {
	          var destinationBufferName = this.sourceDestinationMap[sourceBufferName];
	          this.sourceBuffers[nextIndex][sourceBufferName] = this.destinationBuffers[currentIndex][destinationBufferName];
	          this.destinationBuffers[nextIndex][destinationBufferName] = this.sourceBuffers[currentIndex][sourceBufferName]; // make sure the new destination buffer is a Buffer object

	          (0, _assert.default)(_instanceof(this.destinationBuffers[nextIndex][destinationBufferName], _buffer.default));
	        }

	        transformFeedbacks[nextIndex].bindBuffers(this.destinationBuffers[nextIndex], {
	          varyingMap: varyingMap
	        });
	      }

	      return this;
	    } // Run one transformfeedback loop.

	  }, {
	    key: "run",
	    value: function run() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref3$uniforms = _ref3.uniforms,
	          uniforms = _ref3$uniforms === void 0 ? {} : _ref3$uniforms;

	      var model = this.model,
	          transformFeedbacks = this.transformFeedbacks,
	          sourceBuffers = this.sourceBuffers,
	          currentIndex = this.currentIndex;
	      model.setAttributes(sourceBuffers[currentIndex]);
	      model.draw({
	        transformFeedback: transformFeedbacks[currentIndex],
	        uniforms: uniforms,
	        parameters: _defineProperty({}, _constants.default.RASTERIZER_DISCARD, true)
	      });
	    } // Swap source and destination buffers.

	  }, {
	    key: "swapBuffers",
	    value: function swapBuffers() {
	      (0, _assert.default)(this._buffersSwapable);
	      this.currentIndex = (this.currentIndex + 1) % 2;
	    } // Return Buffer object for given varying name.

	  }, {
	    key: "getBuffer",
	    value: function getBuffer() {
	      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var destinationBuffers = this.destinationBuffers,
	          currentIndex = this.currentIndex;
	      (0, _assert.default)(varyingName && destinationBuffers[currentIndex][varyingName]);
	      return destinationBuffers[currentIndex][varyingName];
	    } // Private
	    // build source and destination buffers

	  }, {
	    key: "_bindBuffers",
	    value: function _bindBuffers(_ref4) {
	      var _ref4$sourceBuffers = _ref4.sourceBuffers,
	          sourceBuffers = _ref4$sourceBuffers === void 0 ? null : _ref4$sourceBuffers,
	          _ref4$destinationBuff = _ref4.destinationBuffers,
	          destinationBuffers = _ref4$destinationBuff === void 0 ? null : _ref4$destinationBuff;
	      var _buffersSwapable = this._buffersSwapable;

	      for (var bufferName in destinationBuffers) {
	        (0, _assert.default)(_instanceof(destinationBuffers[bufferName], _buffer.default));
	      }

	      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);
	      this.destinationBuffers[0] = Object.assign({}, destinationBuffers);

	      if (_buffersSwapable) {
	        this.sourceBuffers[1] = {};
	        this.destinationBuffers[1] = {};

	        for (var sourceBufferName in this.sourceDestinationMap) {
	          var destinationBufferName = this.sourceDestinationMap[sourceBufferName];

	          if (!this.destinationBuffers[0][destinationBufferName]) {
	            // Create new buffer with same layout and settings as source buffer
	            var sourceBuffer = this.sourceBuffers[0][sourceBufferName];
	            var bytes = sourceBuffer.bytes,
	                type = sourceBuffer.type,
	                usage = sourceBuffer.usage,
	                layout = sourceBuffer.layout;
	            this.destinationBuffers[0][destinationBufferName] = new _buffer.default(this.gl, {
	              bytes: bytes,
	              type: type,
	              usage: usage,
	              layout: layout
	            });

	            this._buffersToDelete.push(this.destinationBuffers[0][destinationBufferName]);
	          }

	          this.sourceBuffers[1][sourceBufferName] = this.destinationBuffers[0][destinationBufferName];
	          this.destinationBuffers[1][destinationBufferName] = this.sourceBuffers[0][sourceBufferName]; // make sure the new destination buffer is a Buffer object

	          (0, _assert.default)(_instanceof(this.destinationBuffers[1][destinationBufferName], _buffer.default));
	        }
	      }
	    } // build Model and TransformFeedback objects

	  }, {
	    key: "_buildModel",
	    value: function _buildModel(_ref5) {
	      var vs = _ref5.vs,
	          drawMode = _ref5.drawMode,
	          elementCount = _ref5.elementCount;
	      var varyings = this.varyings,
	          varyingMap = this.varyingMap,
	          _buffersSwapable = this._buffersSwapable; // Append matching version string to FS.

	      var fs = PASS_THROUGH_FS;
	      var vsLines = vs.split('\n');

	      if (vsLines[0].indexOf('#version ') === 0) {
	        fs = "".concat(vsLines[0], "\n").concat(PASS_THROUGH_FS, "\n");
	      }

	      this.model = new _model.default(this.gl, {
	        vs: vs,
	        fs: fs,
	        varyings: varyings,
	        drawMode: drawMode,
	        vertexCount: elementCount
	      });
	      this.transformFeedbacks[0] = new _transformFeedback.default(this.gl, {
	        buffers: this.destinationBuffers[0],
	        varyingMap: varyingMap
	      });

	      if (_buffersSwapable) {
	        this.transformFeedbacks[1] = new _transformFeedback.default(this.gl, {
	          buffers: this.destinationBuffers[1],
	          varyingMap: this.varyingMap
	        });
	      }
	    }
	  }, {
	    key: "elementCount",
	    get: function get() {
	      return this.model.getVertexCount();
	    }
	  }]);

	  return Transform;
	}();

	exports.default = Transform;
	//# sourceMappingURL=transform.js.map

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.glGet = glGet;
	exports.glKey = glKey;
	exports.glKeyType = glKeyType;
	Object.defineProperty(exports, "GL", {
	  enumerable: true,
	  get: function get() {
	    return _constants.default;
	  }
	});
	exports.default = void 0;

	var _constants = _interopRequireDefault(__webpack_require__(59));

	var _constantsToKeys = __webpack_require__(57);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// WEBGL BUILT-IN CONSTANTS
	var _default = _constants.default; // Resolve a WebGL enumeration name (returns itself if already a number)

	exports.default = _default;

	function glGet(name) {
	  return (0, _constantsToKeys.getKeyValue)(_constants.default, name);
	}

	function glKey(value) {
	  return (0, _constantsToKeys.getKey)(_constants.default, value);
	}

	function glKeyType(value) {
	  return (0, _constantsToKeys.getKeyType)(_constants.default, value);
	}
	//# sourceMappingURL=gl-constants.js.map

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _luma = __webpack_require__(46);

	var _project = _interopRequireDefault(__webpack_require__(234));

	var _projectDeprecated = _interopRequireDefault(__webpack_require__(235));

	var _viewportUniforms = __webpack_require__(236);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var INITIAL_MODULE_OPTIONS = {};

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

	  if (opts.viewport) {
	    return (0, _viewportUniforms.getUniformsFromViewport)(opts);
	  }

	  return {};
	}

	var _default = {
	  name: 'project',
	  dependencies: [_luma.fp32],
	  vs: "".concat(_project.default).concat(_projectDeprecated.default),
	  getUniforms: getUniforms,
	  deprecations: [// Removed custom picking uinforms
	  // These don't really belong here but we need to check them for all shaders
	  // the project module is by default included for all
	  {
	    type: 'uniform vec3',
	    old: 'selectedPickingColor',
	    new: "luma.gl's picking module"
	  }, {
	    type: 'uniform float',
	    old: 'renderPickingBuffer',
	    new: "luma.gl's picking module"
	  }, {
	    type: 'uniform float',
	    old: 'pickingEnabled',
	    new: "luma.gl's picking module"
	  }, // Removed project uniforms
	  {
	    type: 'uniform float',
	    old: 'projectionMode',
	    new: 'project_uCoordinateSystem'
	  }, {
	    type: 'uniform vec4',
	    old: 'projectionCenter',
	    new: 'project_uCenter'
	  }, {
	    type: 'uniform vec2',
	    old: 'projectionOrigin'
	  }, {
	    type: 'uniform mat4',
	    old: 'modelMatrix',
	    new: 'project_uModelMatrix'
	  }, {
	    type: 'uniform mat4',
	    old: 'viewMatrix'
	  }, {
	    type: 'uniform mat4',
	    old: 'projectionMatrix',
	    new: 'project_uViewProjectionMatrix'
	  }, {
	    type: 'uniform vec3',
	    old: 'projectionPixelsPerUnit',
	    new: 'project_uPixelsPerUnit'
	  }, {
	    type: 'uniform float',
	    old: 'projectionScale',
	    new: 'project_uScale'
	  }, {
	    type: 'uniform vec2',
	    old: 'viewportSize',
	    new: 'project_uViewportSize'
	  }, {
	    type: 'uniform float',
	    old: 'devicePixelRatio',
	    new: 'project_uDevicePixelRatio'
	  }, {
	    type: 'uniform vec3',
	    old: 'cameraPos',
	    new: 'project_uCameraPosition'
	  }, // Deprecated project functions
	  {
	    type: 'function',
	    old: 'scale',
	    new: 'project_scale',
	    deprecated: 1
	  }, {
	    type: 'function',
	    old: 'preproject',
	    new: 'project_position',
	    deprecated: 1
	  }, {
	    type: 'function',
	    old: 'project',
	    new: 'project_to_clipspace',
	    deprecated: 1
	  }]
	};
	exports.default = _default;
	//# sourceMappingURL=project.js.map

/***/ }),
/* 234 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "// EXTERNAL CONSTANTS: these must match JavaScript constants in \"src/core/lib/constants.js\"\nconst float COORDINATE_SYSTEM_IDENTITY = 0.;\nconst float COORDINATE_SYSTEM_LNG_LAT = 1.;\nconst float COORDINATE_SYSTEM_METER_OFFSETS = 2.;\nconst float COORDINATE_SYSTEM_LNGLAT_OFFSETS = 3.;\n\nuniform float project_uCoordinateSystem;\nuniform float project_uScale;\nuniform vec3 project_uPixelsPerMeter;\nuniform vec3 project_uPixelsPerDegree;\nuniform vec3 project_uPixelsPerUnit;\nuniform vec3 project_uPixelsPerUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\n\n//\n// Scaling offsets - scales meters to \"pixels\"\n// Note the scalar version of project_scale is for scaling the z component only\n//\nfloat project_scale(float meters) {\n  return meters * project_uPixelsPerMeter.z;\n}\n\nvec2 project_scale(vec2 meters) {\n  return meters * project_uPixelsPerMeter.xy;\n}\n\nvec3 project_scale(vec3 meters) {\n  return meters * project_uPixelsPerMeter;\n}\n\nvec4 project_scale(vec4 meters) {\n  return vec4(meters.xyz * project_uPixelsPerMeter, meters.w);\n}\n\n//\n// Projecting normal - transform deltas from current coordinate system to\n// normals in the worldspace\n//\nvec3 project_normal(vec3 vector) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return normalize(vector * project_uPixelsPerDegree);\n  }\n  // Apply model matrix\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  return normalize(normal_modelspace.xyz * project_uPixelsPerMeter);\n}\n\nvec4 project_offset_(vec4 offset) {\n  vec3 pixelsPerUnit = project_uPixelsPerUnit + project_uPixelsPerUnit2 * offset.y;\n  return vec4(offset.xyz * pixelsPerUnit, offset.w);\n}\n\n//\n// Projecting positions - non-linear projection: lnglats => unit tile [0-1, 0-1]\n//\nvec2 project_mercator_(vec2 lnglat) {\n  return vec2(\n    radians(lnglat.x) + PI,\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\n  );\n}\n\n//\n// Projects lnglats (or meter offsets, depending on mode) to pixels\n//\nvec4 project_position(vec4 position) {\n  // TODO - why not simply subtract center and fall through?\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT) {\n    return project_uModelMatrix * vec4(\n      project_mercator_(position.xy) * WORLD_SCALE * project_uScale,\n      project_scale(position.z),\n      position.w\n    );\n  }\n\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    return project_offset_(position);\n  }\n\n  // METER_OFFSETS or IDENTITY\n  // Apply model matrix\n  vec4 position_modelspace = project_uModelMatrix * position;\n  return project_offset_(position_modelspace);\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0));\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0));\n  return projected_position.xy;\n}\n\n//\n// Projects from \"world\" coordinates to clip space.\n// Uses project_uViewProjectionMatrix\n//\nvec4 project_to_clipspace(vec4 position) {\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_METER_OFFSETS ||\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS) {\n    // Needs to be divided with project_uPixelsPerMeter\n    position.w *= project_uPixelsPerMeter.z;\n  }\n  return project_uViewProjectionMatrix * position + project_uCenter;\n}\n\n// Returns a clip space offset that corresponds to a given number of **non-device** pixels\nvec4 project_pixel_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio;\n  return vec4(offset * project_uFocalDistance, 0.0, 0.0);\n}\n";
	exports.default = _default;
	//# sourceMappingURL=project.glsl.js.map

/***/ }),
/* 235 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "float scale(float position) {\n  return project_scale(position);\n}\n\nvec2 scale(vec2 position) {\n  return project_scale(position);\n}\n\nvec3 scale(vec3 position) {\n  return project_scale(position);\n}\n\nvec4 scale(vec4 position) {\n  return project_scale(position);\n}\n\nvec2 preproject(vec2 position) {\n  return project_position(position);\n}\n\nvec3 preproject(vec3 position) {\n  return project_position(position);\n}\n\nvec4 preproject(vec4 position) {\n  return project_position(position);\n}\n\nvec4 project(vec4 position) {\n  return project_to_clipspace(position);\n}\n";
	exports.default = _default;
	//# sourceMappingURL=project-deprecated.glsl.js.map

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getUniformsFromViewport = getUniformsFromViewport;

	var _multiply = _interopRequireDefault(__webpack_require__(135));

	var _transformMat = _interopRequireDefault(__webpack_require__(141));

	var _constants = __webpack_require__(237);

	var _memoize = _interopRequireDefault(__webpack_require__(238));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _viewportMercatorProject = __webpack_require__(240);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// To quickly set a vector to zero
	var ZERO_VECTOR = [0, 0, 0, 0]; // 4x4 matrix that drops 4th component of vector

	var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
	var IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
	var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
	var getMemoizedViewportUniforms = (0, _memoize.default)(calculateViewportUniforms); // The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,
	// has lower performance but provides error checking.
	// Uncomment when debugging

	function calculateMatrixAndOffset(_ref) {
	  var viewport = _ref.viewport,
	      coordinateSystem = _ref.coordinateSystem,
	      coordinateOrigin = _ref.coordinateOrigin,
	      coordinateZoom = _ref.coordinateZoom;
	  var viewMatrixUncentered = viewport.viewMatrixUncentered;
	  var viewMatrix = viewport.viewMatrix;
	  var projectionMatrix = viewport.projectionMatrix;
	  var viewProjectionMatrix = viewport.viewProjectionMatrix;
	  var projectionCenter;

	  switch (coordinateSystem) {
	    case _constants.COORDINATE_SYSTEM.IDENTITY:
	    case _constants.COORDINATE_SYSTEM.LNGLAT:
	      projectionCenter = ZERO_VECTOR;
	      break;
	    // TODO: make lighting work for meter offset mode

	    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
	    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
	      // Calculate transformed projectionCenter (using 64 bit precision JS)
	      // This is the key to offset mode precision
	      // (avoids doing this addition in 32 bit precision in GLSL)
	      var positionPixels = (0, _viewportMercatorProject.lngLatToWorld)(coordinateOrigin, Math.pow(2, coordinateZoom)); // projectionCenter = new Matrix4(viewProjectionMatrix)
	      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);

	      projectionCenter = (0, _transformMat.default)([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix); // Always apply uncentered projection matrix if available (shader adds center)

	      viewMatrix = viewMatrixUncentered || viewMatrix; // Zero out 4th coordinate ("after" model matrix) - avoids further translations
	      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)
	      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);

	      viewProjectionMatrix = (0, _multiply.default)([], projectionMatrix, viewMatrix);
	      viewProjectionMatrix = (0, _multiply.default)([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
	      break;

	    default:
	      throw new Error('Unknown projection mode');
	  }

	  return {
	    viewMatrix: viewMatrix,
	    viewProjectionMatrix: viewProjectionMatrix,
	    projectionCenter: projectionCenter,
	    cameraPos: viewport.cameraPosition
	  };
	}
	/**
	 * Returns uniforms for shaders based on current projection
	 * includes: projection matrix suitable for shaders
	 *
	 * TODO - Ensure this works with any viewport, not just WebMercatorViewports
	 *
	 * @param {WebMercatorViewport} viewport -
	 * @return {Float32Array} - 4x4 projection matrix that can be used in shaders
	 */


	function getUniformsFromViewport() {
	  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      viewport = _ref2.viewport,
	      _ref2$devicePixelRati = _ref2.devicePixelRatio,
	      devicePixelRatio = _ref2$devicePixelRati === void 0 ? 1 : _ref2$devicePixelRati,
	      _ref2$modelMatrix = _ref2.modelMatrix,
	      modelMatrix = _ref2$modelMatrix === void 0 ? null : _ref2$modelMatrix,
	      _ref2$coordinateSyste = _ref2.coordinateSystem,
	      coordinateSystem = _ref2$coordinateSyste === void 0 ? _constants.COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,
	      _ref2$coordinateOrigi = _ref2.coordinateOrigin,
	      coordinateOrigin = _ref2$coordinateOrigi === void 0 ? DEFAULT_COORDINATE_ORIGIN : _ref2$coordinateOrigi,
	      projectionMode = _ref2.projectionMode,
	      positionOrigin = _ref2.positionOrigin;

	  (0, _assert.default)(viewport);

	  if (projectionMode !== undefined) {
	    _log.default.removed('projectionMode', 'coordinateSystem');
	  }

	  if (positionOrigin !== undefined) {
	    _log.default.removed('positionOrigin', 'coordinateOrigin');
	  }

	  return Object.assign({
	    project_uModelMatrix: modelMatrix || IDENTITY_MATRIX
	  }, getMemoizedViewportUniforms({
	    viewport: viewport,
	    devicePixelRatio: devicePixelRatio,
	    coordinateSystem: coordinateSystem,
	    coordinateOrigin: coordinateOrigin
	  }));
	}

	function calculateViewportUniforms(_ref3) {
	  var viewport = _ref3.viewport,
	      devicePixelRatio = _ref3.devicePixelRatio,
	      coordinateSystem = _ref3.coordinateSystem,
	      coordinateOrigin = _ref3.coordinateOrigin;
	  var coordinateZoom = viewport.zoom;
	  (0, _assert.default)(coordinateZoom >= 0);

	  var _calculateMatrixAndOf = calculateMatrixAndOffset({
	    coordinateSystem: coordinateSystem,
	    coordinateOrigin: coordinateOrigin,
	    coordinateZoom: coordinateZoom,
	    viewport: viewport
	  }),
	      projectionCenter = _calculateMatrixAndOf.projectionCenter,
	      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,
	      cameraPos = _calculateMatrixAndOf.cameraPos;

	  (0, _assert.default)(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix'); // Calculate projection pixels per unit

	  var distanceScales = viewport.getDistanceScales();
	  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
	  var uniforms = {
	    // Projection mode values
	    project_uCoordinateSystem: coordinateSystem,
	    project_uCenter: projectionCenter,
	    // Screen size
	    project_uViewportSize: viewportSize,
	    project_uDevicePixelRatio: devicePixelRatio,
	    // Distance at which screen pixels are projected
	    project_uFocalDistance: viewport.focalDistance || 1,
	    project_uPixelsPerMeter: distanceScales.pixelsPerMeter,
	    project_uPixelsPerDegree: distanceScales.pixelsPerDegree,
	    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,
	    project_uPixelsPerUnit2: DEFAULT_PIXELS_PER_UNIT2,
	    project_uScale: viewport.scale,
	    // This is the mercator scale (2 ** zoom)
	    project_uViewProjectionMatrix: viewProjectionMatrix,
	    // This is for lighting calculations
	    project_uCameraPosition: cameraPos
	  };

	  if (coordinateSystem === _constants.COORDINATE_SYSTEM.METER_OFFSETS) {
	    var distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);
	    uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerMeter;
	    uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;
	  }

	  if (coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS) {
	    var _distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);

	    uniforms.project_uPixelsPerUnit = _distanceScalesAtOrigin.pixelsPerDegree;
	    uniforms.project_uPixelsPerUnit2 = _distanceScalesAtOrigin.pixelsPerDegree2;
	  }

	  return uniforms;
	}
	//# sourceMappingURL=viewport-uniforms.js.map

/***/ }),
/* 237 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.COORDINATE_SYSTEM = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// Note: The numeric values here are matched by shader code in the
	// "project" and "project64" shader modules. Both places need to be
	// updated.
	// TODO: Maybe "POSITIONS" would be a better name?
	var COORDINATE_SYSTEM = {
	  // Positions are interpreted as [lng, lat, elevation]
	  // lng lat are degrees, elevation is meters. distances as meters.
	  LNGLAT: 1.0,
	  // Positions are interpreted as meter offsets, distances as meters
	  // Planned to deprecate in later versions
	  METER_OFFSETS: 2.0,
	  METERS: 2.0,
	  // Positions are interpreted as lng lat offsets: [deltaLng, deltaLat, elevation]
	  // deltaLng, deltaLat are delta degrees, elevation is meters.
	  // distances as meters.
	  LNGLAT_OFFSETS: 3.0,
	  // Positions and distances are not transformed: [x, y, z] in unit coordinates
	  IDENTITY: 0.0
	};
	exports.COORDINATE_SYSTEM = COORDINATE_SYSTEM;
	//# sourceMappingURL=constants.js.map

/***/ }),
/* 238 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = memoize;

	function isEqual(a, b) {
	  if (a === b) {
	    return true;
	  }

	  if (Array.isArray(a)) {
	    // Special treatment for arrays: compare 1-level deep
	    // This is to support equality of matrix/coordinate props
	    var len = a.length;

	    if (!b || b.length !== len) {
	      return false;
	    }

	    for (var i = 0; i < len; i++) {
	      if (a[i] !== b[i]) {
	        return false;
	      }
	    }

	    return true;
	  }

	  return false;
	}
	/**
	 * Speed up consecutive function calls by caching the result of calls with identical input
	 * https://en.wikipedia.org/wiki/Memoization
	 * @param {function} compute - the function to be memoized
	 */


	function memoize(compute) {
	  var cachedArgs = {};
	  var cachedResult;
	  return function (args) {
	    for (var key in args) {
	      if (!isEqual(args[key], cachedArgs[key])) {
	        cachedResult = compute(args);
	        cachedArgs = args;
	        break;
	      }
	    }

	    return cachedResult;
	  };
	}
	//# sourceMappingURL=memoize.js.map

/***/ }),
/* 239 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = assert;

	// Replacement for the external assert method to reduce bundle size
	// Note: We don't use the second "message" argument in calling code,
	// so no need to support it here
	function assert(condition, message) {
	  if (!condition) {
	    throw new Error(message || 'deck.gl: assertion failed.');
	  }
	}
	//# sourceMappingURL=assert.js.map

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	Object.defineProperty(exports, "default", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorViewport.default;
	  }
	});
	Object.defineProperty(exports, "WebMercatorViewport", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorViewport.default;
	  }
	});
	Object.defineProperty(exports, "PerspectiveMercatorViewport", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorViewport.default;
	  }
	});
	Object.defineProperty(exports, "fitBounds", {
	  enumerable: true,
	  get: function get() {
	    return _fitBounds.default;
	  }
	});
	Object.defineProperty(exports, "normalizeViewportProps", {
	  enumerable: true,
	  get: function get() {
	    return _normalizeViewportProps.default;
	  }
	});
	Object.defineProperty(exports, "flyToViewport", {
	  enumerable: true,
	  get: function get() {
	    return _flyToViewport.default;
	  }
	});
	Object.defineProperty(exports, "lngLatToWorld", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.lngLatToWorld;
	  }
	});
	Object.defineProperty(exports, "worldToLngLat", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.worldToLngLat;
	  }
	});
	Object.defineProperty(exports, "worldToPixels", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.worldToPixels;
	  }
	});
	Object.defineProperty(exports, "pixelsToWorld", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.pixelsToWorld;
	  }
	});
	Object.defineProperty(exports, "getMeterZoom", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getMeterZoom;
	  }
	});
	Object.defineProperty(exports, "getDistanceScales", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getDistanceScales;
	  }
	});
	Object.defineProperty(exports, "getWorldPosition", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getWorldPosition;
	  }
	});
	Object.defineProperty(exports, "getViewMatrix", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getViewMatrix;
	  }
	});
	Object.defineProperty(exports, "getProjectionMatrix", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getProjectionMatrix;
	  }
	});
	Object.defineProperty(exports, "getProjectionParameters", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getProjectionParameters;
	  }
	});
	Object.defineProperty(exports, "getUncenteredViewMatrix", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.getViewMatrix;
	  }
	});
	Object.defineProperty(exports, "projectFlat", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.lngLatToWorld;
	  }
	});
	Object.defineProperty(exports, "unprojectFlat", {
	  enumerable: true,
	  get: function get() {
	    return _webMercatorUtils.worldToLngLat;
	  }
	});

	var _webMercatorViewport = _interopRequireDefault(__webpack_require__(241));

	var _fitBounds = _interopRequireDefault(__webpack_require__(247));

	var _normalizeViewportProps = _interopRequireDefault(__webpack_require__(250));

	var _flyToViewport = _interopRequireDefault(__webpack_require__(251));

	var _webMercatorUtils = __webpack_require__(244);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=index.js.map

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(242));

	var _webMercatorUtils = __webpack_require__(244);

	var _fitBounds3 = _interopRequireDefault(__webpack_require__(247));

	var _add = _interopRequireDefault(__webpack_require__(248));

	var _negate = _interopRequireDefault(__webpack_require__(249));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var WebMercatorViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(WebMercatorViewport, _Viewport);

	  /**
	   * @classdesc
	   * Creates view/projection matrices from mercator params
	   * Note: The Viewport is immutable in the sense that it only has accessors.
	   * A new viewport instance should be created if any parameters have changed.
	   *
	   * @class
	   * @param {Object} opt - options
	   *
	   * @param {Number} opt.width=1 - Width of "viewport" or window
	   * @param {Number} opt.height=1 - Height of "viewport" or window
	   * @param {Number} opt.scale=1 - Either use scale or zoom
	   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
	   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
	   * @param {Number} opt.altitude= - Altitude of camera in screen units
	   *
	   * Web mercator projection short-hand parameters
	   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
	   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
	   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
	    * Notes:
	   *  - Only one of center or [latitude, longitude] can be specified
	   *  - [latitude, longitude] can only be specified when "mercator" is true
	   *  - Altitude has a default value that matches assumptions in mapbox-gl
	   *  - width and height are forced to 1 if supplied as 0, to avoid
	   *    division by zero. This is intended to reduce the burden of apps to
	   *    to check values before instantiating a Viewport.
	   */

	  /* eslint-disable complexity */
	  function WebMercatorViewport() {
	    var _this;

	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        width = _ref.width,
	        height = _ref.height,
	        _ref$latitude = _ref.latitude,
	        latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,
	        _ref$longitude = _ref.longitude,
	        longitude = _ref$longitude === void 0 ? 0 : _ref$longitude,
	        _ref$zoom = _ref.zoom,
	        zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,
	        _ref$pitch = _ref.pitch,
	        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
	        _ref$bearing = _ref.bearing,
	        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing,
	        _ref$altitude = _ref.altitude,
	        altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude,
	        _ref$farZMultiplier = _ref.farZMultiplier,
	        farZMultiplier = _ref$farZMultiplier === void 0 ? 10 : _ref$farZMultiplier;

	    _classCallCheck(this, WebMercatorViewport);

	    // Silently allow apps to send in 0,0 to facilitate isomorphic render etc
	    width = width || 1;
	    height = height || 1;
	    var scale = (0, _webMercatorUtils.zoomToScale)(zoom); // Altitude - prevent division by 0
	    // TODO - just throw an Error instead?

	    altitude = Math.max(0.75, altitude);
	    var center = (0, _webMercatorUtils.getWorldPosition)({
	      longitude: longitude,
	      latitude: latitude,
	      scale: scale
	    });
	    var projectionMatrix = (0, _webMercatorUtils.getProjectionMatrix)({
	      width: width,
	      height: height,
	      pitch: pitch,
	      bearing: bearing,
	      altitude: altitude,
	      farZMultiplier: farZMultiplier
	    });
	    var viewMatrix = (0, _webMercatorUtils.getViewMatrix)({
	      height: height,
	      center: center,
	      pitch: pitch,
	      bearing: bearing,
	      altitude: altitude,
	      flipY: true
	    });
	    _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, {
	      width: width,
	      height: height,
	      viewMatrix: viewMatrix,
	      projectionMatrix: projectionMatrix
	    })); // Save parameters

	    _this.latitude = latitude;
	    _this.longitude = longitude;
	    _this.zoom = zoom;
	    _this.pitch = pitch;
	    _this.bearing = bearing;
	    _this.altitude = altitude;
	    _this.scale = scale;
	    _this.center = center;
	    Object.freeze(_assertThisInitialized(_this));
	    return _this;
	  }
	  /* eslint-enable complexity */

	  /**
	   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
	   * Performs the nonlinear part of the web mercator projection.
	   * Remaining projection is done with 4x4 matrices which also handles
	   * perspective.
	   *
	   * @param {Array} lngLat - [lng, lat] coordinates
	   *   Specifies a point on the sphere to project onto the map.
	   * @return {Array} [x,y] coordinates.
	   */


	  _createClass(WebMercatorViewport, [{
	    key: "projectFlat",
	    value: function projectFlat(lngLat) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return (0, _webMercatorUtils.lngLatToWorld)(lngLat, scale);
	    }
	    /**
	     * Unproject world point [x,y] on map onto {lat, lon} on sphere
	     *
	     * @param {object|Vector} xy - object with {x,y} members
	     *  representing point on projected map plane
	     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
	     *   Has toArray method if you need a GeoJSON Array.
	     *   Per cartographic tradition, lat and lon are specified as degrees.
	     */

	  }, {
	    key: "unprojectFlat",
	    value: function unprojectFlat(xy) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return (0, _webMercatorUtils.worldToLngLat)(xy, scale);
	    }
	    /**
	     * Get the map center that place a given [lng, lat] coordinate at screen
	     * point [x, y]
	     *
	     * @param {Array} lngLat - [lng,lat] coordinates
	     *   Specifies a point on the sphere.
	     * @param {Array} pos - [x,y] coordinates
	     *   Specifies a point on the screen.
	     * @return {Array} [lng,lat] new map center.
	     */

	  }, {
	    key: "getMapCenterByLngLatPosition",
	    value: function getMapCenterByLngLatPosition(_ref2) {
	      var lngLat = _ref2.lngLat,
	          pos = _ref2.pos;
	      var fromLocation = (0, _webMercatorUtils.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
	      var toLocation = (0, _webMercatorUtils.lngLatToWorld)(lngLat, this.scale);
	      var translate = (0, _add.default)([], toLocation, (0, _negate.default)([], fromLocation));
	      var newCenter = (0, _add.default)([], this.center, translate);
	      return (0, _webMercatorUtils.worldToLngLat)(newCenter, this.scale);
	    } // Legacy method name

	  }, {
	    key: "getLocationAtPoint",
	    value: function getLocationAtPoint(_ref3) {
	      var lngLat = _ref3.lngLat,
	          pos = _ref3.pos;
	      return this.getMapCenterByLngLatPosition({
	        lngLat: lngLat,
	        pos: pos
	      });
	    }
	    /**
	     * Returns a new viewport that fit around the given rectangle.
	     * Only supports non-perspective mode.
	     * @param {Array} bounds - [[lon, lat], [lon, lat]]
	     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
	     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
	     *    [x, y] measured in pixels.
	     * @returns {WebMercatorViewport}
	     */

	  }, {
	    key: "fitBounds",
	    value: function fitBounds(bounds) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var width = this.width,
	          height = this.height;

	      var _fitBounds2 = (0, _fitBounds3.default)(Object.assign({
	        width: width,
	        height: height,
	        bounds: bounds
	      }, options)),
	          longitude = _fitBounds2.longitude,
	          latitude = _fitBounds2.latitude,
	          zoom = _fitBounds2.zoom;

	      return new WebMercatorViewport({
	        width: width,
	        height: height,
	        longitude: longitude,
	        latitude: latitude,
	        zoom: zoom
	      });
	    }
	  }]);

	  return WebMercatorViewport;
	}(_viewport.default);

	exports.default = WebMercatorViewport;
	//# sourceMappingURL=web-mercator-viewport.js.map

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _math = __webpack_require__(109);

	var _mathUtils = __webpack_require__(243);

	var _webMercatorUtils = __webpack_require__(244);

	var _scale = _interopRequireDefault(__webpack_require__(137));

	var _translate = _interopRequireDefault(__webpack_require__(138));

	var _multiply = _interopRequireDefault(__webpack_require__(135));

	var _invert = _interopRequireDefault(__webpack_require__(134));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var IDENTITY = (0, _mathUtils.createMat4)();

	var Viewport =
	/*#__PURE__*/
	function () {
	  /**
	   * @classdesc
	   * Manages coordinate system transformations for deck.gl.
	   *
	   * Note: The Viewport is immutable in the sense that it only has accessors.
	   * A new viewport instance should be created if any parameters have changed.
	   *
	   * @class
	   * @param {Object} opt - options
	   * @param {Boolean} mercator=true - Whether to use mercator projection
	   *
	   * @param {Number} opt.width=1 - Width of "viewport" or window
	   * @param {Number} opt.height=1 - Height of "viewport" or window
	   * @param {Array} opt.center=[0, 0] - Center of viewport
	   *   [longitude, latitude] or [x, y]
	   * @param {Number} opt.scale=1 - Either use scale or zoom
	   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)
	   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)
	   * @param {Number} opt.altitude= - Altitude of camera in screen units
	   *
	   * Web mercator projection short-hand parameters
	   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)
	   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)
	   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)
	   */

	  /* eslint-disable complexity */
	  function Viewport() {
	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        width = _ref.width,
	        height = _ref.height,
	        _ref$viewMatrix = _ref.viewMatrix,
	        viewMatrix = _ref$viewMatrix === void 0 ? IDENTITY : _ref$viewMatrix,
	        _ref$projectionMatrix = _ref.projectionMatrix,
	        projectionMatrix = _ref$projectionMatrix === void 0 ? IDENTITY : _ref$projectionMatrix;

	    _classCallCheck(this, Viewport);

	    // Silently allow apps to send in 0,0
	    this.width = width || 1;
	    this.height = height || 1;
	    this.scale = 1;
	    this.viewMatrix = viewMatrix;
	    this.projectionMatrix = projectionMatrix; // Note: As usual, matrix operations should be applied in "reverse" order
	    // since vectors will be multiplied in from the right during transformation

	    var vpm = (0, _mathUtils.createMat4)();
	    (0, _multiply.default)(vpm, vpm, this.projectionMatrix);
	    (0, _multiply.default)(vpm, vpm, this.viewMatrix);
	    this.viewProjectionMatrix = vpm; // Calculate matrices and scales needed for projection

	    /**
	     * Builds matrices that converts preprojected lngLats to screen pixels
	     * and vice versa.
	     * Note: Currently returns bottom-left coordinates!
	     * Note: Starts with the GL projection matrix and adds steps to the
	     *       scale and translate that matrix onto the window.
	     * Note: WebGL controls clip space to screen projection with gl.viewport
	     *       and does not need this step.
	     */

	    var m = (0, _mathUtils.createMat4)(); // matrix for conversion from location to screen coordinates

	    (0, _scale.default)(m, m, [this.width / 2, -this.height / 2, 1]);
	    (0, _translate.default)(m, m, [1, -1, 0]);
	    (0, _multiply.default)(m, m, this.viewProjectionMatrix);
	    var mInverse = (0, _invert.default)((0, _mathUtils.createMat4)(), m);

	    if (!mInverse) {
	      throw new Error('Pixel project matrix not invertible');
	    }

	    this.pixelProjectionMatrix = m;
	    this.pixelUnprojectionMatrix = mInverse; // Bind methods for easy access

	    this.equals = this.equals.bind(this);
	    this.project = this.project.bind(this);
	    this.unproject = this.unproject.bind(this);
	    this.projectFlat = this.projectFlat.bind(this);
	    this.unprojectFlat = this.unprojectFlat.bind(this);
	  }
	  /* eslint-enable complexity */
	  // Two viewports are equal if width and height are identical, and if
	  // their view and projection matrices are (approximately) equal.


	  _createClass(Viewport, [{
	    key: "equals",
	    value: function equals(viewport) {
	      if (!_instanceof(viewport, Viewport)) {
	        return false;
	      }

	      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix);
	    }
	    /**
	     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
	     * using viewport projection parameters
	     * - [longitude, latitude] to [x, y]
	     * - [longitude, latitude, Z] => [x, y, z]
	     * Note: By default, returns top-left coordinates for canvas/SVG type render
	     *
	     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
	     * @param {Object} opts - options
	     * @param {Object} opts.topLeft=true - Whether projected coords are top left
	     * @return {Array} - screen coordinates [x, y] or [x, y, z], z as pixel depth
	     */

	  }, {
	    key: "project",
	    value: function project(xyz) {
	      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref2$topLeft = _ref2.topLeft,
	          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft;

	      var _xyz = _slicedToArray(xyz, 3),
	          x0 = _xyz[0],
	          y0 = _xyz[1],
	          z0 = _xyz[2];

	      var _projectFlat = this.projectFlat([x0, y0]),
	          _projectFlat2 = _slicedToArray(_projectFlat, 2),
	          X = _projectFlat2[0],
	          Y = _projectFlat2[1];

	      var coord = (0, _webMercatorUtils.worldToPixels)([X, Y, z0], this.pixelProjectionMatrix);

	      var _coord = _slicedToArray(coord, 2),
	          x = _coord[0],
	          y = _coord[1];

	      var y2 = topLeft ? y : this.height - y;
	      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
	    }
	    /**
	     * Unproject pixel coordinates on screen onto world coordinates,
	     * (possibly [lon, lat]) on map.
	     * - [x, y] => [lng, lat]
	     * - [x, y, z] => [lng, lat, Z]
	     * @param {Array} xyz - screen coordinates, z as pixel depth
	     * @param {Object} opts - options
	     * @param {Object} opts.topLeft=true - Whether projected coords are top left
	     * @param {Object} opts.targetZ=0 - If pixel depth is unknown, targetZ is used as
	     *   the elevation plane to unproject onto
	     * @return {Array} - [lng, lat, Z] or [X, Y, Z]
	     */

	  }, {
	    key: "unproject",
	    value: function unproject(xyz) {
	      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref3$topLeft = _ref3.topLeft,
	          topLeft = _ref3$topLeft === void 0 ? true : _ref3$topLeft,
	          targetZ = _ref3.targetZ;

	      var _xyz2 = _slicedToArray(xyz, 3),
	          x = _xyz2[0],
	          y = _xyz2[1],
	          z = _xyz2[2];

	      var y2 = topLeft ? y : this.height - y;
	      var coord = (0, _webMercatorUtils.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZ);

	      var _unprojectFlat = this.unprojectFlat(coord),
	          _unprojectFlat2 = _slicedToArray(_unprojectFlat, 2),
	          X = _unprojectFlat2[0],
	          Y = _unprojectFlat2[1];

	      if (Number.isFinite(z)) {
	        // Has depth component
	        return [X, Y, coord[2]];
	      }

	      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
	    } // NON_LINEAR PROJECTION HOOKS
	    // Used for web meractor projection

	    /**
	     * Project map coordinates to world coordinates.
	     * This should be overridden by each viewport that implements a specific
	     * geographic projection.
	     * @param {Array} xyz - map coordinates
	     * @return {Array} [x,y,z] world coordinates.
	     */

	  }, {
	    key: "projectFlat",
	    value: function projectFlat(xyz) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return xyz;
	    }
	    /**
	     * Project world coordinates to map coordinates.
	     * This should be overridden by each viewport that implements a specific
	     * geographic projection.
	     * @param {Array} xyz - world coordinates
	     * @return {Array} [x,y,z] map coordinates.
	     */

	  }, {
	    key: "unprojectFlat",
	    value: function unprojectFlat(xyz) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return xyz;
	    }
	  }]);

	  return Viewport;
	}();

	exports.default = Viewport;
	//# sourceMappingURL=viewport.js.map

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createMat4 = createMat4;
	exports.transformVector = transformVector;
	exports.mod = mod;
	exports.lerp = lerp;

	var _scale = _interopRequireDefault(__webpack_require__(171));

	var _transformMat = _interopRequireDefault(__webpack_require__(141));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()
	function createMat4() {
	  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	} // Transforms a vec4 with a projection matrix


	function transformVector(matrix, vector) {
	  var result = (0, _transformMat.default)([], vector, matrix);
	  (0, _scale.default)(result, result, 1 / result[3]);
	  return result;
	}

	function mod(value, divisor) {
	  var modulus = value % divisor;
	  return modulus < 0 ? divisor + modulus : modulus;
	}

	function lerp(start, end, step) {
	  return step * end + (1 - step) * start;
	}
	//# sourceMappingURL=math-utils.js.map

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.zoomToScale = zoomToScale;
	exports.scaleToZoom = scaleToZoom;
	exports.lngLatToWorld = lngLatToWorld;
	exports.worldToLngLat = worldToLngLat;
	exports.getMeterZoom = getMeterZoom;
	exports.getDistanceScales = getDistanceScales;
	exports.getWorldPosition = getWorldPosition;
	exports.getViewMatrix = getViewMatrix;
	exports.getProjectionParameters = getProjectionParameters;
	exports.getProjectionMatrix = getProjectionMatrix;
	exports.worldToPixels = worldToPixels;
	exports.pixelsToWorld = pixelsToWorld;

	var _math = __webpack_require__(109);

	var _mathUtils = __webpack_require__(243);

	var _perspective = _interopRequireDefault(__webpack_require__(132));

	var _scale = _interopRequireDefault(__webpack_require__(137));

	var _translate = _interopRequireDefault(__webpack_require__(138));

	var _rotateX = _interopRequireDefault(__webpack_require__(142));

	var _rotateZ = _interopRequireDefault(__webpack_require__(144));

	var _lerp = _interopRequireDefault(__webpack_require__(245));

	var _assert = _interopRequireDefault(__webpack_require__(246));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	// CONSTANTS
	var PI = Math.PI;
	var PI_4 = PI / 4;
	var DEGREES_TO_RADIANS = PI / 180;
	var RADIANS_TO_DEGREES = 180 / PI;
	var TILE_SIZE = 512; // Average circumference (40075 km equatorial, 40007 km meridional)

	var EARTH_CIRCUMFERENCE = 40.03e6; // Mapbox default altitude

	var DEFAULT_ALTITUDE = 1.5;
	/** Util functions **/

	function zoomToScale(zoom) {
	  return Math.pow(2, zoom);
	}

	function scaleToZoom(scale) {
	  return Math.log2(scale);
	}
	/**
	 * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
	 * Performs the nonlinear part of the web mercator projection.
	 * Remaining projection is done with 4x4 matrices which also handles
	 * perspective.
	 *
	 * @param {Array} lngLat - [lng, lat] coordinates
	 *   Specifies a point on the sphere to project onto the map.
	 * @return {Array} [x,y] coordinates.
	 */


	function lngLatToWorld(_ref, scale) {
	  var _ref2 = _slicedToArray(_ref, 2),
	      lng = _ref2[0],
	      lat = _ref2[1];

	  scale *= TILE_SIZE;
	  var lambda2 = lng * DEGREES_TO_RADIANS;
	  var phi2 = lat * DEGREES_TO_RADIANS;
	  var x = scale * (lambda2 + PI) / (2 * PI);
	  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
	  return [x, y];
	}
	/**
	 * Unproject world point [x,y] on map onto {lat, lon} on sphere
	 *
	 * @param {object|Vector} xy - object with {x,y} members
	 *  representing point on projected map plane
	 * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
	 *   Has toArray method if you need a GeoJSON Array.
	 *   Per cartographic tradition, lat and lon are specified as degrees.
	 */


	function worldToLngLat(_ref3, scale) {
	  var _ref4 = _slicedToArray(_ref3, 2),
	      x = _ref4[0],
	      y = _ref4[1];

	  scale *= TILE_SIZE;
	  var lambda2 = x / scale * (2 * PI) - PI;
	  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);
	  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
	} // Returns the zoom level that gives a 1 meter pixel at a certain latitude
	// 1 = C*cos(y)/2^z/TILE_SIZE = C*cos(y)/2^(z+9)


	function getMeterZoom(_ref5) {
	  var latitude = _ref5.latitude;
	  (0, _assert.default)(Number.isFinite(latitude));
	  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
	  return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
	}
	/**
	 * Calculate distance scales in meters around current lat/lon, both for
	 * degrees and pixels.
	 * In mercator projection mode, the distance scales vary significantly
	 * with latitude.
	 */


	function getDistanceScales(_ref6) {
	  var latitude = _ref6.latitude,
	      longitude = _ref6.longitude,
	      zoom = _ref6.zoom,
	      scale = _ref6.scale,
	      _ref6$highPrecision = _ref6.highPrecision,
	      highPrecision = _ref6$highPrecision === void 0 ? false : _ref6$highPrecision;
	  // Calculate scale from zoom if not provided
	  scale = scale !== undefined ? scale : zoomToScale(zoom);
	  (0, _assert.default)(Number.isFinite(latitude) && Number.isFinite(longitude) && Number.isFinite(scale));
	  var result = {};
	  var worldSize = TILE_SIZE * scale;
	  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);
	  /**
	   * Number of pixels occupied by one degree longitude around current lat/lon:
	     pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)
	       = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)
	     pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)
	       = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)
	   */

	  var pixelsPerDegreeX = worldSize / 360;
	  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;
	  /**
	   * Number of pixels occupied by one meter around current lat/lon:
	   */

	  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
	  result.pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];
	  result.metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / altPixelsPerMeter];
	  result.pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, altPixelsPerMeter];
	  result.degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];
	  /**
	   * Taylor series 2nd order for 1/latCosine
	     f'(a) * (x - a)
	       = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat
	       = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat
	   */

	  if (highPrecision) {
	    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;
	    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;
	    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
	    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;
	    result.pixelsPerDegree2 = [0, pixelsPerDegreeY2, altPixelsPerDegree2];
	    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];
	  } // Main results, used for converting meters to latlng deltas and scaling offsets


	  return result;
	}
	/**
	 * Calculates a mercator world position ("pixels" in given zoom level)
	 * from a lng/lat and meterOffset
	 */


	function getWorldPosition(_ref7) {
	  var longitude = _ref7.longitude,
	      latitude = _ref7.latitude,
	      zoom = _ref7.zoom,
	      scale = _ref7.scale,
	      meterOffset = _ref7.meterOffset,
	      _ref7$distanceScales = _ref7.distanceScales,
	      distanceScales = _ref7$distanceScales === void 0 ? null : _ref7$distanceScales;
	  // Calculate scale from zoom if not provided
	  scale = scale !== undefined ? scale : zoomToScale(zoom); // Make a centered version of the matrix for projection modes without an offset

	  var center2d = lngLatToWorld([longitude, latitude], scale);
	  var center = new _math.Vector3(center2d[0], center2d[1], 0);

	  if (meterOffset) {
	    // Calculate distance scales if lng/lat/zoom are provided
	    distanceScales = distanceScales || getDistanceScales({
	      latitude: latitude,
	      longitude: longitude,
	      scale: scale
	    });
	    var pixelPosition = new _math.Vector3(meterOffset) // Convert to pixels in current zoom
	    .scale(distanceScales.pixelsPerMeter) // We want positive Y to represent an offset towards north,
	    // but web mercator world coordinates is top-left
	    .scale([1, -1, 1]);
	    center.add(pixelPosition);
	  }

	  return center;
	} // ATTRIBUTION:
	// view and projection matrix creation is intentionally kept compatible with
	// mapbox-gl's implementation to ensure that seamless interoperation
	// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js


	function getViewMatrix(_ref8) {
	  var height = _ref8.height,
	      pitch = _ref8.pitch,
	      bearing = _ref8.bearing,
	      altitude = _ref8.altitude,
	      _ref8$center = _ref8.center,
	      center = _ref8$center === void 0 ? null : _ref8$center,
	      _ref8$flipY = _ref8.flipY,
	      flipY = _ref8$flipY === void 0 ? false : _ref8$flipY;
	  // VIEW MATRIX: PROJECTS MERCATOR WORLD COORDINATES
	  // Note that mercator world coordinates typically need to be flipped
	  //
	  // Note: As usual, matrix operation orders should be read in reverse
	  // since vectors will be multiplied from the right during transformation
	  var vm = (0, _mathUtils.createMat4)(); // Move camera to altitude (along the pitch & bearing direction)

	  (0, _translate.default)(vm, vm, [0, 0, -altitude]); // After the rotateX, z values are in pixel units. Convert them to
	  // altitude units. 1 altitude unit = the screen height.

	  (0, _scale.default)(vm, vm, [1, 1, 1 / height]); // Rotate by bearing, and then by pitch (which tilts the view)

	  (0, _rotateX.default)(vm, vm, -pitch * DEGREES_TO_RADIANS);
	  (0, _rotateZ.default)(vm, vm, bearing * DEGREES_TO_RADIANS);

	  if (flipY) {
	    (0, _scale.default)(vm, vm, [1, -1, 1]);
	  }

	  if (center) {
	    (0, _translate.default)(vm, vm, new _math.Vector3(center).negate());
	  }

	  return vm;
	} // PROJECTION MATRIX PARAMETERS
	// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
	// Variable fov (in radians)


	function getProjectionParameters(_ref9) {
	  var width = _ref9.width,
	      height = _ref9.height,
	      _ref9$altitude = _ref9.altitude,
	      altitude = _ref9$altitude === void 0 ? DEFAULT_ALTITUDE : _ref9$altitude,
	      _ref9$pitch = _ref9.pitch,
	      pitch = _ref9$pitch === void 0 ? 0 : _ref9$pitch,
	      _ref9$farZMultiplier = _ref9.farZMultiplier,
	      farZMultiplier = _ref9$farZMultiplier === void 0 ? 1 : _ref9$farZMultiplier;
	  // Find the distance from the center point to the center top
	  // in altitude units using law of sines.
	  var pitchRadians = pitch * DEGREES_TO_RADIANS;
	  var halfFov = Math.atan(0.5 / altitude);
	  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov); // Calculate z value of the farthest fragment that should be rendered.

	  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;
	  return {
	    fov: 2 * Math.atan(height / 2 / altitude),
	    aspect: width / height,
	    focalDistance: altitude,
	    near: 0.1,
	    far: farZ * farZMultiplier
	  };
	} // PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE
	// This is a "Mapbox" projection matrix - matches mapbox exactly if farZMultiplier === 1
	// Variable fov (in radians)


	function getProjectionMatrix(_ref10) {
	  var width = _ref10.width,
	      height = _ref10.height,
	      pitch = _ref10.pitch,
	      altitude = _ref10.altitude,
	      _ref10$farZMultiplier = _ref10.farZMultiplier,
	      farZMultiplier = _ref10$farZMultiplier === void 0 ? 10 : _ref10$farZMultiplier;

	  var _getProjectionParamet = getProjectionParameters({
	    width: width,
	    height: height,
	    altitude: altitude,
	    pitch: pitch,
	    farZMultiplier: farZMultiplier
	  }),
	      fov = _getProjectionParamet.fov,
	      aspect = _getProjectionParamet.aspect,
	      near = _getProjectionParamet.near,
	      far = _getProjectionParamet.far;

	  var projectionMatrix = (0, _perspective.default)([], fov, // fov in radians
	  aspect, // aspect ratio
	  near, // near plane
	  far // far plane
	  );
	  return projectionMatrix;
	}
	/**
	 * Project flat coordinates to pixels on screen.
	 *
	 * @param {Array} xyz - flat coordinate on 512*512 Mercator Zoom 0 tile
	 * @param {Matrix4} pixelProjectionMatrix - projection matrix
	 * @return {Array} [x, y, depth] pixel coordinate on screen.
	 */


	function worldToPixels(xyz, pixelProjectionMatrix) {
	  var _xyz = _slicedToArray(xyz, 3),
	      x = _xyz[0],
	      y = _xyz[1],
	      _xyz$ = _xyz[2],
	      z = _xyz$ === void 0 ? 0 : _xyz$;

	  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
	  return (0, _mathUtils.transformVector)(pixelProjectionMatrix, [x, y, z, 1]);
	}
	/**
	 * Unproject pixels on screen to flat coordinates.
	 *
	 * @param {Array} xyz - pixel coordinate on screen.
	 * @param {Matrix4} pixelUnprojectionMatrix - unprojection matrix
	 * @param {Number} targetZ - if pixel coordinate does not have a 3rd component (depth),
	 *    targetZ is used as the elevation plane to unproject onto
	 * @return {Array} [x, y, Z] flat coordinates on 512*512 Mercator Zoom 0 tile.
	 */


	function pixelsToWorld(xyz, pixelUnprojectionMatrix) {
	  var targetZ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	  var _xyz2 = _slicedToArray(xyz, 3),
	      x = _xyz2[0],
	      y = _xyz2[1],
	      z = _xyz2[2];

	  (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y));

	  if (Number.isFinite(z)) {
	    // Has depth component
	    var coord = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, z, 1]);
	    return coord;
	  } // since we don't know the correct projected z value for the point,
	  // unproject two points to get a line and then find the point on that line with z=0


	  var coord0 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 0, 1]);
	  var coord1 = (0, _mathUtils.transformVector)(pixelUnprojectionMatrix, [x, y, 1, 1]);
	  var z0 = coord0[2];
	  var z1 = coord1[2];
	  var t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
	  return (0, _lerp.default)([], coord0, coord1, t);
	}
	//# sourceMappingURL=web-mercator-utils.js.map

/***/ }),
/* 245 */
/***/ (function(module, exports) {

	module.exports = lerp

	/**
	 * Performs a linear interpolation between two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @param {Number} t interpolation amount between the two inputs
	 * @returns {vec2} out
	 */
	function lerp(out, a, b, t) {
	    var ax = a[0],
	        ay = a[1]
	    out[0] = ax + t * (b[0] - ax)
	    out[1] = ay + t * (b[1] - ay)
	    return out
	}

/***/ }),
/* 246 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = assert;

	// Replacement for the external assert method to reduce bundle size
	// Note: We don't use the second "message" argument in calling code,
	// so no need to support it here
	function assert(condition) {
	  if (!condition) {
	    throw new Error('viewport-mercator-project: assertion failed.');
	  }
	}
	//# sourceMappingURL=assert.js.map

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = fitBounds;

	var _webMercatorViewport = _interopRequireDefault(__webpack_require__(241));

	var _assert = _interopRequireDefault(__webpack_require__(246));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	/**
	 * * An object describing the padding to add to the bounds.
	 * @typedef {Object} PaddingObject
	 * @property {Number} top - Padding from top in pixels to add to the given bounds
	 * @property {Number} bottom - Padding from bottom in pixels to add to the given bounds
	 * @property {Number} left - Padding from left in pixels to add to the given bounds
	 * @property {Number} right - Padding from right in pixels to add to the given bounds
	 */

	/**
	 * Returns map settings {latitude, longitude, zoom}
	 * that will contain the provided corners within the provided width.
	 * Only supports non-perspective mode.
	 * @param {Number} width - viewport width
	 * @param {Number} height - viewport height
	 * @param {Array} bounds - [[lon, lat], [lon, lat]]
	 * @param {Number|PaddingObject} [padding] - The amount of padding in pixels
	 *  to add to the given bounds. Can also be an object with top, bottom, left and right
	 *  properties defining the padding.
	 * @param {Array} [offset] - The center of the given bounds relative to the map's center,
	 *    [x, y] measured in pixels.
	 * @returns {Object} - latitude, longitude and zoom
	 */
	function fitBounds(_ref) {
	  var width = _ref.width,
	      height = _ref.height,
	      bounds = _ref.bounds,
	      _ref$padding = _ref.padding,
	      padding = _ref$padding === void 0 ? 0 : _ref$padding,
	      _ref$offset = _ref.offset,
	      offset = _ref$offset === void 0 ? [0, 0] : _ref$offset;

	  var _bounds = _slicedToArray(bounds, 2),
	      _bounds$ = _slicedToArray(_bounds[0], 2),
	      west = _bounds$[0],
	      south = _bounds$[1],
	      _bounds$2 = _slicedToArray(_bounds[1], 2),
	      east = _bounds$2[0],
	      north = _bounds$2[1];

	  if (Number.isFinite(padding)) {
	    var p = padding;
	    padding = {
	      top: p,
	      bottom: p,
	      left: p,
	      right: p
	    };
	  } else {
	    // Make sure all the required properties are set
	    (0, _assert.default)(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
	  }

	  var viewport = new _webMercatorViewport.default({
	    width: width,
	    height: height,
	    longitude: 0,
	    latitude: 0,
	    zoom: 0
	  });
	  var nw = viewport.project([west, north]);
	  var se = viewport.project([east, south]); // width/height on the Web Mercator plane

	  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];
	  var targetSize = [width - padding.left - padding.right - Math.abs(offset[0]) * 2, height - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
	  (0, _assert.default)(targetSize[0] > 0 && targetSize[1] > 0); // scale = screen pixels per unit on the Web Mercator plane

	  var scaleX = targetSize[0] / size[0];
	  var scaleY = targetSize[1] / size[1]; // Find how much we need to shift the center

	  var offsetX = (padding.right - padding.left) / 2 / scaleX;
	  var offsetY = (padding.bottom - padding.top) / 2 / scaleY;
	  var center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
	  var centerLngLat = viewport.unproject(center);
	  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));
	  return {
	    longitude: centerLngLat[0],
	    latitude: centerLngLat[1],
	    zoom: zoom
	  };
	}
	//# sourceMappingURL=fit-bounds.js.map

/***/ }),
/* 248 */
/***/ (function(module, exports) {

	module.exports = add

	/**
	 * Adds two vec2's
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a the first operand
	 * @param {vec2} b the second operand
	 * @returns {vec2} out
	 */
	function add(out, a, b) {
	    out[0] = a[0] + b[0]
	    out[1] = a[1] + b[1]
	    return out
	}

/***/ }),
/* 249 */
/***/ (function(module, exports) {

	module.exports = negate

	/**
	 * Negates the components of a vec2
	 *
	 * @param {vec2} out the receiving vector
	 * @param {vec2} a vector to negate
	 * @returns {vec2} out
	 */
	function negate(out, a) {
	    out[0] = -a[0]
	    out[1] = -a[1]
	    return out
	}

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = normalizeViewportProps;

	var _webMercatorViewport = _interopRequireDefault(__webpack_require__(241));

	var _mathUtils = __webpack_require__(243);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// defined by mapbox-gl
	var MAX_LATITUDE = 85.05113;
	var MIN_LATITUDE = -85.05113; // Apply mathematical constraints to viewport props

	/* eslint-disable complexity */

	function normalizeViewportProps(_ref) {
	  var width = _ref.width,
	      height = _ref.height,
	      longitude = _ref.longitude,
	      latitude = _ref.latitude,
	      zoom = _ref.zoom,
	      _ref$pitch = _ref.pitch,
	      pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
	      _ref$bearing = _ref.bearing,
	      bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;

	  // Normalize degrees
	  if (longitude < -180 || longitude > 180) {
	    longitude = (0, _mathUtils.mod)(longitude + 180, 360) - 180;
	  }

	  if (bearing < -180 || bearing > 180) {
	    bearing = (0, _mathUtils.mod)(bearing + 180, 360) - 180;
	  } // Constrain zoom and shift center at low zoom levels


	  var flatViewport = new _webMercatorViewport.default({
	    width: width,
	    height: height,
	    longitude: longitude,
	    latitude: latitude,
	    zoom: zoom
	  });
	  var topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
	  var bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
	  var shiftY = 0;

	  if (bottomY - topY < height) {
	    // Map height must not be smaller than viewport height
	    // Zoom out map to fit map height into viewport
	    zoom += Math.log2(height / (bottomY - topY)); // Calculate top and bottom using new zoom

	    flatViewport = new _webMercatorViewport.default({
	      width: width,
	      height: height,
	      longitude: longitude,
	      latitude: latitude,
	      zoom: zoom
	    });
	    topY = flatViewport.project([longitude, MAX_LATITUDE])[1];
	    bottomY = flatViewport.project([longitude, MIN_LATITUDE])[1];
	  }

	  if (topY > 0) {
	    // Compensate for white gap on top
	    shiftY = topY;
	  } else if (bottomY < height) {
	    // Compensate for white gap on bottom
	    shiftY = bottomY - height;
	  }

	  if (shiftY) {
	    latitude = flatViewport.unproject([width / 2, height / 2 + shiftY])[1];
	  }

	  return {
	    width: width,
	    height: height,
	    longitude: longitude,
	    latitude: latitude,
	    zoom: zoom,
	    pitch: pitch,
	    bearing: bearing
	  };
	}
	//# sourceMappingURL=normalize-viewport-props.js.map

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = flyToViewport;

	var _math = __webpack_require__(109);

	var _mathUtils = __webpack_require__(243);

	var _webMercatorUtils = __webpack_require__(244);

	var EPSILON = 0.01;
	var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];
	/**
	 * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.
	 * It implements “Smooth and efficient zooming and panning.” algorithm by
	 * "Jarke J. van Wijk and Wim A.A. Nuij"
	*/

	/* eslint-disable max-statements */

	function flyToViewport(startProps, endProps, t) {
	  // Equations from above paper are referred where needed.
	  var viewport = {}; // TODO: add this as an option for applications.

	  var rho = 1.414;
	  var startZoom = startProps.zoom;
	  var startCenter = [startProps.longitude, startProps.latitude];
	  var startScale = (0, _webMercatorUtils.zoomToScale)(startZoom);
	  var endZoom = endProps.zoom;
	  var endCenter = [endProps.longitude, endProps.latitude];
	  var scale = (0, _webMercatorUtils.zoomToScale)(endZoom - startZoom);
	  var startCenterXY = new _math.Vector2((0, _webMercatorUtils.lngLatToWorld)(startCenter, startScale));
	  var endCenterXY = new _math.Vector2((0, _webMercatorUtils.lngLatToWorld)(endCenter, startScale));
	  var uDelta = endCenterXY.subtract(startCenterXY);
	  var w0 = Math.max(startProps.width, startProps.height);
	  var w1 = w0 / scale;
	  var u1 = Math.sqrt(uDelta.x * uDelta.x + uDelta.y * uDelta.y); // u0 is treated as '0' in Eq (9).
	  // If change in center is too small, do linear interpolaiton.

	  if (Math.abs(u1) < EPSILON) {
	    for (var _i = 0; _i < VIEWPORT_TRANSITION_PROPS.length; _i++) {
	      var key = VIEWPORT_TRANSITION_PROPS[_i];
	      var startValue = startProps[key];
	      var endValue = endProps[key];
	      viewport[key] = (0, _mathUtils.lerp)(startValue, endValue, t);
	    }

	    return viewport;
	  } // Implement Equation (9) from above algorithm.


	  var rho2 = rho * rho;
	  var b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * u1 * u1) / (2 * w0 * rho2 * u1);
	  var b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * u1 * u1) / (2 * w1 * rho2 * u1);
	  var r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
	  var r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	  var S = (r1 - r0) / rho;
	  var s = t * S;
	  var w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
	  var u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
	  var scaleIncrement = 1 / w; // Using w method for scaling.

	  var newZoom = startZoom + (0, _webMercatorUtils.scaleToZoom)(scaleIncrement);
	  var newCenter = (0, _webMercatorUtils.worldToLngLat)(startCenterXY.add(uDelta.scale(u)).scale(scaleIncrement), (0, _webMercatorUtils.zoomToScale)(newZoom));
	  viewport.longitude = newCenter[0];
	  viewport.latitude = newCenter[1];
	  viewport.zoom = newZoom;
	  return viewport;
	}
	/* eslint-enable max-statements */
	//# sourceMappingURL=fly-to-viewport.js.map

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _project = _interopRequireDefault(__webpack_require__(233));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var vs = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset, out vec4 worldPosition\n) {\n  vec3 projectedPosition = project_position(position);\n  worldPosition = vec4(projectedPosition + offset, 1.0);\n  return project_to_clipspace(worldPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset\n) {\n  vec4 worldPosition;\n  return project_position_to_clipspace(position, position64xyLow, offset, worldPosition);\n}\n";
	var _default = {
	  name: 'project32',
	  dependencies: [_project.default],
	  vs: vs
	};
	exports.default = _default;
	//# sourceMappingURL=project32.js.map

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _luma = __webpack_require__(46);

	var _project = _interopRequireDefault(__webpack_require__(233));

	var _memoize = _interopRequireDefault(__webpack_require__(238));

	var _project2 = _interopRequireDefault(__webpack_require__(254));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var fp64ify = _luma.fp64.fp64ify,
	    fp64ifyMatrix4 = _luma.fp64.fp64ifyMatrix4;
	var _default = {
	  name: 'project64',
	  dependencies: [_project.default, _luma.fp64],
	  vs: _project2.default,
	  getUniforms: getUniforms,
	  deprecations: [{
	    type: 'uniform vec2',
	    old: 'projectionFP64[16]',
	    new: 'project_uViewProjectionMatrixFP64'
	  }, {
	    type: 'uniform vec2',
	    old: 'projectionScaleFP64',
	    new: 'project64_uScale'
	  }]
	}; // TODO - this module should calculate the 64 bit uniforms
	// It is currently done by project to minimize duplicated work

	exports.default = _default;
	var DEFAULT_MODULE_OPTIONS = {};
	var getMemoizedUniforms = (0, _memoize.default)(calculateUniforms);

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_MODULE_OPTIONS;
	  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  // These two uniforms are generated by the fp32 project module
	  var project_uViewProjectionMatrix = context.project_uViewProjectionMatrix,
	      project_uScale = context.project_uScale;

	  if (project_uViewProjectionMatrix && project_uScale) {
	    // We only need to update fp64 uniforms if fp32 projection is being updated
	    return getMemoizedUniforms({
	      project_uViewProjectionMatrix: project_uViewProjectionMatrix,
	      project_uScale: project_uScale
	    });
	  }

	  return {};
	}

	function calculateUniforms(_ref) {
	  var project_uViewProjectionMatrix = _ref.project_uViewProjectionMatrix,
	      project_uScale = _ref.project_uScale;
	  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(project_uViewProjectionMatrix);
	  var scaleFP64 = fp64ify(project_uScale);
	  return {
	    project_uViewProjectionMatrixFP64: glViewProjectionMatrixFP64,
	    project64_uViewProjectionMatrix: glViewProjectionMatrixFP64,
	    project64_uScale: scaleFP64
	  };
	}
	//# sourceMappingURL=project64.js.map

/***/ }),
/* 254 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "\nconst vec2 WORLD_SCALE_FP64 = vec2(81.4873275756836, 0.0000032873668232014097);\n\nuniform vec2 project64_uScale;\nuniform vec2 project_uViewProjectionMatrixFP64[16];\n\n// longitude: lnglat_fp64.xy; latitude: lnglat_fp64.zw\nvoid mercatorProject_fp64(vec4 lnglat_fp64, out vec2 out_val[2]) {\n\n#if defined(NVIDIA_FP64_WORKAROUND)\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64 * ONE);\n#else\n  out_val[0] = sum_fp64(radians_fp64(lnglat_fp64.xy), PI_FP64);\n#endif\n  out_val[1] = sub_fp64(PI_FP64,\n    log_fp64(tan_fp64(sum_fp64(PI_4_FP64, radians_fp64(lnglat_fp64.zw) / 2.0))));\n  return;\n}\n\nvoid project_position_fp64(vec4 position_fp64, out vec2 out_val[2]) {\n  vec2 pos_fp64[2];\n  mercatorProject_fp64(position_fp64, pos_fp64);\n  vec2 x_fp64 = mul_fp64(pos_fp64[0], project64_uScale);\n  vec2 y_fp64 = mul_fp64(pos_fp64[1], project64_uScale);\n  out_val[0] = mul_fp64(x_fp64, WORLD_SCALE_FP64);\n  out_val[1] = mul_fp64(y_fp64, WORLD_SCALE_FP64);\n\n  return;\n}\n\nvoid project_position_fp64(vec2 position, vec2 position64xyLow, out vec2 out_val[2]) {\n  vec4 position64xy = vec4(\n    position.x, position64xyLow.x,\n    position.y, position64xyLow.y);\n\n  project_position_fp64(position64xy, out_val);\n}\n\nvec4 project_to_clipspace_fp64(vec2 vertex_pos_modelspace[4]) {\n  vec2 vertex_pos_clipspace[4];\n  mat4_vec4_mul_fp64(project_uViewProjectionMatrixFP64, vertex_pos_modelspace,\n    vertex_pos_clipspace);\n  return vec4(\n    vertex_pos_clipspace[0].x,\n    vertex_pos_clipspace[1].x,\n    vertex_pos_clipspace[2].x,\n    vertex_pos_clipspace[3].x\n    );\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset, out vec4 worldPosition\n) {\n  // This is the local offset to the instance position\n  vec2 offset64[4];\n  vec4_fp64(vec4(offset, 0.0), offset64);\n\n  float z = project_scale(position.z);\n\n  // Apply web mercator projection (depends on coordinate system imn use)\n  vec2 projectedPosition64xy[2];\n  project_position_fp64(position.xy, position64xyLow, projectedPosition64xy);\n\n  vec2 worldPosition64[4];\n  worldPosition64[0] = sum_fp64(offset64[0], projectedPosition64xy[0]);\n  worldPosition64[1] = sum_fp64(offset64[1], projectedPosition64xy[1]);\n  worldPosition64[2] = sum_fp64(offset64[2], vec2(z, 0.0));\n  worldPosition64[3] = vec2(1.0, 0.0);\n\n  worldPosition = vec4(projectedPosition64xy[0].x, projectedPosition64xy[1].x, z, 1.0);\n\n  return project_to_clipspace_fp64(worldPosition64);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec2 position64xyLow, vec3 offset\n) {\n  vec4 worldPosition;\n  return project_position_to_clipspace(\n    position, position64xyLow, offset, worldPosition\n  );\n}\n";
	exports.default = _default;
	//# sourceMappingURL=project64.glsl.js.map

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _lighting = _interopRequireDefault(__webpack_require__(256));

	var _project = _interopRequireDefault(__webpack_require__(233));

	var _constants = __webpack_require__(237);

	var _projectFunctions = __webpack_require__(257);

	var _memoize = _interopRequireDefault(__webpack_require__(238));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = {
	  name: 'lighting',
	  dependencies: [_project.default],
	  vs: _lighting.default,
	  getUniforms: getUniforms,
	  deprecations: [// Deprecated lighting functions
	  {
	    type: 'function',
	    old: 'getLightWeight',
	    new: 'lighting_getLightWeight',
	    deprecated: true
	  }]
	};
	exports.default = _default;
	var INITIAL_MODULE_OPTIONS = {};
	var DEFAULT_LIGHTS_POSITION = [-122.45, 37.75, 8000];
	var DEFAULT_LIGHTS_STRENGTH = [2.0, 0.0];
	var DEFAULT_AMBIENT_RATIO = 0.4;
	var DEFAULT_DIFFUSE_RATIO = 0.6;
	var DEFAULT_SPECULAR_RATIO = 0.8;
	var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
	var getMemoizedLightPositions = (0, _memoize.default)(preprojectLightPositions); // TODO: support partial update, e.g.
	// `lightedModel.setModuleParameters({diffuseRatio: 0.3});`

	function getUniforms() {
	  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_MODULE_OPTIONS;

	  if (!opts.lightSettings) {
	    return {};
	  }

	  var _opts$lightSettings = opts.lightSettings,
	      _opts$lightSettings$n = _opts$lightSettings.numberOfLights,
	      numberOfLights = _opts$lightSettings$n === void 0 ? 1 : _opts$lightSettings$n,
	      _opts$lightSettings$l = _opts$lightSettings.lightsPosition,
	      lightsPosition = _opts$lightSettings$l === void 0 ? DEFAULT_LIGHTS_POSITION : _opts$lightSettings$l,
	      _opts$lightSettings$l2 = _opts$lightSettings.lightsStrength,
	      lightsStrength = _opts$lightSettings$l2 === void 0 ? DEFAULT_LIGHTS_STRENGTH : _opts$lightSettings$l2,
	      _opts$lightSettings$c = _opts$lightSettings.coordinateSystem,
	      coordinateSystem = _opts$lightSettings$c === void 0 ? _constants.COORDINATE_SYSTEM.LNGLAT : _opts$lightSettings$c,
	      _opts$lightSettings$c2 = _opts$lightSettings.coordinateOrigin,
	      coordinateOrigin = _opts$lightSettings$c2 === void 0 ? DEFAULT_COORDINATE_ORIGIN : _opts$lightSettings$c2,
	      _opts$lightSettings$m = _opts$lightSettings.modelMatrix,
	      modelMatrix = _opts$lightSettings$m === void 0 ? null : _opts$lightSettings$m,
	      _opts$lightSettings$a = _opts$lightSettings.ambientRatio,
	      ambientRatio = _opts$lightSettings$a === void 0 ? DEFAULT_AMBIENT_RATIO : _opts$lightSettings$a,
	      _opts$lightSettings$d = _opts$lightSettings.diffuseRatio,
	      diffuseRatio = _opts$lightSettings$d === void 0 ? DEFAULT_DIFFUSE_RATIO : _opts$lightSettings$d,
	      _opts$lightSettings$s = _opts$lightSettings.specularRatio,
	      specularRatio = _opts$lightSettings$s === void 0 ? DEFAULT_SPECULAR_RATIO : _opts$lightSettings$s; // Pre-project light positions

	  var lightsPositionWorld = getMemoizedLightPositions({
	    lightsPosition: lightsPosition,
	    numberOfLights: numberOfLights,
	    viewport: opts.viewport,
	    modelMatrix: modelMatrix,
	    coordinateSystem: opts.coordinateSystem,
	    coordinateOrigin: opts.coordinateOrigin,
	    fromCoordinateSystem: coordinateSystem,
	    fromCoordinateOrigin: coordinateOrigin
	  });
	  return {
	    lighting_lightPositions: lightsPositionWorld,
	    lighting_lightStrengths: lightsStrength,
	    lighting_ambientRatio: ambientRatio,
	    lighting_diffuseRatio: diffuseRatio,
	    lighting_specularRatio: specularRatio,
	    lighting_numberOfLights: numberOfLights
	  };
	} // Pre-project light positions


	function preprojectLightPositions(_ref) {
	  var lightsPosition = _ref.lightsPosition,
	      numberOfLights = _ref.numberOfLights,
	      viewport = _ref.viewport,
	      modelMatrix = _ref.modelMatrix,
	      coordinateSystem = _ref.coordinateSystem,
	      coordinateOrigin = _ref.coordinateOrigin,
	      fromCoordinateSystem = _ref.fromCoordinateSystem,
	      fromCoordinateOrigin = _ref.fromCoordinateOrigin;
	  var projectionParameters = {
	    viewport: viewport,
	    modelMatrix: modelMatrix,
	    coordinateSystem: coordinateSystem,
	    coordinateOrigin: coordinateOrigin,
	    fromCoordinateSystem: fromCoordinateSystem,
	    fromCoordinateOrigin: fromCoordinateOrigin
	  };
	  var lightsPositionWorld = [];

	  for (var i = 0; i < numberOfLights; i++) {
	    var position = (0, _projectFunctions.projectPosition)(lightsPosition.slice(i * 3, i * 3 + 3), projectionParameters);
	    lightsPositionWorld[i * 3] = position[0];
	    lightsPositionWorld[i * 3 + 1] = position[1];
	    lightsPositionWorld[i * 3 + 2] = position[2];
	  }

	  return lightsPositionWorld;
	}
	//# sourceMappingURL=lighting.js.map

/***/ }),
/* 256 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// lighting
	var _default = "#define MAX_NUM_OF_LIGHTS 5\n\n// TODO these should be using lighting_ prefix\nuniform vec3 lighting_lightPositions[MAX_NUM_OF_LIGHTS];\nuniform vec2 lighting_lightStrengths[MAX_NUM_OF_LIGHTS];\nuniform float lighting_ambientRatio;\nuniform float lighting_diffuseRatio;\nuniform float lighting_specularRatio;\nuniform int lighting_numberOfLights;\n\nfloat lighting_getLightWeight(vec3 position_worldspace_vec3, vec3 normals_worldspace) {\n  float lightWeight = 0.0;\n\n  vec3 normals_worldspace_vec3 = normals_worldspace.xyz;\n\n  vec3 camera_pos_worldspace = project_uCameraPosition;\n  vec3 view_direction = normalize(camera_pos_worldspace - position_worldspace_vec3);\n\n  for (int i = 0; i < MAX_NUM_OF_LIGHTS; i++) {\n    if (i >= lighting_numberOfLights) {\n      break;\n    }\n    vec3 light_position_worldspace = lighting_lightPositions[i];\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace_vec3);\n\n    vec3 halfway_direction = normalize(light_direction + view_direction);\n    float lambertian = dot(light_direction, normals_worldspace_vec3);\n    float specular = 0.0;\n    if (lambertian > 0.0) {\n      float specular_angle = max(dot(normals_worldspace_vec3, halfway_direction), 0.0);\n      specular = pow(specular_angle, 32.0);\n    }\n    lambertian = max(lambertian, 0.0);\n    lightWeight += (lighting_ambientRatio + lambertian * lighting_diffuseRatio + specular * lighting_specularRatio) *\n      lighting_lightStrengths[i].x;\n  }\n\n  return lightWeight;\n}\n\n// DEPRECATED - Backwards compatibility\n\nfloat getLightWeight(vec3 position_worldspace_vec3, vec3 normals_worldspace) {\n  return lighting_getLightWeight(position_worldspace_vec3, normals_worldspace);\n}\n";
	exports.default = _default;
	//# sourceMappingURL=lighting.glsl.js.map

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.projectPosition = projectPosition;

	var _constants = __webpack_require__(237);

	var _transformMat = _interopRequireDefault(__webpack_require__(141));

	var _subtract = _interopRequireDefault(__webpack_require__(258));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function lngLatZToWorldPosition(lngLatZ, viewport) {
	  var _viewport$projectFlat = viewport.projectFlat(lngLatZ),
	      _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),
	      X = _viewport$projectFlat2[0],
	      Y = _viewport$projectFlat2[1];

	  var Z = (lngLatZ[2] || 0) * viewport.distanceScales.pixelsPerMeter[2];
	  return [X, Y, Z];
	}
	/**
	 * Equivalent to project_position in project.glsl
	 * projects a user supplied position to world position in the target coordinates system
	 * @param {array} position - [x, y, z]
	 * @param {object} params
	 * @param {Viewport} params.viewport - the current viewport
	 * @param {number} params.coordinateSystem - the coordinate system to project into
	 * @param {array} params.coordinateOrigin - the coordinate origin to project into
	 * @param {Matrix4} [params.modelMatrix] - the model matrix of the supplied position
	 * @param {number} [params.fromCoordinateSystem] - the coordinate system that the
	 *   supplied position is in. Default to the same as `coordinateSystem`.
	 * @param {array} [params.fromCoordinateOrigin] - the coordinate origin that the
	 *   supplied position is in. Default to the same as `coordinateOrigin`.
	 */


	function projectPosition(position, _ref) {
	  var viewport = _ref.viewport,
	      coordinateSystem = _ref.coordinateSystem,
	      coordinateOrigin = _ref.coordinateOrigin,
	      modelMatrix = _ref.modelMatrix,
	      fromCoordinateSystem = _ref.fromCoordinateSystem,
	      fromCoordinateOrigin = _ref.fromCoordinateOrigin;

	  var _position = _slicedToArray(position, 3),
	      x = _position[0],
	      y = _position[1],
	      z = _position[2];

	  var worldPosition;

	  if (modelMatrix) {
	    var _vec4_transformMat = (0, _transformMat.default)([], [x, y, z, 1.0], modelMatrix);

	    var _vec4_transformMat2 = _slicedToArray(_vec4_transformMat, 3);

	    x = _vec4_transformMat2[0];
	    y = _vec4_transformMat2[1];
	    z = _vec4_transformMat2[2];
	  }

	  if (fromCoordinateSystem === undefined) {
	    fromCoordinateSystem = coordinateSystem;
	  }

	  if (fromCoordinateOrigin === undefined) {
	    fromCoordinateOrigin = coordinateOrigin;
	  } // pre-project light coordinates


	  switch (fromCoordinateSystem) {
	    case _constants.COORDINATE_SYSTEM.LNGLAT:
	      worldPosition = lngLatZToWorldPosition([x, y, z], viewport);
	      break;

	    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
	      worldPosition = lngLatZToWorldPosition([x + fromCoordinateOrigin[0], y + fromCoordinateOrigin[1], z + (fromCoordinateOrigin[2] || 0)], viewport);
	      break;

	    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
	      worldPosition = lngLatZToWorldPosition(viewport.addMetersToLngLat(fromCoordinateOrigin, [x, y, z]), viewport);
	      break;

	    default:
	      worldPosition = [x, y, z];
	  }

	  switch (coordinateSystem) {
	    case _constants.COORDINATE_SYSTEM.LNGLAT_OFFSETS:
	    case _constants.COORDINATE_SYSTEM.METER_OFFSETS:
	      var originWorld = lngLatZToWorldPosition(coordinateOrigin, viewport);
	      (0, _subtract.default)(worldPosition, worldPosition, originWorld);
	      worldPosition[1] = -worldPosition[1];
	      break;

	    default:
	  }

	  return worldPosition;
	}
	//# sourceMappingURL=project-functions.js.map

/***/ }),
/* 258 */
/***/ (function(module, exports) {

	module.exports = subtract;

	/**
	 * Subtracts vector b from vector a
	 *
	 * @param {vec3} out the receiving vector
	 * @param {vec3} a the first operand
	 * @param {vec3} b the second operand
	 * @returns {vec3} out
	 */
	function subtract(out, a, b) {
	    out[0] = a[0] - b[0]
	    out[1] = a[1] - b[1]
	    out[2] = a[2] - b[2]
	    return out
	}

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _layerManager = _interopRequireDefault(__webpack_require__(260));

	var _effectManager = _interopRequireDefault(__webpack_require__(288));

	var _effect = _interopRequireDefault(__webpack_require__(289));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _luma = __webpack_require__(46);

	var _probe = __webpack_require__(32);

	var _mjolnir = __webpack_require__(290);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _mapController = __webpack_require__(384);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function noop() {}

	function getPropTypes(PropTypes) {
	  // Note: Arrays (layers, views, ) can contain falsy values
	  return {
	    id: PropTypes.string,
	    width: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
	    height: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
	    // layer/view/controller settings
	    layers: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
	    layerFilter: PropTypes.func,
	    views: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),
	    viewState: PropTypes.object,
	    controller: PropTypes.func,
	    onViewStateChange: PropTypes.func,
	    effects: PropTypes.arrayOf(PropTypes.instanceOf(_effect.default)),
	    // GL settings
	    glOptions: PropTypes.object,
	    gl: PropTypes.object,
	    pickingRadius: PropTypes.number,
	    onWebGLInitialized: PropTypes.func,
	    onResize: PropTypes.func,
	    onBeforeRender: PropTypes.func,
	    onAfterRender: PropTypes.func,
	    onLayerClick: PropTypes.func,
	    onLayerHover: PropTypes.func,
	    useDevicePixels: PropTypes.bool,
	    // Debug settings
	    debug: PropTypes.bool,
	    drawPickingColors: PropTypes.bool
	  };
	}

	var defaultProps = {
	  id: 'deckgl-overlay',
	  width: '100%',
	  height: '100%',
	  pickingRadius: 0,
	  layerFilter: null,
	  glOptions: {},
	  gl: null,
	  layers: [],
	  effects: [],
	  views: null,
	  controller: null,
	  // Rely on external controller, e.g. react-map-gl
	  onWebGLInitialized: noop,
	  onBeforeRender: noop,
	  onAfterRender: noop,
	  onLayerClick: null,
	  onLayerHover: null,
	  useDevicePixels: true,
	  debug: false,
	  drawPickingColors: false
	};
	var PREFIX = '-webkit-';
	var CURSOR = {
	  GRABBING: "".concat(PREFIX, "grabbing"),
	  GRAB: "".concat(PREFIX, "grab"),
	  POINTER: 'pointer'
	};

	var getCursor = function getCursor(_ref) {
	  var isDragging = _ref.isDragging;
	  return isDragging ? CURSOR.GRABBING : CURSOR.GRAB;
	}; // TODO - move into Controller classes


	var defaultControllerProps = Object.assign({}, _mapController.MAPBOX_LIMITS, {
	  scrollZoom: true,
	  dragPan: true,
	  dragRotate: true,
	  doubleClickZoom: true,
	  touchZoomRotate: true,
	  getCursor: getCursor
	});

	var Deck =
	/*#__PURE__*/
	function () {
	  function Deck(props) {
	    _classCallCheck(this, Deck);

	    props = Object.assign({}, defaultProps, props);
	    this.width = 0; // "read-only", auto-updated from canvas

	    this.height = 0; // "read-only", auto-updated from canvas

	    this.needsRedraw = true;
	    this.layerManager = null;
	    this.effectManager = null;
	    this.controller = null;
	    this.stats = new _probe.Stats({
	      id: 'deck.gl'
	    });
	    this.viewState = props.initialViewState || null; // Internal view state if no callback is supplied

	    this.interactiveState = {
	      isDragging: false // Whether the cursor is down

	    }; // Bind methods

	    this._onRendererInitialized = this._onRendererInitialized.bind(this);
	    this._onRenderFrame = this._onRenderFrame.bind(this);
	    this._onViewStateChange = this._onViewStateChange.bind(this);
	    this._onInteractiveStateChange = this._onInteractiveStateChange.bind(this); // Note: LayerManager creation deferred until gl context available

	    this.canvas = this._createCanvas(props);
	    this.controller = this._createController(props);
	    this.animationLoop = this._createAnimationLoop(props);
	    this.setProps(props);
	    this.animationLoop.start();
	  }

	  _createClass(Deck, [{
	    key: "finalize",
	    value: function finalize() {
	      this.animationLoop.stop();
	      this.animationLoop = null;

	      if (this.layerManager) {
	        this.layerManager.finalize();
	        this.layerManager = null;
	      }

	      if (this.controller) {
	        this.controller.finalize();
	        this.controller = null;
	      }

	      if (this.eventManager) {
	        this.eventManager.destroy();
	      }
	    }
	  }, {
	    key: "setProps",
	    value: function setProps(props) {
	      this.stats.timeStart('deck.setProps');
	      props = Object.assign({}, this.props, props);
	      this.props = props; // Update CSS size of canvas

	      this._setCanvasSize(props); // We need to overwrite CSS style width and height with actual, numeric values


	      var newProps = Object.assign({}, props, {
	        viewState: this._getViewState(props),
	        width: this.width,
	        height: this.height
	      }); // Update layer manager props (but not size)

	      if (this.layerManager) {
	        this.layerManager.setParameters(newProps);
	      } // Update animation loop


	      if (this.animationLoop) {
	        this.animationLoop.setProps(newProps);
	      } // Update controller props


	      if (this.controller) {
	        this.controller.setProps(Object.assign(newProps, {
	          onViewStateChange: this._onViewStateChange
	        }));
	      }

	      this.stats.timeEnd('deck.setProps');
	    } // Public API

	  }, {
	    key: "pickObject",
	    value: function pickObject(_ref2) {
	      var x = _ref2.x,
	          y = _ref2.y,
	          _ref2$radius = _ref2.radius,
	          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,
	          _ref2$layerIds = _ref2.layerIds,
	          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds;
	      this.stats.timeStart('deck.pickObject');
	      var selectedInfos = this.layerManager.pickObject({
	        x: x,
	        y: y,
	        radius: radius,
	        layerIds: layerIds,
	        mode: 'query',
	        depth: 1
	      });
	      this.stats.timeEnd('deck.pickObject');
	      return selectedInfos.length ? selectedInfos[0] : null;
	    }
	  }, {
	    key: "pickMultipleObjects",
	    value: function pickMultipleObjects(_ref3) {
	      var x = _ref3.x,
	          y = _ref3.y,
	          _ref3$radius = _ref3.radius,
	          radius = _ref3$radius === void 0 ? 0 : _ref3$radius,
	          _ref3$layerIds = _ref3.layerIds,
	          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds,
	          _ref3$depth = _ref3.depth,
	          depth = _ref3$depth === void 0 ? 10 : _ref3$depth;
	      this.stats.timeStart('deck.pickMultipleObjects');
	      var selectedInfos = this.layerManager.pickObject({
	        x: x,
	        y: y,
	        radius: radius,
	        layerIds: layerIds,
	        mode: 'query',
	        depth: depth
	      });
	      this.stats.timeEnd('deck.pickMultipleObjects');
	      return selectedInfos;
	    }
	  }, {
	    key: "pickObjects",
	    value: function pickObjects(_ref4) {
	      var x = _ref4.x,
	          y = _ref4.y,
	          _ref4$width = _ref4.width,
	          width = _ref4$width === void 0 ? 1 : _ref4$width,
	          _ref4$height = _ref4.height,
	          height = _ref4$height === void 0 ? 1 : _ref4$height,
	          _ref4$layerIds = _ref4.layerIds,
	          layerIds = _ref4$layerIds === void 0 ? null : _ref4$layerIds;
	      this.stats.timeStart('deck.pickObjects');
	      var infos = this.layerManager.pickObjects({
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        layerIds: layerIds
	      });
	      this.stats.timeEnd('deck.pickObjects');
	      return infos;
	    }
	  }, {
	    key: "getViewports",
	    value: function getViewports() {
	      return this.layerManager ? this.layerManager.getViewports() : [];
	    } // Private Methods
	    // canvas, either string, canvas or `null`

	  }, {
	    key: "_createCanvas",
	    value: function _createCanvas(props) {
	      var canvas = props.canvas; // TODO EventManager should accept element id

	      if (typeof canvas === 'string') {
	        /* global document */
	        canvas = document.getElementById(canvas);
	        (0, _assert.default)(canvas);
	      }

	      if (!canvas) {
	        canvas = document.createElement('canvas');
	        var parent = props.parent || document.body;
	        parent.appendChild(canvas);
	      }

	      var id = props.id,
	          style = props.style;
	      canvas.id = id;
	      Object.assign(canvas.style, style);
	      return canvas;
	    } // Updates canvas width and/or height, if provided as props

	  }, {
	    key: "_setCanvasSize",
	    value: function _setCanvasSize(props) {
	      var canvas = this.canvas;
	      var width = props.width,
	          height = props.height; // Set size ONLY if props are being provided, otherwise let canvas be layouted freely

	      if (width || width === 0) {
	        width = Number.isFinite(width) ? "".concat(width, "px") : width;
	        canvas.style.width = width;
	      }

	      if (height || height === 0) {
	        height = Number.isFinite(height) ? "".concat(height, "px") : height; // Note: position==='absolute' required for height 100% to work

	        canvas.style.position = 'absolute';
	        canvas.style.height = height;
	      }
	    } // If canvas size has changed, updates

	  }, {
	    key: "_updateCanvasSize",
	    value: function _updateCanvasSize() {
	      if (this._checkForCanvasSizeChange()) {
	        var width = this.width,
	            height = this.height;
	        this.layerManager.setParameters({
	          width: width,
	          height: height
	        });

	        if (this.controller) {
	          this.controller.setProps({
	            viewState: this._getViewState(this.props),
	            width: this.width,
	            height: this.height
	          });
	        }

	        if (this.props.onResize) {
	          this.props.onResize({
	            width: this.width,
	            height: this.height
	          });
	        }
	      }
	    } // If canvas size has changed, reads out the new size and returns true

	  }, {
	    key: "_checkForCanvasSizeChange",
	    value: function _checkForCanvasSizeChange() {
	      var canvas = this.canvas;

	      if (canvas && (this.width !== canvas.clientWidth || this.height !== canvas.clientHeight)) {
	        this.width = canvas.clientWidth;
	        this.height = canvas.clientHeight;
	        return true;
	      }

	      return false;
	    } // Note: props.controller must be a class constructor, not an already created instance

	  }, {
	    key: "_createController",
	    value: function _createController(props) {
	      var controller = null;

	      if (props.controller) {
	        var Controller = props.controller;
	        controller = new Controller(props);
	        controller.setProps(Object.assign({}, this.props, defaultControllerProps, {
	          eventManager: this.eventManager,
	          viewState: this._getViewState(props),
	          // Set an internal callback that calls the prop callback if provided
	          onViewStateChange: this._onViewStateChange,
	          onStateChange: this._onInteractiveStateChange
	        }));
	      }

	      return controller;
	    }
	  }, {
	    key: "_createAnimationLoop",
	    value: function _createAnimationLoop(props) {
	      var _this = this;

	      var width = props.width,
	          height = props.height,
	          gl = props.gl,
	          glOptions = props.glOptions,
	          debug = props.debug,
	          useDevicePixels = props.useDevicePixels,
	          autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
	      return new _luma.AnimationLoop({
	        width: width,
	        height: height,
	        useDevicePixels: useDevicePixels,
	        autoResizeDrawingBuffer: autoResizeDrawingBuffer,
	        onCreateContext: function onCreateContext(opts) {
	          return gl || (0, _luma.createGLContext)(Object.assign({}, glOptions, {
	            canvas: _this.canvas,
	            debug: debug
	          }));
	        },
	        onInitialize: this._onRendererInitialized,
	        onRender: this._onRenderFrame,
	        onBeforeRender: props.onBeforeRender,
	        onAfterRender: props.onAfterRender
	      });
	    } // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
	    // TODO: For backwards compatibility ensure numeric width and height is added to the viewState

	  }, {
	    key: "_getViewState",
	    value: function _getViewState(props) {
	      return Object.assign({}, props.viewState || this.viewState || {}, {
	        width: this.width,
	        height: this.height
	      });
	    } // Callbacks

	  }, {
	    key: "_onViewStateChange",
	    value: function _onViewStateChange(_ref5) {
	      var viewState = _ref5.viewState;

	      // Let app know that view state is changing, and give it a chance to change it
	      if (this.props.onViewStateChange) {
	        var _this$props;

	        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	          args[_key - 1] = arguments[_key];
	        }

	        viewState = (_this$props = this.props).onViewStateChange.apply(_this$props, [{
	          viewState: viewState
	        }].concat(args)) || viewState;
	      } // If initialViewState was set on creation, auto track position


	      if (this.viewState) {
	        this.viewState = viewState;
	        this.layerManager.setParameters({
	          viewState: viewState
	        });
	        this.controller.setProps({
	          viewState: viewState
	        });
	      }
	    }
	  }, {
	    key: "_onInteractiveStateChange",
	    value: function _onInteractiveStateChange(_ref6) {
	      var _ref6$isDragging = _ref6.isDragging,
	          isDragging = _ref6$isDragging === void 0 ? false : _ref6$isDragging;

	      if (isDragging !== this.interactiveState.isDragging) {
	        this.interactiveState.isDragging = isDragging;

	        if (this.props.getCursor) {
	          this.canvas.style.cursor = this.props.getCursor(this.interactiveState);
	        }
	      }
	    }
	  }, {
	    key: "_onRendererInitialized",
	    value: function _onRendererInitialized(_ref7) {
	      var gl = _ref7.gl,
	          canvas = _ref7.canvas;
	      (0, _luma.setParameters)(gl, {
	        blend: true,
	        blendFunc: [_luma.GL.SRC_ALPHA, _luma.GL.ONE_MINUS_SRC_ALPHA, _luma.GL.ONE, _luma.GL.ONE_MINUS_SRC_ALPHA],
	        polygonOffsetFill: true,
	        depthTest: true,
	        depthFunc: _luma.GL.LEQUAL
	      });
	      this.props.onWebGLInitialized(gl);
	      this.eventManager = new _mjolnir.EventManager(canvas);

	      if (this.controller) {
	        this.controller.setProps({
	          eventManager: this.eventManager
	        });
	      } // Note: avoid React setState due GL animation loop / setState timing issue


	      this.layerManager = new _layerManager.default(gl, {
	        eventManager: this.eventManager,
	        stats: this.stats
	      });
	      this.effectManager = new _effectManager.default({
	        gl: gl,
	        layerManager: this.layerManager
	      });
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var effect = _step.value;
	          this.effectManager.addEffect(effect);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      this.setProps(this.props);

	      this._updateCanvasSize();
	    }
	  }, {
	    key: "_onRenderFrame",
	    value: function _onRenderFrame(_ref8) {
	      var gl = _ref8.gl;

	      if (this.stats.oneSecondPassed()) {
	        var table = this.stats.getStatsTable();
	        this.stats.reset();

	        _log.default.table(1, table)();
	      }

	      this._updateCanvasSize(); // Update layers if needed (e.g. some async prop has loaded)


	      this.layerManager.updateLayers();
	      this.stats.bump('fps');
	      var redrawReason = this.layerManager.needsRedraw({
	        clearRedrawFlags: true
	      });

	      if (!redrawReason) {
	        return;
	      }

	      this.stats.bump('render-fps');

	      if (this.props.onBeforeRender) {
	        this.props.onBeforeRender({
	          gl: gl
	        }); // TODO - should be called by AnimationLoop
	      }

	      this.layerManager.drawLayers({
	        pass: 'screen',
	        redrawReason: redrawReason,
	        // Helps debug layer picking, especially in framebuffer powered layers
	        drawPickingColors: this.props.drawPickingColors
	      });

	      if (this.props.onAfterRender) {
	        this.props.onAfterRender({
	          gl: gl
	        }); // TODO - should be called by AnimationLoop
	      }
	    }
	  }]);

	  return Deck;
	}();

	exports.default = Deck;
	Deck.displayName = 'Deck';
	Deck.getPropTypes = getPropTypes;
	Deck.defaultProps = defaultProps;
	//# sourceMappingURL=deck.js.map

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _luma = __webpack_require__(46);

	var _seer = _interopRequireDefault(__webpack_require__(189));

	var _layer = _interopRequireDefault(__webpack_require__(261));

	var _drawLayers2 = __webpack_require__(277);

	var _pickLayers = __webpack_require__(278);

	var _constants = __webpack_require__(272);

	var _viewManager = _interopRequireDefault(__webpack_require__(279));

	var _mapView = _interopRequireDefault(__webpack_require__(286));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _flatten = __webpack_require__(266);

	var _probe = __webpack_require__(32);

	var _seerIntegration = __webpack_require__(268);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	var LOG_PRIORITY_LIFECYCLE = 2;
	var LOG_PRIORITY_LIFECYCLE_MINOR = 4; // CONTEXT IS EXPOSED TO LAYERS

	var INITIAL_CONTEXT = Object.seal({
	  layerManager: null,
	  gl: null,
	  // Settings
	  useDevicePixels: true,
	  // Exposed in case custom layers need to adjust sizes
	  // General resources
	  stats: null,
	  // for tracking lifecycle performance
	  viewport: null,
	  // Current viewport, exposed to layers for project* function
	  // GL Resources
	  shaderCache: null,
	  pickingFBO: null,
	  // Screen-size framebuffer that layers can reuse
	  // State
	  lastPickedInfo: {
	    // For callback tracking and autohighlight
	    index: -1,
	    layerId: null
	  },
	  userData: {} // Place for any custom app `context`

	});

	var layerName = function layerName(layer) {
	  return _instanceof(layer, _layer.default) ? "".concat(layer) : !layer ? 'null' : 'invalid';
	};

	var LayerManager =
	/*#__PURE__*/
	function () {
	  // eslint-disable-next-line
	  function LayerManager(gl) {
	    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        eventManager = _ref.eventManager,
	        stats = _ref.stats;

	    _classCallCheck(this, LayerManager);

	    // Currently deck.gl expects the DeckGL.layers array to be different
	    // whenever React rerenders. If the same layers array is used, the
	    // LayerManager's diffing algorithm will generate a fatal error and
	    // break the rendering.
	    // `this.lastRenderedLayers` stores the UNFILTERED layers sent
	    // down to LayerManager, so that `layers` reference can be compared.
	    // If it's the same across two React render calls, the diffing logic
	    // will be skipped.
	    this.lastRenderedLayers = [];
	    this.layers = [];
	    this.context = Object.assign({}, INITIAL_CONTEXT, {
	      layerManager: this,
	      gl: gl,
	      // Enabling luma.gl Program caching using private API (_cachePrograms)
	      shaderCache: new _luma.ShaderCache({
	        gl: gl,
	        _cachePrograms: true
	      }),
	      stats: stats || new _probe.Stats({
	        id: 'deck.gl'
	      })
	    }); // Maps view descriptors to vieports, rebuilds when width/height/viewState/views change

	    this.viewManager = new _viewManager.default();
	    this.layerFilter = null;
	    this.drawPickingColors = false;
	    this._needsRedraw = 'Initial render';
	    this._needsUpdate = false; // Event handling

	    this._pickingRadius = 0;
	    this._eventManager = null;
	    this._onLayerClick = null;
	    this._onLayerHover = null;
	    this._onClick = this._onClick.bind(this);
	    this._onPointerMove = this._onPointerMove.bind(this);
	    this._onPointerLeave = this._onPointerLeave.bind(this);
	    this._pickAndCallback = this._pickAndCallback.bind(this); // Seer integration

	    this._initSeer = this._initSeer.bind(this);
	    this._editSeer = this._editSeer.bind(this); // DEPRECATED

	    this.width = 100;
	    this.height = 100;
	    Object.seal(this);
	    (0, _seerIntegration.seerInitListener)(this._initSeer);
	    (0, _seerIntegration.layerEditListener)(this._editSeer);

	    if (eventManager) {
	      this._initEventHandling(eventManager);
	    } // Init with default map viewport


	    this.setViews();
	  } // Method to call when the layer manager is not needed anymore.
	  // Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.


	  _createClass(LayerManager, [{
	    key: "finalize",
	    value: function finalize() {
	      _seer.default.removeListener(this._initSeer);

	      _seer.default.removeListener(this._editSeer);
	    } // Check if a redraw is needed

	  }, {
	    key: "needsRedraw",
	    value: function needsRedraw() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
	          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? true : _ref2$clearRedrawFlag;

	      return this._checkIfNeedsRedraw(clearRedrawFlags);
	    } // Check if a deep update of all layers is needed

	  }, {
	    key: "needsUpdate",
	    value: function needsUpdate() {
	      return this._needsUpdate;
	    } // Layers will be redrawn (in next animation frame)

	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw(reason) {
	      this._needsRedraw = this._needsRedraw || reason;
	    } // Layers will be updated deeply (in next animation frame)
	    // Potentially regenerating attributes and sub layers

	  }, {
	    key: "setNeedsUpdate",
	    value: function setNeedsUpdate(reason) {
	      this._needsUpdate = this._needsUpdate || reason;
	    } // Gets an (optionally) filtered list of layers

	  }, {
	    key: "getLayers",
	    value: function getLayers() {
	      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref3$layerIds = _ref3.layerIds,
	          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;

	      // Filtering by layerId compares beginning of strings, so that sublayers will be included
	      // Dependes on the convention of adding suffixes to the parent's layer name
	      return layerIds ? this.layers.filter(function (layer) {
	        return layerIds.find(function (layerId) {
	          return layer.id.indexOf(layerId) === 0;
	        });
	      }) : this.layers;
	    }
	  }, {
	    key: "getViews",
	    value: function getViews() {
	      return this.viewManager.views;
	    } // Get a set of viewports for a given width and height

	  }, {
	    key: "getViewports",
	    value: function getViewports() {
	      var viewports = this.viewManager.getViewports();

	      if (viewports.length) {
	        this._activateViewport(viewports[0]);
	      }

	      return viewports;
	    }
	    /**
	     * Set props needed for layer rendering and picking.
	     * Parameters are to be passed as a single object, with the following values:
	     * @param {Boolean} useDevicePixels
	     */

	    /* eslint-disable complexity, max-statements */

	  }, {
	    key: "setProps",
	    value: function setProps(props) {
	      if ('eventManager' in props) {
	        this._initEventHandling(props.eventManager);
	      }

	      if ('pickingRadius' in props || 'onLayerClick' in props || 'onLayerHover' in props) {
	        this._setEventHandlingParameters(props);
	      }

	      if ('width' in props || 'height' in props) {
	        this.viewManager.setSize(props.width, props.height);
	        this.width = props.width;
	        this.height = props.height;
	      }

	      if ('views' in props) {
	        this.setViews(props.views);
	      } // TODO - support multiple view states


	      if ('viewState' in props) {
	        this.viewManager.setViewState(props.viewState);
	      } // TODO - For now we set layers before viewports to preserve changeFlags


	      if ('layers' in props) {
	        this.setLayers(props.layers);
	      }

	      if ('layerFilter' in props) {
	        if (this.layerFilter !== props.layerFilter) {
	          this.layerFilter = props.layerFilter;
	          this.setNeedsRedraw('layerFilter changed');
	        }
	      }

	      if ('drawPickingColors' in props) {
	        if (props.drawPickingColors !== this.drawPickingColors) {
	          this.drawPickingColors = props.drawPickingColors;
	          this.setNeedsRedraw('drawPickingColors changed');
	        }
	      } // A way for apps to add data to context that can be accessed in layers


	      if ('userData' in props) {
	        this.context.userData = props.userData;
	      }

	      if ('useDevicePixels' in props) {
	        this.context.useDevicePixels = props.useDevicePixels;
	      }
	    }
	    /* eslint-enable complexity, max-statements */
	    // Update the view descriptor list and set change flag if needed
	    // Does not actually rebuild the `Viewport`s until `getViewports` is called

	  }, {
	    key: "setViews",
	    value: function setViews(views) {
	      // For now, we default to a full screen map view port
	      // TODO - apps may want to specify an empty view list...
	      if (!views || views.length === 0) {
	        views = [new _mapView.default({
	          id: 'default-view'
	        })];
	      }

	      this.viewManager.setViews(views);
	    } // Supply a new layer list, initiating sublayer generation and layer matching

	  }, {
	    key: "setLayers",
	    value: function setLayers(newLayers) {
	      this.getViewports();
	      (0, _assert.default)(this.context.viewport, 'LayerManager.updateLayers: viewport not set'); // TODO - something is generating state updates that cause rerender of the same

	      if (newLayers === this.lastRenderedLayers) {
	        _log.default.log(3, 'Ignoring layer update due to layer array not changed')();

	        return this;
	      }

	      this.lastRenderedLayers = newLayers;
	      newLayers = (0, _flatten.flatten)(newLayers, {
	        filter: Boolean
	      });
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var layer = _step.value;
	          layer.context = this.context;
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      var _this$_updateLayers = this._updateLayers({
	        oldLayers: this.layers,
	        newLayers: newLayers
	      }),
	          error = _this$_updateLayers.error,
	          generatedLayers = _this$_updateLayers.generatedLayers;

	      this.layers = generatedLayers; // Throw first error found, if any

	      if (error) {
	        throw error;
	      }

	      return this;
	    } // Update layers from last cycle if `setNeedsUpdate()` has been called

	  }, {
	    key: "updateLayers",
	    value: function updateLayers() {
	      // NOTE: For now, even if only some layer has changed, we update all layers
	      // to ensure that layer id maps etc remain consistent even if different
	      // sublayers are rendered
	      var reason = this.needsUpdate();

	      if (reason) {
	        this.setNeedsRedraw("updating layers: ".concat(reason)); // HACK - Call with a copy of lastRenderedLayers to trigger a full update

	        this.setLayers(_toConsumableArray(this.lastRenderedLayers));
	      }
	    } //
	    // METHODS FOR LAYERS
	    //
	    // Draw all layers in all views

	  }, {
	    key: "drawLayers",
	    value: function drawLayers() {
	      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref4$pass = _ref4.pass,
	          pass = _ref4$pass === void 0 ? 'render to screen' : _ref4$pass,
	          _ref4$redrawReason = _ref4.redrawReason,
	          redrawReason = _ref4$redrawReason === void 0 ? 'unknown reason' : _ref4$redrawReason;

	      var drawPickingColors = this.drawPickingColors;
	      var _this$context = this.context,
	          gl = _this$context.gl,
	          useDevicePixels = _this$context.useDevicePixels; // render this viewport

	      (0, _drawLayers2.drawLayers)(gl, {
	        layers: this.layers,
	        viewports: this.getViewports(),
	        onViewportActive: this._activateViewport.bind(this),
	        useDevicePixels: useDevicePixels,
	        drawPickingColors: drawPickingColors,
	        pass: pass,
	        layerFilter: this.layerFilter,
	        redrawReason: redrawReason
	      });
	    } // Pick the closest info at given coordinate

	  }, {
	    key: "pickObject",
	    value: function pickObject(_ref5) {
	      var x = _ref5.x,
	          y = _ref5.y,
	          mode = _ref5.mode,
	          _ref5$radius = _ref5.radius,
	          radius = _ref5$radius === void 0 ? 0 : _ref5$radius,
	          layerIds = _ref5.layerIds,
	          layerFilter = _ref5.layerFilter,
	          _ref5$depth = _ref5.depth,
	          depth = _ref5$depth === void 0 ? 1 : _ref5$depth;
	      var _this$context2 = this.context,
	          gl = _this$context2.gl,
	          useDevicePixels = _this$context2.useDevicePixels;
	      var layers = this.getLayers({
	        layerIds: layerIds
	      });
	      return (0, _pickLayers.pickObject)(gl, {
	        // User params
	        x: x,
	        y: y,
	        radius: radius,
	        layers: layers,
	        mode: mode,
	        layerFilter: layerFilter,
	        depth: depth,
	        // Injected params
	        viewports: this.getViewports(),
	        onViewportActive: this._activateViewport.bind(this),
	        pickingFBO: this._getPickingBuffer(),
	        lastPickedInfo: this.context.lastPickedInfo,
	        useDevicePixels: useDevicePixels
	      });
	    } // Get all unique infos within a bounding box

	  }, {
	    key: "pickObjects",
	    value: function pickObjects(_ref6) {
	      var x = _ref6.x,
	          y = _ref6.y,
	          width = _ref6.width,
	          height = _ref6.height,
	          layerIds = _ref6.layerIds,
	          layerFilter = _ref6.layerFilter;
	      var _this$context3 = this.context,
	          gl = _this$context3.gl,
	          useDevicePixels = _this$context3.useDevicePixels;
	      var layers = this.getLayers({
	        layerIds: layerIds
	      });
	      return (0, _pickLayers.pickVisibleObjects)(gl, {
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        layers: layers,
	        layerFilter: layerFilter,
	        mode: 'pickObjects',
	        viewports: this.getViewports(),
	        onViewportActive: this._activateViewport.bind(this),
	        pickingFBO: this._getPickingBuffer(),
	        useDevicePixels: useDevicePixels
	      });
	    } //
	    // DEPRECATED METHODS in V5.3
	    //

	  }, {
	    key: "setParameters",
	    value: function setParameters(parameters) {
	      return this.setProps(parameters);
	    }
	  }, {
	    key: "setSize",
	    value: function setSize(width, height) {
	      this.setProps({
	        width: width,
	        height: height
	      });
	    }
	  }, {
	    key: "setViewState",
	    value: function setViewState(viewState) {
	      this.setProps({
	        viewState: viewState
	      });
	    } //
	    // DEPRECATED METHODS in V5.1
	    //

	  }, {
	    key: "setViewports",
	    value: function setViewports(viewports) {
	      _log.default.deprecated('setViewport', 'setViews')();

	      this.setViews(viewports);
	      return this;
	    } //
	    // DEPRECATED METHODS in V5
	    //

	  }, {
	    key: "setViewport",
	    value: function setViewport(viewport) {
	      _log.default.deprecated('setViewport', 'setViews')();

	      this.setViews([viewport]);
	      return this;
	    } //
	    // PRIVATE METHODS
	    //

	  }, {
	    key: "_checkIfNeedsRedraw",
	    value: function _checkIfNeedsRedraw(clearRedrawFlags) {
	      var redraw = this._needsRedraw;

	      if (clearRedrawFlags) {
	        this._needsRedraw = false;
	      }

	      redraw = redraw || this.viewManager.needsRedraw(); // This layers list doesn't include sublayers, relying on composite layers

	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var layer = _step2.value;
	          // Call every layer to clear their flags
	          var layerNeedsRedraw = layer.getNeedsRedraw({
	            clearRedrawFlags: clearRedrawFlags
	          });
	          redraw = redraw || layerNeedsRedraw;
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      return redraw;
	    }
	    /**
	     * @param {Object} eventManager   A source of DOM input events
	     */

	  }, {
	    key: "_initEventHandling",
	    value: function _initEventHandling(eventManager) {
	      this._eventManager = eventManager; // TODO: add/remove handlers on demand at runtime, not all at once on init.
	      // Consider both top-level handlers like onLayerClick/Hover
	      // and per-layer handlers attached to individual layers.
	      // https://github.com/uber/deck.gl/issues/634

	      this._eventManager.on({
	        click: this._onClick,
	        pointermove: this._onPointerMove,
	        pointerleave: this._onPointerLeave
	      });
	    } // Set parameters for input event handling.

	  }, {
	    key: "_setEventHandlingParameters",
	    value: function _setEventHandlingParameters(_ref7) {
	      var pickingRadius = _ref7.pickingRadius,
	          onLayerClick = _ref7.onLayerClick,
	          onLayerHover = _ref7.onLayerHover;

	      if (!isNaN(pickingRadius)) {
	        this._pickingRadius = pickingRadius;
	      }

	      if (typeof onLayerClick !== 'undefined') {
	        this._onLayerClick = onLayerClick;
	      }

	      if (typeof onLayerHover !== 'undefined') {
	        this._onLayerHover = onLayerHover;
	      }

	      this._validateEventHandling();
	    } // Make a viewport "current" in layer context, updating viewportChanged flags

	  }, {
	    key: "_activateViewport",
	    value: function _activateViewport(viewport) {
	      var oldViewport = this.context.viewport;
	      var viewportChanged = !oldViewport || !viewport.equals(oldViewport);

	      if (viewportChanged) {
	        _log.default.log(4, 'Viewport changed', viewport)();

	        this.context.viewport = viewport; // Update layers states
	        // Let screen space layers update their state based on viewport

	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;

	        try {
	          for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var layer = _step3.value;
	            layer.setChangeFlags({
	              viewportChanged: 'Viewport changed'
	            });

	            this._updateLayer(layer);
	          }
	        } catch (err) {
	          _didIteratorError3 = true;
	          _iteratorError3 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	              _iterator3.return();
	            }
	          } finally {
	            if (_didIteratorError3) {
	              throw _iteratorError3;
	            }
	          }
	        }
	      }

	      (0, _assert.default)(this.context.viewport, 'LayerManager: viewport not set');
	      return this;
	    }
	  }, {
	    key: "_getPickingBuffer",
	    value: function _getPickingBuffer() {
	      var gl = this.context.gl; // Create a frame buffer if not already available

	      this.context.pickingFBO = this.context.pickingFBO || new _luma.Framebuffer(gl); // Resize it to current canvas size (this is a noop if size hasn't changed)

	      this.context.pickingFBO.resize({
	        width: gl.canvas.width,
	        height: gl.canvas.height
	      });
	      return this.context.pickingFBO;
	    } // Match all layers, checking for caught errors
	    // To avoid having an exception in one layer disrupt other layers
	    // TODO - mark layers with exceptions as bad and remove from rendering cycle?

	  }, {
	    key: "_updateLayers",
	    value: function _updateLayers(_ref8) {
	      var oldLayers = _ref8.oldLayers,
	          newLayers = _ref8.newLayers;
	      // Create old layer map
	      var oldLayerMap = {};
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;

	      try {
	        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var oldLayer = _step4.value;

	          if (oldLayerMap[oldLayer.id]) {
	            _log.default.warn("Multiple old layers with same id ".concat(layerName(oldLayer)))();
	          } else {
	            oldLayerMap[oldLayer.id] = oldLayer;
	          }
	        } // Allocate array for generated layers

	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }

	      var generatedLayers = []; // Match sublayers

	      var error = this._updateSublayersRecursively({
	        newLayers: newLayers,
	        oldLayerMap: oldLayerMap,
	        generatedLayers: generatedLayers
	      }); // Finalize unmatched layers


	      var error2 = this._finalizeOldLayers(oldLayerMap);

	      this._needsUpdate = false;
	      var firstError = error || error2;
	      return {
	        error: firstError,
	        generatedLayers: generatedLayers
	      };
	    } // Note: adds generated layers to `generatedLayers` array parameter

	  }, {
	    key: "_updateSublayersRecursively",
	    value: function _updateSublayersRecursively(_ref9) {
	      var newLayers = _ref9.newLayers,
	          oldLayerMap = _ref9.oldLayerMap,
	          generatedLayers = _ref9.generatedLayers;
	      var error = null;
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var newLayer = _step5.value;
	          newLayer.context = this.context; // Given a new coming layer, find its matching old layer (if any)

	          var oldLayer = oldLayerMap[newLayer.id];

	          if (oldLayer === null) {
	            // null, rather than undefined, means this id was originally there
	            _log.default.warn("Multiple new layers with same id ".concat(layerName(newLayer)))();
	          } // Remove the old layer from candidates, as it has been matched with this layer


	          oldLayerMap[newLayer.id] = null;
	          var sublayers = null; // We must not generate exceptions until after layer matching is complete

	          try {
	            if (!oldLayer) {
	              this._initializeLayer(newLayer);

	              (0, _seerIntegration.initLayerInSeer)(newLayer); // Initializes layer in seer chrome extension (if connected)
	            } else {
	              this._transferLayerState(oldLayer, newLayer);

	              this._updateLayer(newLayer);

	              (0, _seerIntegration.updateLayerInSeer)(newLayer); // Updates layer in seer chrome extension (if connected)
	            }

	            generatedLayers.push(newLayer); // Call layer lifecycle method: render sublayers

	            sublayers = newLayer.isComposite && newLayer.getSubLayers(); // End layer lifecycle method: render sublayers
	          } catch (err) {
	            _log.default.warn("error during matching of ".concat(layerName(newLayer)), err);

	            error = error || err; // Record first exception
	          }

	          if (sublayers) {
	            this._updateSublayersRecursively({
	              newLayers: sublayers,
	              oldLayerMap: oldLayerMap,
	              generatedLayers: generatedLayers
	            });
	          }
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }

	      return error;
	    } // Finalize any old layers that were not matched

	  }, {
	    key: "_finalizeOldLayers",
	    value: function _finalizeOldLayers(oldLayerMap) {
	      var error = null;

	      for (var layerId in oldLayerMap) {
	        var layer = oldLayerMap[layerId];

	        if (layer) {
	          error = error || this._finalizeLayer(layer);
	        }
	      }

	      return error;
	    } // EXCEPTION SAFE LAYER ACCESS
	    // Initializes a single layer, calling layer methods

	  }, {
	    key: "_initializeLayer",
	    value: function _initializeLayer(layer) {
	      _log.default.log(LOG_PRIORITY_LIFECYCLE, "initializing ".concat(layerName(layer)))();

	      var error = null;

	      try {
	        layer._initialize();

	        layer.lifecycle = _constants.LIFECYCLE.INITIALIZED;
	      } catch (err) {
	        _log.default.warn("error while initializing ".concat(layerName(layer), "\n"), err)();

	        error = error || err; // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?
	      } // Set back pointer (used in picking)


	      layer.internalState.layer = layer; // Save layer on model for picking purposes
	      // store on model.userData rather than directly on model

	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;

	      try {
	        for (var _iterator6 = layer.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var model = _step6.value;
	          model.userData.layer = layer;
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }

	      return error;
	    }
	  }, {
	    key: "_transferLayerState",
	    value: function _transferLayerState(oldLayer, newLayer) {
	      newLayer._transferState(oldLayer);

	      newLayer.lifecycle = _constants.LIFECYCLE.MATCHED;

	      if (newLayer !== oldLayer) {
	        _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "matched ".concat(layerName(newLayer)), oldLayer, '->', newLayer)();

	        oldLayer.lifecycle = _constants.LIFECYCLE.AWAITING_GC;
	      } else {
	        _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "Matching layer is unchanged ".concat(newLayer.id))();
	      }
	    } // Updates a single layer, cleaning all flags

	  }, {
	    key: "_updateLayer",
	    value: function _updateLayer(layer) {
	      _log.default.log(LOG_PRIORITY_LIFECYCLE_MINOR, "updating ".concat(layer, " because: ").concat(layer.printChangeFlags()))();

	      var error = null;

	      try {
	        layer._update();
	      } catch (err) {
	        _log.default.warn("error during update of ".concat(layerName(layer)), err)(); // Save first error


	        error = err;
	      }

	      return error;
	    } // Finalizes a single layer

	  }, {
	    key: "_finalizeLayer",
	    value: function _finalizeLayer(layer) {
	      (0, _assert.default)(layer.lifecycle !== _constants.LIFECYCLE.AWAITING_FINALIZATION);
	      layer.lifecycle = _constants.LIFECYCLE.AWAITING_FINALIZATION;
	      var error = null;
	      this.setNeedsRedraw("finalized ".concat(layerName(layer)));

	      try {
	        layer._finalize();
	      } catch (err) {
	        _log.default.warn("error during finalization of ".concat(layerName(layer)), err)();

	        error = err;
	      }

	      layer.lifecycle = _constants.LIFECYCLE.FINALIZED;

	      _log.default.log(LOG_PRIORITY_LIFECYCLE, "finalizing ".concat(layerName(layer)));

	      return error;
	    }
	    /**
	     * Warn if a deck-level mouse event has been specified,
	     * but no layers are `pickable`.
	     */

	  }, {
	    key: "_validateEventHandling",
	    value: function _validateEventHandling() {
	      if (this.onLayerClick || this.onLayerHover) {
	        if (this.layers.length && !this.layers.some(function (layer) {
	          return layer.props.pickable;
	        })) {
	          _log.default.warn('You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.')();
	        }
	      }
	    }
	    /**
	     * Route click events to layers.
	     * `pickLayer` will call the `onClick` prop of any picked layer,
	     * and `onLayerClick` is called directly from here
	     * with any picking info generated by `pickLayer`.
	     * @param {Object} event  An object encapsulating an input event,
	     *                        with the following shape:
	     *                        {Object: {x, y}} offsetCenter: center of the event
	     *                        {Object} srcEvent:             native JS Event object
	     */

	  }, {
	    key: "_onClick",
	    value: function _onClick(event) {
	      if (!event.offsetCenter) {
	        // Do not trigger onHover callbacks when click position is invalid.
	        return;
	      }

	      this._pickAndCallback({
	        callback: this._onLayerClick,
	        event: event,
	        mode: 'click'
	      });
	    }
	    /**
	     * Route click events to layers.
	     * `pickLayer` will call the `onHover` prop of any picked layer,
	     * and `onLayerHover` is called directly from here
	     * with any picking info generated by `pickLayer`.
	     * @param {Object} event  An object encapsulating an input event,
	     *                        with the following shape:
	     *                        {Object: {x, y}} offsetCenter: center of the event
	     *                        {Object} srcEvent:             native JS Event object
	     */

	  }, {
	    key: "_onPointerMove",
	    value: function _onPointerMove(event) {
	      if (event.leftButton || event.rightButton) {
	        // Do not trigger onHover callbacks if mouse button is down.
	        return;
	      }

	      this._pickAndCallback({
	        callback: this._onLayerHover,
	        event: event,
	        mode: 'hover'
	      });
	    }
	  }, {
	    key: "_onPointerLeave",
	    value: function _onPointerLeave(event) {
	      this.pickObject({
	        x: -1,
	        y: -1,
	        radius: this._pickingRadius,
	        mode: 'hover'
	      });
	    }
	  }, {
	    key: "_pickAndCallback",
	    value: function _pickAndCallback(options) {
	      var pos = options.event.offsetCenter;
	      var radius = this._pickingRadius;
	      var selectedInfos = this.pickObject({
	        x: pos.x,
	        y: pos.y,
	        radius: radius,
	        mode: options.mode
	      });

	      if (options.callback) {
	        var firstInfo = selectedInfos.find(function (info) {
	          return info.index >= 0;
	        }) || null; // As per documentation, send null value when no valid object is picked.

	        options.callback(firstInfo, selectedInfos, options.event.srcEvent);
	      }
	    } // SEER INTEGRATION

	    /**
	     * Called upon Seer initialization, manually sends layers data.
	     */

	  }, {
	    key: "_initSeer",
	    value: function _initSeer() {
	      this.layers.forEach(function (layer) {
	        (0, _seerIntegration.initLayerInSeer)(layer);
	        (0, _seerIntegration.updateLayerInSeer)(layer);
	      });
	    }
	    /**
	     * On Seer property edition, set override and update layers.
	     */

	  }, {
	    key: "_editSeer",
	    value: function _editSeer(payload) {
	      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {
	        return;
	      }

	      (0, _seerIntegration.setPropOverrides)(payload.itemKey, payload.valuePath.slice(1), payload.value);
	      var newLayers = this.layers.map(function (layer) {
	        return new layer.constructor(layer.props);
	      });
	      this.updateLayers({
	        newLayers: newLayers
	      });
	    }
	  }]);

	  return LayerManager;
	}();

	exports.default = LayerManager;
	//# sourceMappingURL=layer-manager.js.map

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = __webpack_require__(237);

	var _attributeManager = _interopRequireDefault(__webpack_require__(262));

	var _seerIntegration = __webpack_require__(268);

	var _props = __webpack_require__(269);

	var _count = __webpack_require__(270);

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _luma = __webpack_require__(46);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _component = _interopRequireDefault(__webpack_require__(271));

	var _layerState = _interopRequireDefault(__webpack_require__(276));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var LOG_PRIORITY_UPDATE = 1;
	var EMPTY_ARRAY = Object.freeze([]);

	var noop = function noop() {};

	var defaultProps = {
	  // data: Special handling for null, see below
	  data: {
	    type: 'data',
	    value: EMPTY_ARRAY,
	    async: true
	  },
	  dataComparator: null,
	  dataTransform: function dataTransform(data) {
	    return data;
	  },
	  fetch: function (_fetch) {
	    function fetch(_x) {
	      return _fetch.apply(this, arguments);
	    }

	    fetch.toString = function () {
	      return _fetch.toString();
	    };

	    return fetch;
	  }(function (url) {
	    return fetch(url).then(function (response) {
	      return response.json();
	    });
	  }),
	  updateTriggers: {},
	  // Update triggers: a core change detection mechanism in deck.gl
	  numInstances: undefined,
	  visible: true,
	  pickable: false,
	  opacity: {
	    type: 'number',
	    min: 0,
	    max: 1,
	    value: 0.8
	  },
	  onHover: noop,
	  onClick: noop,
	  coordinateSystem: _constants.COORDINATE_SYSTEM.LNGLAT,
	  coordinateOrigin: [0, 0, 0],
	  parameters: {},
	  uniforms: {},
	  framebuffer: null,
	  animation: null,
	  // Passed prop animation functions to evaluate props
	  // Offset depth based on layer index to avoid z-fighting.
	  // Negative values pull layer towards the camera
	  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
	  getPolygonOffset: function getPolygonOffset(_ref) {
	    var layerIndex = _ref.layerIndex;
	    return [0, -layerIndex * 100];
	  },
	  // Selection/Highlighting
	  highlightedObjectIndex: null,
	  autoHighlight: false,
	  highlightColor: [0, 0, 128, 128]
	};

	var Layer =
	/*#__PURE__*/
	function (_Component) {
	  _inherits(Layer, _Component);

	  function Layer() {
	    _classCallCheck(this, Layer);

	    return _possibleConstructorReturn(this, (Layer.__proto__ || Object.getPrototypeOf(Layer)).apply(this, arguments));
	  }

	  _createClass(Layer, [{
	    key: "toString",
	    value: function toString() {
	      var className = this.constructor.layerName || this.constructor.name;
	      return "".concat(className, "({id: '").concat(this.props.id, "'})");
	    } // Public API
	    // Updates selected state members and marks the object for redraw

	  }, {
	    key: "setState",
	    value: function setState(updateObject) {
	      Object.assign(this.state, updateObject);
	      this.setNeedsRedraw();
	    } // Sets the redraw flag for this layer, will trigger a redraw next animation frame

	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw() {
	      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

	      if (this.internalState) {
	        this.internalState.needsRedraw = redraw;
	      }
	    } // This layer needs a deep update
	    // TODO - Need to align with existing needsUpdate before uncommenting
	    // For now async props will call layerManager directly

	  }, {
	    key: "setLayerNeedsUpdate",
	    value: function setLayerNeedsUpdate() {
	      this.context.layerManager.setNeedsUpdate(String(this));
	    } // Checks state of attributes and model

	  }, {
	    key: "getNeedsRedraw",
	    value: function getNeedsRedraw() {
	      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,
	          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? false : _ref2$clearRedrawFlag;

	      return this._getNeedsRedraw(clearRedrawFlags);
	    } // Checks if layer attributes needs updating

	  }, {
	    key: "needsUpdate",
	    value: function needsUpdate() {
	      // Call subclass lifecycle method
	      return this.shouldUpdateState(this._getUpdateParams()); // End lifecycle method
	    } // Returns true if the layer is pickable and visible.

	  }, {
	    key: "isPickable",
	    value: function isPickable() {
	      return this.props.pickable && this.props.visible;
	    } // Return an array of models used by this layer, can be overriden by layer subclass

	  }, {
	    key: "getModels",
	    value: function getModels() {
	      return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));
	    } // TODO - Gradually phase out, does not support multi model layers

	  }, {
	    key: "getSingleModel",
	    value: function getSingleModel() {
	      return this.state && this.state.model;
	    }
	  }, {
	    key: "getAttributeManager",
	    value: function getAttributeManager() {
	      return this.internalState && this.internalState.attributeManager;
	    } // Returns the most recent layer that matched to this state
	    // (When reacting to an async event, this layer may no longer be the latest)

	  }, {
	    key: "getCurrentLayer",
	    value: function getCurrentLayer() {
	      return this.internalState && this.internalState.layer;
	    } // Use iteration (the only required capability on data) to get first element
	    // deprecated since we are effectively only supporting Arrays

	  }, {
	    key: "getFirstObject",
	    value: function getFirstObject() {
	      var data = this.props.data;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var object = _step.value;
	          return object;
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return null;
	    } // PROJECTION METHODS
	    // Projects a point with current map state (lat, lon, zoom, pitch, bearing)
	    // TODO - need to be extended to work with COORDINATE_SYSTEM.METERS,IDENTITY
	    // TODO - need to be extended to work with multiple `views`

	  }, {
	    key: "project",
	    value: function project(lngLat) {
	      var viewport = this.context.viewport;
	      (0, _assert.default)(Array.isArray(lngLat));
	      return viewport.project(lngLat);
	    }
	  }, {
	    key: "unproject",
	    value: function unproject(xy) {
	      var viewport = this.context.viewport;
	      (0, _assert.default)(Array.isArray(xy));
	      return viewport.unproject(xy);
	    }
	  }, {
	    key: "projectFlat",
	    value: function projectFlat(lngLat) {
	      var viewport = this.context.viewport;
	      (0, _assert.default)(Array.isArray(lngLat));
	      return viewport.projectFlat(lngLat);
	    }
	  }, {
	    key: "unprojectFlat",
	    value: function unprojectFlat(xy) {
	      var viewport = this.context.viewport;
	      (0, _assert.default)(Array.isArray(xy));
	      return viewport.unprojectFlat(xy);
	    }
	  }, {
	    key: "is64bitEnabled",
	    value: function is64bitEnabled() {
	      if (this.props.fp64) {
	        if (this.props.coordinateSystem === _constants.COORDINATE_SYSTEM.LNGLAT) {
	          return true;
	        }

	        _log.default.once(0, "64-bit mode only works with coordinateSystem set to\n        COORDINATE_SYSTEM.LNGLAT. Rendering in 32-bit mode instead");
	      }

	      return false;
	    } // TODO - needs to refer to context for devicePixels setting

	  }, {
	    key: "screenToDevicePixels",
	    value: function screenToDevicePixels(screenPixels) {
	      _log.default.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion')();

	      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;
	      return screenPixels * devicePixelRatio;
	    } // Returns the picking color that doesn't match any subfeature
	    // Use if some graphics do not belong to any pickable subfeature
	    // @return {Array} - a black color

	  }, {
	    key: "nullPickingColor",
	    value: function nullPickingColor() {
	      return [0, 0, 0];
	    } // Returns the picking color that doesn't match any subfeature
	    // Use if some graphics do not belong to any pickable subfeature

	  }, {
	    key: "encodePickingColor",
	    value: function encodePickingColor(i) {
	      (0, _assert.default)((i + 1 >> 24 & 255) === 0, 'index out of picking color range');
	      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];
	    } // Returns the index corresponding to a picking color that doesn't match any subfeature
	    // @param {Uint8Array} color - color array to be decoded
	    // @return {Array} - the decoded picking color

	  }, {
	    key: "decodePickingColor",
	    value: function decodePickingColor(color) {
	      (0, _assert.default)(_instanceof(color, Uint8Array));

	      var _color = _slicedToArray(color, 3),
	          i1 = _color[0],
	          i2 = _color[1],
	          i3 = _color[2]; // 1 was added to seperate from no selection


	      var index = i1 + i2 * 256 + i3 * 65536 - 1;
	      return index;
	    } // //////////////////////////////////////////////////
	    // LIFECYCLE METHODS, overridden by the layer subclasses
	    // Called once to set up the initial state
	    // App can create WebGL resources

	  }, {
	    key: "initializeState",
	    value: function initializeState() {
	      throw new Error("Layer ".concat(this, " has not defined initializeState"));
	    } // Let's layer control if updateState should be called

	  }, {
	    key: "shouldUpdateState",
	    value: function shouldUpdateState(_ref3) {
	      var oldProps = _ref3.oldProps,
	          props = _ref3.props,
	          context = _ref3.context,
	          changeFlags = _ref3.changeFlags;
	      return changeFlags.propsOrDataChanged;
	    } // Default implementation, all attributes will be invalidated and updated
	    // when data changes

	  }, {
	    key: "updateState",
	    value: function updateState(_ref4) {
	      var oldProps = _ref4.oldProps,
	          props = _ref4.props,
	          context = _ref4.context,
	          changeFlags = _ref4.changeFlags;
	      var attributeManager = this.getAttributeManager();

	      if (changeFlags.dataChanged && attributeManager) {
	        attributeManager.invalidateAll();
	      }
	    } // Called once when layer is no longer matched and state will be discarded
	    // App can destroy WebGL resources here

	  }, {
	    key: "finalizeState",
	    value: function finalizeState() {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this.getModels()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var model = _step2.value;
	          model.delete();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      this.getAttributeManager().finalize();
	    } // If state has a model, draw it with supplied uniforms

	  }, {
	    key: "draw",
	    value: function draw(opts) {
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var model = _step3.value;
	          model.draw(opts);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    } // called to populate the info object that is passed to the event handler
	    // @return null to cancel event

	  }, {
	    key: "getPickingInfo",
	    value: function getPickingInfo(_ref5) {
	      var info = _ref5.info,
	          mode = _ref5.mode;
	      var index = info.index;

	      if (index >= 0) {
	        // If props.data is an indexable array, get the object
	        if (Array.isArray(this.props.data)) {
	          info.object = this.props.data[index];
	        }
	      }

	      return info;
	    } // END LIFECYCLE METHODS
	    // //////////////////////////////////////////////////
	    // INTERNAL METHODS
	    // Default implementation of attribute invalidation, can be redefined

	  }, {
	    key: "invalidateAttribute",
	    value: function invalidateAttribute() {
	      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';
	      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
	      var attributeManager = this.getAttributeManager();

	      if (!attributeManager) {
	        return;
	      }

	      if (name === 'all') {
	        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating all attributes: ".concat(diffReason))();

	        attributeManager.invalidateAll();
	      } else {
	        _log.default.log(LOG_PRIORITY_UPDATE, "updateTriggers invalidating attribute ".concat(name, ": ").concat(diffReason))();

	        attributeManager.invalidate(name);
	      }
	    } // Calls attribute manager to update any WebGL attributes

	  }, {
	    key: "updateAttributes",
	    value: function updateAttributes(props) {
	      var attributeManager = this.getAttributeManager();

	      if (!attributeManager) {
	        return;
	      } // Figure out data length


	      var numInstances = this.getNumInstances(props);
	      attributeManager.update({
	        data: props.data,
	        numInstances: numInstances,
	        props: props,
	        transitions: props.transitions,
	        buffers: props,
	        context: this,
	        // Don't worry about non-attribute props
	        ignoreUnknownAttributes: true
	      });
	      var model = this.getSingleModel();

	      if (model) {
	        var changedAttributes = attributeManager.getChangedAttributes({
	          clearChangedFlags: true
	        });
	        model.setAttributes(changedAttributes);
	      }
	    } // Update attribute transition

	  }, {
	    key: "updateTransition",
	    value: function updateTransition() {
	      var model = this.getSingleModel();
	      var attributeManager = this.getAttributeManager();
	      var isInTransition = attributeManager && attributeManager.updateTransition();

	      if (model && isInTransition) {
	        model.setAttributes(attributeManager.getChangedAttributes({
	          transition: true
	        }));
	      }
	    }
	  }, {
	    key: "calculateInstancePickingColors",
	    value: function calculateInstancePickingColors(attribute, _ref6) {
	      var numInstances = _ref6.numInstances;
	      var value = attribute.value,
	          size = attribute.size; // add 1 to index to seperate from no selection

	      for (var i = 0; i < numInstances; i++) {
	        var pickingColor = this.encodePickingColor(i);
	        value[i * size + 0] = pickingColor[0];
	        value[i * size + 1] = pickingColor[1];
	        value[i * size + 2] = pickingColor[2];
	      }
	    } // Sets the specified instanced picking color to null picking color. Used for multi picking.

	  }, {
	    key: "_clearInstancePickingColor",
	    value: function _clearInstancePickingColor(color) {
	      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;
	      var attribute = instancePickingColors.state;
	      var value = attribute.value,
	          size = attribute.size;
	      var i = this.decodePickingColor(color);
	      value[i * size + 0] = 0;
	      value[i * size + 1] = 0;
	      value[i * size + 2] = 0; // TODO: Optimize this to use sub-buffer update!

	      var models = this.getModels();

	      if (models) {
	        models.forEach(function (model) {
	          return model.setAttributes({
	            instancePickingColors: attribute
	          });
	        });
	      }
	    } // Sets all occurrences of the specified picking color to null picking color. Used for multi picking.

	  }, {
	    key: "_clearPickingColor",
	    value: function _clearPickingColor(color) {
	      var pickingColors = this.getAttributeManager().attributes.pickingColors;
	      var attribute = pickingColors.state;
	      var value = attribute.value;

	      for (var i = 0; i < value.length; i += 3) {
	        if (value[i + 0] === color[0] && value[i + 1] === color[1] && value[i + 2] === color[2]) {
	          value[i + 0] = 0;
	          value[i + 1] = 0;
	          value[i + 2] = 0;
	        }
	      } // TODO: Optimize this to use sub-buffer update!


	      var models = this.getModels();

	      if (models) {
	        models.forEach(function (model) {
	          return model.setAttributes({
	            pickingColors: attribute
	          });
	        });
	      }
	    } // This method figures out if we use instance colors or not
	    // and calls _clearInstancePickingColor or _clearPickingColor

	  }, {
	    key: "clearPickingColor",
	    value: function clearPickingColor(color) {
	      if (this.getAttributeManager().attributes.pickingColors) {
	        this._clearPickingColor(color);
	      } else {
	        this._clearInstancePickingColor(color);
	      }
	    }
	  }, {
	    key: "copyPickingColors",
	    value: function copyPickingColors() {
	      var _this$getAttributeMan = this.getAttributeManager().attributes,
	          pickingColors = _this$getAttributeMan.pickingColors,
	          instancePickingColors = _this$getAttributeMan.instancePickingColors;
	      var colors = pickingColors || instancePickingColors;
	      return new Uint8ClampedArray(colors.value);
	    }
	  }, {
	    key: "restorePickingColors",
	    value: function restorePickingColors(value) {
	      var _this$getAttributeMan2 = this.getAttributeManager().attributes,
	          pickingColors = _this$getAttributeMan2.pickingColors,
	          instancePickingColors = _this$getAttributeMan2.instancePickingColors;
	      var colors = pickingColors || instancePickingColors;
	      colors.value.set(value);
	      colors.setNeedsUpdate();
	      this.updateAttributes(this.props);
	    } // Deduces numer of instances. Intention is to support:
	    // - Explicit setting of numInstances
	    // - Auto-deduction for ES6 containers that define a size member
	    // - Auto-deduction for Classic Arrays via the built-in length attribute
	    // - Auto-deduction via arrays

	  }, {
	    key: "getNumInstances",
	    value: function getNumInstances(props) {
	      props = props || this.props; // First check if the layer has set its own value

	      if (this.state && this.state.numInstances !== undefined) {
	        return this.state.numInstances;
	      } // Check if app has provided an explicit value


	      if (props.numInstances !== undefined) {
	        return props.numInstances;
	      } // Use container library to get a count for any ES6 container or object


	      var data = this.props.data;
	      return (0, _count.count)(data);
	    } // LAYER MANAGER API
	    // Should only be called by the deck.gl LayerManager class
	    // Called by layer manager when a new layer is found

	    /* eslint-disable max-statements */

	  }, {
	    key: "_initialize",
	    value: function _initialize() {
	      (0, _assert.default)(this.context.gl);

	      this._initState(); // Call subclass lifecycle methods


	      this.initializeState(this.context); // End subclass lifecycle methods
	      // TODO deprecated, for backwards compatibility with older layers
	      // in case layer resets state

	      this.state.attributeManager = this.getAttributeManager(); // initializeState callback tends to clear state

	      this.setChangeFlags({
	        dataChanged: true,
	        propsChanged: true,
	        viewportChanged: true
	      });

	      this._updateState();

	      var model = this.getSingleModel();

	      if (model) {
	        model.id = this.props.id;
	        model.program.id = "".concat(this.props.id, "-program");
	        model.geometry.id = "".concat(this.props.id, "-geometry");
	        model.setAttributes(this.getAttributeManager().getAttributes());
	      }
	    } // Called by layer manager
	    // if this layer is new (not matched with an existing layer) oldProps will be empty object

	  }, {
	    key: "_update",
	    value: function _update() {
	      // Call subclass lifecycle method
	      var stateNeedsUpdate = this.needsUpdate(); // End lifecycle method

	      if (stateNeedsUpdate) {
	        this._updateState();
	      }
	    }
	    /* eslint-enable max-statements */
	    // Common code for _initialize and _update

	  }, {
	    key: "_updateState",
	    value: function _updateState() {
	      var updateParams = this._getUpdateParams(); // Call subclass lifecycle methods


	      this.updateState(updateParams); // Render or update previously rendered sublayers

	      if (this.isComposite) {
	        this._renderLayers(updateParams);
	      } // End subclass lifecycle methods
	      // Add any subclass attributes


	      this.updateAttributes(this.props);

	      this._updateBaseUniforms();

	      this._updateModuleSettings(); // Note: Automatic instance count update only works for single layers


	      if (this.state.model) {
	        this.state.model.setInstanceCount(this.getNumInstances());
	      }

	      this.clearChangeFlags();
	      this.internalState.resetOldProps();
	    } // Called by manager when layer is about to be disposed
	    // Note: not guaranteed to be called on application shutdown

	  }, {
	    key: "_finalize",
	    value: function _finalize() {
	      (0, _assert.default)(this.internalState && this.state); // Call subclass lifecycle method

	      this.finalizeState(this.context); // End lifecycle method

	      (0, _seerIntegration.removeLayerInSeer)(this.id);
	    } // Calculates uniforms

	  }, {
	    key: "drawLayer",
	    value: function drawLayer(_ref7) {
	      var _this = this;

	      var _ref7$moduleParameter = _ref7.moduleParameters,
	          moduleParameters = _ref7$moduleParameter === void 0 ? null : _ref7$moduleParameter,
	          _ref7$uniforms = _ref7.uniforms,
	          uniforms = _ref7$uniforms === void 0 ? {} : _ref7$uniforms,
	          _ref7$parameters = _ref7.parameters,
	          parameters = _ref7$parameters === void 0 ? {} : _ref7$parameters;

	      if (!uniforms.picking_uActive) {
	        this.updateTransition();
	      } // TODO/ib - hack move to luma Model.draw


	      if (moduleParameters) {
	        var _iteratorNormalCompletion4 = true;
	        var _didIteratorError4 = false;
	        var _iteratorError4 = undefined;

	        try {
	          for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	            var model = _step4.value;
	            model.updateModuleSettings(moduleParameters);
	          }
	        } catch (err) {
	          _didIteratorError4 = true;
	          _iteratorError4 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
	              _iterator4.return();
	            }
	          } finally {
	            if (_didIteratorError4) {
	              throw _iteratorError4;
	            }
	          }
	        }
	      } // Apply polygon offset to avoid z-fighting
	      // TODO - move to draw-layers


	      var getPolygonOffset = this.props.getPolygonOffset;
	      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
	      parameters.polygonOffset = offsets; // Call subclass lifecycle method

	      (0, _luma.withParameters)(this.context.gl, parameters, function () {
	        _this.draw({
	          moduleParameters: moduleParameters,
	          uniforms: uniforms,
	          parameters: parameters,
	          context: _this.context
	        });
	      }); // End lifecycle method
	    } // {uniforms = {}, ...opts}

	  }, {
	    key: "pickLayer",
	    value: function pickLayer(opts) {
	      // Call subclass lifecycle method
	      return this.getPickingInfo(opts); // End lifecycle method
	    } // Helper methods

	  }, {
	    key: "getChangeFlags",
	    value: function getChangeFlags() {
	      return this.internalState.changeFlags;
	    } // Dirty some change flags, will be handled by updateLayer

	    /* eslint-disable complexity */

	  }, {
	    key: "setChangeFlags",
	    value: function setChangeFlags(flags) {
	      var _this2 = this;

	      this.internalState.changeFlags = this.internalState.changeFlags || {};
	      var changeFlags = this.internalState.changeFlags; // Update primary flags

	      if (flags.dataChanged && !changeFlags.dataChanged) {
	        changeFlags.dataChanged = flags.dataChanged;

	        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
	          return "dataChanged: ".concat(flags.dataChanged, " in ").concat(_this2.id);
	        })();
	      }

	      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {
	        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;

	        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
	          return 'updateTriggersChanged: ' + "".concat(Object.keys(flags.updateTriggersChanged).join(', '), " in ").concat(_this2.id);
	        })();
	      }

	      if (flags.propsChanged && !changeFlags.propsChanged) {
	        changeFlags.propsChanged = flags.propsChanged;

	        _log.default.log(LOG_PRIORITY_UPDATE + 1, function () {
	          return "propsChanged: ".concat(flags.propsChanged, " in ").concat(_this2.id);
	        })();
	      }

	      if (flags.viewportChanged && !changeFlags.viewportChanged) {
	        changeFlags.viewportChanged = flags.viewportChanged;

	        _log.default.log(LOG_PRIORITY_UPDATE + 2, function () {
	          return "viewportChanged: ".concat(flags.viewportChanged, " in ").concat(_this2.id);
	        })();
	      } // Update composite flags


	      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;
	      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;
	      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged;
	    }
	    /* eslint-enable complexity */
	    // Clear all changeFlags, typically after an update

	  }, {
	    key: "clearChangeFlags",
	    value: function clearChangeFlags() {
	      this.internalState.changeFlags = {
	        // Primary changeFlags, can be strings stating reason for change
	        dataChanged: false,
	        propsChanged: false,
	        updateTriggersChanged: false,
	        viewportChanged: false,
	        // Derived changeFlags
	        propsOrDataChanged: false,
	        somethingChanged: false
	      };
	    }
	  }, {
	    key: "printChangeFlags",
	    value: function printChangeFlags() {
	      var flags = this.internalState.changeFlags;
	      return "".concat(flags.dataChanged ? 'data ' : '').concat(flags.propsChanged ? 'props ' : '').concat(flags.updateTriggersChanged ? 'triggers ' : '').concat(flags.viewportChanged ? 'viewport' : '');
	    } // Compares the layers props with old props from a matched older layer
	    // and extracts change flags that describe what has change so that state
	    // can be update correctly with minimal effort

	  }, {
	    key: "diffProps",
	    value: function diffProps(newProps, oldProps) {
	      var changeFlags = (0, _props.diffProps)(newProps, oldProps); // iterate over changedTriggers

	      if (changeFlags.updateTriggersChanged) {
	        for (var key in changeFlags.updateTriggersChanged) {
	          if (changeFlags.updateTriggersChanged[key]) {
	            this._activeUpdateTrigger(key);
	          }
	        }
	      }

	      return this.setChangeFlags(changeFlags);
	    } // PRIVATE METHODS

	  }, {
	    key: "_getUpdateParams",
	    value: function _getUpdateParams() {
	      return {
	        props: this.props,
	        oldProps: this.internalState.getOldProps(),
	        context: this.context,
	        changeFlags: this.internalState.changeFlags
	      };
	    } // Checks state of attributes and model

	  }, {
	    key: "_getNeedsRedraw",
	    value: function _getNeedsRedraw(clearRedrawFlags) {
	      // this method may be called by the render loop as soon a the layer
	      // has been created, so guard against uninitialized state
	      if (!this.internalState) {
	        return false;
	      }

	      var redraw = false;
	      redraw = redraw || this.internalState.needsRedraw && this.id;
	      this.internalState.needsRedraw = this.internalState.needsRedraw && !clearRedrawFlags; // TODO - is attribute manager needed? - Model should be enough.

	      var attributeManager = this.getAttributeManager();
	      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({
	        clearRedrawFlags: clearRedrawFlags
	      });
	      redraw = redraw || attributeManagerNeedsRedraw;
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var model = _step5.value;
	          var modelNeedsRedraw = model.getNeedsRedraw({
	            clearRedrawFlags: clearRedrawFlags
	          });

	          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {
	            modelNeedsRedraw = "model ".concat(model.id);
	          }

	          redraw = redraw || modelNeedsRedraw;
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }

	      return redraw;
	    }
	  }, {
	    key: "_initState",
	    value: function _initState() {
	      (0, _assert.default)(!this.internalState && !this.state);
	      var attributeManager = new _attributeManager.default(this.context.gl, {
	        id: this.props.id,
	        stats: this.context.stats
	      }); // All instanced layers get instancePickingColors attribute by default
	      // Their shaders can use it to render a picking scene
	      // TODO - this slightly slows down non instanced layers

	      attributeManager.addInstanced({
	        instancePickingColors: {
	          type: _luma.GL.UNSIGNED_BYTE,
	          size: 3,
	          update: this.calculateInstancePickingColors
	        }
	      });
	      this.internalState = new _layerState.default({
	        attributeManager: attributeManager,
	        layer: this
	      });
	      this.state = {}; // TODO deprecated, for backwards compatibility with older layers

	      this.state.attributeManager = this.getAttributeManager();
	      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this); // Ensure any async props are updated

	      this.internalState.setAsyncProps(this.props);
	    } // Called by layer manager to transfer state from an old layer

	  }, {
	    key: "_transferState",
	    value: function _transferState(oldLayer) {
	      var state = oldLayer.state,
	          internalState = oldLayer.internalState;
	      (0, _assert.default)(state && internalState);

	      if (this === oldLayer) {
	        return;
	      } // Move internalState


	      this.internalState = internalState;
	      this.internalState.component = this; // Move state

	      this.state = state; // Deprecated: layer references on `state`

	      state.layer = this; // We keep the state ref on old layers to support async actions
	      // oldLayer.state = null;
	      // Ensure any async props are updated

	      this.internalState.setAsyncProps(this.props); // Update model layer reference

	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;

	      try {
	        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var model = _step6.value;
	          model.userData.layer = this;
	        } // Ensure any async props are updated

	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }

	      this.internalState.setAsyncProps(this.props);
	      this.diffProps(this.props, this.internalState.getOldProps());
	    }
	  }, {
	    key: "_onAsyncPropUpdated",
	    value: function _onAsyncPropUpdated() {
	      this.diffProps(this.props, this.internalState.getOldProps());
	      this.setLayerNeedsUpdate();
	    } // Operate on each changed triggers, will be called when an updateTrigger changes

	  }, {
	    key: "_activeUpdateTrigger",
	    value: function _activeUpdateTrigger(propName) {
	      this.invalidateAttribute(propName);
	    } //  Helper to check that required props are supplied

	  }, {
	    key: "_checkRequiredProp",
	    value: function _checkRequiredProp(propertyName, condition) {
	      var value = this.props[propertyName];

	      if (value === undefined) {
	        throw new Error("Property ".concat(propertyName, " undefined in layer ").concat(this));
	      }

	      if (condition && !condition(value)) {
	        throw new Error("Bad property ".concat(propertyName, " in layer ").concat(this));
	      }
	    }
	  }, {
	    key: "_updateBaseUniforms",
	    value: function _updateBaseUniforms() {
	      var uniforms = {
	        // apply gamma to opacity to make it visually "linear"
	        opacity: Math.pow(this.props.opacity, 1 / 2.2),
	        ONE: 1.0
	      };
	      var _iteratorNormalCompletion7 = true;
	      var _didIteratorError7 = false;
	      var _iteratorError7 = undefined;

	      try {
	        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	          var model = _step7.value;
	          model.setUniforms(uniforms);
	        } // TODO - set needsRedraw on the model(s)?

	      } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
	            _iterator7.return();
	          }
	        } finally {
	          if (_didIteratorError7) {
	            throw _iteratorError7;
	          }
	        }
	      }

	      this.setNeedsRedraw();
	    }
	  }, {
	    key: "_updateModuleSettings",
	    value: function _updateModuleSettings() {
	      var settings = {
	        pickingHighlightColor: this.props.highlightColor
	      };
	      var _iteratorNormalCompletion8 = true;
	      var _didIteratorError8 = false;
	      var _iteratorError8 = undefined;

	      try {
	        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
	          var model = _step8.value;
	          model.updateModuleSettings(settings);
	        }
	      } catch (err) {
	        _didIteratorError8 = true;
	        _iteratorError8 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
	            _iterator8.return();
	          }
	        } finally {
	          if (_didIteratorError8) {
	            throw _iteratorError8;
	          }
	        }
	      }
	    } // DEPRECATED METHODS
	    // Updates selected state members and marks the object for redraw

	  }, {
	    key: "setUniforms",
	    value: function setUniforms(uniformMap) {
	      var _iteratorNormalCompletion9 = true;
	      var _didIteratorError9 = false;
	      var _iteratorError9 = undefined;

	      try {
	        for (var _iterator9 = this.getModels()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
	          var model = _step9.value;
	          model.setUniforms(uniformMap);
	        } // TODO - set needsRedraw on the model(s)?

	      } catch (err) {
	        _didIteratorError9 = true;
	        _iteratorError9 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
	            _iterator9.return();
	          }
	        } finally {
	          if (_didIteratorError9) {
	            throw _iteratorError9;
	          }
	        }
	      }

	      this.setNeedsRedraw();

	      _log.default.deprecated('layer.setUniforms', 'model.setUniforms')();
	    }
	  }]);

	  return Layer;
	}(_component.default);

	exports.default = Layer;
	Layer.layerName = 'Layer';
	Layer.defaultProps = defaultProps;
	//# sourceMappingURL=layer.js.map

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _attribute = _interopRequireDefault(__webpack_require__(263));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _attributeTransitionManager = _interopRequireDefault(__webpack_require__(264));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var LOG_START_END_PRIORITY = 2;
	var LOG_DETAIL_PRIORITY = 3;

	function noop() {} // Default loggers


	var logFunctions = {
	  savedMessages: null,
	  timeStart: null,
	  onLog: function onLog(_ref) {
	    var level = _ref.level,
	        message = _ref.message;

	    _log.default.log(level, message)();
	  },
	  onUpdateStart: function onUpdateStart(_ref2) {
	    var level = _ref2.level,
	        numInstances = _ref2.numInstances;
	    logFunctions.savedMessages = [];
	    logFunctions.timeStart = new Date();
	  },
	  onUpdate: function onUpdate(_ref3) {
	    var level = _ref3.level,
	        message = _ref3.message;

	    if (logFunctions.savedMessages) {
	      logFunctions.savedMessages.push(message);
	    }
	  },
	  onUpdateEnd: function onUpdateEnd(_ref4) {
	    var level = _ref4.level,
	        id = _ref4.id,
	        numInstances = _ref4.numInstances;
	    var timeMs = Math.round(new Date() - logFunctions.timeStart);
	    var time = "".concat(timeMs, "ms");

	    _log.default.group(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time), {
	      collapsed: true
	    })();

	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var message = _step.value;

	        _log.default.log(level, message)();
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return != null) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    _log.default.groupEnd(level, "Updated attributes for ".concat(numInstances, " instances in ").concat(id, " in ").concat(time))();

	    logFunctions.savedMessages = null;
	  }
	};

	var AttributeManager =
	/*#__PURE__*/
	function () {
	  _createClass(AttributeManager, null, [{
	    key: "setDefaultLogFunctions",

	    /**
	     * Sets log functions to help trace or time attribute updates.
	     * Default logging uses deck logger.
	     *
	     * `onLog` is called for each attribute.
	     *
	     * To enable detailed control of timming and e.g. hierarchical logging,
	     * hooks are also provided for update start and end.
	     *
	     * @param {Object} [opts]
	     * @param {String} [onLog=] - called to print
	     * @param {String} [onUpdateStart=] - called before update() starts
	     * @param {String} [onUpdateEnd=] - called after update() ends
	     */
	    value: function setDefaultLogFunctions() {
	      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          onLog = _ref5.onLog,
	          onUpdateStart = _ref5.onUpdateStart,
	          onUpdate = _ref5.onUpdate,
	          onUpdateEnd = _ref5.onUpdateEnd;

	      if (onLog !== undefined) {
	        logFunctions.onLog = onLog || noop;
	      }

	      if (onUpdateStart !== undefined) {
	        logFunctions.onUpdateStart = onUpdateStart || noop;
	      }

	      if (onUpdate !== undefined) {
	        logFunctions.onUpdate = onUpdate || noop;
	      }

	      if (onUpdateEnd !== undefined) {
	        logFunctions.onUpdateEnd = onUpdateEnd || noop;
	      }
	    }
	    /**
	     * @classdesc
	     * Automated attribute generation and management. Suitable when a set of
	     * vertex shader attributes are generated by iteration over a data array,
	     * and updates to these attributes are needed either when the data itself
	     * changes, or when other data relevant to the calculations change.
	     *
	     * - First the application registers descriptions of its dynamic vertex
	     *   attributes using AttributeManager.add().
	     * - Then, when any change that affects attributes is detected by the
	     *   application, the app will call AttributeManager.invalidate().
	     * - Finally before it renders, it calls AttributeManager.update() to
	     *   ensure that attributes are automatically rebuilt if anything has been
	     *   invalidated.
	     *
	     * The application provided update functions describe how attributes
	     * should be updated from a data array and are expected to traverse
	     * that data array (or iterable) and fill in the attribute's typed array.
	     *
	     * Note that the attribute manager intentionally does not do advanced
	     * change detection, but instead makes it easy to build such detection
	     * by offering the ability to "invalidate" each attribute separately.
	     */

	  }]);

	  function AttributeManager(gl) {
	    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	        _ref6$id = _ref6.id,
	        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,
	        stats = _ref6.stats;

	    _classCallCheck(this, AttributeManager);

	    this.id = id;
	    this.gl = gl;
	    this.attributes = {};
	    this.updateTriggers = {};
	    this.accessors = {};
	    this.needsRedraw = true;
	    this.userData = {};
	    this.stats = stats;
	    this.attributeTransitionManager = new _attributeTransitionManager.default(gl, {
	      id: "".concat(id, "-transitions")
	    }); // For debugging sanity, prevent uninitialized members

	    Object.seal(this);
	  }

	  _createClass(AttributeManager, [{
	    key: "finalize",
	    value: function finalize() {
	      for (var attributeName in this.attributes) {
	        this.attributes[attributeName].delete();
	      }

	      this.attributeTransitionManager.finalize();
	    } // Returns the redraw flag, optionally clearing it.
	    // Redraw flag will be set if any attributes attributes changed since
	    // flag was last cleared.
	    //
	    // @param {String} [clearRedrawFlags=false] - whether to clear the flag
	    // @return {false|String} - reason a redraw is needed.

	  }, {
	    key: "getNeedsRedraw",
	    value: function getNeedsRedraw() {
	      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,
	          clearRedrawFlags = _ref7$clearRedrawFlag === void 0 ? false : _ref7$clearRedrawFlag;

	      var redraw = this.needsRedraw;
	      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;
	      return redraw && this.id;
	    } // Sets the redraw flag.
	    // @param {Boolean} redraw=true
	    // @return {AttributeManager} - for chaining

	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw() {
	      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.needsRedraw = true;
	      return this;
	    } // Adds attributes

	  }, {
	    key: "add",
	    value: function add(attributes) {
	      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      this._add(attributes, updaters);
	    } // Adds attributes

	  }, {
	    key: "addInstanced",
	    value: function addInstanced(attributes) {
	      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      this._add(attributes, updaters, {
	        instanced: 1
	      });
	    }
	    /**
	     * Removes attributes
	     * Takes an array of attribute names and delete them from
	     * the attribute map if they exists
	     *
	     * @example
	     * attributeManager.remove(['position']);
	     *
	     * @param {Object} attributeNameArray - attribute name array (see above)
	     */

	  }, {
	    key: "remove",
	    value: function remove(attributeNameArray) {
	      for (var i = 0; i < attributeNameArray.length; i++) {
	        var name = attributeNameArray[i];

	        if (this.attributes[name] !== undefined) {
	          this.attributes[name].delete();
	          delete this.attributes[name];
	        }
	      }
	    } // Marks an attribute for update

	  }, {
	    key: "invalidate",
	    value: function invalidate(triggerName) {
	      var invalidatedAttributes = this._invalidateTrigger(triggerName); // For performance tuning


	      logFunctions.onLog({
	        level: LOG_DETAIL_PRIORITY,
	        message: "invalidated attributes ".concat(invalidatedAttributes, " (").concat(triggerName, ") for ").concat(this.id)
	      });
	    }
	  }, {
	    key: "invalidateAll",
	    value: function invalidateAll() {
	      for (var attributeName in this.attributes) {
	        this.attributes[attributeName].setNeedsUpdate();
	      } // For performance tuning


	      logFunctions.onLog({
	        level: LOG_DETAIL_PRIORITY,
	        message: "invalidated all attributes for ".concat(this.id)
	      });
	    } // Ensure all attribute buffers are updated from props or data.

	  }, {
	    key: "update",
	    value: function update() {
	      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          data = _ref8.data,
	          numInstances = _ref8.numInstances,
	          transitions = _ref8.transitions,
	          _ref8$props = _ref8.props,
	          props = _ref8$props === void 0 ? {} : _ref8$props,
	          _ref8$buffers = _ref8.buffers,
	          buffers = _ref8$buffers === void 0 ? {} : _ref8$buffers,
	          _ref8$context = _ref8.context,
	          context = _ref8$context === void 0 ? {} : _ref8$context,
	          _ref8$ignoreUnknownAt = _ref8.ignoreUnknownAttributes,
	          ignoreUnknownAttributes = _ref8$ignoreUnknownAt === void 0 ? false : _ref8$ignoreUnknownAt;

	      // First apply any application provided buffers
	      this._checkExternalBuffers({
	        buffers: buffers,
	        ignoreUnknownAttributes: ignoreUnknownAttributes
	      });

	      this._setExternalBuffers(buffers); // Apply constant accessors


	      this._setGenericAttributes({
	        data: data,
	        props: props,
	        context: context
	      }); // Only initiate alloc/update (and logging) if actually needed


	      if (this._checkIfBuffersNeedUpdating({
	        numInstances: numInstances
	      })) {
	        logFunctions.onUpdateStart({
	          level: LOG_START_END_PRIORITY,
	          id: this.id,
	          numInstances: numInstances
	        });

	        if (this.stats) {
	          this.stats.timeStart('attribute updates', this.id);
	        }

	        this._allocateBuffers({
	          numInstances: numInstances,
	          data: data,
	          props: props,
	          context: context
	        });

	        this._updateBuffers({
	          numInstances: numInstances,
	          data: data,
	          props: props,
	          context: context
	        });

	        if (this.stats) {
	          this.stats.timeEnd('attribute updates', this.id);
	        }

	        logFunctions.onUpdateEnd({
	          level: LOG_START_END_PRIORITY,
	          id: this.id,
	          numInstances: numInstances
	        });
	      }

	      this.attributeTransitionManager.update({
	        attributes: this.attributes,
	        numInstances: numInstances,
	        transitions: transitions
	      });
	    } // Update attribute transition to the current timestamp
	    // Returns `true` if any transition is in progress

	  }, {
	    key: "updateTransition",
	    value: function updateTransition() {
	      var attributeTransitionManager = this.attributeTransitionManager;
	      var transitionUpdated = attributeTransitionManager.setCurrentTime(Date.now());
	      this.needsRedraw = this.needsRedraw || transitionUpdated;
	      return transitionUpdated;
	    }
	    /**
	     * Returns all attribute descriptors
	     * Note: Format matches luma.gl Model/Program.setAttributes()
	     * @return {Object} attributes - descriptors
	     */

	  }, {
	    key: "getAttributes",
	    value: function getAttributes() {
	      return this.attributes;
	    }
	    /**
	     * Returns changed attribute descriptors
	     * This indicates which WebGLBuggers need to be updated
	     * @return {Object} attributes - descriptors
	     */

	  }, {
	    key: "getChangedAttributes",
	    value: function getChangedAttributes(_ref9) {
	      var _ref9$transition = _ref9.transition,
	          transition = _ref9$transition === void 0 ? false : _ref9$transition,
	          _ref9$clearChangedFla = _ref9.clearChangedFlags,
	          clearChangedFlags = _ref9$clearChangedFla === void 0 ? false : _ref9$clearChangedFla;
	      var attributes = this.attributes,
	          attributeTransitionManager = this.attributeTransitionManager;

	      if (transition) {
	        return attributeTransitionManager.getAttributes();
	      }

	      var changedAttributes = {};

	      for (var attributeName in attributes) {
	        var attribute = attributes[attributeName];

	        if (attribute.needsRedraw({
	          clearChangedFlags: true
	        })) {
	          // Only return non-transition attributes
	          if (!attributeTransitionManager.hasAttribute(attributeName)) {
	            changedAttributes[attributeName] = attribute;
	          }
	        }
	      }

	      return changedAttributes;
	    } // PROTECTED METHODS - Only to be used by collaborating classes, not by apps
	    // Returns object containing all accessors as keys, with non-null values
	    // @return {Object} - accessors object

	  }, {
	    key: "getAccessors",
	    value: function getAccessors() {
	      return this.updateTriggers;
	    } // PRIVATE METHODS
	    // Used to register an attribute

	  }, {
	    key: "_add",
	    value: function _add(attributes, updaters) {
	      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      if (updaters) {
	        _log.default.removed('AttributeManager.add({updaters}) - updater map no longer supported');
	      }

	      var newAttributes = {};

	      for (var attributeName in attributes) {
	        var attribute = attributes[attributeName]; // Initialize the attribute descriptor, with WebGL and metadata fields

	        newAttributes[attributeName] = new _attribute.default(this.gl, Object.assign({}, attribute, {
	          id: attributeName,
	          // Luma fields
	          isGeneric: attribute.isGeneric || false,
	          isIndexed: attribute.isIndexed || attribute.elements,
	          size: attribute.elements && 1 || attribute.size,
	          value: attribute.value || null,
	          instanced: attribute.instanced || extraProps.instanced
	        }));
	      }

	      Object.assign(this.attributes, newAttributes);

	      this._mapUpdateTriggersToAttributes();
	    }
	    /* eslint-enable max-statements */
	    // build updateTrigger name to attribute name mapping

	  }, {
	    key: "_mapUpdateTriggersToAttributes",
	    value: function _mapUpdateTriggersToAttributes() {
	      var _this = this;

	      var triggers = {};

	      var _loop = function _loop(attributeName) {
	        var attribute = _this.attributes[attributeName];
	        attribute.getUpdateTriggers().forEach(function (triggerName) {
	          if (!triggers[triggerName]) {
	            triggers[triggerName] = [];
	          }

	          triggers[triggerName].push(attributeName);
	        });
	      };

	      for (var attributeName in this.attributes) {
	        _loop(attributeName);
	      }

	      this.updateTriggers = triggers;
	    }
	  }, {
	    key: "_invalidateTrigger",
	    value: function _invalidateTrigger(triggerName) {
	      var attributes = this.attributes,
	          updateTriggers = this.updateTriggers;
	      var invalidatedAttributes = updateTriggers[triggerName];

	      if (!invalidatedAttributes) {
	        var message = "invalidating non-existent trigger ".concat(triggerName, " for ").concat(this.id, "\n");
	        message += "Valid triggers: ".concat(Object.keys(attributes).join(', '));

	        _log.default.warn(message, invalidatedAttributes)();
	      } else {
	        invalidatedAttributes.forEach(function (name) {
	          var attribute = attributes[name];

	          if (attribute) {
	            attribute.setNeedsUpdate();
	          }
	        });
	      }

	      return invalidatedAttributes;
	    } // Set the buffers for the supplied attributes
	    // Update attribute buffers from any attributes in props
	    // Detach any previously set buffers, marking all
	    // Attributes for auto allocation

	    /* eslint-disable max-statements, max-depth */

	  }, {
	    key: "_setExternalBuffers",
	    value: function _setExternalBuffers(bufferMap) {
	      // Copy the refs of any supplied buffers in the props
	      for (var attributeName in this.attributes) {
	        var attribute = this.attributes[attributeName];
	        var buffer = bufferMap[attributeName];
	        attribute.setExternalBuffer(buffer, this.numInstances);
	        this.needsRedraw |= attribute.needsRedraw();
	      }
	    } // Checks that any attribute buffers in props are valid
	    // Note: This is just to help app catch mistakes

	  }, {
	    key: "_checkExternalBuffers",
	    value: function _checkExternalBuffers() {
	      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref10$buffers = _ref10.buffers,
	          buffers = _ref10$buffers === void 0 ? {} : _ref10$buffers,
	          _ref10$ignoreUnknownA = _ref10.ignoreUnknownAttributes,
	          ignoreUnknownAttributes = _ref10$ignoreUnknownA === void 0 ? false : _ref10$ignoreUnknownA;

	      var attributes = this.attributes;

	      for (var attributeName in buffers) {
	        var attribute = attributes[attributeName];

	        if (!attribute && !ignoreUnknownAttributes) {
	          throw new Error("Unknown attribute prop ".concat(attributeName));
	        }
	      }
	    }
	    /* Checks that typed arrays for attributes are big enough
	     * sets alloc flag if not
	     * @return {Boolean} whether any updates are needed
	     */

	  }, {
	    key: "_checkIfBuffersNeedUpdating",
	    value: function _checkIfBuffersNeedUpdating(_ref11) {
	      var numInstances = _ref11.numInstances;
	      (0, _assert.default)(numInstances !== undefined, 'numInstances not defined'); // Track whether any allocations or updates are needed

	      var needsUpdate = false;

	      for (var attributeName in this.attributes) {
	        var attribute = this.attributes[attributeName];
	        attribute.setNumInstances(numInstances);
	        needsUpdate = needsUpdate || attribute.needsUpdate();
	      }

	      return needsUpdate;
	    }
	  }, {
	    key: "_setGenericAttributes",
	    value: function _setGenericAttributes(_ref12) {
	      var data = _ref12.data,
	          props = _ref12.props,
	          context = _ref12.context;
	      var attributes = this.attributes;

	      for (var attributeName in attributes) {
	        var attribute = attributes[attributeName];
	        attribute.setGenericValue({
	          props: props
	        });
	      }
	    } // Calls update on any buffers that need update
	    // TODO? - If app supplied all attributes, no need to iterate over data
	    //
	    // @param {Object} data - data (iterable object)
	    // @param {Object} numInstances - count of data
	    // @param {Object} props - passed to updaters
	    // @param {Object} context - Used as "this" context for updaters

	  }, {
	    key: "_allocateBuffers",
	    value: function _allocateBuffers(_ref13) {
	      var numInstances = _ref13.numInstances,
	          data = _ref13.data,
	          props = _ref13.props,
	          context = _ref13.context;
	      var attributes = this.attributes;

	      for (var attributeName in attributes) {
	        var attribute = attributes[attributeName];

	        if (attribute.allocate(numInstances)) {
	          logFunctions.onUpdate({
	            level: LOG_DETAIL_PRIORITY,
	            message: "".concat(attributeName, " allocated ").concat(numInstances),
	            id: this.id
	          });
	        }
	      }
	    } // Calls update on any buffers that need update

	  }, {
	    key: "_updateBuffers",
	    value: function _updateBuffers(_ref14) {
	      var numInstances = _ref14.numInstances,
	          data = _ref14.data,
	          props = _ref14.props,
	          context = _ref14.context;

	      for (var attributeName in this.attributes) {
	        var attribute = this.attributes[attributeName]; // Call updater function if needed

	        var timeStart = Date.now();
	        var updated = attribute.updateBuffer({
	          numInstances: numInstances,
	          data: data,
	          props: props,
	          context: context
	        });

	        if (updated) {
	          this.needsRedraw = true;
	          var timeMs = Math.round(Date.now() - timeStart);
	          logFunctions.onUpdate({
	            level: LOG_DETAIL_PRIORITY,
	            message: "".concat(attributeName, " updated ").concat(numInstances, " in ").concat(timeMs, "ms")
	          });
	        }
	      }
	    }
	  }]);

	  return AttributeManager;
	}();

	exports.default = AttributeManager;
	//# sourceMappingURL=attribute-manager.js.map

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.glArrayFromType = glArrayFromType;
	exports.default = void 0;

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _luma = __webpack_require__(46);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var Attribute = _luma.experimental.Attribute;
	var DEFAULT_STATE = {
	  isExternalBuffer: false,
	  needsAlloc: false,
	  needsUpdate: false,
	  needsRedraw: false,
	  allocedInstances: -1
	};

	var LayerAttribute =
	/*#__PURE__*/
	function (_Attribute) {
	  _inherits(LayerAttribute, _Attribute);

	  function LayerAttribute(gl) {
	    var _this;

	    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, LayerAttribute);

	    _this = _possibleConstructorReturn(this, (LayerAttribute.__proto__ || Object.getPrototypeOf(LayerAttribute)).call(this, gl, opts));
	    var _opts$transition = opts.transition,
	        transition = _opts$transition === void 0 ? false : _opts$transition,
	        _opts$noAlloc = opts.noAlloc,
	        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,
	        _opts$update = opts.update,
	        update = _opts$update === void 0 ? null : _opts$update,
	        _opts$accessor = opts.accessor,
	        accessor = _opts$accessor === void 0 ? null : _opts$accessor;
	    var _opts$defaultValue = opts.defaultValue,
	        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;
	    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];
	    Object.assign(_this.userData, DEFAULT_STATE, opts, {
	      transition: transition,
	      noAlloc: noAlloc,
	      update: update,
	      accessor: accessor,
	      defaultValue: defaultValue
	    });
	    Object.seal(_this.userData); // Check all fields and generate helpful error messages

	    _this._validateAttributeUpdaters();

	    return _this;
	  }

	  _createClass(LayerAttribute, [{
	    key: "needsUpdate",
	    value: function needsUpdate() {
	      return this.userData.needsUpdate;
	    }
	  }, {
	    key: "needsRedraw",
	    value: function needsRedraw() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$clearChangedFlag = _ref.clearChangedFlags,
	          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;

	      var needsRedraw = this.userData.needsRedraw;
	      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;
	      return needsRedraw;
	    }
	  }, {
	    key: "getInstanceCount",
	    value: function getInstanceCount() {
	      return this.value !== null ? this.value.length / this.size : 0;
	    }
	  }, {
	    key: "getUpdateTriggers",
	    value: function getUpdateTriggers() {
	      var accessor = this.userData.accessor; // Backards compatibility: allow attribute name to be used as update trigger key

	      return [this.id].concat(accessor || []);
	    }
	  }, {
	    key: "supportsTransition",
	    value: function supportsTransition() {
	      return this.userData.transition;
	    } // Checks that typed arrays for attributes are big enough
	    // sets alloc flag if not
	    // @return {Boolean} whether any updates are needed

	  }, {
	    key: "setNeedsUpdate",
	    value: function setNeedsUpdate() {
	      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
	      this.userData.needsUpdate = this.userData.needsUpdate || reason;
	    }
	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw() {
	      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;
	      this.userData.needsRedraw = this.userData.needsRedraw || reason;
	    }
	  }, {
	    key: "setNumInstances",
	    value: function setNumInstances(numInstances) {
	      var state = this.userData;

	      if (state.isExternalBuffer || state.noAlloc) {
	        // Data is provided through a Buffer object.
	        return;
	      } // Do we need to reallocate the attribute's typed array?


	      var instanceCount = this.getInstanceCount();
	      var needsAlloc = instanceCount === 0 || instanceCount < numInstances;

	      if (needsAlloc && (state.update || state.accessor)) {
	        state.needsAlloc = true;
	        this.setNeedsUpdate(this.id);
	      }
	    }
	  }, {
	    key: "allocate",
	    value: function allocate(numInstances) {
	      this.setNumInstances(numInstances);
	      var state = this.userData; // Allocate a new typed array if needed

	      if (state.needsAlloc) {
	        // Allocate at least one element to ensure a valid buffer
	        var allocCount = Math.max(numInstances, 1);
	        var ArrayType = glArrayFromType(this.type || _luma.GL.FLOAT);
	        this.isGeneric = false;
	        this.value = new ArrayType(this.size * allocCount);
	        state.needsAlloc = false;
	        state.needsUpdate = true;
	        state.allocedInstances = allocCount;
	        return true;
	      }

	      return false;
	    }
	  }, {
	    key: "updateBuffer",
	    value: function updateBuffer(_ref2) {
	      var numInstances = _ref2.numInstances,
	          data = _ref2.data,
	          props = _ref2.props,
	          context = _ref2.context;

	      if (!this.needsUpdate()) {
	        return false;
	      }

	      var state = this.userData;
	      var update = state.update,
	          accessor = state.accessor;
	      var updated = true;

	      if (update) {
	        // Custom updater - typically for non-instanced layers
	        update.call(context, this, {
	          data: data,
	          props: props,
	          numInstances: numInstances
	        });
	        this.update({
	          value: this.value,
	          isGeneric: this.isGeneric
	        });

	        this._checkAttributeArray();
	      } else if (accessor) {
	        // Standard updater
	        this._updateBufferViaStandardAccessor(data, props);

	        this._checkAttributeArray();
	      } else {
	        updated = false;
	      }

	      state.needsUpdate = false;
	      state.needsRedraw = true;
	      return updated;
	    }
	  }, {
	    key: "setGenericValue",
	    value: function setGenericValue(_ref3) {
	      var props = _ref3.props;
	      var state = this.userData;
	      var value = props[state.accessor];

	      if (value === undefined || typeof value === 'function') {
	        // ignore if this attribute has no accessor
	        // ignore if accessor is function, will be used in updateBuffer
	        return;
	      }

	      value = this._normalizeValue(value);
	      var hasChanged = !this.isGeneric || !this._areValuesEqual(value, this.value);

	      if (hasChanged) {
	        this.update({
	          isGeneric: true,
	          value: value
	        });
	      }

	      state.needsRedraw = state.needsUpdate || hasChanged;
	      state.needsUpdate = false;
	      state.isExternalBuffer = true;
	    }
	  }, {
	    key: "setExternalBuffer",
	    value: function setExternalBuffer(buffer, numInstances) {
	      var state = this.userData;

	      if (buffer) {
	        state.isExternalBuffer = true;
	        state.needsUpdate = false;

	        if (_instanceof(buffer, _luma.Buffer)) {
	          if (this.externalBuffer !== buffer) {
	            this.update({
	              isGeneric: false,
	              buffer: buffer
	            });
	            state.needsRedraw = true;
	          }
	        } else {
	          var ArrayType = glArrayFromType(this.type || _luma.GL.FLOAT);

	          if (!_instanceof(buffer, ArrayType)) {
	            throw new Error("Attribute ".concat(this.id, " must be of type ").concat(ArrayType.name));
	          }

	          if (state.auto && buffer.length <= numInstances * this.size) {
	            throw new Error('Attribute prop array must match length and size');
	          }

	          if (this.value !== buffer) {
	            this.update({
	              value: buffer
	            });
	            state.needsRedraw = true;
	          }
	        }
	      } else {
	        state.isExternalBuffer = false;
	      }
	    } // PRIVATE HELPER METHODS

	    /* check user supplied values and apply fallback */

	  }, {
	    key: "_normalizeValue",
	    value: function _normalizeValue(value) {
	      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
	      var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.userData.defaultValue;

	      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {
	        value = [value];
	      }
	      /* eslint-disable no-fallthrough, default-case */


	      switch (size) {
	        case 4:
	          value[3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];

	        case 3:
	          value[2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];

	        case 2:
	          value[1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];

	        case 1:
	          value[0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];
	      }

	      return value;
	    }
	  }, {
	    key: "_areValuesEqual",
	    value: function _areValuesEqual(value1, value2) {
	      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;

	      for (var i = 0; i < size; i++) {
	        if (value1[i] !== value2[i]) {
	          return false;
	        }
	      }

	      return true;
	    }
	  }, {
	    key: "_updateBufferViaStandardAccessor",
	    value: function _updateBufferViaStandardAccessor(data, props) {
	      var state = this.userData;
	      var accessor = state.accessor,
	          defaultValue = state.defaultValue;
	      var value = this.value,
	          size = this.size;
	      var accessorFunc = props[accessor];
	      (0, _assert.default)(typeof accessorFunc === 'function', "accessor \"".concat(accessor, "\" is not a function"));
	      var i = 0;
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var object = _step.value;
	          var objectValue = accessorFunc(object);
	          objectValue = this._normalizeValue(objectValue, size, defaultValue);

	          for (var j = 0; j < size; j++) {
	            value[i++] = objectValue[j];
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      this.update({
	        value: value
	      });
	    } // Validate deck.gl level fields

	  }, {
	    key: "_validateAttributeUpdaters",
	    value: function _validateAttributeUpdaters() {
	      var state = this.userData; // Check that either 'accessor' or 'update' is a valid function

	      var hasUpdater = state.noAlloc || typeof state.update === 'function' || typeof state.accessor === 'string';

	      if (!hasUpdater) {
	        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
	      }
	    }
	  }, {
	    key: "_checkAttributeArray",
	    value: function _checkAttributeArray() {
	      var value = this.value;

	      if (value && value.length >= 4) {
	        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);

	        if (!valid) {
	          throw new Error("Illegal attribute generated for ".concat(this.id));
	        }
	      }
	    }
	  }]);

	  return LayerAttribute;
	}(Attribute);
	/* eslint-disable complexity */


	exports.default = LayerAttribute;

	function glArrayFromType(glType) {
	  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref4$clamped = _ref4.clamped,
	      clamped = _ref4$clamped === void 0 ? true : _ref4$clamped;

	  // Sorted in some order of likelihood to reduce amount of comparisons
	  switch (glType) {
	    case _luma.GL.FLOAT:
	      return Float32Array;

	    case _luma.GL.UNSIGNED_SHORT:
	    case _luma.GL.UNSIGNED_SHORT_5_6_5:
	    case _luma.GL.UNSIGNED_SHORT_4_4_4_4:
	    case _luma.GL.UNSIGNED_SHORT_5_5_5_1:
	      return Uint16Array;

	    case _luma.GL.UNSIGNED_INT:
	      return Uint32Array;

	    case _luma.GL.UNSIGNED_BYTE:
	      return clamped ? Uint8ClampedArray : Uint8Array;

	    case _luma.GL.BYTE:
	      return Int8Array;

	    case _luma.GL.SHORT:
	      return Int16Array;

	    case _luma.GL.INT:
	      return Int32Array;

	    default:
	      throw new Error('Failed to deduce type from array');
	  }
	}
	/* eslint-enable complexity */
	//# sourceMappingURL=attribute.js.map

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _luma = __webpack_require__(46);

	var _attributeTransitionUtils = __webpack_require__(265);

	var _transition = _interopRequireDefault(__webpack_require__(267));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var Transform = _luma.experimental.Transform;

	var noop = function noop() {};

	var AttributeTransitionManager =
	/*#__PURE__*/
	function () {
	  function AttributeTransitionManager(gl, _ref) {
	    var id = _ref.id;

	    _classCallCheck(this, AttributeTransitionManager);

	    this.id = id;
	    this.gl = gl;
	    this.attributeTransitions = {};
	    this.needsRedraw = false;
	    this.transform = null;
	    this.numInstances = 0;

	    if (Transform.isSupported(gl)) {
	      this.isSupported = true;
	    } else {
	      _log.default.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();
	    }
	  }

	  _createClass(AttributeTransitionManager, [{
	    key: "finalize",
	    value: function finalize() {
	      if (this.transform) {
	        this.transform.delete();
	      }

	      for (var attributeName in this.attributeTransitions) {
	        this._removeTransition(attributeName);
	      }
	    }
	    /* Public methods */
	    // Called when attribute manager updates
	    // Check the latest attributes for updates.

	  }, {
	    key: "update",
	    value: function update(_ref2) {
	      var attributes = _ref2.attributes,
	          _ref2$transitions = _ref2.transitions,
	          transitions = _ref2$transitions === void 0 ? {} : _ref2$transitions,
	          numInstances = _ref2.numInstances;
	      this.opts = transitions;
	      this.numInstances = numInstances;

	      if (!this.isSupported) {
	        return;
	      }

	      var attributeTransitions = this.attributeTransitions;
	      var changedTransitions = {};

	      for (var attributeName in attributes) {
	        var hasChanged = this._updateAttribute(attributeName, attributes[attributeName]);

	        if (hasChanged) {
	          changedTransitions[attributeName] = attributeTransitions[attributeName];
	        }
	      }

	      for (var _attributeName in attributeTransitions) {
	        var attribute = attributes[_attributeName];

	        if (!attribute || !attribute.supportsTransition()) {
	          // Animated attribute has been removed
	          this._removeTransition(_attributeName);
	        }
	      }

	      if (!this.transform) {
	        this._createModel();
	      } else if (this.transform) {
	        var _getBuffers = (0, _attributeTransitionUtils.getBuffers)(changedTransitions),
	            sourceBuffers = _getBuffers.sourceBuffers,
	            destinationBuffers = _getBuffers.destinationBuffers;

	        this.transform.update({
	          elementCount: this.numInstances,
	          sourceBuffers: sourceBuffers,
	          destinationBuffers: destinationBuffers
	        });
	      }
	    } // Returns `true` if attribute is transition-enabled

	  }, {
	    key: "hasAttribute",
	    value: function hasAttribute(attributeName) {
	      return attributeName in this.attributeTransitions;
	    } // Get all the animated attributes

	  }, {
	    key: "getAttributes",
	    value: function getAttributes() {
	      var animatedAttributes = {};

	      for (var attributeName in this.attributeTransitions) {
	        var transition = this.attributeTransitions[attributeName];

	        if (transition.buffer) {
	          animatedAttributes[attributeName] = transition.buffer;
	        }
	      }

	      return animatedAttributes;
	    }
	    /* eslint-disable max-statements */
	    // Called every render cycle, run transform feedback
	    // Returns `true` if anything changes

	  }, {
	    key: "setCurrentTime",
	    value: function setCurrentTime(currentTime) {
	      if (!this.transform) {
	        return false;
	      }

	      var uniforms = {};
	      var needsRedraw = this.needsRedraw;
	      this.needsRedraw = false;

	      for (var attributeName in this.attributeTransitions) {
	        var transition = this.attributeTransitions[attributeName];
	        var updated = transition.update(currentTime);

	        if (updated) {
	          uniforms["".concat(attributeName, "Time")] = transition.time;
	          needsRedraw = true;
	        }
	      }

	      if (needsRedraw) {
	        this.transform.run({
	          uniforms: uniforms
	        });
	      }

	      return needsRedraw;
	    }
	    /* eslint-enable max-statements */

	    /* Private methods */

	  }, {
	    key: "_createTransition",
	    value: function _createTransition(attributeName, attribute) {
	      var transition = this.attributeTransitions[attributeName];

	      if (!transition) {
	        transition = new _transition.default({
	          name: attributeName,
	          attribute: attribute
	        });
	        this.attributeTransitions[attributeName] = transition;

	        this._invalidateModel();

	        return transition;
	      }

	      return null;
	    }
	  }, {
	    key: "_removeTransition",
	    value: function _removeTransition(attributeName) {
	      var transition = this.attributeTransitions[attributeName];

	      if (transition) {
	        if (transition.buffer) {
	          transition.buffer.delete();
	        }

	        if (transition._swapBuffer) {
	          transition._swapBuffer.delete();
	        }

	        delete this.attributeTransitions[attributeName];

	        this._invalidateModel();
	      }
	    } // Check an attributes for updates
	    // Returns a transition object if a new transition is triggered.

	  }, {
	    key: "_updateAttribute",
	    value: function _updateAttribute(attributeName, attribute) {
	      var settings = this._getTransitionSettings(attribute);

	      if (settings) {
	        var hasChanged;
	        var transition = this.attributeTransitions[attributeName];

	        if (transition) {
	          hasChanged = attribute.needsRedraw();
	        } else {
	          // New animated attributes have been added
	          transition = this._createTransition(attributeName, attribute);
	          hasChanged = true;
	        }

	        if (hasChanged) {
	          this._triggerTransition(transition, settings);

	          return true;
	        }
	      }

	      return false;
	    } // Invalidates the current model

	  }, {
	    key: "_invalidateModel",
	    value: function _invalidateModel() {
	      if (this.transform) {
	        this.transform.delete();
	        this.transform = null;
	      }
	    } // Create a model for the transform feedback

	  }, {
	    key: "_createModel",
	    value: function _createModel() {
	      if (Object.keys(this.attributeTransitions).length === 0) {
	        // no transitions
	        return;
	      }

	      this.transform = new Transform(this.gl, Object.assign({
	        elementCount: this.numInstances
	      }, (0, _attributeTransitionUtils.getBuffers)(this.attributeTransitions), (0, _attributeTransitionUtils.getShaders)(this.attributeTransitions)));
	    } // get current values of an attribute, clipped/padded to the size of the new buffer

	  }, {
	    key: "_getNextTransitionStates",
	    value: function _getNextTransitionStates(transition) {
	      var attribute = transition.attribute;
	      var size = attribute.size;
	      var toState;

	      if (attribute.isGeneric) {
	        toState = {
	          isGeneric: true,
	          value: attribute.value,
	          size: size
	        };
	      } else {
	        toState = {
	          isGeneric: false,
	          buffer: attribute.getBuffer(),
	          size: size
	        };
	      }

	      var fromState = transition.buffer || toState;
	      var toLength = this.numInstances * size;
	      var fromLength = fromState.data && fromState.data.length || toLength; // Alternate between two buffers when new transitions start.
	      // Last destination buffer is used as an attribute (from state),
	      // And the other buffer is now the destination buffer.

	      var buffer = transition._swapBuffer;
	      transition._swapBuffer = transition.buffer;

	      if (!buffer) {
	        buffer = new _luma.Buffer(this.gl, {
	          size: size,
	          data: new Float32Array(toLength),
	          usage: _luma.GL.DYNAMIC_COPY
	        });
	      } // Pad buffers to be the same length


	      if (buffer.data.length < toLength) {
	        buffer.setData({
	          data: new Float32Array(toLength)
	        });
	      }

	      (0, _attributeTransitionUtils.padBuffer)({
	        fromState: fromState,
	        toState: toState,
	        fromLength: fromLength,
	        toLength: toLength
	      });
	      return {
	        fromState: fromState,
	        toState: toState,
	        buffer: buffer
	      };
	    } // Returns transition settings object if transition is enabled, otherwise `null`

	  }, {
	    key: "_getTransitionSettings",
	    value: function _getTransitionSettings(attribute) {
	      var opts = this.opts;
	      var _attribute$userData = attribute.userData,
	          transition = _attribute$userData.transition,
	          accessor = _attribute$userData.accessor;

	      if (!transition) {
	        return null;
	      }

	      return Array.isArray(accessor) ? accessor.map(function (a) {
	        return opts[a];
	      }).find(Boolean) : opts[accessor];
	    } // Normalizes transition settings object, merge with default settings

	  }, {
	    key: "_normalizeTransitionSettings",
	    value: function _normalizeTransitionSettings(settings) {
	      // Shorthand: use duration instead of parameter object
	      if (Number.isFinite(settings)) {
	        settings = {
	          duration: settings
	        };
	      } // Check if settings is valid


	      (0, _assert.default)(settings && settings.duration > 0);
	      return {
	        duration: settings.duration,
	        easing: settings.easing || function (t) {
	          return t;
	        },
	        onStart: settings.onStart || noop,
	        onEnd: settings.onEnd || noop,
	        onInterrupt: settings.onInterrupt || noop
	      };
	    } // Start a new transition using the current settings
	    // Updates transition state and from/to buffer

	  }, {
	    key: "_triggerTransition",
	    value: function _triggerTransition(transition, settings) {
	      this.needsRedraw = true;

	      var transitionSettings = this._normalizeTransitionSettings(settings); // Attribute descriptor to transition from


	      transition.start(Object.assign({}, this._getNextTransitionStates(transition), transitionSettings));
	    }
	  }]);

	  return AttributeTransitionManager;
	}();

	exports.default = AttributeTransitionManager;
	//# sourceMappingURL=attribute-transition-manager.js.map

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.getShaders = getShaders;
	exports.getBuffers = getBuffers;
	exports.padBuffer = padBuffer;

	var _luma = __webpack_require__(46);

	var _flatten = __webpack_require__(266);

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	var ATTRIBUTE_MAPPING = {
	  1: 'float',
	  2: 'vec2',
	  3: 'vec3',
	  4: 'vec4'
	};

	function getShaders(transitions) {
	  // Build shaders
	  var varyings = [];
	  var attributeDeclarations = [];
	  var uniformsDeclarations = [];
	  var varyingDeclarations = [];
	  var calculations = [];

	  for (var attributeName in transitions) {
	    var transition = transitions[attributeName];
	    var attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];

	    if (attributeType) {
	      transition.bufferIndex = varyings.length;
	      varyings.push(attributeName);
	      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "From;"));
	      attributeDeclarations.push("attribute ".concat(attributeType, " ").concat(attributeName, "To;"));
	      uniformsDeclarations.push("uniform float ".concat(attributeName, "Time;"));
	      varyingDeclarations.push("varying ".concat(attributeType, " ").concat(attributeName, ";"));
	      calculations.push("".concat(attributeName, " = mix(").concat(attributeName, "From, ").concat(attributeName, "To,\n        ").concat(attributeName, "Time);"));
	    }
	  }

	  var vs = "\n#define SHADER_NAME feedback-vertex-shader\n".concat(attributeDeclarations.join('\n'), "\n").concat(uniformsDeclarations.join('\n'), "\n").concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  ").concat(calculations.join('\n'), "\n  gl_Position = vec4(0.0);\n}\n");
	  var fs = "#define SHADER_NAME feedback-fragment-shader\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n".concat(varyingDeclarations.join('\n'), "\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n");
	  return {
	    vs: vs,
	    fs: fs,
	    varyings: varyings
	  };
	}

	function getBuffers(transitions) {
	  var sourceBuffers = {};
	  var destinationBuffers = {};

	  for (var attributeName in transitions) {
	    var _transitions$attribut = transitions[attributeName],
	        fromState = _transitions$attribut.fromState,
	        toState = _transitions$attribut.toState,
	        buffer = _transitions$attribut.buffer;
	    sourceBuffers["".concat(attributeName, "From")] = fromState;
	    sourceBuffers["".concat(attributeName, "To")] = toState;
	    destinationBuffers["".concat(attributeName)] = buffer;
	  }

	  return {
	    sourceBuffers: sourceBuffers,
	    destinationBuffers: destinationBuffers
	  };
	}

	function padBuffer(_ref) {
	  var fromState = _ref.fromState,
	      toState = _ref.toState,
	      fromLength = _ref.fromLength,
	      toLength = _ref.toLength;

	  // check if buffer needs to be padded
	  if (fromLength >= toLength || !_instanceof(fromState, _luma.Buffer)) {
	    return;
	  }

	  var data = new Float32Array(toLength); // copy the currect values

	  data.set(fromState.getData({}));

	  if (toState.isGeneric) {
	    (0, _flatten.fillArray)({
	      target: data,
	      source: toState.value,
	      start: fromLength,
	      count: (toLength - fromLength) / toState.size
	    });
	  } else {
	    data.set(toState.buffer.data.subarray(fromLength), fromLength);
	  }

	  fromState.setData({
	    data: data
	  });
	}
	//# sourceMappingURL=attribute-transition-utils.js.map

/***/ }),
/* 266 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.flatten = flatten;
	exports.countVertices = countVertices;
	exports.flattenVertices = flattenVertices;
	exports.fillArray = fillArray;

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	/**
	 * Flattens a nested array into a single level array,
	 * or a single value into an array with one value
	 * @example flatten([[1, [2]], [3], 4]) => [1, 2, 3, 4]
	 * @example flatten(1) => [1]
	 * @param {Array} array The array to flatten.
	 * @param {Function} filter= - Optional predicate called on each `value` to
	 *   determine if it should be included (pushed onto) the resulting array.
	 * @param {Function} map= - Optional transform applied to each array elements.
	 * @param {Array} result=[] - Optional array to push value into
	 * @return {Array} Returns the new flattened array (new array or `result` if provided)
	 */
	function flatten(array) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref$filter = _ref.filter,
	      filter = _ref$filter === void 0 ? function () {
	    return true;
	  } : _ref$filter,
	      _ref$map = _ref.map,
	      map = _ref$map === void 0 ? function (x) {
	    return x;
	  } : _ref$map,
	      _ref$result = _ref.result,
	      result = _ref$result === void 0 ? [] : _ref$result;

	  // Wrap single object in array
	  if (!Array.isArray(array)) {
	    return filter(array) ? [map(array)] : [];
	  } // Deep flatten and filter the array


	  return flattenArray(array, filter, map, result);
	} // Deep flattens an array. Helper to `flatten`, see its parameters


	function flattenArray(array, filter, map, result) {
	  var index = -1;

	  while (++index < array.length) {
	    var value = array[index];

	    if (Array.isArray(value)) {
	      flattenArray(value, filter, map, result);
	    } else if (filter(value)) {
	      result.push(map(value));
	    }
	  }

	  return result;
	}

	function countVertices(nestedArray) {
	  var count = 0;
	  var index = -1;

	  while (++index < nestedArray.length) {
	    var value = nestedArray[index];

	    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
	      count += countVertices(value);
	    } else {
	      count++;
	    }
	  }

	  return count;
	} // Flattens nested array of vertices, padding third coordinate as needed


	function flattenVertices(nestedArray) {
	  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      _ref2$result = _ref2.result,
	      result = _ref2$result === void 0 ? [] : _ref2$result,
	      _ref2$dimensions = _ref2.dimensions,
	      dimensions = _ref2$dimensions === void 0 ? 3 : _ref2$dimensions;

	  var index = -1;
	  var vertexLength = 0;

	  while (++index < nestedArray.length) {
	    var value = nestedArray[index];

	    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
	      flattenVertices(value, {
	        result: result,
	        dimensions: dimensions
	      });
	    } else {
	      // eslint-disable-next-line
	      if (vertexLength < dimensions) {
	        result.push(value);
	        vertexLength++;
	      }
	    }
	  } // Add a third coordinate if needed


	  if (vertexLength > 0 && vertexLength < dimensions) {
	    result.push(0);
	  }

	  return result;
	} // Uses copyWithin to significantly speed up typed array value filling


	function fillArray(_ref3) {
	  var target = _ref3.target,
	      source = _ref3.source,
	      _ref3$start = _ref3.start,
	      start = _ref3$start === void 0 ? 0 : _ref3$start,
	      _ref3$count = _ref3.count,
	      count = _ref3$count === void 0 ? 1 : _ref3$count;
	  var length = source.length;
	  var total = count * length;
	  var copied = 0;

	  for (var i = start; copied < length; copied++) {
	    target[i++] = source[copied];
	  }

	  while (copied < total) {
	    // If we have copied less than half, copy everything we got
	    // else copy remaining in one operation
	    if (copied < total - copied) {
	      target.copyWithin(start + copied, start, start + copied);
	      copied *= 2;
	    } else {
	      target.copyWithin(start + copied, start, start + total - copied);
	      copied = total;
	    }
	  }

	  return target;
	} // Flattens nested array of vertices, padding third coordinate as needed

	/*
	export function flattenTypedVertices(nestedArray, {
	  result = [],
	  Type = Float32Array,
	  start = 0,
	  dimensions = 3
	} = {}) {
	  let index = -1;
	  let vertexLength = 0;
	  while (++index < nestedArray.length) {
	    const value = nestedArray[index];
	    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
	      start = flattenTypedVertices(value, {result, start, dimensions});
	    } else {
	      if (vertexLength < dimensions) { // eslint-disable-line
	        result[start++] = value;
	        vertexLength++;
	      }
	    }
	  }
	  // Add a third coordinate if needed
	  if (vertexLength > 0 && vertexLength < dimensions) {
	    result[start++] = 0;
	  }
	  return start;
	}
	*/
	//# sourceMappingURL=flatten.js.map

/***/ }),
/* 267 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.TRANSITION_STATE = void 0;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var TRANSITION_STATE = {
	  NONE: 'none',
	  PENDING: 'pending',
	  IN_PROGRESS: 'in_progress',
	  ENDED: 'ended'
	};
	exports.TRANSITION_STATE = TRANSITION_STATE;

	function noop() {}

	var Transition =
	/*#__PURE__*/
	function () {
	  /**
	   * @params props {object} - properties of the transition.
	   *
	   * @params props.duration {number} - total time to complete the transition
	   * @params props.easing {func} - easing function
	   * @params props.onStart {func} - callback when transition starts
	   * @params props.onUpdate {func} - callback when transition updates
	   * @params props.onInterrupt {func} - callback when transition is interrupted
	   * @params props.onEnd {func} - callback when transition ends
	   *
	   * Any additional properties are also saved on the instance but have no effect.
	   */
	  function Transition(props) {
	    _classCallCheck(this, Transition);

	    this._startTime = null;
	    this._state = TRANSITION_STATE.NONE; // Defaults

	    this.duration = 1;

	    this.easing = function (t) {
	      return t;
	    };

	    this.onStart = noop;
	    this.onUpdate = noop;
	    this.onInterrupt = noop;
	    this.onEnd = noop;
	    Object.assign(this, props);
	  }
	  /* Public API */


	  _createClass(Transition, [{
	    key: "start",

	    /**
	     * (re)start this transition.
	     * @params props {object} - optional overriding props. see constructor
	     */
	    value: function start(props) {
	      if (this.inProgress) {
	        this.onInterrupt(this);
	      }

	      Object.assign(this, props);

	      this._setState(TRANSITION_STATE.PENDING);
	    }
	    /**
	     * cancel this transition if it is in progress.
	     */

	  }, {
	    key: "cancel",
	    value: function cancel() {
	      if (this.inProgress) {
	        this.onInterrupt(this);

	        this._setState(TRANSITION_STATE.NONE);
	      }
	    }
	    /**
	     * update this transition.
	     * @params currentTime {number} - timestamp of the update. should be in the same unit as `duration`.
	     */

	  }, {
	    key: "update",
	    value: function update(currentTime) {
	      if (this.state === TRANSITION_STATE.PENDING) {
	        this._startTime = currentTime;

	        this._setState(TRANSITION_STATE.IN_PROGRESS);
	      }

	      if (this.state === TRANSITION_STATE.IN_PROGRESS) {
	        var shouldEnd = false;
	        var time = (currentTime - this._startTime) / this.duration;

	        if (time >= 1) {
	          time = 1;
	          shouldEnd = true;
	        }

	        this.time = this.easing(time);
	        this.onUpdate(this);

	        if (shouldEnd) {
	          this._setState(TRANSITION_STATE.ENDED);
	        }

	        return true;
	      }

	      return false;
	    }
	    /* Private API */

	  }, {
	    key: "_setState",
	    value: function _setState(newState) {
	      if (this._state === newState) {
	        return;
	      }

	      this._state = newState;

	      switch (newState) {
	        case TRANSITION_STATE.PENDING:
	          this.onStart(this);
	          break;

	        case TRANSITION_STATE.ENDED:
	          this.onEnd(this);
	          break;

	        default:
	      }
	    }
	  }, {
	    key: "state",
	    get: function get() {
	      return this._state;
	    }
	  }, {
	    key: "inProgress",
	    get: function get() {
	      return this._state === TRANSITION_STATE.PENDING || this._state === TRANSITION_STATE.IN_PROGRESS;
	    }
	  }]);

	  return Transition;
	}();

	exports.default = Transition;
	//# sourceMappingURL=transition.js.map

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.removeLayerInSeer = exports.updateLayerInSeer = exports.initLayerInSeer = exports.seerInitListener = exports.layerEditListener = exports.applyPropOverrides = exports.setPropOverrides = void 0;

	var _seer = _interopRequireDefault(__webpack_require__(189));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	/**
	 * Recursively set a nested property of an object given a properties array and a value
	 */
	var recursiveSet = function recursiveSet(obj, path, value) {
	  if (!obj) {
	    return;
	  }

	  if (path.length > 1) {
	    recursiveSet(obj[path[0]], path.slice(1), value);
	  } else {
	    obj[path[0]] = value;
	  }
	};

	var overrides = new Map();
	/**
	 * Create an override on the specify layer, indexed by a valuePath array.
	 * Do nothing in case Seer as not been initialized to prevent any preformance drawback.
	 */

	var setPropOverrides = function setPropOverrides(id, valuePath, value) {
	  if (!_seer.default.isReady()) {
	    return;
	  }

	  if (!overrides.has(id)) {
	    overrides.set(id, new Map());
	  }

	  var props = overrides.get(id);
	  props.set(valuePath, value);
	};
	/**
	 * Get the props overrides of a specific layer if Seer as been initialized
	 * Invalidates the data to be sure new ones are always picked up.
	 */


	exports.setPropOverrides = setPropOverrides;

	var applyPropOverrides = function applyPropOverrides(props) {
	  if (!_seer.default.isReady() || !props.id) {
	    return;
	  }

	  var overs = overrides.get(props.id);

	  if (!overs) {
	    return;
	  }

	  overs.forEach(function (value, valuePath) {
	    recursiveSet(props, valuePath, value); // Invalidate data array if we have a data override

	    if (valuePath[0] === 'data') {
	      props.data = _toConsumableArray(props.data);
	    }
	  });
	};
	/**
	 * Listen for deck.gl edit events
	 */


	exports.applyPropOverrides = applyPropOverrides;

	var layerEditListener = function layerEditListener(cb) {
	  if (!_seer.default.isReady()) {
	    return;
	  }

	  _seer.default.listenFor('deck.gl', cb);
	};
	/**
	 * Listen for seer init events to resend data
	 */


	exports.layerEditListener = layerEditListener;

	var seerInitListener = function seerInitListener(cb) {
	  if (!_seer.default.isReady()) {
	    return;
	  }

	  _seer.default.listenFor('init', cb);
	};

	exports.seerInitListener = seerInitListener;

	var initLayerInSeer = function initLayerInSeer(layer) {
	  if (!_seer.default.isReady() || !layer) {
	    return;
	  }

	  var badges = [layer.constructor.layerName];

	  _seer.default.listItem('deck.gl', layer.id, {
	    badges: badges,
	    // TODO: Seer currently only handles single model layers
	    links: layer.state && layer.state.model ? ["luma.gl:".concat(layer.state.model.id)] : undefined,
	    parent: layer.parent ? layer.parent.id : undefined
	  });
	};
	/**
	 * Log layer's properties to Seer
	 */


	exports.initLayerInSeer = initLayerInSeer;

	var updateLayerInSeer = function updateLayerInSeer(layer) {
	  if (!_seer.default.isReady() || _seer.default.throttle("deck.gl:".concat(layer.id), 1e3)) {
	    return;
	  }

	  var data = logPayload(layer);

	  _seer.default.multiUpdate('deck.gl', layer.id, data);
	};
	/**
	 * On finalize of a specify layer, remove it from seer
	 */


	exports.updateLayerInSeer = updateLayerInSeer;

	var removeLayerInSeer = function removeLayerInSeer(id) {
	  if (!_seer.default.isReady() || !id) {
	    return;
	  }

	  _seer.default.deleteItem('deck.gl', id);
	};

	exports.removeLayerInSeer = removeLayerInSeer;

	function logPayload(layer) {
	  var data = [{
	    path: 'objects.props',
	    data: layer.props
	  }];
	  var badges = [layer.constructor.layerName];

	  if (layer.state) {
	    if (layer.getAttributeManager()) {
	      var attrs = layer.getAttributeManager().getAttributes();
	      data.push({
	        path: 'objects.attributes',
	        data: attrs
	      });
	      badges.push(layer.getAttributeManager().stats.getTimeString());
	    } // TODO: Seer currently only handles single model layers


	    if (layer.state.model) {
	      layer.state.model.timerQueryEnabled = true;
	      var lastFrameTime = layer.state.model.stats.lastFrameTime;

	      if (lastFrameTime) {
	        badges.push("".concat((lastFrameTime * 1000).toFixed(0), "\u03BCs"));
	      }
	    }
	  }

	  data.push({
	    path: 'badges',
	    data: badges
	  });
	  return data;
	}
	//# sourceMappingURL=seer-integration.js.map

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.diffProps = diffProps;
	exports.compareProps = compareProps;

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	// Returns an object with "change flags", either false or strings indicating reason for change
	function diffProps(props, oldProps) {
	  // First check if any props have changed (ignore props that will be examined separately)
	  var propsChangedReason = compareProps({
	    newProps: props,
	    oldProps: oldProps,
	    ignoreProps: {
	      data: null,
	      updateTriggers: null
	    }
	  }); // Now check if any data related props have changed

	  var dataChangedReason = diffDataProps(props, oldProps); // Check update triggers to determine if any attributes need regeneration
	  // Note - if data has changed, all attributes will need regeneration, so skip this step

	  var updateTriggersChangedReason = false;

	  if (!dataChangedReason) {
	    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
	  }

	  return {
	    dataChanged: dataChangedReason,
	    propsChanged: propsChangedReason,
	    updateTriggersChanged: updateTriggersChangedReason
	  };
	}
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * @param {Object} opt.oldProps - object with old key/value pairs
	 * @param {Object} opt.newProps - object with new key/value pairs
	 * @param {Object} opt.ignoreProps={} - object, keys that should not be compared
	 * @returns {null|String} - null when values of all keys are strictly equal.
	 *   if unequal, returns a string explaining what changed.
	 */

	/* eslint-disable max-statements, max-depth, complexity */


	function compareProps() {
	  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	      newProps = _ref.newProps,
	      oldProps = _ref.oldProps,
	      _ref$ignoreProps = _ref.ignoreProps,
	      ignoreProps = _ref$ignoreProps === void 0 ? {} : _ref$ignoreProps,
	      _ref$shallowComparePr = _ref.shallowCompareProps,
	      shallowCompareProps = _ref$shallowComparePr === void 0 ? {} : _ref$shallowComparePr,
	      _ref$triggerName = _ref.triggerName,
	      triggerName = _ref$triggerName === void 0 ? 'props' : _ref$triggerName;

	  (0, _assert.default)(oldProps !== undefined && newProps !== undefined, 'compareProps args'); // shallow equality => deep equality

	  if (oldProps === newProps) {
	    return null;
	  } // TODO - do we need these checks? Should never happen...


	  if (_typeof(newProps) !== 'object' || newProps === null) {
	    return "".concat(triggerName, " changed shallowly");
	  }

	  if (_typeof(oldProps) !== 'object' || oldProps === null) {
	    return "".concat(triggerName, " changed shallowly");
	  } // Test if new props different from old props


	  for (var key in oldProps) {
	    if (!(key in ignoreProps)) {
	      if (!(key in newProps)) {
	        return "".concat(triggerName, ".").concat(key, " dropped: ").concat(oldProps[key], " -> undefined");
	      } // If object has an equals function, invoke it


	      var equals = newProps[key] && oldProps[key] && newProps[key].equals;

	      if (equals && !equals.call(newProps[key], oldProps[key])) {
	        return "".concat(triggerName, ".").concat(key, " changed deeply: ").concat(oldProps[key], " -> ").concat(newProps[key]);
	      } // If both new and old value are functions, ignore differences


	      if (key in shallowCompareProps) {
	        var type = _typeof(newProps[key]);

	        if (type === 'function' && typeof oldProps[key] === 'function') {
	          equals = true;
	        }
	      }

	      if (!equals && oldProps[key] !== newProps[key]) {
	        return "".concat(triggerName, ".").concat(key, " changed shallowly: ").concat(oldProps[key], " -> ").concat(newProps[key]);
	      }
	    }
	  } // Test if any new props have been added


	  for (var _key in newProps) {
	    if (!(_key in ignoreProps)) {
	      if (!(_key in oldProps)) {
	        return "".concat(triggerName, ".").concat(_key, " added: undefined -> ").concat(newProps[_key]);
	      }
	    }
	  }

	  return null;
	}
	/* eslint-enable max-statements, max-depth, complexity */
	// HELPERS
	// The comparison of the data prop requires special handling
	// the dataComparator should be used if supplied


	function diffDataProps(props, oldProps) {
	  if (oldProps === null) {
	    return 'oldProps is null, initial diff';
	  } // Support optional app defined comparison of data


	  var dataComparator = props.dataComparator;

	  if (dataComparator) {
	    if (!dataComparator(props.data, oldProps.data)) {
	      return 'Data comparator detected a change';
	    } // Otherwise, do a shallow equal on props

	  } else if (props.data !== oldProps.data) {
	    return 'A new data container was supplied';
	  }

	  return null;
	} // Checks if any update triggers have changed
	// also calls callback to invalidate attributes accordingly.


	function diffUpdateTriggers(props, oldProps) {
	  if (oldProps === null) {
	    return 'oldProps is null, initial diff';
	  } // If the 'all' updateTrigger fires, ignore testing others


	  if ('all' in props.updateTriggers) {
	    var diffReason = diffUpdateTrigger(oldProps, props, 'all');

	    if (diffReason) {
	      return {
	        all: true
	      };
	    }
	  }

	  var triggerChanged = {};
	  var reason = false; // If the 'all' updateTrigger didn't fire, need to check all others

	  for (var triggerName in props.updateTriggers) {
	    if (triggerName !== 'all') {
	      var _diffReason = diffUpdateTrigger(oldProps, props, triggerName);

	      if (_diffReason) {
	        triggerChanged[triggerName] = true;
	        reason = triggerChanged;
	      }
	    }
	  }

	  return reason;
	}

	function diffUpdateTrigger(props, oldProps, triggerName) {
	  var newTriggers = props.updateTriggers[triggerName] || {};
	  var oldTriggers = oldProps.updateTriggers[triggerName] || {};
	  var diffReason = compareProps({
	    oldProps: oldTriggers,
	    newProps: newTriggers,
	    triggerName: triggerName
	  });
	  return diffReason;
	}
	//# sourceMappingURL=props.js.map

/***/ }),
/* 270 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.count = count;

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var ERR_NOT_OBJECT = 'count(): argument not an object';
	var ERR_NOT_CONTAINER = 'count(): argument not a container';
	/**
	 * Deduces numer of elements in a JavaScript container.
	 * - Auto-deduction for ES6 containers that define a count() method
	 * - Auto-deduction for ES6 containers that define a size member
	 * - Auto-deduction for Classic Arrays via the built-in length attribute
	 * - Also handles objects, although note that this an O(N) operation
	 */

	function count(container) {
	  if (!isObject(container)) {
	    throw new Error(ERR_NOT_OBJECT);
	  } // Check if ES6 collection "count" function is available


	  if (typeof container.count === 'function') {
	    return container.count();
	  } // Check if ES6 collection "size" attribute is set


	  if (Number.isFinite(container.size)) {
	    return container.size;
	  } // Check if array length attribute is set
	  // Note: checking this last since some ES6 collections (Immutable.js)
	  // emit profuse warnings when trying to access `length` attribute


	  if (Number.isFinite(container.length)) {
	    return container.length;
	  } // Note that getting the count of an object is O(N)


	  if (isPlainObject(container)) {
	    return Object.keys(container).length;
	  }

	  throw new Error(ERR_NOT_CONTAINER);
	}
	/**
	 * Checks if argument is a plain object (not a class or array etc)
	 * @param {*} value - JavaScript value to be tested
	 * @return {Boolean} - true if argument is a plain JavaScript object
	 */


	function isPlainObject(value) {
	  return value !== null && _typeof(value) === 'object' && value.constructor === Object;
	}
	/**
	 * Checks if argument is an indexable object (not a primitive value, nor null)
	 * @param {*} value - JavaScript value to be tested
	 * @return {Boolean} - true if argument is a JavaScript object
	 */


	function isObject(value) {
	  return value !== null && _typeof(value) === 'object';
	}
	//# sourceMappingURL=count.js.map

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _constants = __webpack_require__(272);

	var _createProps = __webpack_require__(273);

	var _componentState = _interopRequireDefault(__webpack_require__(275));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var defaultProps = {};
	var counter = 0;

	var Component =
	/*#__PURE__*/
	function () {
	  function Component()
	  /* ...propObjects */
	  {
	    _classCallCheck(this, Component);

	    // Merge supplied props with default props and freeze them.

	    /* eslint-disable prefer-spread */
	    this.props = _createProps.createProps.apply(this, arguments);
	    /* eslint-enable prefer-spread */
	    // Define all members before layer is sealed

	    this.id = this.props.id; // The layer's id, used for matching with layers from last render cycle

	    this.count = counter++; // Keep track of how many layer instances you are generating

	    this.lifecycle = _constants.LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers

	    this.parent = null; // reference to the composite layer parent that rendered this layer

	    this.context = null; // Will reference layer manager's context, contains state shared by layers

	    this.state = null; // Will be set to the shared layer state object during layer matching

	    this.internalState = null; // Seal the layer

	    Object.seal(this);
	  } // clone this layer with modified props


	  _createClass(Component, [{
	    key: "clone",
	    value: function clone(newProps) {
	      return new this.constructor(Object.assign({}, this.props, newProps));
	    }
	  }, {
	    key: "_initState",
	    // PROTECTED METHODS, override in subclass
	    value: function _initState() {
	      this.internalState = new _componentState.default({});
	    }
	  }, {
	    key: "stats",
	    get: function get() {
	      return this.internalState.stats;
	    }
	  }]);

	  return Component;
	}();

	exports.default = Component;
	Component.defaultProps = defaultProps;
	//# sourceMappingURL=component.js.map

/***/ }),
/* 272 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.LIFECYCLE = void 0;
	var LIFECYCLE = {
	  NO_STATE: 'Awaiting state',
	  MATCHED: 'Matched. State transferred from previous layer',
	  INITIALIZED: 'Initialized',
	  AWAITING_GC: 'Discarded. Awaiting garbage collection',
	  AWAITING_FINALIZATION: 'No longer matched. Awaiting garbage collection',
	  FINALIZED: 'Finalized! Awaiting garbage collection'
	};
	exports.LIFECYCLE = LIFECYCLE;
	//# sourceMappingURL=constants.js.map

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.createProps = createProps;

	var _seerIntegration = __webpack_require__(268);

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _propTypes = __webpack_require__(274);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	// Create a property object
	function createProps() {
	  var component = this; // eslint-disable-line
	  // Get default prop object (a prototype chain for now)

	  var propsPrototype = getPropsPrototypeAndTypes(component.constructor).defaultProps; // Create a new prop object with default props object in prototype chain

	  var propsInstance = Object.create(propsPrototype, {
	    // Props need a back pointer to the owning component
	    _component: {
	      enumerable: false,
	      value: component
	    },
	    // The supplied (original) values for those async props that are set to url strings or Promises.
	    // In this case, the actual (i.e. resolved) values are looked up from component.internalState
	    _asyncPropOriginalValues: {
	      enumerable: false,
	      value: {}
	    },
	    // Note: the actual (resolved) values for props that are NOT set to urls or Promises.
	    // in this case the values are served directly from this map
	    _asyncPropResolvedValues: {
	      enumerable: false,
	      value: {}
	    }
	  }); // "Copy" all sync props

	  for (var i = 0; i < arguments.length; ++i) {
	    Object.assign(propsInstance, arguments[i]);
	  } // SEER: Apply any overrides from the seer debug extension if it is active


	  (0, _seerIntegration.applyPropOverrides)(propsInstance); // Props must be immutable

	  Object.freeze(propsInstance);
	  return propsInstance;
	} // Return precalculated defaultProps and propType objects if available
	// build them if needed


	function getPropsPrototypeAndTypes(componentClass) {
	  var props = getOwnProperty(componentClass, '_mergedDefaultProps');

	  if (props) {
	    return {
	      defaultProps: props,
	      propTypes: getOwnProperty(componentClass, '_propTypes')
	    };
	  }

	  return createPropsPrototypeAndTypes(componentClass);
	} // Build defaultProps and propType objects by walking component prototype chain


	function createPropsPrototypeAndTypes(componentClass) {
	  var parent = componentClass.prototype;

	  if (!parent) {
	    return {
	      defaultProps: {}
	    };
	  }

	  var parentClass = Object.getPrototypeOf(componentClass);
	  var parentPropDefs = parent && getPropsPrototypeAndTypes(parentClass) || null; // Parse propTypes from Component.defaultProps

	  var componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};
	  var componentPropDefs = (0, _propTypes.parsePropTypes)(componentDefaultProps); // Create a merged type object

	  var propTypes = Object.assign({}, parentPropDefs && parentPropDefs.propTypes, componentPropDefs.propTypes); // Create any necessary property descriptors and create the default prop object
	  // Assign merged default props

	  var defaultProps = createPropsPrototype(componentPropDefs.defaultProps, parentPropDefs && parentPropDefs.defaultProps, propTypes, componentClass); // Store the precalculated props

	  componentClass._mergedDefaultProps = defaultProps;
	  componentClass._propTypes = propTypes;
	  return {
	    propTypes: propTypes,
	    defaultProps: defaultProps
	  };
	} // Builds a pre-merged default props object that component props can inherit from


	function createPropsPrototype(props, parentProps, propTypes, componentClass) {
	  var defaultProps = Object.create(null);
	  Object.assign(defaultProps, parentProps, props); // Avoid freezing `id` prop

	  var id = getComponentName(componentClass);
	  delete props.id; // Add getters/setters for async prop properties

	  Object.defineProperties(defaultProps, {
	    // `id` is treated specially because layer might need to override it
	    id: {
	      configurable: false,
	      writable: true,
	      value: id
	    }
	  }); // Add getters/setters for async prop properties

	  addAsyncPropsToPropPrototype(defaultProps, propTypes);
	  return defaultProps;
	} // Create descriptors for overridable props


	function addAsyncPropsToPropPrototype(defaultProps, propTypes) {
	  var defaultValues = {};
	  var descriptors = {
	    // Default "resolved" values for async props, returned if value not yet resolved/set.
	    _asyncPropDefaultValues: {
	      enumerable: false,
	      value: defaultValues
	    },
	    // Shadowed object, just to make sure "early indexing" into the instance does not fail
	    _asyncPropOriginalValues: {
	      enumerable: false,
	      value: {}
	    }
	  }; // Move async props into shadow values

	  for (var propName in propTypes) {
	    var propType = propTypes[propName];
	    var name = propType.name,
	        value = propType.value; // Note: async is ES7 keyword, can't destructure

	    if (propType.async) {
	      defaultValues[name] = value;
	      descriptors[name] = getDescriptorForAsyncProp(name, value);
	    }
	  }

	  Object.defineProperties(defaultProps, descriptors);
	} // Helper: Configures getter and setter for one async prop


	function getDescriptorForAsyncProp(name) {
	  return {
	    configurable: false,
	    enumerable: true,
	    // Save the provided value for async props in a special map
	    set: function set(newValue) {
	      if (typeof newValue === 'string' || _instanceof(newValue, Promise)) {
	        this._asyncPropOriginalValues[name] = newValue;
	      } else {
	        this._asyncPropResolvedValues[name] = newValue;
	      }
	    },
	    // Only the component's state knows the true value of async prop
	    get: function get() {
	      if (this._asyncPropResolvedValues) {
	        // Prop value isn't async, so just return it
	        if (name in this._asyncPropResolvedValues) {
	          var value = this._asyncPropResolvedValues[name]; // Special handling - components expect null `data` prop expects to be replaced with `[]`

	          if (name === 'data') {
	            return value || this._asyncPropDefaultValues[name];
	          }

	          return value;
	        } // It's an async prop value: look into component state


	        var state = this._component && this._component.internalState;

	        if (state && state.hasAsyncProp(name)) {
	          return state.getAsyncProp(name);
	        }
	      } // component not yet initialized/matched, return the component's default value for the prop


	      return this._asyncPropDefaultValues[name];
	    }
	  };
	} // HELPER METHODS
	// Constructors have their super class constructors as prototypes


	function getOwnProperty(object, prop) {
	  return Object.prototype.hasOwnProperty.call(object, prop) && object[prop];
	}

	function getComponentName(componentClass) {
	  var componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');

	  if (!componentName) {
	    _log.default.once(0, "".concat(componentClass.name, ".componentName not specified"));
	  }

	  return componentName || componentClass.name;
	}
	//# sourceMappingURL=create-props.js.map

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parsePropTypes = parsePropTypes;

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	var TYPE_DEFINITIONS = {
	  boolean: {
	    validate: function validate(value, propType) {
	      return true;
	    }
	  },
	  number: {
	    validateType: function validateType(value, propType) {
	      return 'value' in propType && (!('max' in propType) || Number.isFinite(propType.max)) && (!('min' in propType) || Number.isFinite(propType.min));
	    },
	    validate: function validate(value, propType) {
	      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);
	    }
	  }
	};

	function parsePropTypes(propDefs) {
	  var propTypes = {};
	  var defaultProps = {};

	  var _arr = Object.entries(propDefs);

	  for (var _i = 0; _i < _arr.length; _i++) {
	    var _arr$_i = _slicedToArray(_arr[_i], 2),
	        propName = _arr$_i[0],
	        propDef = _arr$_i[1];

	    var propType = parsePropType(propName, propDef);
	    propTypes[propName] = propType;
	    defaultProps[propName] = propType.value;
	  }

	  return {
	    propTypes: propTypes,
	    defaultProps: defaultProps
	  };
	} // Parses one property definition entry. Either contains:
	// * a valid prop type object ({type, ...})
	// * or just a default value, in which case type and name inference is used


	function parsePropType(name, propDef) {
	  switch (getTypeOf(propDef)) {
	    case 'object':
	      propDef = normalizePropDefinition(name, propDef);
	      return parsePropDefinition(propDef);

	    case 'array':
	      return guessArrayType(name, propDef);

	    case 'boolean':
	      return {
	        name: name,
	        type: 'boolean',
	        value: propDef
	      };

	    case 'number':
	      return guessNumberType(name, propDef);

	    case 'function':
	      return {
	        name: name,
	        type: 'function',
	        value: propDef
	      };
	    // return guessFunctionType(name, propDef);

	    default:
	      return {
	        name: name,
	        type: 'unknown',
	        value: propDef
	      };
	  }
	}

	function guessArrayType(name, array) {
	  if (/color/i.test(name) && (array.length === 3 || array.length === 4)) {
	    return {
	      name: name,
	      type: 'color',
	      value: array
	    };
	  }

	  return {
	    name: name,
	    type: 'array',
	    value: array
	  };
	}

	function normalizePropDefinition(name, propDef) {
	  if (!('type' in propDef)) {
	    if (!('value' in propDef)) {
	      // If no type and value this object is likely the value
	      return {
	        name: name,
	        type: 'object',
	        value: propDef
	      };
	    }

	    return Object.assign({
	      name: name,
	      type: getTypeOf(propDef.value)
	    }, propDef);
	  }

	  return Object.assign({
	    name: name
	  }, propDef);
	}

	function parsePropDefinition(propDef) {
	  var type = propDef.type;
	  var typeDefinition = TYPE_DEFINITIONS[type] || {};
	  var typeValidator = typeDefinition.typeValidator;

	  if (typeValidator) {
	    (0, _assert.default)(typeValidator(propDef), 'Illegal prop type');
	  }

	  return propDef;
	}

	function guessNumberType(name, value) {
	  var isKnownProp = /radius|scale|width|height|pixel|size|miter/i.test(name) && /^((?!scale).)*$/.test(name);
	  var max = isKnownProp ? 100 : 1;
	  var min = 0;
	  return {
	    name: name,
	    type: 'number',
	    max: Math.max(value, max),
	    min: Math.min(value, min),
	    value: value
	  };
	} // improved version of javascript typeof that can distinguish arrays and null values


	function getTypeOf(value) {
	  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
	    return 'array';
	  }

	  if (value === null) {
	    return 'null';
	  }

	  return _typeof(value);
	}
	//# sourceMappingURL=prop-types.js.map

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var EMPTY_PROPS = Object.freeze({});

	var ComponentState =
	/*#__PURE__*/
	function () {
	  function ComponentState() {
	    var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, ComponentState);

	    this.component = component;
	    this.asyncProps = {}; // Prop values that the layer sees

	    this.onAsyncPropUpdated = function () {};

	    this.oldProps = EMPTY_PROPS; // Last props before update

	    this.oldAsyncProps = null; // Last props before update, with async values copied.
	  }

	  _createClass(ComponentState, [{
	    key: "getOldProps",
	    value: function getOldProps() {
	      return this.oldAsyncProps || this.oldProps;
	    }
	  }, {
	    key: "resetOldProps",
	    value: function resetOldProps() {
	      this.oldAsyncProps = null;
	      this.oldProps = this.component.props;
	    } // Whenever async props are changing, we need to make a copy of oldProps
	    // otherwise the prop rewriting will affect the value both in props and oldProps.
	    // While the copy is relatively expensive, this only happens on load completion.

	  }, {
	    key: "freezeAsyncOldProps",
	    value: function freezeAsyncOldProps() {
	      if (!this.oldAsyncProps) {
	        // Make sure oldProps is set
	        this.oldProps = this.oldProps || this.component.props; // Deep copy props (Object.assign only handles shallow props)
	        // TODO - Alternatively, just reconfigure the async prop descriptors to fixed values?

	        this.oldAsyncProps = {};

	        for (var propName in this.oldProps) {
	          this.oldAsyncProps[propName] = this.oldProps[propName];
	        }
	      }
	    } // ASYNC PROP HANDLING
	    //
	    // Checks if a prop is overridden

	  }, {
	    key: "hasAsyncProp",
	    value: function hasAsyncProp(propName) {
	      return propName in this.asyncProps;
	    } // Returns value of an overriden prop

	  }, {
	    key: "getAsyncProp",
	    value: function getAsyncProp(propName) {
	      var asyncProp = this.asyncProps[propName];
	      return asyncProp && asyncProp.resolvedValue;
	    }
	  }, {
	    key: "isAsyncPropLoading",
	    value: function isAsyncPropLoading(propName) {
	      var asyncProp = this.asyncProps[propName];
	      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
	    } // Updates all async/overridden props (when new props come in)
	    // Checks if urls have changed, starts loading, or removes override

	  }, {
	    key: "setAsyncProps",
	    value: function setAsyncProps(props) {
	      // NOTE: prop param and default values are only support for testing
	      var resolvedValues = props._asyncPropResolvedValues || {};
	      var originalValues = props._asyncPropOriginalValues || props;
	      var defaultValues = props._asyncPropDefaultValues || {}; // TODO - use async props from the layer's prop types

	      for (var propName in resolvedValues) {
	        var value = resolvedValues[propName];

	        this._createAsyncPropData(propName, value, defaultValues[propName]);

	        this._updateAsyncProp(propName, value);
	      }

	      for (var _propName in originalValues) {
	        var _value = originalValues[_propName]; // Makes sure a record exists for this prop

	        this._createAsyncPropData(_propName, _value, defaultValues[_propName]);

	        this._updateAsyncProp(_propName, _value);
	      }
	    } // Intercept strings (URLs) and Promises and activates loading and prop rewriting

	  }, {
	    key: "_updateAsyncProp",
	    value: function _updateAsyncProp(propName, value) {
	      if (!this._didAsyncInputValueChange(propName, value)) {
	        return;
	      } // interpret value string as url and start a new load tracked by a promise


	      if (typeof value === 'string') {
	        var fetch = this.layer.props.fetch;
	        var url = value;
	        value = fetch(url);
	      } // interprets promise and track the "loading"


	      if (_instanceof(value, Promise)) {
	        this._watchPromise(propName, value);

	        return;
	      } // else, normal, non-async value. Just store value for now


	      this._setPropValue(propName, value);
	    } // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)

	  }, {
	    key: "_didAsyncInputValueChange",
	    value: function _didAsyncInputValueChange(propName, value) {
	      var asyncProp = this.asyncProps[propName];

	      if (value === asyncProp.lastValue) {
	        return false;
	      }

	      asyncProp.lastValue = value;
	      return true;
	    } // Set normal, non-async value

	  }, {
	    key: "_setPropValue",
	    value: function _setPropValue(propName, value) {
	      var asyncProp = this.asyncProps[propName];
	      asyncProp.value = value;
	      asyncProp.resolvedValue = value;
	      asyncProp.pendingLoadCount++;
	      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
	    } // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously

	  }, {
	    key: "_setAsyncPropValue",
	    value: function _setAsyncPropValue(propName, value, loadCount) {
	      // Only update if loadCount is larger or equal to resolvedLoadCount
	      // otherwise a more recent load has already completed
	      var asyncProp = this.asyncProps[propName];

	      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount) {
	        (0, _assert.default)(value !== undefined); // A chance to copy old props before updating

	        this.freezeAsyncOldProps();
	        value = this._postProcessValue(propName, value);
	        asyncProp.resolvedValue = value;
	        asyncProp.resolvedLoadCount = loadCount; // Call callback to inform listener

	        this.onAsyncPropUpdated(propName, value);
	      }
	    } // Tracks a promise, sets the prop when loaded, handles load count

	  }, {
	    key: "_watchPromise",
	    value: function _watchPromise(propName, promise) {
	      var _this = this;

	      var asyncProp = this.asyncProps[propName];
	      asyncProp.pendingLoadCount++;
	      var loadCount = asyncProp.pendingLoadCount;
	      promise.then(function (data) {
	        return _this._setAsyncPropValue(propName, data, loadCount);
	      }).catch(function (error) {
	        return _log.default.error(error);
	      });
	    } // Give the app a chance to post process the loaded data

	  }, {
	    key: "_postProcessValue",
	    value: function _postProcessValue(propName, value) {
	      var _ref = this.component ? this.component.props : {},
	          dataTransform = _ref.dataTransform;

	      if (propName === 'data' && dataTransform) {
	        value = dataTransform(value);
	      }

	      return value;
	    } // Creating an asyncProp record if needed

	  }, {
	    key: "_createAsyncPropData",
	    value: function _createAsyncPropData(propName, value, defaultValue) {
	      var asyncProp = this.asyncProps[propName];

	      if (!asyncProp) {
	        // assert(defaultValue !== undefined);
	        this.asyncProps[propName] = {
	          lastValue: null,
	          // Supplied prop value (can be url/promise, not visible to layer)
	          resolvedValue: defaultValue,
	          // Resolved prop value (valid data, can be "shown" to layer)
	          pendingLoadCount: 0,
	          // How many loads have been issued
	          resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)

	        };
	      }
	    }
	  }]);

	  return ComponentState;
	}();

	exports.default = ComponentState;
	//# sourceMappingURL=component-state.js.map

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _componentState = _interopRequireDefault(__webpack_require__(275));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var LayerState =
	/*#__PURE__*/
	function (_ComponentState) {
	  _inherits(LayerState, _ComponentState);

	  function LayerState(_ref) {
	    var _this;

	    var attributeManager = _ref.attributeManager,
	        layer = _ref.layer;

	    _classCallCheck(this, LayerState);

	    _this = _possibleConstructorReturn(this, (LayerState.__proto__ || Object.getPrototypeOf(LayerState)).call(this, layer));
	    _this.attributeManager = attributeManager;
	    _this.model = null;
	    _this.needsRedraw = true;
	    _this.subLayers = null; // reference to sublayers rendered in a previous cycle

	    return _this;
	  }

	  _createClass(LayerState, [{
	    key: "layer",
	    get: function get() {
	      return this.component;
	    },
	    set: function set(layer) {
	      this.component = layer;
	    }
	  }]);

	  return LayerState;
	}(_componentState.default);

	exports.default = LayerState;
	//# sourceMappingURL=layer-state.js.map

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.drawLayers = drawLayers;
	exports.drawPickingBuffer = drawPickingBuffer;
	exports.getPixelRatio = void 0;

	var _luma = __webpack_require__(46);

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	/* global window */
	var LOG_PRIORITY_DRAW = 2;
	var renderCount = 0; // TODO - Exported for pick-layers.js - Move to util?

	var getPixelRatio = function getPixelRatio(_ref) {
	  var useDevicePixels = _ref.useDevicePixels;
	  (0, _assert.default)(typeof useDevicePixels === 'boolean', 'Invalid useDevicePixels');
	  return useDevicePixels && typeof window !== 'undefined' ? window.devicePixelRatio : 1;
	}; // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates


	exports.getPixelRatio = getPixelRatio;

	var getGLViewport = function getGLViewport(gl, _ref2) {
	  var viewport = _ref2.viewport,
	      pixelRatio = _ref2.pixelRatio;
	  // TODO - dummy default for node
	  var height = gl.canvas ? gl.canvas.clientHeight : 100; // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates

	  var dimensions = viewport;
	  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];
	}; // Helper functions


	function clearCanvas(gl, _ref3) {
	  var useDevicePixels = _ref3.useDevicePixels;
	  // const pixelRatio = getPixelRatio({useDevicePixels});
	  var width = gl.drawingBufferWidth;
	  var height = gl.drawingBufferHeight; // clear depth and color buffers, restoring transparency

	  (0, _luma.withParameters)(gl, {
	    viewport: [0, 0, width, height]
	  }, function () {
	    gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
	  });
	} // Draw a list of layers in a list of viewports


	function drawLayers(gl, _ref4) {
	  var layers = _ref4.layers,
	      viewports = _ref4.viewports,
	      onViewportActive = _ref4.onViewportActive,
	      useDevicePixels = _ref4.useDevicePixels,
	      _ref4$drawPickingColo = _ref4.drawPickingColors,
	      drawPickingColors = _ref4$drawPickingColo === void 0 ? false : _ref4$drawPickingColo,
	      _ref4$deviceRect = _ref4.deviceRect,
	      deviceRect = _ref4$deviceRect === void 0 ? null : _ref4$deviceRect,
	      _ref4$parameters = _ref4.parameters,
	      parameters = _ref4$parameters === void 0 ? {} : _ref4$parameters,
	      _ref4$layerFilter = _ref4.layerFilter,
	      layerFilter = _ref4$layerFilter === void 0 ? null : _ref4$layerFilter,
	      _ref4$pass = _ref4.pass,
	      pass = _ref4$pass === void 0 ? 'draw' : _ref4$pass,
	      _ref4$redrawReason = _ref4.redrawReason,
	      redrawReason = _ref4$redrawReason === void 0 ? '' : _ref4$redrawReason,
	      stats = _ref4.stats;
	  clearCanvas(gl, {
	    useDevicePixels: useDevicePixels
	  }); // effectManager.preDraw();

	  viewports.forEach(function (viewportOrDescriptor, i) {
	    var viewport = getViewportFromDescriptor(viewportOrDescriptor); // Update context to point to this viewport

	    onViewportActive(viewport); // render this viewport

	    drawLayersInViewport(gl, {
	      layers: layers,
	      viewport: viewport,
	      useDevicePixels: useDevicePixels,
	      drawPickingColors: drawPickingColors,
	      deviceRect: deviceRect,
	      parameters: parameters,
	      layerFilter: layerFilter,
	      pass: pass,
	      redrawReason: redrawReason,
	      stats: stats
	    });
	  }); // effectManager.draw();
	} // Draws list of layers and viewports into the picking buffer
	// Note: does not sample the buffer, that has to be done by the caller


	function drawPickingBuffer(gl, _ref5) {
	  var layers = _ref5.layers,
	      viewports = _ref5.viewports,
	      onViewportActive = _ref5.onViewportActive,
	      useDevicePixels = _ref5.useDevicePixels,
	      pickingFBO = _ref5.pickingFBO,
	      _ref5$deviceRect = _ref5.deviceRect,
	      x = _ref5$deviceRect.x,
	      y = _ref5$deviceRect.y,
	      width = _ref5$deviceRect.width,
	      height = _ref5$deviceRect.height,
	      _ref5$layerFilter = _ref5.layerFilter,
	      layerFilter = _ref5$layerFilter === void 0 ? null : _ref5$layerFilter,
	      _ref5$redrawReason = _ref5.redrawReason,
	      redrawReason = _ref5$redrawReason === void 0 ? '' : _ref5$redrawReason;
	  // Make sure we clear scissor test and fbo bindings in case of exceptions
	  // We are only interested in one pixel, no need to render anything else
	  // Note that the callback here is called synchronously.
	  // Set blend mode for picking
	  // always overwrite existing pixel with [r,g,b,layerIndex]
	  return (0, _luma.withParameters)(gl, {
	    framebuffer: pickingFBO,
	    scissorTest: true,
	    scissor: [x, y, width, height],
	    clearColor: [0, 0, 0, 0]
	  }, function () {
	    drawLayers(gl, {
	      layers: layers,
	      viewports: viewports,
	      onViewportActive: onViewportActive,
	      useDevicePixels: useDevicePixels,
	      drawPickingColors: true,
	      layerFilter: layerFilter,
	      pass: 'picking',
	      redrawReason: redrawReason,
	      parameters: {
	        blend: true,
	        blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],
	        blendEquation: gl.FUNC_ADD,
	        blendColor: [0, 0, 0, 0]
	      }
	    });
	  });
	} // Draws a list of layers in one viewport
	// TODO - when picking we could completely skip rendering viewports that dont
	// intersect with the picking rect


	function drawLayersInViewport(gl, _ref6) {
	  var layers = _ref6.layers,
	      viewport = _ref6.viewport,
	      useDevicePixels = _ref6.useDevicePixels,
	      _ref6$drawPickingColo = _ref6.drawPickingColors,
	      drawPickingColors = _ref6$drawPickingColo === void 0 ? false : _ref6$drawPickingColo,
	      _ref6$deviceRect = _ref6.deviceRect,
	      deviceRect = _ref6$deviceRect === void 0 ? null : _ref6$deviceRect,
	      _ref6$parameters = _ref6.parameters,
	      parameters = _ref6$parameters === void 0 ? {} : _ref6$parameters,
	      layerFilter = _ref6.layerFilter,
	      _ref6$pass = _ref6.pass,
	      pass = _ref6$pass === void 0 ? 'draw' : _ref6$pass,
	      _ref6$redrawReason = _ref6.redrawReason,
	      redrawReason = _ref6$redrawReason === void 0 ? '' : _ref6$redrawReason,
	      stats = _ref6.stats;
	  var pixelRatio = getPixelRatio({
	    useDevicePixels: useDevicePixels
	  });
	  var glViewport = getGLViewport(gl, {
	    viewport: viewport,
	    pixelRatio: pixelRatio
	  }); // render layers in normal colors

	  var renderStats = {
	    totalCount: layers.length,
	    visibleCount: 0,
	    compositeCount: 0,
	    pickableCount: 0
	  }; // const {x, y, width, height} = deviceRect || [];

	  (0, _luma.setParameters)(gl, parameters || {}); // render layers in normal colors

	  layers.forEach(function (layer, layerIndex) {
	    // Check if we should draw layer
	    var shouldDrawLayer = layer.props.visible;

	    if (drawPickingColors) {
	      shouldDrawLayer = shouldDrawLayer && layer.props.pickable;
	    }

	    if (shouldDrawLayer && layerFilter) {
	      shouldDrawLayer = layerFilter({
	        layer: layer,
	        viewport: viewport,
	        isPicking: drawPickingColors
	      });
	    } // Calculate stats


	    if (shouldDrawLayer && layer.props.pickable) {
	      renderStats.pickableCount++;
	    }

	    if (layer.isComposite) {
	      renderStats.compositeCount++;
	    } // Draw the layer


	    if (shouldDrawLayer) {
	      if (!layer.isComposite) {
	        renderStats.visibleCount++;
	      }

	      drawLayerInViewport({
	        gl: gl,
	        layer: layer,
	        layerIndex: layerIndex,
	        drawPickingColors: drawPickingColors,
	        pixelRatio: pixelRatio,
	        glViewport: glViewport,
	        parameters: parameters
	      });
	    }
	  });
	  renderCount++;
	  logRenderStats({
	    renderStats: renderStats,
	    pass: pass,
	    redrawReason: redrawReason,
	    stats: stats
	  });
	}

	function drawLayerInViewport(_ref7) {
	  var gl = _ref7.gl,
	      layer = _ref7.layer,
	      layerIndex = _ref7.layerIndex,
	      drawPickingColors = _ref7.drawPickingColors,
	      pixelRatio = _ref7.pixelRatio,
	      glViewport = _ref7.glViewport,
	      parameters = _ref7.parameters;
	  var moduleParameters = Object.assign(Object.create(layer.props), {
	    viewport: layer.context.viewport,
	    pickingActive: drawPickingColors ? 1 : 0,
	    devicePixelRatio: pixelRatio
	  });
	  var uniforms = Object.assign({}, layer.context.uniforms, {
	    layerIndex: layerIndex
	  }); // All parameter resolving is done here instead of the layer
	  // Blend parameters must not be overriden

	  var layerParameters = Object.assign({}, layer.props.parameters || {}, parameters);
	  Object.assign(layerParameters, {
	    viewport: glViewport
	  });

	  if (drawPickingColors) {
	    Object.assign(layerParameters, {
	      blendColor: [0, 0, 0, (layerIndex + 1) / 255]
	    });
	  } else {
	    Object.assign(moduleParameters, getObjectHighlightParameters(layer));
	  }

	  layer.drawLayer({
	    moduleParameters: moduleParameters,
	    uniforms: uniforms,
	    parameters: layerParameters
	  });
	}

	function logRenderStats(_ref8) {
	  var renderStats = _ref8.renderStats,
	      pass = _ref8.pass,
	      redrawReason = _ref8.redrawReason,
	      stats = _ref8.stats;

	  if (_log.default.priority >= LOG_PRIORITY_DRAW) {
	    var totalCount = renderStats.totalCount,
	        visibleCount = renderStats.visibleCount,
	        compositeCount = renderStats.compositeCount,
	        pickableCount = renderStats.pickableCount;
	    var primitiveCount = totalCount - compositeCount;
	    var hiddenCount = primitiveCount - visibleCount;
	    var message = '';
	    message += "RENDER #".concat(renderCount, " ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass, " because ").concat(redrawReason, " ");

	    if (_log.default.priority > LOG_PRIORITY_DRAW) {
	      message += "(".concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)");
	    }

	    _log.default.log(LOG_PRIORITY_DRAW, message)();

	    if (stats) {
	      stats.increment('redraw layers', visibleCount);
	    }
	  }
	} // Get a viewport from a viewport descriptor (which can be a plain viewport)


	function getViewportFromDescriptor(viewportOrDescriptor) {
	  return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;
	}
	/**
	 * Returns the picking color of currenlty selected object of the given 'layer'.
	 * @return {Array} - the picking color or null if layers selected object is invalid.
	 */


	function getObjectHighlightParameters(layer) {
	  // TODO - inefficient to update settings every render?
	  // TODO: Add warning if 'highlightedObjectIndex' is > numberOfInstances of the model.
	  // Update picking module settings if highlightedObjectIndex is set.
	  // This will overwrite any settings from auto highlighting.
	  if (Number.isInteger(layer.props.highlightedObjectIndex)) {
	    var pickingSelectedColor = layer.props.highlightedObjectIndex >= 0 ? layer.encodePickingColor(layer.props.highlightedObjectIndex) : null;
	    return {
	      pickingSelectedColor: pickingSelectedColor
	    };
	  }

	  return null;
	}
	//# sourceMappingURL=draw-layers.js.map

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.pickObject = pickObject;
	exports.pickVisibleObjects = pickVisibleObjects;
	exports.getClosestFromPickingBuffer = getClosestFromPickingBuffer;

	var _drawLayers = __webpack_require__(277);

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var NO_PICKED_OBJECT = {
	  pickedColor: null,
	  pickedLayer: null,
	  pickedObjectIndex: -1
	};
	/* eslint-disable max-depth, max-statements */
	// Pick the closest object at the given (x,y) coordinate

	function pickObject(gl, _ref) {
	  var layers = _ref.layers,
	      viewports = _ref.viewports,
	      x = _ref.x,
	      y = _ref.y,
	      radius = _ref.radius,
	      layerFilter = _ref.layerFilter,
	      _ref$depth = _ref.depth,
	      depth = _ref$depth === void 0 ? 1 : _ref$depth,
	      mode = _ref.mode,
	      onViewportActive = _ref.onViewportActive,
	      pickingFBO = _ref.pickingFBO,
	      lastPickedInfo = _ref.lastPickedInfo,
	      useDevicePixels = _ref.useDevicePixels;
	  // Convert from canvas top-left to WebGL bottom-left coordinates
	  // And compensate for pixelRatio
	  var pixelRatio = (0, _drawLayers.getPixelRatio)({
	    useDevicePixels: useDevicePixels
	  });
	  var deviceX = Math.round(x * pixelRatio);
	  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);
	  var deviceRadius = Math.round(radius * pixelRatio);
	  var deviceRect = getPickingRect({
	    deviceX: deviceX,
	    deviceY: deviceY,
	    deviceRadius: deviceRadius,
	    deviceWidth: pickingFBO.width,
	    deviceHeight: pickingFBO.height
	  });
	  var result = [];
	  var affectedLayers = {};

	  for (var i = 0; i < depth; i++) {
	    var pickedColors = deviceRect && drawAndSamplePickingBuffer(gl, {
	      layers: layers,
	      viewports: viewports,
	      onViewportActive: onViewportActive,
	      useDevicePixels: useDevicePixels,
	      pickingFBO: pickingFBO,
	      deviceRect: deviceRect,
	      layerFilter: layerFilter,
	      redrawReason: mode
	    });
	    var pickInfo = pickedColors && getClosestFromPickingBuffer(gl, {
	      pickedColors: pickedColors,
	      layers: layers,
	      deviceX: deviceX,
	      deviceY: deviceY,
	      deviceRadius: deviceRadius,
	      deviceRect: deviceRect
	    }) || NO_PICKED_OBJECT;

	    if (!pickInfo.pickedColor) {
	      break;
	    } // only exclude if we need to run picking again


	    if (i + 1 < depth) {
	      var layerId = pickInfo.pickedColor[3] - 1;

	      if (!affectedLayers[layerId]) {
	        // backup original colors
	        affectedLayers[layerId] = layers[layerId].copyPickingColors();
	      }

	      layers[layerId].clearPickingColor(pickInfo.pickedColor);
	    }

	    var processedPickInfos = processPickInfo({
	      pickInfo: pickInfo,
	      lastPickedInfo: lastPickedInfo,
	      mode: mode,
	      layers: layers,
	      viewports: viewports,
	      x: x,
	      y: y,
	      deviceX: deviceX,
	      deviceY: deviceY,
	      pixelRatio: pixelRatio
	    });

	    if (processedPickInfos) {
	      processedPickInfos.forEach(function (info) {
	        return result.push(info);
	      });
	    }
	  } // reset only affected buffers


	  Object.keys(affectedLayers).forEach(function (layerId) {
	    return layers[layerId].restorePickingColors(affectedLayers[layerId]);
	  });
	  return result;
	} // Pick all objects within the given bounding box


	function pickVisibleObjects(gl, _ref2) {
	  var layers = _ref2.layers,
	      viewports = _ref2.viewports,
	      x = _ref2.x,
	      y = _ref2.y,
	      width = _ref2.width,
	      height = _ref2.height,
	      mode = _ref2.mode,
	      layerFilter = _ref2.layerFilter,
	      onViewportActive = _ref2.onViewportActive,
	      pickingFBO = _ref2.pickingFBO,
	      useDevicePixels = _ref2.useDevicePixels;
	  // Convert from canvas top-left to WebGL bottom-left coordinates
	  // And compensate for pixelRatio
	  var pixelRatio = (0, _drawLayers.getPixelRatio)({
	    useDevicePixels: useDevicePixels
	  });
	  var deviceLeft = Math.round(x * pixelRatio);
	  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);
	  var deviceRight = Math.round((x + width) * pixelRatio);
	  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);
	  var deviceRect = {
	    x: deviceLeft,
	    y: deviceTop,
	    width: deviceRight - deviceLeft,
	    height: deviceBottom - deviceTop
	  };
	  var pickedColors = drawAndSamplePickingBuffer(gl, {
	    layers: layers,
	    viewports: viewports,
	    onViewportActive: onViewportActive,
	    pickingFBO: pickingFBO,
	    useDevicePixels: useDevicePixels,
	    deviceRect: deviceRect,
	    layerFilter: layerFilter,
	    redrawReason: mode
	  });
	  var pickInfos = getUniquesFromPickingBuffer(gl, {
	    pickedColors: pickedColors,
	    layers: layers
	  }); // Only return unique infos, identified by info.object

	  var uniqueInfos = new Map();
	  pickInfos.forEach(function (pickInfo) {
	    var info = {
	      color: pickInfo.pickedColor,
	      layer: null,
	      index: pickInfo.pickedObjectIndex,
	      picked: true,
	      x: x,
	      y: y,
	      width: width,
	      height: height,
	      pixelRatio: pixelRatio
	    };
	    info = getLayerPickingInfo({
	      layer: pickInfo.pickedLayer,
	      info: info,
	      mode: mode
	    });

	    if (!uniqueInfos.has(info.object)) {
	      uniqueInfos.set(info.object, info);
	    }
	  });
	  return Array.from(uniqueInfos.values());
	} // HELPER METHODS
	// returns pickedColor or null if no pickable layers found.


	function drawAndSamplePickingBuffer(gl, _ref3) {
	  var layers = _ref3.layers,
	      viewports = _ref3.viewports,
	      onViewportActive = _ref3.onViewportActive,
	      useDevicePixels = _ref3.useDevicePixels,
	      pickingFBO = _ref3.pickingFBO,
	      deviceRect = _ref3.deviceRect,
	      layerFilter = _ref3.layerFilter,
	      redrawReason = _ref3.redrawReason;
	  (0, _assert.default)(deviceRect);
	  (0, _assert.default)(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');
	  (0, _assert.default)(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');
	  var pickableLayers = layers.filter(function (layer) {
	    return layer.isPickable();
	  });

	  if (pickableLayers.length < 1) {
	    return null;
	  }

	  (0, _drawLayers.drawPickingBuffer)(gl, {
	    layers: layers,
	    viewports: viewports,
	    onViewportActive: onViewportActive,
	    useDevicePixels: useDevicePixels,
	    pickingFBO: pickingFBO,
	    deviceRect: deviceRect,
	    layerFilter: layerFilter,
	    redrawReason: redrawReason
	  }); // Read from an already rendered picking buffer
	  // Returns an Uint8ClampedArray of picked pixels

	  var x = deviceRect.x,
	      y = deviceRect.y,
	      width = deviceRect.width,
	      height = deviceRect.height;
	  var pickedColors = new Uint8Array(width * height * 4);
	  pickingFBO.readPixels({
	    x: x,
	    y: y,
	    width: width,
	    height: height,
	    pixelArray: pickedColors
	  });
	  return pickedColors;
	} // Indentifies which viewport, if any corresponds to x and y
	// Returns first viewport if no match
	// TODO - need to determine which viewport we are in
	// TODO - document concept of "primary viewport" that matches all coords?
	// TODO - static method on Viewport class?


	function getViewportFromCoordinates(_ref4) {
	  var viewports = _ref4.viewports;
	  var viewport = viewports[0];
	  return viewport;
	} // Calculate a picking rect centered on deviceX and deviceY and clipped to device
	// Returns null if pixel is outside of device


	function getPickingRect(_ref5) {
	  var deviceX = _ref5.deviceX,
	      deviceY = _ref5.deviceY,
	      deviceRadius = _ref5.deviceRadius,
	      deviceWidth = _ref5.deviceWidth,
	      deviceHeight = _ref5.deviceHeight;
	  var valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight; // x, y out of bounds.

	  if (!valid) {
	    return null;
	  } // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]


	  var x = Math.max(0, deviceX - deviceRadius);
	  var y = Math.max(0, deviceY - deviceRadius);
	  var width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;
	  var height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;
	  return {
	    x: x,
	    y: y,
	    width: width,
	    height: height
	  };
	} // TODO - break this monster function into 3+ parts


	function processPickInfo(_ref6) {
	  var pickInfo = _ref6.pickInfo,
	      lastPickedInfo = _ref6.lastPickedInfo,
	      mode = _ref6.mode,
	      layers = _ref6.layers,
	      viewports = _ref6.viewports,
	      x = _ref6.x,
	      y = _ref6.y,
	      deviceX = _ref6.deviceX,
	      deviceY = _ref6.deviceY,
	      pixelRatio = _ref6.pixelRatio;
	  var pickedColor = pickInfo.pickedColor,
	      pickedLayer = pickInfo.pickedLayer,
	      pickedObjectIndex = pickInfo.pickedObjectIndex;
	  var affectedLayers = pickedLayer ? [pickedLayer] : [];

	  if (mode === 'hover') {
	    // only invoke onHover events if picked object has changed
	    var lastPickedObjectIndex = lastPickedInfo.index;
	    var lastPickedLayerId = lastPickedInfo.layerId;
	    var pickedLayerId = pickedLayer && pickedLayer.props.id; // proceed only if picked object changed

	    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {
	      if (pickedLayerId !== lastPickedLayerId) {
	        // We cannot store a ref to lastPickedLayer in the context because
	        // the state of an outdated layer is no longer valid
	        // and the props may have changed
	        var lastPickedLayer = layers.find(function (layer) {
	          return layer.props.id === lastPickedLayerId;
	        });

	        if (lastPickedLayer) {
	          // Let leave event fire before enter event
	          affectedLayers.unshift(lastPickedLayer);
	        }
	      } // Update layer manager context


	      lastPickedInfo.layerId = pickedLayerId;
	      lastPickedInfo.index = pickedObjectIndex;
	    }
	  }

	  var viewport = getViewportFromCoordinates({
	    viewports: viewports
	  }); // TODO - add coords

	  var baseInfo = {
	    color: null,
	    layer: null,
	    index: -1,
	    picked: false,
	    x: x,
	    y: y,
	    pixel: [x, y],
	    lngLat: viewport.unproject([x, y]),
	    devicePixel: [deviceX, deviceY],
	    pixelRatio: pixelRatio
	  }; // Use a Map to store all picking infos.
	  // The following two forEach loops are the result of
	  // https://github.com/uber/deck.gl/issues/443
	  // Please be very careful when changing this pattern

	  var infos = new Map();
	  affectedLayers.forEach(function (layer) {
	    var info = Object.assign({}, baseInfo);

	    if (layer === pickedLayer) {
	      info.color = pickedColor;
	      info.index = pickedObjectIndex;
	      info.picked = true;
	    }

	    info = getLayerPickingInfo({
	      layer: layer,
	      info: info,
	      mode: mode
	    }); // This guarantees that there will be only one copy of info for
	    // one composite layer

	    if (info) {
	      infos.set(info.layer.id, info);
	    }

	    var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;
	    var pickingParameters = {
	      pickingSelectedColor: pickingSelectedColor
	    };
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = layer.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var model = _step.value;
	        model.updateModuleSettings(pickingParameters);
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return != null) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }
	  });
	  var unhandledPickInfos = callLayerPickingCallbacks(infos, mode);
	  return unhandledPickInfos;
	} // Per-layer event handlers (e.g. onClick, onHover) are provided by the
	// user and out of deck.gl's control. It's very much possible that
	// the user calls React lifecycle methods in these function, such as
	// ReactComponent.setState(). React lifecycle methods sometimes induce
	// a re-render and re-generation of props of deck.gl and its layers,
	// which invalidates all layers currently passed to this very function.
	// Therefore, per-layer event handlers must be invoked at the end
	// of the picking operation. NO operation that relies on the states of current
	// layers should be called after this code.


	function callLayerPickingCallbacks(infos, mode) {
	  var unhandledPickInfos = [];
	  infos.forEach(function (info) {
	    var handled = false;

	    switch (mode) {
	      case 'click':
	        handled = info.layer.props.onClick(info);
	        break;

	      case 'hover':
	        handled = info.layer.props.onHover(info);
	        break;

	      case 'query':
	        break;

	      default:
	        throw new Error('unknown pick type');
	    }

	    if (!handled) {
	      unhandledPickInfos.push(info);
	    }
	  });
	  return unhandledPickInfos;
	}
	/**
	 * Pick at a specified pixel with a tolerance radius
	 * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`
	 */


	function getClosestFromPickingBuffer(gl, _ref7) {
	  var pickedColors = _ref7.pickedColors,
	      layers = _ref7.layers,
	      deviceX = _ref7.deviceX,
	      deviceY = _ref7.deviceY,
	      deviceRadius = _ref7.deviceRadius,
	      deviceRect = _ref7.deviceRect;
	  (0, _assert.default)(pickedColors); // Traverse all pixels in picking results and find the one closest to the supplied
	  // [deviceX, deviceY]

	  var x = deviceRect.x,
	      y = deviceRect.y,
	      width = deviceRect.width,
	      height = deviceRect.height;
	  var minSquareDistanceToCenter = deviceRadius * deviceRadius;
	  var closestPixelIndex = -1;
	  var i = 0;

	  for (var row = 0; row < height; row++) {
	    var dy = row + y - deviceY;
	    var dy2 = dy * dy;

	    if (dy2 > minSquareDistanceToCenter) {
	      // skip this row
	      i += 4 * width;
	    } else {
	      for (var col = 0; col < width; col++) {
	        // Decode picked layer from color
	        var pickedLayerIndex = pickedColors[i + 3] - 1;

	        if (pickedLayerIndex >= 0) {
	          var dx = col + x - deviceX;
	          var d2 = dx * dx + dy2;

	          if (d2 <= minSquareDistanceToCenter) {
	            minSquareDistanceToCenter = d2;
	            closestPixelIndex = i;
	          }
	        }

	        i += 4;
	      }
	    }
	  }

	  if (closestPixelIndex >= 0) {
	    // Decode picked object index from color
	    var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;

	    var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
	    var pickedLayer = layers[_pickedLayerIndex];

	    if (pickedLayer) {
	      var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);
	      return {
	        pickedColor: pickedColor,
	        pickedLayer: pickedLayer,
	        pickedObjectIndex: pickedObjectIndex
	      };
	    }

	    _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
	  }

	  return NO_PICKED_OBJECT;
	}
	/* eslint-enable max-depth, max-statements */

	/**
	 * Examines a picking buffer for unique colors
	 * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`
	 */


	function getUniquesFromPickingBuffer(gl, _ref8) {
	  var pickedColors = _ref8.pickedColors,
	      layers = _ref8.layers;
	  var uniqueColors = new Map(); // Traverse all pixels in picking results and get unique colors

	  if (pickedColors) {
	    for (var i = 0; i < pickedColors.length; i += 4) {
	      // Decode picked layer from color
	      var pickedLayerIndex = pickedColors[i + 3] - 1;

	      if (pickedLayerIndex >= 0) {
	        var pickedColor = pickedColors.slice(i, i + 4);
	        var colorKey = pickedColor.join(','); // eslint-disable-next-line

	        if (!uniqueColors.has(colorKey)) {
	          var pickedLayer = layers[pickedLayerIndex]; // eslint-disable-next-line

	          if (pickedLayer) {
	            uniqueColors.set(colorKey, {
	              pickedColor: pickedColor,
	              pickedLayer: pickedLayer,
	              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)
	            });
	          } else {
	            _log.default.error('Picked non-existent layer. Is picking buffer corrupt?')();
	          }
	        }
	      }
	    }
	  }

	  return Array.from(uniqueColors.values());
	} // Walk up the layer composite chain to populate the info object


	function getLayerPickingInfo(_ref9) {
	  var layer = _ref9.layer,
	      info = _ref9.info,
	      mode = _ref9.mode;

	  while (layer && info) {
	    // For a composite layer, sourceLayer will point to the sublayer
	    // where the event originates from.
	    // It provides additional context for the composite layer's
	    // getPickingInfo() method to populate the info object
	    var sourceLayer = info.layer || layer;
	    info.layer = layer; // layer.pickLayer() function requires a non-null ```layer.state```
	    // object to funtion properly. So the layer refereced here
	    // must be the "current" layer, not an "out-dated" / "invalidated" layer

	    info = layer.pickLayer({
	      info: info,
	      mode: mode,
	      sourceLayer: sourceLayer
	    });
	    layer = layer.parent;
	  }

	  return info;
	}
	//# sourceMappingURL=pick-layers.js.map

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _assert = _interopRequireDefault(__webpack_require__(239));

	var _deepEqual = __webpack_require__(280);

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _flatten = __webpack_require__(266);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var INITIAL_VIEW_STATE = {
	  latitude: 0,
	  longitude: 0,
	  zoom: 1
	};

	var ViewManager =
	/*#__PURE__*/
	function () {
	  function ViewManager() {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, ViewManager);

	    // List of view descriptors, gets re-evaluated when width/height changes
	    this.views = [];
	    this.width = 100;
	    this.height = 100;
	    this.viewState = INITIAL_VIEW_STATE;
	    this._viewports = []; // Generated viewports

	    this._needsRedraw = 'Initial render';
	    this._needsUpdate = true;
	    Object.seal(this); // Init with default map viewport

	    this.setProps(props);
	  }

	  _createClass(ViewManager, [{
	    key: "finalize",
	    value: function finalize() {} // Check if a redraw is needed

	  }, {
	    key: "needsRedraw",
	    value: function needsRedraw() {
	      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref$clearRedrawFlags = _ref.clearRedrawFlags,
	          clearRedrawFlags = _ref$clearRedrawFlags === void 0 ? true : _ref$clearRedrawFlags;

	      var redraw = this._needsRedraw;

	      if (clearRedrawFlags) {
	        this._needsRedraw = false;
	      }

	      return redraw;
	    } // Layers will be redrawn (in next animation frame)

	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw(reason) {
	      this._needsRedraw = this._needsRedraw || reason;
	    } // Layers will be updated deeply (in next animation frame)
	    // Potentially regenerating attributes and sub layers

	  }, {
	    key: "setNeedsUpdate",
	    value: function setNeedsUpdate(reason) {
	      this._needsUpdate = this._needsUpdate || reason;
	      this._needsRedraw = this._needsRedraw || reason;
	    } // Get a set of viewports for a given width and height
	    // TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props

	  }, {
	    key: "getViewports",
	    value: function getViewports() {
	      this._rebuildViewportsFromViews();

	      return this._viewports;
	    }
	    /**
	     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
	     * using viewport projection parameters
	     * - [longitude, latitude] to [x, y]
	     * - [longitude, latitude, Z] => [x, y, z]
	     * Note: By default, returns top-left coordinates for canvas/SVG type render
	     *
	     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
	     * @param {Object} opts - options
	     * @param {Object} opts.topLeft=true - Whether projected coords are top left
	     * @return {Array} - [x, y] or [x, y, z] in top left coords
	     */

	  }, {
	    key: "project",
	    value: function project(xyz) {
	      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
	        topLeft: true
	      };
	      var viewports = this.getViewports();

	      for (var i = viewports.length - 1; i >= 0; --i) {
	        var viewport = viewports[i];

	        if (viewport.contains(xyz, opts)) {
	          return viewport.project(xyz, opts);
	        }
	      }

	      return null;
	    }
	    /**
	     * Unproject pixel coordinates on screen onto world coordinates,
	     * (possibly [lon, lat]) on map.
	     * - [x, y] => [lng, lat]
	     * - [x, y, z] => [lng, lat, Z]
	     * @param {Array} xyz -
	     * @param {Object} opts - options
	     * @param {Object} opts.topLeft=true - Whether origin is top left
	     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
	     */

	  }, {
	    key: "unproject",
	    value: function unproject(xyz, opts) {
	      var viewports = this.getViewports();

	      for (var i = viewports.length - 1; i >= 0; --i) {
	        var viewport = viewports[i];

	        if (viewport.containsPixel(xyz, opts)) {
	          return viewport.unproject(xyz);
	        }
	      }

	      return null;
	    }
	    /**
	     * Set props needed for layer rendering and picking.
	     * Parameters are to be passed as a single object, with the following values:
	     * @param {Boolean} useDevicePixels
	     */

	    /* eslint-disable complexity */

	  }, {
	    key: "setProps",
	    value: function setProps(props) {
	      if ('views' in props) {
	        this.setViews(props.views);
	      } // TODO - support multiple view states


	      if ('viewState' in props) {
	        this.setViewState(props.viewState);
	      }

	      if ('width' in props || 'height' in props) {
	        this.setSize(props.width, props.height);
	      }

	      if ('useDevicePixels' in props) {
	        this.context.useDevicePixels = props.useDevicePixels;
	      }
	    }
	    /* eslint-enable complexity */

	  }, {
	    key: "setSize",
	    value: function setSize(width, height) {
	      (0, _assert.default)(Number.isFinite(width) && Number.isFinite(height));

	      if (width !== this.width || height !== this.height) {
	        this.width = width;
	        this.height = height;
	        this.setNeedsUpdate('Size changed');
	      }
	    } // Update the view descriptor list and set change flag if needed
	    // Does not actually rebuild the `Viewport`s until `getViewports` is called

	  }, {
	    key: "setViews",
	    value: function setViews(views) {
	      // DEPRECATED: Ensure any "naked" Viewports are wrapped in View instances
	      views = (0, _flatten.flatten)(views, {
	        filter: Boolean
	      }).map(function (view) {
	        return _instanceof(view, _viewport.default) ? new _view.default({
	          viewportInstance: view
	        }) : view;
	      });

	      var viewsChanged = this._diffViews(views, this.views);

	      if (viewsChanged) {
	        this.setNeedsUpdate('views changed');
	      }

	      this.views = views;
	    }
	  }, {
	    key: "setViewState",
	    value: function setViewState(viewState) {
	      if (viewState) {
	        var viewStateChanged = (0, _deepEqual.deepEqual)(viewState, this.viewState);

	        if (viewStateChanged) {
	          this.setNeedsUpdate('viewState changed');
	        }

	        this.viewState = viewState;
	      } else {
	        _log.default.warn('setting null viewState')();
	      }
	    } //
	    // PRIVATE METHODS
	    //
	    // Rebuilds viewports from descriptors towards a certain window size

	  }, {
	    key: "_rebuildViewportsFromViews",
	    value: function _rebuildViewportsFromViews() {
	      var updateReason = this._needsUpdate;

	      if (updateReason) {
	        var width = this.width,
	            height = this.height,
	            views = this.views,
	            viewState = this.viewState;
	        this._viewports = views.map(function (view) {
	          return view.makeViewport({
	            width: width,
	            height: height,
	            viewState: viewState
	          });
	        }); // We've just rebuilt the Viewports to match the View descriptors,
	        // so clear the update flag and set the render flag

	        this._needsUpdate = false;
	      }
	    } // Check if viewport array has changed, returns true if any change
	    // Note that descriptors can be the same

	  }, {
	    key: "_diffViews",
	    value: function _diffViews(newViews, oldViews) {
	      if (newViews.length !== oldViews.length) {
	        return true;
	      }

	      return newViews.some(function (_, i) {
	        return !newViews[i].equals(oldViews[i]);
	      });
	    }
	  }]);

	  return ViewManager;
	}();

	exports.default = ViewManager;
	//# sourceMappingURL=view-manager.js.map

/***/ }),
/* 280 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.deepEqual = deepEqual;

	// Compare two objects, partial deep equal
	function deepEqual(a, b) {
	  // TODO - implement deep equal on view descriptors
	  return Object.keys(a).some(function (key) {
	    if (Array.isArray(a[key]) && Array.isArray(b[key])) {
	      return deepEqual(a[key], b[key]);
	    }

	    return a[key] === b[key];
	  });
	}
	//# sourceMappingURL=deep-equal.js.map

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _positions = __webpack_require__(285);

	var _deepEqual = __webpack_require__(280);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var View =
	/*#__PURE__*/
	function () {
	  function View() {
	    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, View);

	    var _props$id = props.id,
	        id = _props$id === void 0 ? null : _props$id,
	        _props$x = props.x,
	        x = _props$x === void 0 ? 0 : _props$x,
	        _props$y = props.y,
	        y = _props$y === void 0 ? 0 : _props$y,
	        _props$width = props.width,
	        width = _props$width === void 0 ? '100%' : _props$width,
	        _props$height = props.height,
	        height = _props$height === void 0 ? '100%' : _props$height,
	        _props$projectionMatr = props.projectionMatrix,
	        projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr,
	        _props$fovy = props.fovy,
	        fovy = _props$fovy === void 0 ? 75 : _props$fovy,
	        _props$near = props.near,
	        near = _props$near === void 0 ? 0.1 : _props$near,
	        _props$far = props.far,
	        far = _props$far === void 0 ? 1000 : _props$far,
	        _props$modelMatrix = props.modelMatrix,
	        modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix,
	        _props$viewportInstan = props.viewportInstance,
	        viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan,
	        _props$type = props.type,
	        type = _props$type === void 0 ? _viewport.default : _props$type;
	    (0, _assert.default)(!viewportInstance || _instanceof(viewportInstance, _viewport.default));
	    this.viewportInstance = viewportInstance; // Id

	    this.id = id || this.constructor.displayName || 'view';
	    this.type = type;
	    this.props = Object.assign({}, props, {
	      projectionMatrix: projectionMatrix,
	      fovy: fovy,
	      near: near,
	      far: far,
	      modelMatrix: modelMatrix
	    }); // Extents

	    this._parseDimensions({
	      x: x,
	      y: y,
	      width: width,
	      height: height
	    }); // Bind methods for easy access


	    this.equals = this.equals.bind(this);
	    Object.seal(this);
	  }

	  _createClass(View, [{
	    key: "equals",
	    value: function equals(view) {
	      if (this === view) {
	        return true;
	      } // if `viewportInstance` is set, it is the only prop that is used
	      // Delegate to `Viewport.equals`


	      if (this.viewportInstance) {
	        return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);
	      } // TODO - implement deep equal on view descriptors


	      var viewChanged = (0, _deepEqual.deepEqual)(this, view);
	      return viewChanged;
	    } // Build a `Viewport` from a view descriptor
	    // TODO - add support for autosizing viewports using width and height

	  }, {
	    key: "makeViewport",
	    value: function makeViewport(_ref) {
	      var width = _ref.width,
	          height = _ref.height,
	          viewState = _ref.viewState;

	      if (this.viewportInstance) {
	        return this.viewportInstance;
	      } // Resolve relative viewport dimensions


	      var viewportDimensions = this.getDimensions({
	        width: width,
	        height: height
	      });
	      var props = Object.assign({
	        viewState: viewState
	      }, viewState, this.props, viewportDimensions);
	      return this._getViewport(props);
	    } // Resolve relative viewport dimensions into actual dimensions (y='50%', width=800 => y=400)

	  }, {
	    key: "getDimensions",
	    value: function getDimensions(_ref2) {
	      var width = _ref2.width,
	          height = _ref2.height;
	      return {
	        x: (0, _positions.getPosition)(this._x, width),
	        y: (0, _positions.getPosition)(this._y, height),
	        width: (0, _positions.getPosition)(this._width, width),
	        height: (0, _positions.getPosition)(this._height, height)
	      };
	    } // Overridable method

	  }, {
	    key: "_getViewport",
	    value: function _getViewport(props) {
	      // Get the type of the viewport
	      var ViewportType = this.type;
	      return new ViewportType(props);
	    } // Parse relative viewport dimension descriptors (e.g {y: '50%', height: '50%'})

	  }, {
	    key: "_parseDimensions",
	    value: function _parseDimensions(_ref3) {
	      var x = _ref3.x,
	          y = _ref3.y,
	          width = _ref3.width,
	          height = _ref3.height;
	      this._x = (0, _positions.parsePosition)(x);
	      this._y = (0, _positions.parsePosition)(y);
	      this._width = (0, _positions.parsePosition)(width);
	      this._height = (0, _positions.parsePosition)(height);
	    }
	  }]);

	  return View;
	}();

	exports.default = View;
	//# sourceMappingURL=view.js.map

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _mathUtils = __webpack_require__(283);

	var _math = __webpack_require__(109);

	var _scale = _interopRequireDefault(__webpack_require__(137));

	var _translate = _interopRequireDefault(__webpack_require__(138));

	var _multiply = _interopRequireDefault(__webpack_require__(135));

	var _invert = _interopRequireDefault(__webpack_require__(134));

	var _viewportMercatorProject = __webpack_require__(240);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var DEGREES_TO_RADIANS = Math.PI / 180;
	var IDENTITY = (0, _mathUtils.createMat4)();
	var ZERO_VECTOR = [0, 0, 0];
	var DEFAULT_DISTANCE_SCALES = {
	  pixelsPerMeter: [1, 1, 1],
	  metersPerPixel: [1, 1, 1],
	  pixelsPerDegree: [1, 1, 1],
	  degreesPerPixel: [1, 1, 1]
	};
	var DEFAULT_ZOOM = 0;
	var ERR_ARGUMENT = 'Illegal argument to Viewport';

	var Viewport =
	/*#__PURE__*/
	function () {
	  /**
	   * @classdesc
	   * Manages coordinate system transformations for deck.gl.
	   *
	   * Note: The Viewport is immutable in the sense that it only has accessors.
	   * A new viewport instance should be created if any parameters have changed.
	   */
	  function Viewport() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, Viewport);

	    var _opts$id = opts.id,
	        id = _opts$id === void 0 ? null : _opts$id,
	        _opts$x = opts.x,
	        x = _opts$x === void 0 ? 0 : _opts$x,
	        _opts$y = opts.y,
	        y = _opts$y === void 0 ? 0 : _opts$y,
	        _opts$width = opts.width,
	        width = _opts$width === void 0 ? 1 : _opts$width,
	        _opts$height = opts.height,
	        height = _opts$height === void 0 ? 1 : _opts$height;
	    this.id = id || this.constructor.displayName || 'viewport';
	    this.x = x;
	    this.y = y; // Silently allow apps to send in w,h = 0,0

	    this.width = width || 1;
	    this.height = height || 1;

	    this._initViewMatrix(opts);

	    this._initProjectionMatrix(opts);

	    this._initPixelMatrices(); // Bind methods for easy access


	    this.equals = this.equals.bind(this);
	    this.project = this.project.bind(this);
	    this.unproject = this.unproject.bind(this);
	    this.projectFlat = this.projectFlat.bind(this);
	    this.unprojectFlat = this.unprojectFlat.bind(this);
	    this.getMatrices = this.getMatrices.bind(this);
	  } // Two viewports are equal if width and height are identical, and if
	  // their view and projection matrices are (approximately) equal.


	  _createClass(Viewport, [{
	    key: "equals",
	    value: function equals(viewport) {
	      if (!_instanceof(viewport, Viewport)) {
	        return false;
	      }

	      return viewport.width === this.width && viewport.height === this.height && (0, _math.equals)(viewport.projectionMatrix, this.projectionMatrix) && (0, _math.equals)(viewport.viewMatrix, this.viewMatrix); // TODO - check distance scales?
	    }
	    /**
	     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
	     * using viewport projection parameters
	     * - [longitude, latitude] to [x, y]
	     * - [longitude, latitude, Z] => [x, y, z]
	     * Note: By default, returns top-left coordinates for canvas/SVG type render
	     *
	     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
	     * @param {Object} opts - options
	     * @param {Object} opts.topLeft=true - Whether projected coords are top left
	     * @return {Array} - [x, y] or [x, y, z] in top left coords
	     */

	  }, {
	    key: "project",
	    value: function project(xyz) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref$topLeft = _ref.topLeft,
	          topLeft = _ref$topLeft === void 0 ? true : _ref$topLeft;

	      var _xyz = _slicedToArray(xyz, 3),
	          x0 = _xyz[0],
	          y0 = _xyz[1],
	          _xyz$ = _xyz[2],
	          z0 = _xyz$ === void 0 ? 0 : _xyz$;

	      var _this$projectFlat = this.projectFlat([x0, y0]),
	          _this$projectFlat2 = _slicedToArray(_this$projectFlat, 2),
	          X = _this$projectFlat2[0],
	          Y = _this$projectFlat2[1];

	      var coord = (0, _viewportMercatorProject.worldToPixels)([X, Y, z0], this.pixelProjectionMatrix);

	      var _coord = _slicedToArray(coord, 2),
	          x = _coord[0],
	          y = _coord[1];

	      var y2 = topLeft ? y : this.height - y;
	      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
	    }
	    /**
	     * Unproject pixel coordinates on screen onto world coordinates,
	     * (possibly [lon, lat]) on map.
	     * - [x, y] => [lng, lat]
	     * - [x, y, z] => [lng, lat, Z]
	     * @param {Array} xyz -
	     * @param {Object} opts - options
	     * @param {Object} opts.topLeft=true - Whether origin is top left
	     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
	     */

	  }, {
	    key: "unproject",
	    value: function unproject(xyz) {
	      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref2$topLeft = _ref2.topLeft,
	          topLeft = _ref2$topLeft === void 0 ? true : _ref2$topLeft,
	          targetZ = _ref2.targetZ;

	      var _xyz2 = _slicedToArray(xyz, 3),
	          x = _xyz2[0],
	          y = _xyz2[1],
	          z = _xyz2[2];

	      var y2 = topLeft ? y : this.height - y;
	      var coord = (0, _viewportMercatorProject.pixelsToWorld)([x, y2, z], this.pixelUnprojectionMatrix, targetZ);

	      var _this$unprojectFlat = this.unprojectFlat(coord),
	          _this$unprojectFlat2 = _slicedToArray(_this$unprojectFlat, 2),
	          X = _this$unprojectFlat2[0],
	          Y = _this$unprojectFlat2[1];

	      if (Number.isFinite(z)) {
	        // Has depth component
	        return [X, Y, coord[2]];
	      }

	      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
	    } // NON_LINEAR PROJECTION HOOKS
	    // Used for web meractor projection

	    /**
	     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
	     * Performs the nonlinear part of the web mercator projection.
	     * Remaining projection is done with 4x4 matrices which also handles
	     * perspective.
	     * @param {Array} lngLat - [lng, lat] coordinates
	     *   Specifies a point on the sphere to project onto the map.
	     * @return {Array} [x,y] coordinates.
	     */

	  }, {
	    key: "projectFlat",
	    value: function projectFlat(_ref3) {
	      var _ref4 = _slicedToArray(_ref3, 2),
	          x = _ref4[0],
	          y = _ref4[1];

	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return this._projectFlat.apply(this, arguments);
	    }
	    /**
	     * Unproject world point [x,y] on map onto {lat, lon} on sphere
	     * @param {object|Vector} xy - object with {x,y} members
	     *  representing point on projected map plane
	     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
	     *   Has toArray method if you need a GeoJSON Array.
	     *   Per cartographic tradition, lat and lon are specified as degrees.
	     */

	  }, {
	    key: "unprojectFlat",
	    value: function unprojectFlat(xyz) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return this._unprojectFlat.apply(this, arguments);
	    } // TODO - why do we need these?

	  }, {
	    key: "_projectFlat",
	    value: function _projectFlat(xyz) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return xyz;
	    }
	  }, {
	    key: "_unprojectFlat",
	    value: function _unprojectFlat(xyz) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return xyz;
	    }
	  }, {
	    key: "getMercatorParams",
	    value: function getMercatorParams() {
	      var lngLat = this._addMetersToLngLat([this.longitude || 0, this.latitude || 0], this.meterOffset);

	      return {
	        longitude: lngLat[0],
	        latitude: lngLat[1]
	      };
	    }
	  }, {
	    key: "isMapSynched",
	    value: function isMapSynched() {
	      return false;
	    }
	  }, {
	    key: "getDistanceScales",
	    value: function getDistanceScales() {
	      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	      if (coordinateOrigin) {
	        return (0, _viewportMercatorProject.getDistanceScales)({
	          longitude: coordinateOrigin[0],
	          latitude: coordinateOrigin[1],
	          scale: this.scale,
	          highPrecision: true
	        });
	      }

	      return this.distanceScales;
	    }
	  }, {
	    key: "getMatrices",
	    value: function getMatrices() {
	      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	          _ref5$modelMatrix = _ref5.modelMatrix,
	          modelMatrix = _ref5$modelMatrix === void 0 ? null : _ref5$modelMatrix;

	      var modelViewProjectionMatrix = this.viewProjectionMatrix;
	      var pixelProjectionMatrix = this.pixelProjectionMatrix;
	      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;

	      if (modelMatrix) {
	        modelViewProjectionMatrix = (0, _multiply.default)([], this.viewProjectionMatrix, modelMatrix);
	        pixelProjectionMatrix = (0, _multiply.default)([], this.pixelProjectionMatrix, modelMatrix);
	        pixelUnprojectionMatrix = (0, _invert.default)([], pixelProjectionMatrix);
	      }

	      var matrices = Object.assign({
	        modelViewProjectionMatrix: modelViewProjectionMatrix,
	        viewProjectionMatrix: this.viewProjectionMatrix,
	        viewMatrix: this.viewMatrix,
	        projectionMatrix: this.projectionMatrix,
	        // project/unproject between pixels and world
	        pixelProjectionMatrix: pixelProjectionMatrix,
	        pixelUnprojectionMatrix: pixelUnprojectionMatrix,
	        width: this.width,
	        height: this.height,
	        scale: this.scale
	      });
	      return matrices;
	    } // EXPERIMENTAL METHODS

	  }, {
	    key: "getCameraPosition",
	    value: function getCameraPosition() {
	      return this.cameraPosition;
	    }
	  }, {
	    key: "getCameraDirection",
	    value: function getCameraDirection() {
	      return this.cameraDirection;
	    }
	  }, {
	    key: "getCameraUp",
	    value: function getCameraUp() {
	      return this.cameraUp;
	    } // INTERNAL METHODS
	    // TODO - these are duplicating WebMercator methods

	  }, {
	    key: "_addMetersToLngLat",
	    value: function _addMetersToLngLat(lngLatZ, xyz) {
	      var _lngLatZ = _slicedToArray(lngLatZ, 3),
	          lng = _lngLatZ[0],
	          lat = _lngLatZ[1],
	          _lngLatZ$ = _lngLatZ[2],
	          Z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

	      var _this$_metersToLngLat = this._metersToLngLatDelta(xyz),
	          _this$_metersToLngLat2 = _slicedToArray(_this$_metersToLngLat, 3),
	          deltaLng = _this$_metersToLngLat2[0],
	          deltaLat = _this$_metersToLngLat2[1],
	          _this$_metersToLngLat3 = _this$_metersToLngLat2[2],
	          deltaZ = _this$_metersToLngLat3 === void 0 ? 0 : _this$_metersToLngLat3;

	      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
	    }
	  }, {
	    key: "_metersToLngLatDelta",
	    value: function _metersToLngLatDelta(xyz) {
	      var _xyz3 = _slicedToArray(xyz, 3),
	          x = _xyz3[0],
	          y = _xyz3[1],
	          _xyz3$ = _xyz3[2],
	          z = _xyz3$ === void 0 ? 0 : _xyz3$;

	      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
	      var _this$distanceScales = this.distanceScales,
	          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
	          degreesPerPixel = _this$distanceScales.degreesPerPixel;
	      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
	      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
	      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
	    }
	  }, {
	    key: "_createProjectionMatrix",
	    value: function _createProjectionMatrix(_ref6) {
	      var orthographic = _ref6.orthographic,
	          fovyRadians = _ref6.fovyRadians,
	          aspect = _ref6.aspect,
	          focalDistance = _ref6.focalDistance,
	          near = _ref6.near,
	          far = _ref6.far;
	      (0, _assert.default)(Number.isFinite(fovyRadians));
	      return orthographic ? new _math.Matrix4().orthographic({
	        fovy: fovyRadians,
	        aspect: aspect,
	        focalDistance: focalDistance,
	        near: near,
	        far: far
	      }) : new _math.Matrix4().perspective({
	        fovy: fovyRadians,
	        aspect: aspect,
	        near: near,
	        far: far
	      });
	    }
	    /* eslint-disable complexity, max-statements */

	  }, {
	    key: "_initViewMatrix",
	    value: function _initViewMatrix(opts) {
	      var _opts$viewMatrix = opts.viewMatrix,
	          viewMatrix = _opts$viewMatrix === void 0 ? IDENTITY : _opts$viewMatrix,
	          _opts$longitude = opts.longitude,
	          longitude = _opts$longitude === void 0 ? null : _opts$longitude,
	          _opts$latitude = opts.latitude,
	          latitude = _opts$latitude === void 0 ? null : _opts$latitude,
	          _opts$zoom = opts.zoom,
	          zoom = _opts$zoom === void 0 ? null : _opts$zoom,
	          _opts$position = opts.position,
	          position = _opts$position === void 0 ? null : _opts$position,
	          _opts$modelMatrix = opts.modelMatrix,
	          modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,
	          _opts$focalDistance = opts.focalDistance,
	          focalDistance = _opts$focalDistance === void 0 ? 1 : _opts$focalDistance,
	          _opts$distanceScales = opts.distanceScales,
	          distanceScales = _opts$distanceScales === void 0 ? null : _opts$distanceScales; // Check if we have a geospatial anchor

	      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
	      this.zoom = zoom;

	      if (!Number.isFinite(this.zoom)) {
	        this.zoom = this.isGeospatial ? (0, _viewportMercatorProject.getMeterZoom)({
	          latitude: latitude
	        }) + Math.log2(focalDistance) : DEFAULT_ZOOM;
	      }

	      this.scale = Math.pow(2, this.zoom); // Calculate distance scales if lng/lat/zoom are provided

	      this.distanceScales = this.isGeospatial ? (0, _viewportMercatorProject.getDistanceScales)({
	        latitude: latitude,
	        longitude: longitude,
	        scale: this.scale
	      }) : distanceScales || DEFAULT_DISTANCE_SCALES;
	      this.focalDistance = focalDistance;
	      this.distanceScales.metersPerPixel = new _math.Vector3(this.distanceScales.metersPerPixel);
	      this.distanceScales.pixelsPerMeter = new _math.Vector3(this.distanceScales.pixelsPerMeter);
	      this.position = ZERO_VECTOR;
	      this.meterOffset = ZERO_VECTOR;

	      if (position) {
	        // Apply model matrix if supplied
	        this.position = position;
	        this.modelMatrix = modelMatrix;
	        this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;
	      }

	      this.viewMatrixUncentered = viewMatrix;

	      if (this.isGeospatial) {
	        // Determine camera center
	        this.center = (0, _viewportMercatorProject.getWorldPosition)({
	          longitude: longitude,
	          latitude: latitude,
	          scale: this.scale,
	          distanceScales: this.distanceScales,
	          meterOffset: this.meterOffset
	        }); // Make a centered version of the matrix for projection modes without an offset

	        this.viewMatrix = new _math.Matrix4() // Apply the uncentered view matrix
	        .multiplyRight(this.viewMatrixUncentered) // The Mercator world coordinate system is upper left,
	        // but GL expects lower left, so we flip it around the center after all transforms are done
	        .scale([1, -1, 1]) // And center it
	        .translate(new _math.Vector3(this.center || ZERO_VECTOR).negate());
	      } else {
	        this.center = position;
	        this.viewMatrix = viewMatrix;
	      }
	    }
	    /* eslint-enable complexity, max-statements */

	  }, {
	    key: "_initProjectionMatrix",
	    value: function _initProjectionMatrix(opts) {
	      var _opts$projectionMatri = opts.projectionMatrix,
	          projectionMatrix = _opts$projectionMatri === void 0 ? null : _opts$projectionMatri,
	          _opts$orthographic = opts.orthographic,
	          orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic,
	          fovyRadians = opts.fovyRadians,
	          fovyDegrees = opts.fovyDegrees,
	          fovy = opts.fovy,
	          _opts$near = opts.near,
	          near = _opts$near === void 0 ? 0.1 : _opts$near,
	          _opts$far = opts.far,
	          far = _opts$far === void 0 ? 1000 : _opts$far,
	          _opts$focalDistance2 = opts.focalDistance,
	          focalDistance = _opts$focalDistance2 === void 0 ? 1 : _opts$focalDistance2,
	          orthographicFocalDistance = opts.orthographicFocalDistance;
	      var radians = fovyRadians || (fovyDegrees || fovy || 75) * DEGREES_TO_RADIANS;
	      this.projectionMatrix = projectionMatrix || this._createProjectionMatrix({
	        orthographic: orthographic,
	        fovyRadians: radians,
	        aspect: this.width / this.height,
	        focalDistance: orthographicFocalDistance || focalDistance,
	        near: near,
	        far: far
	      });
	    }
	  }, {
	    key: "_initPixelMatrices",
	    value: function _initPixelMatrices() {
	      // Note: As usual, matrix operations should be applied in "reverse" order
	      // since vectors will be multiplied in from the right during transformation
	      var vpm = (0, _mathUtils.createMat4)();
	      (0, _multiply.default)(vpm, vpm, this.projectionMatrix);
	      (0, _multiply.default)(vpm, vpm, this.viewMatrix);
	      this.viewProjectionMatrix = vpm; // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);
	      // Calculate inverse view matrix

	      this.viewMatrixInverse = (0, _invert.default)([], this.viewMatrix) || this.viewMatrix; // Decompose camera directions

	      var _extractCameraVectors = (0, _mathUtils.extractCameraVectors)({
	        viewMatrix: this.viewMatrix,
	        viewMatrixInverse: this.viewMatrixInverse
	      }),
	          eye = _extractCameraVectors.eye,
	          direction = _extractCameraVectors.direction,
	          up = _extractCameraVectors.up;

	      this.cameraPosition = eye;
	      this.cameraDirection = direction;
	      this.cameraUp = up; // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);

	      /*
	       * Builds matrices that converts preprojected lngLats to screen pixels
	       * and vice versa.
	       * Note: Currently returns bottom-left coordinates!
	       * Note: Starts with the GL projection matrix and adds steps to the
	       *       scale and translate that matrix onto the window.
	       * Note: WebGL controls clip space to screen projection with gl.viewport
	       *       and does not need this step.
	       */
	      // matrix for conversion from world location to screen (pixel) coordinates

	      var m = (0, _mathUtils.createMat4)();
	      (0, _scale.default)(m, m, [this.width / 2, -this.height / 2, 1]);
	      (0, _translate.default)(m, m, [1, -1, 0]);
	      (0, _multiply.default)(m, m, this.viewProjectionMatrix);
	      this.pixelProjectionMatrix = m;
	      this.pixelUnprojectionMatrix = (0, _invert.default)((0, _mathUtils.createMat4)(), this.pixelProjectionMatrix);

	      if (!this.pixelUnprojectionMatrix) {
	        _log.default.warn('Pixel project matrix not invertible')(); // throw new Error('Pixel project matrix not invertible');

	      }
	    }
	  }]);

	  return Viewport;
	}();

	exports.default = Viewport;
	Viewport.displayName = 'Viewport';
	//# sourceMappingURL=viewport.js.map

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.transformVector = transformVector;
	exports.createMat4 = createMat4;
	exports.extractCameraVectors = extractCameraVectors;
	exports.mod = mod;

	var _multiply = _interopRequireDefault(__webpack_require__(284));

	var _transformMat = _interopRequireDefault(__webpack_require__(141));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Extensions to math.gl library. Intended to be folded back.
	function transformVector(matrix, vector) {
	  // Handle non-invertible matrix
	  if (!matrix) {
	    return null;
	  }

	  var result = (0, _transformMat.default)([0, 0, 0, 0], vector, matrix);
	  var scale = 1 / result[3];
	  (0, _multiply.default)(result, result, [scale, scale, scale, scale]);
	  return result;
	} // Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()


	function createMat4() {
	  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	} // Extract camera vectors (move to math library?)


	function extractCameraVectors(_ref) {
	  var viewMatrix = _ref.viewMatrix,
	      viewMatrixInverse = _ref.viewMatrixInverse;
	  // Read the translation from the inverse view matrix
	  return {
	    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],
	    direction: [viewMatrix[2], viewMatrix[6], viewMatrix[10]],
	    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]]
	  };
	}

	function mod(value, divisor) {
	  (0, _assert.default)(Number.isFinite(value) && Number.isFinite(divisor));
	  var modulus = value % divisor;
	  return modulus < 0 ? divisor + modulus : modulus;
	}
	//# sourceMappingURL=math-utils.js.map

/***/ }),
/* 284 */
/***/ (function(module, exports) {

	module.exports = multiply

	/**
	 * Multiplies two vec4's
	 *
	 * @param {vec4} out the receiving vector
	 * @param {vec4} a the first operand
	 * @param {vec4} b the second operand
	 * @returns {vec4} out
	 */
	function multiply (out, a, b) {
	  out[0] = a[0] * b[0]
	  out[1] = a[1] * b[1]
	  out[2] = a[2] * b[2]
	  out[3] = a[3] * b[3]
	  return out
	}


/***/ }),
/* 285 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.parsePosition = parsePosition;
	exports.getPosition = getPosition;

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/; // Takes a number or a string of formats `50%`, `33.3%` or `200px`

	function parsePosition(value) {
	  switch (_typeof(value)) {
	    case 'number':
	      return {
	        position: value,
	        relative: false
	      };

	    case 'string':
	      var match = value.match(PERCENT_OR_PIXELS_REGEX);

	      if (match && match.length >= 3) {
	        var relative = match[2] === '%';
	        var position = parseFloat(match[1]);
	        return {
	          position: relative ? position / 100 : position,
	          relative: relative
	        };
	      }

	    // fallthrough

	    default:
	      // eslint-disable-line
	      throw new Error("Could not parse position string ".concat(value));
	  }
	}

	function getPosition(position, extent) {
	  return position.relative ? Math.round(position.position * extent) : position.position;
	}
	//# sourceMappingURL=positions.js.map

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _webMercatorViewport = _interopRequireDefault(__webpack_require__(287));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var MapView =
	/*#__PURE__*/
	function (_View) {
	  _inherits(MapView, _View);

	  function MapView(props) {
	    _classCallCheck(this, MapView);

	    return _possibleConstructorReturn(this, (MapView.__proto__ || Object.getPrototypeOf(MapView)).call(this, Object.assign({}, props, {
	      type: _webMercatorViewport.default
	    })));
	  }

	  return MapView;
	}(_view.default);

	exports.default = MapView;
	MapView.displayName = 'MapView';
	//# sourceMappingURL=map-view.js.map

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _viewportMercatorProject = __webpack_require__(240);

	var _add = _interopRequireDefault(__webpack_require__(248));

	var _negate = _interopRequireDefault(__webpack_require__(249));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	var ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';

	var WebMercatorViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(WebMercatorViewport, _Viewport);

	  /**
	   * @classdesc
	   * Creates view/projection matrices from mercator params
	   * Note: The Viewport is immutable in the sense that it only has accessors.
	   * A new viewport instance should be created if any parameters have changed.
	   */

	  /* eslint-disable complexity, max-statements */
	  function WebMercatorViewport() {
	    var _this;

	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, WebMercatorViewport);

	    var _opts$latitude = opts.latitude,
	        latitude = _opts$latitude === void 0 ? 0 : _opts$latitude,
	        _opts$longitude = opts.longitude,
	        longitude = _opts$longitude === void 0 ? 0 : _opts$longitude,
	        _opts$zoom = opts.zoom,
	        zoom = _opts$zoom === void 0 ? 11 : _opts$zoom,
	        _opts$pitch = opts.pitch,
	        pitch = _opts$pitch === void 0 ? 0 : _opts$pitch,
	        _opts$bearing = opts.bearing,
	        bearing = _opts$bearing === void 0 ? 0 : _opts$bearing,
	        _opts$farZMultiplier = opts.farZMultiplier,
	        farZMultiplier = _opts$farZMultiplier === void 0 ? 10 : _opts$farZMultiplier,
	        _opts$orthographic = opts.orthographic,
	        orthographic = _opts$orthographic === void 0 ? false : _opts$orthographic;
	    var width = opts.width,
	        height = opts.height,
	        _opts$altitude = opts.altitude,
	        altitude = _opts$altitude === void 0 ? 1.5 : _opts$altitude; // Silently allow apps to send in 0,0 to facilitate isomorphic render etc

	    width = width || 1;
	    height = height || 1; // Altitude - prevent division by 0
	    // TODO - just throw an Error instead?

	    altitude = Math.max(0.75, altitude);

	    var _getProjectionParamet = (0, _viewportMercatorProject.getProjectionParameters)({
	      width: width,
	      height: height,
	      pitch: pitch,
	      altitude: altitude,
	      farZMultiplier: farZMultiplier
	    }),
	        fov = _getProjectionParamet.fov,
	        aspect = _getProjectionParamet.aspect,
	        focalDistance = _getProjectionParamet.focalDistance,
	        near = _getProjectionParamet.near,
	        far = _getProjectionParamet.far; // The uncentered matrix allows us two move the center addition to the
	    // shader (cheap) which gives a coordinate system that has its center in
	    // the layer's center position. This makes rotations and other modelMatrx
	    // transforms much more useful.


	    var viewMatrixUncentered = (0, _viewportMercatorProject.getViewMatrix)({
	      height: height,
	      pitch: pitch,
	      bearing: bearing,
	      altitude: altitude
	    }); // TODO / hack - prevent vertical offsets if not FirstPersonViewport

	    var position = opts.position && [opts.position[0], opts.position[1], 0];
	    var viewportOpts = Object.assign({}, opts, {
	      // x, y,
	      width: width,
	      height: height,
	      // view matrix
	      viewMatrix: viewMatrixUncentered,
	      longitude: longitude,
	      latitude: latitude,
	      zoom: zoom,
	      position: position,
	      // projection matrix parameters
	      orthographic: orthographic,
	      fovyRadians: fov,
	      aspect: aspect,
	      // TODO Viewport is already carefully set up to "focus" on ground, so can't use focal distance
	      orthographicFocalDistance: focalDistance,
	      near: near,
	      far: far
	    });
	    _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, viewportOpts)); // Save parameters

	    _this.latitude = latitude;
	    _this.longitude = longitude;
	    _this.zoom = zoom;
	    _this.pitch = pitch;
	    _this.bearing = bearing;
	    _this.altitude = altitude;
	    _this.orthographic = orthographic; // Bind methods

	    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_assertThisInitialized(_this));
	    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_assertThisInitialized(_this));
	    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_assertThisInitialized(_this));
	    Object.freeze(_assertThisInitialized(_this));
	    return _this;
	  }
	  /* eslint-enable complexity, max-statements */

	  /**
	   * Converts a meter offset to a lnglat offset
	   *
	   * Note: Uses simple linear approximation around the viewport center
	   * Error increases with size of offset (roughly 1% per 100km)
	   *
	   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
	   * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas
	   */


	  _createClass(WebMercatorViewport, [{
	    key: "metersToLngLatDelta",
	    value: function metersToLngLatDelta(xyz) {
	      var _xyz = _slicedToArray(xyz, 3),
	          x = _xyz[0],
	          y = _xyz[1],
	          _xyz$ = _xyz[2],
	          z = _xyz$ === void 0 ? 0 : _xyz$;

	      (0, _assert.default)(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);
	      var _this$distanceScales = this.distanceScales,
	          pixelsPerMeter = _this$distanceScales.pixelsPerMeter,
	          degreesPerPixel = _this$distanceScales.degreesPerPixel;
	      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];
	      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];
	      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];
	    }
	    /**
	     * Converts a lnglat offset to a meter offset
	     *
	     * Note: Uses simple linear approximation around the viewport center
	     * Error increases with size of offset (roughly 1% per 100km)
	     *
	     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas
	     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas
	     */

	  }, {
	    key: "lngLatDeltaToMeters",
	    value: function lngLatDeltaToMeters(deltaLngLatZ) {
	      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),
	          deltaLng = _deltaLngLatZ[0],
	          deltaLat = _deltaLngLatZ[1],
	          _deltaLngLatZ$ = _deltaLngLatZ[2],
	          deltaZ = _deltaLngLatZ$ === void 0 ? 0 : _deltaLngLatZ$;

	      (0, _assert.default)(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);
	      var _this$distanceScales2 = this.distanceScales,
	          pixelsPerDegree = _this$distanceScales2.pixelsPerDegree,
	          metersPerPixel = _this$distanceScales2.metersPerPixel;
	      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];
	      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];
	      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];
	    }
	    /**
	     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
	     *
	     * Note: Uses simple linear approximation around the viewport center
	     * Error increases with size of offset (roughly 1% per 100km)
	     *
	     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
	     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
	     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
	     */

	  }, {
	    key: "addMetersToLngLat",
	    value: function addMetersToLngLat(lngLatZ, xyz) {
	      var _lngLatZ = _slicedToArray(lngLatZ, 3),
	          lng = _lngLatZ[0],
	          lat = _lngLatZ[1],
	          _lngLatZ$ = _lngLatZ[2],
	          Z = _lngLatZ$ === void 0 ? 0 : _lngLatZ$;

	      var _this$metersToLngLatD = this.metersToLngLatDelta(xyz),
	          _this$metersToLngLatD2 = _slicedToArray(_this$metersToLngLatD, 3),
	          deltaLng = _this$metersToLngLatD2[0],
	          deltaLat = _this$metersToLngLatD2[1],
	          _this$metersToLngLatD3 = _this$metersToLngLatD2[2],
	          deltaZ = _this$metersToLngLatD3 === void 0 ? 0 : _this$metersToLngLatD3;

	      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];
	    }
	    /**
	     * Get the map center that place a given [lng, lat] coordinate at screen
	     * point [x, y]
	     *
	     * @param {Array} lngLat - [lng,lat] coordinates
	     *   Specifies a point on the sphere.
	     * @param {Array} pos - [x,y] coordinates
	     *   Specifies a point on the screen.
	     * @return {Array} [lng,lat] new map center.
	     */

	  }, {
	    key: "getMapCenterByLngLatPosition",
	    value: function getMapCenterByLngLatPosition(_ref) {
	      var lngLat = _ref.lngLat,
	          pos = _ref.pos;
	      var fromLocation = (0, _viewportMercatorProject.pixelsToWorld)(pos, this.pixelUnprojectionMatrix);
	      var toLocation = (0, _viewportMercatorProject.lngLatToWorld)(lngLat, this.scale);
	      var translate = (0, _add.default)([], toLocation, (0, _negate.default)([], fromLocation));
	      var newCenter = (0, _add.default)([], this.center, translate);
	      return (0, _viewportMercatorProject.worldToLngLat)(newCenter, this.scale);
	    } // Legacy method name

	  }, {
	    key: "getLocationAtPoint",
	    value: function getLocationAtPoint(_ref2) {
	      var lngLat = _ref2.lngLat,
	          pos = _ref2.pos;
	      return this.getMapCenterByLngLatPosition({
	        lngLat: lngLat,
	        pos: pos
	      });
	    }
	    /**
	     * Returns a new viewport that fit around the given rectangle.
	     * Only supports non-perspective mode.
	     * @param {Array} bounds - [[lon, lat], [lon, lat]]
	     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.
	     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,
	     *    [x, y] measured in pixels.
	     * @returns {WebMercatorViewport}
	     */

	  }, {
	    key: "fitBounds",
	    value: function fitBounds(bounds) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var width = this.width,
	          height = this.height;

	      var _fitBounds2 = (0, _viewportMercatorProject.fitBounds)(Object.assign({
	        width: width,
	        height: height,
	        bounds: bounds
	      }, options)),
	          longitude = _fitBounds2.longitude,
	          latitude = _fitBounds2.latitude,
	          zoom = _fitBounds2.zoom;

	      return new WebMercatorViewport({
	        width: width,
	        height: height,
	        longitude: longitude,
	        latitude: latitude,
	        zoom: zoom
	      });
	    } // TODO - should support user supplied constraints

	  }, {
	    key: "isMapSynched",
	    value: function isMapSynched() {
	      var EPSILON = 0.000001;
	      var MAPBOX_LIMITS = {
	        pitch: 60,
	        zoom: 40
	      };
	      var pitch = this.pitch,
	          zoom = this.zoom;
	      return pitch <= MAPBOX_LIMITS.pitch + EPSILON && zoom <= MAPBOX_LIMITS.zoom + EPSILON;
	    } // INTERNAL METHODS
	    // Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.

	  }, {
	    key: "_projectFlat",
	    value: function _projectFlat(lngLat) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return (0, _viewportMercatorProject.lngLatToWorld)(lngLat, scale);
	    } // Unproject world point [x,y] on map onto {lat, lon} on sphere

	  }, {
	    key: "_unprojectFlat",
	    value: function _unprojectFlat(xy) {
	      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;
	      return (0, _viewportMercatorProject.worldToLngLat)(xy, scale);
	    }
	  }]);

	  return WebMercatorViewport;
	}(_viewport.default);

	exports.default = WebMercatorViewport;
	WebMercatorViewport.displayName = 'WebMercatorViewport';
	//# sourceMappingURL=web-mercator-viewport.js.map

/***/ }),
/* 288 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	/* eslint-disable no-try-catch */
	var EffectManager =
	/*#__PURE__*/
	function () {
	  function EffectManager(_ref) {
	    var gl = _ref.gl,
	        layerManager = _ref.layerManager;

	    _classCallCheck(this, EffectManager);

	    this.gl = gl;
	    this.layerManager = layerManager;
	    this._effects = [];
	  }
	  /**
	   * Adds an effect to be managed.  That effect's initialize function will
	   * be called, and the effect's preDraw and draw callbacks will be
	   * called at the appropriate times in the render loop
	   * @param {Effect} effect - the effect to be added
	   */


	  _createClass(EffectManager, [{
	    key: "addEffect",
	    value: function addEffect(effect) {
	      this._effects.push(effect);

	      this._sortEffects();

	      effect.initialize({
	        gl: this.gl,
	        layerManager: this.layerManager
	      });
	    }
	    /**
	     * Removes an effect that is already being managed.  That effect's
	     * finalize function will be called, and its callbacks will no longer
	     * be envoked in the render loop
	     * @param {Effect} effect - the effect to be removed
	     * @return {bool} - True if the effect was already being managed, and
	     * thus successfully removed; false otherwise
	     */

	  }, {
	    key: "removeEffect",
	    value: function removeEffect(effect) {
	      var i = this._effects.indexOf(effect);

	      if (i >= 0) {
	        effect.finalize({
	          gl: this.gl,
	          layerManager: this.layerManager
	        });

	        this._effects.splice(i, 1);

	        return true;
	      }

	      return false;
	    }
	    /**
	     * Envoke the preDraw callback of all managed events, in order of
	     * decreasing priority
	     */

	  }, {
	    key: "preDraw",
	    value: function preDraw() {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var effect = _step.value;

	          if (effect.needsRedraw) {
	            effect.preDraw({
	              gl: this.gl,
	              layerManager: this.layerManager
	            });
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	    /**
	     * Envoke the draw callback of all managed events, in order of
	     * decreasing priority
	     */

	  }, {
	    key: "draw",
	    value: function draw() {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this._effects[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var effect = _step2.value;

	          if (effect.needsRedraw) {
	            effect.draw({
	              gl: this.gl,
	              layerManager: this.layerManager
	            });
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  }, {
	    key: "_sortEffects",
	    value: function _sortEffects() {
	      this._effects.sort(function (a, b) {
	        if (a.priority > b.priority) {
	          return -1;
	        } else if (a.priority < b.priority) {
	          return 1;
	        }

	        return a.count - b.count;
	      });
	    }
	  }]);

	  return EffectManager;
	}();

	exports.default = EffectManager;
	//# sourceMappingURL=effect-manager.js.map

/***/ }),
/* 289 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var counter = 0;

	var Effect =
	/*#__PURE__*/
	function () {
	  function Effect() {
	    _classCallCheck(this, Effect);

	    this.id = 'effect';
	    this.count = counter++;
	    this.visible = true;
	    this.priority = 0;
	    this.needsRedraw = false;
	  }
	  /**
	   * subclasses should override to set up any resources needed
	   */


	  _createClass(Effect, [{
	    key: "initialize",
	    value: function initialize(_ref) {
	      var gl = _ref.gl,
	          layerManager = _ref.layerManager;
	    }
	    /**
	     * and subclasses should free those resources here
	     */

	  }, {
	    key: "finalize",
	    value: function finalize(_ref2) {
	      var gl = _ref2.gl,
	          layerManager = _ref2.layerManager;
	    }
	    /**
	     * override for a callback immediately before drawing each frame
	     */

	  }, {
	    key: "preDraw",
	    value: function preDraw(_ref3) {
	      var gl = _ref3.gl,
	          layerManager = _ref3.layerManager;
	    }
	    /**
	     * override for a callback immediately after drawing a frame's layers
	     */

	  }, {
	    key: "draw",
	    value: function draw(_ref4) {
	      var gl = _ref4.gl,
	          layerManager = _ref4.layerManager;
	    }
	  }, {
	    key: "setNeedsRedraw",
	    value: function setNeedsRedraw() {
	      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
	      this.needsRedraw = redraw;
	    }
	  }]);

	  return Effect;
	}();

	exports.default = Effect;
	//# sourceMappingURL=effect.js.map

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _eventManager = __webpack_require__(291);

	Object.defineProperty(exports, 'EventManager', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_eventManager).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJkZWZhdWx0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztpREFvQlFBLE8iLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5leHBvcnQge2RlZmF1bHQgYXMgRXZlbnRNYW5hZ2VyfSBmcm9tICcuL2V2ZW50LW1hbmFnZXInO1xuIl19

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _keys = __webpack_require__(292);

	var _keys2 = _interopRequireDefault(_keys);

	var _assign = __webpack_require__(328);

	var _assign2 = _interopRequireDefault(_assign);

	var _classCallCheck2 = __webpack_require__(334);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(335);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _hammer = __webpack_require__(339);

	var _wheelInput = __webpack_require__(376);

	var _wheelInput2 = _interopRequireDefault(_wheelInput);

	var _moveInput = __webpack_require__(378);

	var _moveInput2 = _interopRequireDefault(_moveInput);

	var _keyInput = __webpack_require__(379);

	var _keyInput2 = _interopRequireDefault(_keyInput);

	var _constants = __webpack_require__(377);

	var _eventUtils = __webpack_require__(380);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var DEFAULT_OPTIONS = {
	  // event handlers
	  events: null,
	  // custom recognizers
	  recognizers: null,
	  // Manager class
	  Manager: _hammer.Manager,
	  // recognize right button gestures
	  rightButton: false,
	  // block scrolling - this is a legacy behavior and will be removed in the next version
	  legacyBlockScroll: true
	};

	function preventDefault(evt) {
	  evt.preventDefault();
	}

	// Unified API for subscribing to events about both
	// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
	// and gestural input (e.g. 'click', 'tap', 'panstart').
	// Delegates gesture related event registration and handling to Hammer.js.

	var EventManager = function () {
	  function EventManager() {
	    var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    (0, _classCallCheck3.default)(this, EventManager);

	    this.options = (0, _assign2.default)({}, DEFAULT_OPTIONS, options);
	    this.eventHandlers = [];

	    this._onBasicInput = this._onBasicInput.bind(this);
	    this._onOtherEvent = this._onOtherEvent.bind(this);

	    this.setElement(element);

	    // Register all passed events.
	    var events = options.events;

	    if (events) {
	      this.on(events);
	    }
	  }

	  (0, _createClass3.default)(EventManager, [{
	    key: 'setElement',
	    value: function setElement(element) {
	      var _this = this;

	      if (this.element) {
	        // unregister all events
	        this.destroy();
	      }
	      this.element = element;
	      if (!element) {
	        return;
	      }

	      var options = this.options;

	      var ManagerClass = options.Manager;

	      this.manager = new ManagerClass(element, { recognizers: options.recognizers || _constants.RECOGNIZERS }).on('hammer.input', this._onBasicInput);

	      if (!options.recognizers) {
	        // Set default recognize withs
	        // http://hammerjs.github.io/recognize-with/
	        (0, _keys2.default)(_constants.RECOGNIZER_COMPATIBLE_MAP).forEach(function (name) {
	          var recognizer = _this.manager.get(name);
	          if (recognizer) {
	            _constants.RECOGNIZER_COMPATIBLE_MAP[name].forEach(function (otherName) {
	              recognizer.recognizeWith(otherName);
	            });
	          }
	        });
	      }

	      // Handle events not handled by Hammer.js:
	      // - mouse wheel
	      // - pointer/touch/mouse move
	      this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, {
	        enable: false,
	        legacyBlockScroll: options.legacyBlockScroll
	      });
	      this.moveInput = new _moveInput2.default(element, this._onOtherEvent, { enable: false });
	      this.keyInput = new _keyInput2.default(element, this._onOtherEvent, { enable: false });

	      if (options.rightButton) {
	        // Block right click
	        element.addEventListener('contextmenu', preventDefault);
	      }

	      // Register all existing events
	      this.eventHandlers.forEach(function (_ref) {
	        var recognizerName = _ref.recognizerName,
	            eventAlias = _ref.eventAlias,
	            wrappedHandler = _ref.wrappedHandler;

	        // Enable recognizer for this event.
	        _this._toggleRecognizer(recognizerName, true);
	        _this.manager.on(eventAlias, wrappedHandler);
	      });
	    }

	    // Tear down internal event management implementations.

	  }, {
	    key: 'destroy',
	    value: function destroy() {
	      if (this.element) {
	        this.element.removeEventListener('contextmenu', preventDefault);

	        // wheelInput etc. are created in setElement() and therefore
	        // cannot exist if there is no element
	        this.wheelInput.destroy();
	        this.moveInput.destroy();
	        this.keyInput.destroy();
	        this.manager.destroy();

	        this.wheelInput = null;
	        this.moveInput = null;
	        this.keyInput = null;
	        this.manager = null;
	        this.element = null;
	      }
	    }

	    // Register an event handler function to be called on `event`.

	  }, {
	    key: 'on',
	    value: function on(event, handler, srcElement) {
	      if (typeof event === 'string') {
	        this._addEventHandler(event, handler, srcElement);
	      } else {
	        srcElement = handler;
	        // If `event` is a map, call `on()` for each entry.
	        for (var eventName in event) {
	          this._addEventHandler(eventName, event[eventName], srcElement);
	        }
	      }
	    }

	    /**
	     * Deregister a previously-registered event handler.
	     * @param {string|Object} event   An event name (String) or map of event names to handlers
	     * @param {Function} [handler]    The function to be called on `event`.
	     */

	  }, {
	    key: 'off',
	    value: function off(event, handler) {
	      if (typeof event === 'string') {
	        this._removeEventHandler(event, handler);
	      } else {
	        // If `event` is a map, call `off()` for each entry.
	        for (var eventName in event) {
	          this._removeEventHandler(eventName, event[eventName]);
	        }
	      }
	    }

	    /*
	     * Enable/disable recognizer for the given event
	     */

	  }, {
	    key: '_toggleRecognizer',
	    value: function _toggleRecognizer(name, enabled) {
	      var manager = this.manager;

	      if (!manager) {
	        return;
	      }
	      var recognizer = manager.get(name);
	      if (recognizer) {
	        recognizer.set({ enable: enabled });

	        var fallbackRecognizers = _constants.RECOGNIZER_FALLBACK_MAP[name];
	        if (fallbackRecognizers && !this.options.recognizers) {
	          // Set default require failures
	          // http://hammerjs.github.io/require-failure/
	          fallbackRecognizers.forEach(function (otherName) {
	            var otherRecognizer = manager.get(otherName);
	            if (enabled) {
	              // Wait for this recognizer to fail
	              otherRecognizer.requireFailure(name);
	            } else {
	              // Do not wait for this recognizer to fail
	              otherRecognizer.dropRequireFailure(name);
	            }
	          });
	        }
	      }
	      this.wheelInput.enableEventType(name, enabled);
	      this.moveInput.enableEventType(name, enabled);
	      this.keyInput.enableEventType(name, enabled);
	    }

	    /**
	     * Process the event registration for a single event + handler.
	     */

	  }, {
	    key: '_addEventHandler',
	    value: function _addEventHandler(event, handler) {
	      var srcElement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	      var manager = this.manager,
	          eventHandlers = this.eventHandlers;

	      var wrappedHandler = this._wrapEventHandler(event, handler, srcElement);
	      // Alias to a recognized gesture as necessary.
	      var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
	      // Get recognizer for this event
	      var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
	      // Enable recognizer for this event.
	      this._toggleRecognizer(recognizerName, true);

	      // Find ancestors
	      var ancestorEventHandlers = eventHandlers.filter(function (entry) {
	        return entry.eventAlias === eventAlias && entry.srcElement !== srcElement && (!entry.srcElement || entry.srcElement.contains(srcElement));
	      });

	      // Save wrapped handler
	      eventHandlers.push({ event: event, eventAlias: eventAlias, recognizerName: recognizerName, srcElement: srcElement,
	        handler: handler, wrappedHandler: wrappedHandler });

	      // Sort handlers by DOM hierarchy
	      // So the event will always fire first on child nodes
	      ancestorEventHandlers.forEach(function (entry) {
	        return manager.off(eventAlias, entry.wrappedHandler);
	      });
	      if (manager) {
	        manager.on(eventAlias, wrappedHandler);
	      }
	      ancestorEventHandlers.forEach(function (entry) {
	        return manager.on(eventAlias, entry.wrappedHandler);
	      });
	    }

	    /**
	     * Process the event deregistration for a single event + handler.
	     */

	  }, {
	    key: '_removeEventHandler',
	    value: function _removeEventHandler(event, handler) {
	      var manager = this.manager,
	          eventHandlers = this.eventHandlers;

	      var eventHandlerRemoved = false;

	      // Find saved handler if any.
	      for (var i = eventHandlers.length; i--;) {
	        var entry = eventHandlers[i];
	        if (entry.event === event && entry.handler === handler) {
	          // Deregister event handler.
	          if (manager) {
	            manager.off(entry.eventAlias, entry.wrappedHandler);
	          }
	          // Delete saved handler
	          eventHandlers.splice(i, 1);
	          eventHandlerRemoved = true;
	        }
	      }

	      if (eventHandlerRemoved) {
	        // Alias to a recognized gesture as necessary.
	        var eventAlias = _constants.GESTURE_EVENT_ALIASES[event] || event;
	        // Get recognizer for this event
	        var recognizerName = _constants.EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
	        // Disable recognizer if no more handlers are attached to its events
	        var isRecognizerUsed = eventHandlers.find(function (entry) {
	          return entry.recognizerName === recognizerName;
	        });
	        if (!isRecognizerUsed) {
	          this._toggleRecognizer(recognizerName, false);
	        }
	      }
	    }

	    /**
	     * Returns an event handler that aliases events and add props before passing
	     * to the real handler.
	     */

	  }, {
	    key: '_wrapEventHandler',
	    value: function _wrapEventHandler(type, handler, srcElement) {
	      var _this2 = this;

	      return function (event) {
	        var mjolnirEvent = event.mjolnirEvent;


	        if (!mjolnirEvent) {
	          mjolnirEvent = _this2._normalizeEvent(event);
	          event.mjolnirEvent = mjolnirEvent;
	        }

	        var isStopped = mjolnirEvent.handled && mjolnirEvent.handled !== srcElement;

	        if (!isStopped) {
	          var isFromDecendant = !srcElement || srcElement.contains(event.srcEvent.target);
	          if (isFromDecendant) {
	            handler((0, _assign2.default)({}, mjolnirEvent, {
	              type: type,
	              stopPropagation: function stopPropagation() {
	                if (!mjolnirEvent.handled) {
	                  mjolnirEvent.handled = srcElement;
	                }
	              }
	            }));
	          }
	        }
	      };
	    }

	    /**
	     * Normalizes hammerjs and custom events to have predictable fields.
	     */

	  }, {
	    key: '_normalizeEvent',
	    value: function _normalizeEvent(event) {
	      var element = this.element;


	      return (0, _assign2.default)({}, event, (0, _eventUtils.whichButtons)(event), (0, _eventUtils.getOffsetPosition)(event, element), {
	        handled: false,
	        rootElement: element
	      });
	    }

	    /**
	     * Handle basic events using the 'hammer.input' Hammer.js API:
	     * Before running Recognizers, Hammer emits a 'hammer.input' event
	     * with the basic event info. This function emits all basic events
	     * aliased to the "class" of event received.
	     * See constants.BASIC_EVENT_CLASSES basic event class definitions.
	     */

	  }, {
	    key: '_onBasicInput',
	    value: function _onBasicInput(event) {
	      var srcEvent = event.srcEvent;

	      var alias = _constants.BASIC_EVENT_ALIASES[srcEvent.type];
	      if (alias) {
	        // fire all events aliased to srcEvent.type
	        this.manager.emit(alias, event);
	      }
	    }

	    /**
	     * Handle events not supported by Hammer.js,
	     * and pipe back out through same (Hammer) channel used by other events.
	     */

	  }, {
	    key: '_onOtherEvent',
	    value: function _onOtherEvent(event) {
	      this.manager.emit(event.type, event);
	    }
	  }]);
	  return EventManager;
	}();

	exports.default = EventManager;
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9ldmVudC1tYW5hZ2VyLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfT1BUSU9OUyIsImV2ZW50cyIsInJlY29nbml6ZXJzIiwiTWFuYWdlciIsInJpZ2h0QnV0dG9uIiwibGVnYWN5QmxvY2tTY3JvbGwiLCJwcmV2ZW50RGVmYXVsdCIsImV2dCIsIkV2ZW50TWFuYWdlciIsImVsZW1lbnQiLCJvcHRpb25zIiwiZXZlbnRIYW5kbGVycyIsIl9vbkJhc2ljSW5wdXQiLCJiaW5kIiwiX29uT3RoZXJFdmVudCIsInNldEVsZW1lbnQiLCJvbiIsImRlc3Ryb3kiLCJNYW5hZ2VyQ2xhc3MiLCJtYW5hZ2VyIiwiZm9yRWFjaCIsInJlY29nbml6ZXIiLCJnZXQiLCJuYW1lIiwicmVjb2duaXplV2l0aCIsIm90aGVyTmFtZSIsIndoZWVsSW5wdXQiLCJlbmFibGUiLCJtb3ZlSW5wdXQiLCJrZXlJbnB1dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZWNvZ25pemVyTmFtZSIsImV2ZW50QWxpYXMiLCJ3cmFwcGVkSGFuZGxlciIsIl90b2dnbGVSZWNvZ25pemVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwiaGFuZGxlciIsInNyY0VsZW1lbnQiLCJfYWRkRXZlbnRIYW5kbGVyIiwiZXZlbnROYW1lIiwiX3JlbW92ZUV2ZW50SGFuZGxlciIsImVuYWJsZWQiLCJzZXQiLCJmYWxsYmFja1JlY29nbml6ZXJzIiwib3RoZXJSZWNvZ25pemVyIiwicmVxdWlyZUZhaWx1cmUiLCJkcm9wUmVxdWlyZUZhaWx1cmUiLCJlbmFibGVFdmVudFR5cGUiLCJfd3JhcEV2ZW50SGFuZGxlciIsImFuY2VzdG9yRXZlbnRIYW5kbGVycyIsImZpbHRlciIsImVudHJ5IiwiY29udGFpbnMiLCJwdXNoIiwib2ZmIiwiZXZlbnRIYW5kbGVyUmVtb3ZlZCIsImkiLCJsZW5ndGgiLCJzcGxpY2UiLCJpc1JlY29nbml6ZXJVc2VkIiwiZmluZCIsInR5cGUiLCJtam9sbmlyRXZlbnQiLCJfbm9ybWFsaXplRXZlbnQiLCJpc1N0b3BwZWQiLCJoYW5kbGVkIiwiaXNGcm9tRGVjZW5kYW50Iiwic3JjRXZlbnQiLCJ0YXJnZXQiLCJzdG9wUHJvcGFnYXRpb24iLCJyb290RWxlbWVudCIsImFsaWFzIiwiZW1pdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFTQTs7OztBQW5DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFtQkEsSUFBTUEsa0JBQWtCO0FBQ3RCO0FBQ0FDLFVBQVEsSUFGYztBQUd0QjtBQUNBQyxlQUFhLElBSlM7QUFLdEI7QUFDQUMsMEJBTnNCO0FBT3RCO0FBQ0FDLGVBQWEsS0FSUztBQVN0QjtBQUNBQyxxQkFBbUI7QUFWRyxDQUF4Qjs7QUFhQSxTQUFTQyxjQUFULENBQXdCQyxHQUF4QixFQUE2QjtBQUMzQkEsTUFBSUQsY0FBSjtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztJQUNxQkUsWTtBQUNuQiwwQkFBMEM7QUFBQSxRQUE5QkMsT0FBOEIsdUVBQXBCLElBQW9CO0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7O0FBQ3hDLFNBQUtBLE9BQUwsR0FBZSxzQkFBYyxFQUFkLEVBQWtCVixlQUFsQixFQUFtQ1UsT0FBbkMsQ0FBZjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsRUFBckI7O0FBRUEsU0FBS0MsYUFBTCxHQUFxQixLQUFLQSxhQUFMLENBQW1CQyxJQUFuQixDQUF3QixJQUF4QixDQUFyQjtBQUNBLFNBQUtDLGFBQUwsR0FBcUIsS0FBS0EsYUFBTCxDQUFtQkQsSUFBbkIsQ0FBd0IsSUFBeEIsQ0FBckI7O0FBRUEsU0FBS0UsVUFBTCxDQUFnQk4sT0FBaEI7O0FBRUE7QUFUd0MsUUFVakNSLE1BVmlDLEdBVXZCUyxPQVZ1QixDQVVqQ1QsTUFWaUM7O0FBV3hDLFFBQUlBLE1BQUosRUFBWTtBQUNWLFdBQUtlLEVBQUwsQ0FBUWYsTUFBUjtBQUNEO0FBQ0Y7Ozs7K0JBRVVRLE8sRUFBUztBQUFBOztBQUNsQixVQUFJLEtBQUtBLE9BQVQsRUFBa0I7QUFDaEI7QUFDQSxhQUFLUSxPQUFMO0FBQ0Q7QUFDRCxXQUFLUixPQUFMLEdBQWVBLE9BQWY7QUFDQSxVQUFJLENBQUNBLE9BQUwsRUFBYztBQUNaO0FBQ0Q7O0FBUmlCLFVBVVhDLE9BVlcsR0FVQSxJQVZBLENBVVhBLE9BVlc7O0FBV2xCLFVBQU1RLGVBQWVSLFFBQVFQLE9BQTdCOztBQUVBLFdBQUtnQixPQUFMLEdBQWUsSUFBSUQsWUFBSixDQUFpQlQsT0FBakIsRUFBMEIsRUFBQ1AsYUFBYVEsUUFBUVIsV0FBUiwwQkFBZCxFQUExQixFQUNaYyxFQURZLENBQ1QsY0FEUyxFQUNPLEtBQUtKLGFBRFosQ0FBZjs7QUFHQSxVQUFJLENBQUNGLFFBQVFSLFdBQWIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBLGtFQUF1Q2tCLE9BQXZDLENBQStDLGdCQUFRO0FBQ3JELGNBQU1DLGFBQWEsTUFBS0YsT0FBTCxDQUFhRyxHQUFiLENBQWlCQyxJQUFqQixDQUFuQjtBQUNBLGNBQUlGLFVBQUosRUFBZ0I7QUFDZCxpREFBMEJFLElBQTFCLEVBQWdDSCxPQUFoQyxDQUF3QyxxQkFBYTtBQUNuREMseUJBQVdHLGFBQVgsQ0FBeUJDLFNBQXpCO0FBQ0QsYUFGRDtBQUdEO0FBQ0YsU0FQRDtBQVFEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQUtDLFVBQUwsR0FBa0IseUJBQWVqQixPQUFmLEVBQXdCLEtBQUtLLGFBQTdCLEVBQTRDO0FBQzVEYSxnQkFBUSxLQURvRDtBQUU1RHRCLDJCQUFtQkssUUFBUUw7QUFGaUMsT0FBNUMsQ0FBbEI7QUFJQSxXQUFLdUIsU0FBTCxHQUFpQix3QkFBY25CLE9BQWQsRUFBdUIsS0FBS0ssYUFBNUIsRUFBMkMsRUFBQ2EsUUFBUSxLQUFULEVBQTNDLENBQWpCO0FBQ0EsV0FBS0UsUUFBTCxHQUFnQix1QkFBYXBCLE9BQWIsRUFBc0IsS0FBS0ssYUFBM0IsRUFBMEMsRUFBQ2EsUUFBUSxLQUFULEVBQTFDLENBQWhCOztBQUVBLFVBQUlqQixRQUFRTixXQUFaLEVBQXlCO0FBQ3ZCO0FBQ0FLLGdCQUFRcUIsZ0JBQVIsQ0FBeUIsYUFBekIsRUFBd0N4QixjQUF4QztBQUNEOztBQUVEO0FBQ0EsV0FBS0ssYUFBTCxDQUFtQlMsT0FBbkIsQ0FBMkIsZ0JBQWtEO0FBQUEsWUFBaERXLGNBQWdELFFBQWhEQSxjQUFnRDtBQUFBLFlBQWhDQyxVQUFnQyxRQUFoQ0EsVUFBZ0M7QUFBQSxZQUFwQkMsY0FBb0IsUUFBcEJBLGNBQW9COztBQUMzRTtBQUNBLGNBQUtDLGlCQUFMLENBQXVCSCxjQUF2QixFQUF1QyxJQUF2QztBQUNBLGNBQUtaLE9BQUwsQ0FBYUgsRUFBYixDQUFnQmdCLFVBQWhCLEVBQTRCQyxjQUE1QjtBQUNELE9BSkQ7QUFLRDs7QUFFRDs7Ozs4QkFDVTtBQUNSLFVBQUksS0FBS3hCLE9BQVQsRUFBa0I7QUFDaEIsYUFBS0EsT0FBTCxDQUFhMEIsbUJBQWIsQ0FBaUMsYUFBakMsRUFBZ0Q3QixjQUFoRDs7QUFFQTtBQUNBO0FBQ0EsYUFBS29CLFVBQUwsQ0FBZ0JULE9BQWhCO0FBQ0EsYUFBS1csU0FBTCxDQUFlWCxPQUFmO0FBQ0EsYUFBS1ksUUFBTCxDQUFjWixPQUFkO0FBQ0EsYUFBS0UsT0FBTCxDQUFhRixPQUFiOztBQUVBLGFBQUtTLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxhQUFLRSxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBS0MsUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUtWLE9BQUwsR0FBZSxJQUFmO0FBQ0EsYUFBS1YsT0FBTCxHQUFlLElBQWY7QUFDRDtBQUNGOztBQUVEOzs7O3VCQUNHMkIsSyxFQUFPQyxPLEVBQVNDLFUsRUFBWTtBQUM3QixVQUFJLE9BQU9GLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsYUFBS0csZ0JBQUwsQ0FBc0JILEtBQXRCLEVBQTZCQyxPQUE3QixFQUFzQ0MsVUFBdEM7QUFDRCxPQUZELE1BRU87QUFDTEEscUJBQWFELE9BQWI7QUFDQTtBQUNBLGFBQUssSUFBTUcsU0FBWCxJQUF3QkosS0FBeEIsRUFBK0I7QUFDN0IsZUFBS0csZ0JBQUwsQ0FBc0JDLFNBQXRCLEVBQWlDSixNQUFNSSxTQUFOLENBQWpDLEVBQW1ERixVQUFuRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7d0JBS0lGLEssRUFBT0MsTyxFQUFTO0FBQ2xCLFVBQUksT0FBT0QsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QixhQUFLSyxtQkFBTCxDQUF5QkwsS0FBekIsRUFBZ0NDLE9BQWhDO0FBQ0QsT0FGRCxNQUVPO0FBQ0w7QUFDQSxhQUFLLElBQU1HLFNBQVgsSUFBd0JKLEtBQXhCLEVBQStCO0FBQzdCLGVBQUtLLG1CQUFMLENBQXlCRCxTQUF6QixFQUFvQ0osTUFBTUksU0FBTixDQUFwQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7O3NDQUdrQmpCLEksRUFBTW1CLE8sRUFBUztBQUFBLFVBQ3hCdkIsT0FEd0IsR0FDYixJQURhLENBQ3hCQSxPQUR3Qjs7QUFFL0IsVUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFDWjtBQUNEO0FBQ0QsVUFBTUUsYUFBYUYsUUFBUUcsR0FBUixDQUFZQyxJQUFaLENBQW5CO0FBQ0EsVUFBSUYsVUFBSixFQUFnQjtBQUNkQSxtQkFBV3NCLEdBQVgsQ0FBZSxFQUFDaEIsUUFBUWUsT0FBVCxFQUFmOztBQUVBLFlBQU1FLHNCQUFzQixtQ0FBd0JyQixJQUF4QixDQUE1QjtBQUNBLFlBQUlxQix1QkFBdUIsQ0FBQyxLQUFLbEMsT0FBTCxDQUFhUixXQUF6QyxFQUFzRDtBQUNwRDtBQUNBO0FBQ0EwQyw4QkFBb0J4QixPQUFwQixDQUE0QixxQkFBYTtBQUN2QyxnQkFBTXlCLGtCQUFrQjFCLFFBQVFHLEdBQVIsQ0FBWUcsU0FBWixDQUF4QjtBQUNBLGdCQUFJaUIsT0FBSixFQUFhO0FBQ1g7QUFDQUcsOEJBQWdCQyxjQUFoQixDQUErQnZCLElBQS9CO0FBQ0QsYUFIRCxNQUdPO0FBQ0w7QUFDQXNCLDhCQUFnQkUsa0JBQWhCLENBQW1DeEIsSUFBbkM7QUFDRDtBQUNGLFdBVEQ7QUFVRDtBQUNGO0FBQ0QsV0FBS0csVUFBTCxDQUFnQnNCLGVBQWhCLENBQWdDekIsSUFBaEMsRUFBc0NtQixPQUF0QztBQUNBLFdBQUtkLFNBQUwsQ0FBZW9CLGVBQWYsQ0FBK0J6QixJQUEvQixFQUFxQ21CLE9BQXJDO0FBQ0EsV0FBS2IsUUFBTCxDQUFjbUIsZUFBZCxDQUE4QnpCLElBQTlCLEVBQW9DbUIsT0FBcEM7QUFDRDs7QUFFRDs7Ozs7O3FDQUdpQk4sSyxFQUFPQyxPLEVBQTRCO0FBQUEsVUFBbkJDLFVBQW1CLHVFQUFOLElBQU07QUFBQSxVQUMzQ25CLE9BRDJDLEdBQ2pCLElBRGlCLENBQzNDQSxPQUQyQztBQUFBLFVBQ2xDUixhQURrQyxHQUNqQixJQURpQixDQUNsQ0EsYUFEa0M7O0FBRWxELFVBQU1zQixpQkFBaUIsS0FBS2dCLGlCQUFMLENBQXVCYixLQUF2QixFQUE4QkMsT0FBOUIsRUFBdUNDLFVBQXZDLENBQXZCO0FBQ0E7QUFDQSxVQUFNTixhQUFhLGlDQUFzQkksS0FBdEIsS0FBZ0NBLEtBQW5EO0FBQ0E7QUFDQSxVQUFNTCxpQkFBaUIsZ0NBQXFCQyxVQUFyQixLQUFvQ0EsVUFBM0Q7QUFDQTtBQUNBLFdBQUtFLGlCQUFMLENBQXVCSCxjQUF2QixFQUF1QyxJQUF2Qzs7QUFFQTtBQUNBLFVBQU1tQix3QkFBd0J2QyxjQUFjd0MsTUFBZCxDQUFxQixpQkFBUztBQUMxRCxlQUFPQyxNQUFNcEIsVUFBTixLQUFxQkEsVUFBckIsSUFDTG9CLE1BQU1kLFVBQU4sS0FBcUJBLFVBRGhCLEtBRUosQ0FBQ2MsTUFBTWQsVUFBUCxJQUFxQmMsTUFBTWQsVUFBTixDQUFpQmUsUUFBakIsQ0FBMEJmLFVBQTFCLENBRmpCLENBQVA7QUFHRCxPQUo2QixDQUE5Qjs7QUFNQTtBQUNBM0Isb0JBQWMyQyxJQUFkLENBQW1CLEVBQUNsQixZQUFELEVBQVFKLHNCQUFSLEVBQW9CRCw4QkFBcEIsRUFBb0NPLHNCQUFwQztBQUNqQkQsd0JBRGlCLEVBQ1JKLDhCQURRLEVBQW5COztBQUdBO0FBQ0E7QUFDQWlCLDRCQUFzQjlCLE9BQXRCLENBQThCO0FBQUEsZUFBU0QsUUFBUW9DLEdBQVIsQ0FBWXZCLFVBQVosRUFBd0JvQixNQUFNbkIsY0FBOUIsQ0FBVDtBQUFBLE9BQTlCO0FBQ0EsVUFBSWQsT0FBSixFQUFhO0FBQ1hBLGdCQUFRSCxFQUFSLENBQVdnQixVQUFYLEVBQXVCQyxjQUF2QjtBQUNEO0FBQ0RpQiw0QkFBc0I5QixPQUF0QixDQUE4QjtBQUFBLGVBQVNELFFBQVFILEVBQVIsQ0FBV2dCLFVBQVgsRUFBdUJvQixNQUFNbkIsY0FBN0IsQ0FBVDtBQUFBLE9BQTlCO0FBQ0Q7O0FBRUQ7Ozs7Ozt3Q0FHb0JHLEssRUFBT0MsTyxFQUFTO0FBQUEsVUFDM0JsQixPQUQyQixHQUNELElBREMsQ0FDM0JBLE9BRDJCO0FBQUEsVUFDbEJSLGFBRGtCLEdBQ0QsSUFEQyxDQUNsQkEsYUFEa0I7O0FBRWxDLFVBQUk2QyxzQkFBc0IsS0FBMUI7O0FBRUE7QUFDQSxXQUFLLElBQUlDLElBQUk5QyxjQUFjK0MsTUFBM0IsRUFBbUNELEdBQW5DLEdBQXlDO0FBQ3ZDLFlBQU1MLFFBQVF6QyxjQUFjOEMsQ0FBZCxDQUFkO0FBQ0EsWUFBSUwsTUFBTWhCLEtBQU4sS0FBZ0JBLEtBQWhCLElBQXlCZ0IsTUFBTWYsT0FBTixLQUFrQkEsT0FBL0MsRUFBd0Q7QUFDdEQ7QUFDQSxjQUFJbEIsT0FBSixFQUFhO0FBQ1hBLG9CQUFRb0MsR0FBUixDQUFZSCxNQUFNcEIsVUFBbEIsRUFBOEJvQixNQUFNbkIsY0FBcEM7QUFDRDtBQUNEO0FBQ0F0Qix3QkFBY2dELE1BQWQsQ0FBcUJGLENBQXJCLEVBQXdCLENBQXhCO0FBQ0FELGdDQUFzQixJQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsVUFBSUEsbUJBQUosRUFBeUI7QUFDdkI7QUFDQSxZQUFNeEIsYUFBYSxpQ0FBc0JJLEtBQXRCLEtBQWdDQSxLQUFuRDtBQUNBO0FBQ0EsWUFBTUwsaUJBQWlCLGdDQUFxQkMsVUFBckIsS0FBb0NBLFVBQTNEO0FBQ0E7QUFDQSxZQUFNNEIsbUJBQW1CakQsY0FBY2tELElBQWQsQ0FDdkI7QUFBQSxpQkFBU1QsTUFBTXJCLGNBQU4sS0FBeUJBLGNBQWxDO0FBQUEsU0FEdUIsQ0FBekI7QUFHQSxZQUFJLENBQUM2QixnQkFBTCxFQUF1QjtBQUNyQixlQUFLMUIsaUJBQUwsQ0FBdUJILGNBQXZCLEVBQXVDLEtBQXZDO0FBQ0Q7QUFDRjtBQUNGOztBQUVEOzs7Ozs7O3NDQUlrQitCLEksRUFBTXpCLE8sRUFBU0MsVSxFQUFZO0FBQUE7O0FBQzNDLGFBQU8saUJBQVM7QUFBQSxZQUNUeUIsWUFEUyxHQUNPM0IsS0FEUCxDQUNUMkIsWUFEUzs7O0FBR2QsWUFBSSxDQUFDQSxZQUFMLEVBQW1CO0FBQ2pCQSx5QkFBZSxPQUFLQyxlQUFMLENBQXFCNUIsS0FBckIsQ0FBZjtBQUNBQSxnQkFBTTJCLFlBQU4sR0FBcUJBLFlBQXJCO0FBQ0Q7O0FBRUQsWUFBTUUsWUFBWUYsYUFBYUcsT0FBYixJQUF3QkgsYUFBYUcsT0FBYixLQUF5QjVCLFVBQW5FOztBQUVBLFlBQUksQ0FBQzJCLFNBQUwsRUFBZ0I7QUFDZCxjQUFNRSxrQkFBa0IsQ0FBQzdCLFVBQUQsSUFBZUEsV0FBV2UsUUFBWCxDQUFvQmpCLE1BQU1nQyxRQUFOLENBQWVDLE1BQW5DLENBQXZDO0FBQ0EsY0FBSUYsZUFBSixFQUFxQjtBQUNuQjlCLG9CQUFRLHNCQUFjLEVBQWQsRUFBa0IwQixZQUFsQixFQUFnQztBQUN0Q0Qsd0JBRHNDO0FBRXRDUSwrQkFBaUIsMkJBQU07QUFDckIsb0JBQUksQ0FBQ1AsYUFBYUcsT0FBbEIsRUFBMkI7QUFDekJILCtCQUFhRyxPQUFiLEdBQXVCNUIsVUFBdkI7QUFDRDtBQUNGO0FBTnFDLGFBQWhDLENBQVI7QUFRRDtBQUNGO0FBQ0YsT0F2QkQ7QUF3QkQ7O0FBRUQ7Ozs7OztvQ0FHZ0JGLEssRUFBTztBQUFBLFVBQ2QzQixPQURjLEdBQ0gsSUFERyxDQUNkQSxPQURjOzs7QUFHckIsYUFBTyxzQkFBYyxFQUFkLEVBQWtCMkIsS0FBbEIsRUFDTCw4QkFBYUEsS0FBYixDQURLLEVBRUwsbUNBQWtCQSxLQUFsQixFQUF5QjNCLE9BQXpCLENBRkssRUFHTDtBQUNFeUQsaUJBQVMsS0FEWDtBQUVFSyxxQkFBYTlEO0FBRmYsT0FISyxDQUFQO0FBT0Q7O0FBRUQ7Ozs7Ozs7Ozs7a0NBT2MyQixLLEVBQU87QUFBQSxVQUNaZ0MsUUFEWSxHQUNBaEMsS0FEQSxDQUNaZ0MsUUFEWTs7QUFFbkIsVUFBTUksUUFBUSwrQkFBb0JKLFNBQVNOLElBQTdCLENBQWQ7QUFDQSxVQUFJVSxLQUFKLEVBQVc7QUFDVDtBQUNBLGFBQUtyRCxPQUFMLENBQWFzRCxJQUFiLENBQWtCRCxLQUFsQixFQUF5QnBDLEtBQXpCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7OztrQ0FJY0EsSyxFQUFPO0FBQ25CLFdBQUtqQixPQUFMLENBQWFzRCxJQUFiLENBQWtCckMsTUFBTTBCLElBQXhCLEVBQThCMUIsS0FBOUI7QUFDRDs7Ozs7a0JBaFNrQjVCLFkiLCJmaWxlIjoiZXZlbnQtbWFuYWdlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7TWFuYWdlcn0gZnJvbSAnLi91dGlscy9oYW1tZXInO1xuXG5pbXBvcnQgV2hlZWxJbnB1dCBmcm9tICcuL2lucHV0cy93aGVlbC1pbnB1dCc7XG5pbXBvcnQgTW92ZUlucHV0IGZyb20gJy4vaW5wdXRzL21vdmUtaW5wdXQnO1xuaW1wb3J0IEtleUlucHV0IGZyb20gJy4vaW5wdXRzL2tleS1pbnB1dCc7XG5cbmltcG9ydCB7XG4gIEJBU0lDX0VWRU5UX0FMSUFTRVMsXG4gIEVWRU5UX1JFQ09HTklaRVJfTUFQLFxuICBHRVNUVVJFX0VWRU5UX0FMSUFTRVMsXG4gIFJFQ09HTklaRVJTLFxuICBSRUNPR05JWkVSX0NPTVBBVElCTEVfTUFQLFxuICBSRUNPR05JWkVSX0ZBTExCQUNLX01BUFxufSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmltcG9ydCB7d2hpY2hCdXR0b25zLCBnZXRPZmZzZXRQb3NpdGlvbn0gZnJvbSAnLi91dGlscy9ldmVudC11dGlscyc7XG5cbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgZXZlbnRzOiBudWxsLFxuICAvLyBjdXN0b20gcmVjb2duaXplcnNcbiAgcmVjb2duaXplcnM6IG51bGwsXG4gIC8vIE1hbmFnZXIgY2xhc3NcbiAgTWFuYWdlcixcbiAgLy8gcmVjb2duaXplIHJpZ2h0IGJ1dHRvbiBnZXN0dXJlc1xuICByaWdodEJ1dHRvbjogZmFsc2UsXG4gIC8vIGJsb2NrIHNjcm9sbGluZyAtIHRoaXMgaXMgYSBsZWdhY3kgYmVoYXZpb3IgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCB2ZXJzaW9uXG4gIGxlZ2FjeUJsb2NrU2Nyb2xsOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldnQpIHtcbiAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbi8vIFVuaWZpZWQgQVBJIGZvciBzdWJzY3JpYmluZyB0byBldmVudHMgYWJvdXQgYm90aFxuLy8gYmFzaWMgaW5wdXQgZXZlbnRzIChlLmcuICdtb3VzZW1vdmUnLCAndG91Y2hzdGFydCcsICd3aGVlbCcpXG4vLyBhbmQgZ2VzdHVyYWwgaW5wdXQgKGUuZy4gJ2NsaWNrJywgJ3RhcCcsICdwYW5zdGFydCcpLlxuLy8gRGVsZWdhdGVzIGdlc3R1cmUgcmVsYXRlZCBldmVudCByZWdpc3RyYXRpb24gYW5kIGhhbmRsaW5nIHRvIEhhbW1lci5qcy5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50TWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQgPSBudWxsLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIG9wdGlvbnMpO1xuICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IFtdO1xuXG4gICAgdGhpcy5fb25CYXNpY0lucHV0ID0gdGhpcy5fb25CYXNpY0lucHV0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25PdGhlckV2ZW50ID0gdGhpcy5fb25PdGhlckV2ZW50LmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnNldEVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAvLyBSZWdpc3RlciBhbGwgcGFzc2VkIGV2ZW50cy5cbiAgICBjb25zdCB7ZXZlbnRzfSA9IG9wdGlvbnM7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgdGhpcy5vbihldmVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHNldEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIC8vIHVucmVnaXN0ZXIgYWxsIGV2ZW50c1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge29wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBNYW5hZ2VyQ2xhc3MgPSBvcHRpb25zLk1hbmFnZXI7XG5cbiAgICB0aGlzLm1hbmFnZXIgPSBuZXcgTWFuYWdlckNsYXNzKGVsZW1lbnQsIHtyZWNvZ25pemVyczogb3B0aW9ucy5yZWNvZ25pemVycyB8fCBSRUNPR05JWkVSU30pXG4gICAgICAub24oJ2hhbW1lci5pbnB1dCcsIHRoaXMuX29uQmFzaWNJbnB1dCk7XG5cbiAgICBpZiAoIW9wdGlvbnMucmVjb2duaXplcnMpIHtcbiAgICAgIC8vIFNldCBkZWZhdWx0IHJlY29nbml6ZSB3aXRoc1xuICAgICAgLy8gaHR0cDovL2hhbW1lcmpzLmdpdGh1Yi5pby9yZWNvZ25pemUtd2l0aC9cbiAgICAgIE9iamVjdC5rZXlzKFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVApLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlY29nbml6ZXIgPSB0aGlzLm1hbmFnZXIuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgIFJFQ09HTklaRVJfQ09NUEFUSUJMRV9NQVBbbmFtZV0uZm9yRWFjaChvdGhlck5hbWUgPT4ge1xuICAgICAgICAgICAgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKG90aGVyTmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBldmVudHMgbm90IGhhbmRsZWQgYnkgSGFtbWVyLmpzOlxuICAgIC8vIC0gbW91c2Ugd2hlZWxcbiAgICAvLyAtIHBvaW50ZXIvdG91Y2gvbW91c2UgbW92ZVxuICAgIHRoaXMud2hlZWxJbnB1dCA9IG5ldyBXaGVlbElucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge1xuICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgIGxlZ2FjeUJsb2NrU2Nyb2xsOiBvcHRpb25zLmxlZ2FjeUJsb2NrU2Nyb2xsXG4gICAgfSk7XG4gICAgdGhpcy5tb3ZlSW5wdXQgPSBuZXcgTW92ZUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcbiAgICB0aGlzLmtleUlucHV0ID0gbmV3IEtleUlucHV0KGVsZW1lbnQsIHRoaXMuX29uT3RoZXJFdmVudCwge2VuYWJsZTogZmFsc2V9KTtcblxuICAgIGlmIChvcHRpb25zLnJpZ2h0QnV0dG9uKSB7XG4gICAgICAvLyBCbG9jayByaWdodCBjbGlja1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBhbGwgZXhpc3RpbmcgZXZlbnRzXG4gICAgdGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goKHtyZWNvZ25pemVyTmFtZSwgZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXJ9KSA9PiB7XG4gICAgICAvLyBFbmFibGUgcmVjb2duaXplciBmb3IgdGhpcyBldmVudC5cbiAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIHRydWUpO1xuICAgICAgdGhpcy5tYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIHdyYXBwZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRlYXIgZG93biBpbnRlcm5hbCBldmVudCBtYW5hZ2VtZW50IGltcGxlbWVudGF0aW9ucy5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG5cbiAgICAgIC8vIHdoZWVsSW5wdXQgZXRjLiBhcmUgY3JlYXRlZCBpbiBzZXRFbGVtZW50KCkgYW5kIHRoZXJlZm9yZVxuICAgICAgLy8gY2Fubm90IGV4aXN0IGlmIHRoZXJlIGlzIG5vIGVsZW1lbnRcbiAgICAgIHRoaXMud2hlZWxJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1vdmVJbnB1dC5kZXN0cm95KCk7XG4gICAgICB0aGlzLmtleUlucHV0LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMubWFuYWdlci5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMud2hlZWxJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLm1vdmVJbnB1dCA9IG51bGw7XG4gICAgICB0aGlzLmtleUlucHV0ID0gbnVsbDtcbiAgICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlZ2lzdGVyIGFuIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGBldmVudGAuXG4gIG9uKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2FkZEV2ZW50SGFuZGxlcihldmVudCwgaGFuZGxlciwgc3JjRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNyY0VsZW1lbnQgPSBoYW5kbGVyO1xuICAgICAgLy8gSWYgYGV2ZW50YCBpcyBhIG1hcCwgY2FsbCBgb24oKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9hZGRFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdLCBzcmNFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHByZXZpb3VzbHktcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGV2ZW50ICAgQW4gZXZlbnQgbmFtZSAoU3RyaW5nKSBvciBtYXAgb2YgZXZlbnQgbmFtZXMgdG8gaGFuZGxlcnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdICAgIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYGV2ZW50YC5cbiAgICovXG4gIG9mZihldmVudCwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBgZXZlbnRgIGlzIGEgbWFwLCBjYWxsIGBvZmYoKWAgZm9yIGVhY2ggZW50cnkuXG4gICAgICBmb3IgKGNvbnN0IGV2ZW50TmFtZSBpbiBldmVudCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnROYW1lLCBldmVudFtldmVudE5hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKlxuICAgKiBFbmFibGUvZGlzYWJsZSByZWNvZ25pemVyIGZvciB0aGUgZ2l2ZW4gZXZlbnRcbiAgICovXG4gIF90b2dnbGVSZWNvZ25pemVyKG5hbWUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCB7bWFuYWdlcn0gPSB0aGlzO1xuICAgIGlmICghbWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWNvZ25pemVyID0gbWFuYWdlci5nZXQobmFtZSk7XG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHJlY29nbml6ZXIuc2V0KHtlbmFibGU6IGVuYWJsZWR9KTtcblxuICAgICAgY29uc3QgZmFsbGJhY2tSZWNvZ25pemVycyA9IFJFQ09HTklaRVJfRkFMTEJBQ0tfTUFQW25hbWVdO1xuICAgICAgaWYgKGZhbGxiYWNrUmVjb2duaXplcnMgJiYgIXRoaXMub3B0aW9ucy5yZWNvZ25pemVycykge1xuICAgICAgICAvLyBTZXQgZGVmYXVsdCByZXF1aXJlIGZhaWx1cmVzXG4gICAgICAgIC8vIGh0dHA6Ly9oYW1tZXJqcy5naXRodWIuaW8vcmVxdWlyZS1mYWlsdXJlL1xuICAgICAgICBmYWxsYmFja1JlY29nbml6ZXJzLmZvckVhY2gob3RoZXJOYW1lID0+IHtcbiAgICAgICAgICBjb25zdCBvdGhlclJlY29nbml6ZXIgPSBtYW5hZ2VyLmdldChvdGhlck5hbWUpO1xuICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGlzIHJlY29nbml6ZXIgdG8gZmFpbFxuICAgICAgICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKG5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyBub3Qgd2FpdCBmb3IgdGhpcyByZWNvZ25pemVyIHRvIGZhaWxcbiAgICAgICAgICAgIG90aGVyUmVjb2duaXplci5kcm9wUmVxdWlyZUZhaWx1cmUobmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy53aGVlbElucHV0LmVuYWJsZUV2ZW50VHlwZShuYW1lLCBlbmFibGVkKTtcbiAgICB0aGlzLm1vdmVJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gICAgdGhpcy5rZXlJbnB1dC5lbmFibGVFdmVudFR5cGUobmFtZSwgZW5hYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgcmVnaXN0cmF0aW9uIGZvciBhIHNpbmdsZSBldmVudCArIGhhbmRsZXIuXG4gICAqL1xuICBfYWRkRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50ID0gbnVsbCkge1xuICAgIGNvbnN0IHttYW5hZ2VyLCBldmVudEhhbmRsZXJzfSA9IHRoaXM7XG4gICAgY29uc3Qgd3JhcHBlZEhhbmRsZXIgPSB0aGlzLl93cmFwRXZlbnRIYW5kbGVyKGV2ZW50LCBoYW5kbGVyLCBzcmNFbGVtZW50KTtcbiAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgY29uc3QgZXZlbnRBbGlhcyA9IEdFU1RVUkVfRVZFTlRfQUxJQVNFU1tldmVudF0gfHwgZXZlbnQ7XG4gICAgLy8gR2V0IHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnRcbiAgICBjb25zdCByZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgLy8gRW5hYmxlIHJlY29nbml6ZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5fdG9nZ2xlUmVjb2duaXplcihyZWNvZ25pemVyTmFtZSwgdHJ1ZSk7XG5cbiAgICAvLyBGaW5kIGFuY2VzdG9yc1xuICAgIGNvbnN0IGFuY2VzdG9yRXZlbnRIYW5kbGVycyA9IGV2ZW50SGFuZGxlcnMuZmlsdGVyKGVudHJ5ID0+IHtcbiAgICAgIHJldHVybiBlbnRyeS5ldmVudEFsaWFzID09PSBldmVudEFsaWFzICYmXG4gICAgICAgIGVudHJ5LnNyY0VsZW1lbnQgIT09IHNyY0VsZW1lbnQgJiZcbiAgICAgICAgKCFlbnRyeS5zcmNFbGVtZW50IHx8IGVudHJ5LnNyY0VsZW1lbnQuY29udGFpbnMoc3JjRWxlbWVudCkpO1xuICAgIH0pO1xuXG4gICAgLy8gU2F2ZSB3cmFwcGVkIGhhbmRsZXJcbiAgICBldmVudEhhbmRsZXJzLnB1c2goe2V2ZW50LCBldmVudEFsaWFzLCByZWNvZ25pemVyTmFtZSwgc3JjRWxlbWVudCxcbiAgICAgIGhhbmRsZXIsIHdyYXBwZWRIYW5kbGVyfSk7XG5cbiAgICAvLyBTb3J0IGhhbmRsZXJzIGJ5IERPTSBoaWVyYXJjaHlcbiAgICAvLyBTbyB0aGUgZXZlbnQgd2lsbCBhbHdheXMgZmlyZSBmaXJzdCBvbiBjaGlsZCBub2Rlc1xuICAgIGFuY2VzdG9yRXZlbnRIYW5kbGVycy5mb3JFYWNoKGVudHJ5ID0+IG1hbmFnZXIub2ZmKGV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKSk7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgIG1hbmFnZXIub24oZXZlbnRBbGlhcywgd3JhcHBlZEhhbmRsZXIpO1xuICAgIH1cbiAgICBhbmNlc3RvckV2ZW50SGFuZGxlcnMuZm9yRWFjaChlbnRyeSA9PiBtYW5hZ2VyLm9uKGV2ZW50QWxpYXMsIGVudHJ5LndyYXBwZWRIYW5kbGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyB0aGUgZXZlbnQgZGVyZWdpc3RyYXRpb24gZm9yIGEgc2luZ2xlIGV2ZW50ICsgaGFuZGxlci5cbiAgICovXG4gIF9yZW1vdmVFdmVudEhhbmRsZXIoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBjb25zdCB7bWFuYWdlciwgZXZlbnRIYW5kbGVyc30gPSB0aGlzO1xuICAgIGxldCBldmVudEhhbmRsZXJSZW1vdmVkID0gZmFsc2U7XG5cbiAgICAvLyBGaW5kIHNhdmVkIGhhbmRsZXIgaWYgYW55LlxuICAgIGZvciAobGV0IGkgPSBldmVudEhhbmRsZXJzLmxlbmd0aDsgaS0tOykge1xuICAgICAgY29uc3QgZW50cnkgPSBldmVudEhhbmRsZXJzW2ldO1xuICAgICAgaWYgKGVudHJ5LmV2ZW50ID09PSBldmVudCAmJiBlbnRyeS5oYW5kbGVyID09PSBoYW5kbGVyKSB7XG4gICAgICAgIC8vIERlcmVnaXN0ZXIgZXZlbnQgaGFuZGxlci5cbiAgICAgICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgICBtYW5hZ2VyLm9mZihlbnRyeS5ldmVudEFsaWFzLCBlbnRyeS53cmFwcGVkSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVsZXRlIHNhdmVkIGhhbmRsZXJcbiAgICAgICAgZXZlbnRIYW5kbGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGV2ZW50SGFuZGxlclJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChldmVudEhhbmRsZXJSZW1vdmVkKSB7XG4gICAgICAvLyBBbGlhcyB0byBhIHJlY29nbml6ZWQgZ2VzdHVyZSBhcyBuZWNlc3NhcnkuXG4gICAgICBjb25zdCBldmVudEFsaWFzID0gR0VTVFVSRV9FVkVOVF9BTElBU0VTW2V2ZW50XSB8fCBldmVudDtcbiAgICAgIC8vIEdldCByZWNvZ25pemVyIGZvciB0aGlzIGV2ZW50XG4gICAgICBjb25zdCByZWNvZ25pemVyTmFtZSA9IEVWRU5UX1JFQ09HTklaRVJfTUFQW2V2ZW50QWxpYXNdIHx8IGV2ZW50QWxpYXM7XG4gICAgICAvLyBEaXNhYmxlIHJlY29nbml6ZXIgaWYgbm8gbW9yZSBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gaXRzIGV2ZW50c1xuICAgICAgY29uc3QgaXNSZWNvZ25pemVyVXNlZCA9IGV2ZW50SGFuZGxlcnMuZmluZChcbiAgICAgICAgZW50cnkgPT4gZW50cnkucmVjb2duaXplck5hbWUgPT09IHJlY29nbml6ZXJOYW1lXG4gICAgICApO1xuICAgICAgaWYgKCFpc1JlY29nbml6ZXJVc2VkKSB7XG4gICAgICAgIHRoaXMuX3RvZ2dsZVJlY29nbml6ZXIocmVjb2duaXplck5hbWUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBldmVudCBoYW5kbGVyIHRoYXQgYWxpYXNlcyBldmVudHMgYW5kIGFkZCBwcm9wcyBiZWZvcmUgcGFzc2luZ1xuICAgKiB0byB0aGUgcmVhbCBoYW5kbGVyLlxuICAgKi9cbiAgX3dyYXBFdmVudEhhbmRsZXIodHlwZSwgaGFuZGxlciwgc3JjRWxlbWVudCkge1xuICAgIHJldHVybiBldmVudCA9PiB7XG4gICAgICBsZXQge21qb2xuaXJFdmVudH0gPSBldmVudDtcblxuICAgICAgaWYgKCFtam9sbmlyRXZlbnQpIHtcbiAgICAgICAgbWpvbG5pckV2ZW50ID0gdGhpcy5fbm9ybWFsaXplRXZlbnQoZXZlbnQpO1xuICAgICAgICBldmVudC5tam9sbmlyRXZlbnQgPSBtam9sbmlyRXZlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlzU3RvcHBlZCA9IG1qb2xuaXJFdmVudC5oYW5kbGVkICYmIG1qb2xuaXJFdmVudC5oYW5kbGVkICE9PSBzcmNFbGVtZW50O1xuXG4gICAgICBpZiAoIWlzU3RvcHBlZCkge1xuICAgICAgICBjb25zdCBpc0Zyb21EZWNlbmRhbnQgPSAhc3JjRWxlbWVudCB8fCBzcmNFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnNyY0V2ZW50LnRhcmdldCk7XG4gICAgICAgIGlmIChpc0Zyb21EZWNlbmRhbnQpIHtcbiAgICAgICAgICBoYW5kbGVyKE9iamVjdC5hc3NpZ24oe30sIG1qb2xuaXJFdmVudCwge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHN0b3BQcm9wYWdhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIW1qb2xuaXJFdmVudC5oYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgbWpvbG5pckV2ZW50LmhhbmRsZWQgPSBzcmNFbGVtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGhhbW1lcmpzIGFuZCBjdXN0b20gZXZlbnRzIHRvIGhhdmUgcHJlZGljdGFibGUgZmllbGRzLlxuICAgKi9cbiAgX25vcm1hbGl6ZUV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3Qge2VsZW1lbnR9ID0gdGhpcztcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBldmVudCxcbiAgICAgIHdoaWNoQnV0dG9ucyhldmVudCksXG4gICAgICBnZXRPZmZzZXRQb3NpdGlvbihldmVudCwgZWxlbWVudCksXG4gICAgICB7XG4gICAgICAgIGhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICByb290RWxlbWVudDogZWxlbWVudFxuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGJhc2ljIGV2ZW50cyB1c2luZyB0aGUgJ2hhbW1lci5pbnB1dCcgSGFtbWVyLmpzIEFQSTpcbiAgICogQmVmb3JlIHJ1bm5pbmcgUmVjb2duaXplcnMsIEhhbW1lciBlbWl0cyBhICdoYW1tZXIuaW5wdXQnIGV2ZW50XG4gICAqIHdpdGggdGhlIGJhc2ljIGV2ZW50IGluZm8uIFRoaXMgZnVuY3Rpb24gZW1pdHMgYWxsIGJhc2ljIGV2ZW50c1xuICAgKiBhbGlhc2VkIHRvIHRoZSBcImNsYXNzXCIgb2YgZXZlbnQgcmVjZWl2ZWQuXG4gICAqIFNlZSBjb25zdGFudHMuQkFTSUNfRVZFTlRfQ0xBU1NFUyBiYXNpYyBldmVudCBjbGFzcyBkZWZpbml0aW9ucy5cbiAgICovXG4gIF9vbkJhc2ljSW5wdXQoZXZlbnQpIHtcbiAgICBjb25zdCB7c3JjRXZlbnR9ID0gZXZlbnQ7XG4gICAgY29uc3QgYWxpYXMgPSBCQVNJQ19FVkVOVF9BTElBU0VTW3NyY0V2ZW50LnR5cGVdO1xuICAgIGlmIChhbGlhcykge1xuICAgICAgLy8gZmlyZSBhbGwgZXZlbnRzIGFsaWFzZWQgdG8gc3JjRXZlbnQudHlwZVxuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQoYWxpYXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGV2ZW50cyBub3Qgc3VwcG9ydGVkIGJ5IEhhbW1lci5qcyxcbiAgICogYW5kIHBpcGUgYmFjayBvdXQgdGhyb3VnaCBzYW1lIChIYW1tZXIpIGNoYW5uZWwgdXNlZCBieSBvdGhlciBldmVudHMuXG4gICAqL1xuICBfb25PdGhlckV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLmVtaXQoZXZlbnQudHlwZSwgZXZlbnQpO1xuICB9XG59XG4iXX0=

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(293), __esModule: true };

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(294);
	module.exports = __webpack_require__(309).Object.keys;


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(295);
	var $keys = __webpack_require__(297);

	__webpack_require__(314)('keys', function () {
	  return function keys(it) {
	    return $keys(toObject(it));
	  };
	});


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(296);
	module.exports = function (it) {
	  return Object(defined(it));
	};


/***/ }),
/* 296 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on  " + it);
	  return it;
	};


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys = __webpack_require__(298);
	var enumBugKeys = __webpack_require__(313);

	module.exports = Object.keys || function keys(O) {
	  return $keys(O, enumBugKeys);
	};


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

	var has = __webpack_require__(299);
	var toIObject = __webpack_require__(300);
	var arrayIndexOf = __webpack_require__(303)(false);
	var IE_PROTO = __webpack_require__(307)('IE_PROTO');

	module.exports = function (object, names) {
	  var O = toIObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};


/***/ }),
/* 299 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(301);
	var defined = __webpack_require__(296);
	module.exports = function (it) {
	  return IObject(defined(it));
	};


/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(302);
	// eslint-disable-next-line no-prototype-builtins
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};


/***/ }),
/* 302 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = function (it) {
	  return toString.call(it).slice(8, -1);
	};


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(300);
	var toLength = __webpack_require__(304);
	var toAbsoluteIndex = __webpack_require__(306);
	module.exports = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
	      if (O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(305);
	var min = Math.min;
	module.exports = function (it) {
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};


/***/ }),
/* 305 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil = Math.ceil;
	var floor = Math.floor;
	module.exports = function (it) {
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(305);
	var max = Math.max;
	var min = Math.min;
	module.exports = function (index, length) {
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};


/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(308)('keys');
	var uid = __webpack_require__(312);
	module.exports = function (key) {
	  return shared[key] || (shared[key] = uid(key));
	};


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

	var core = __webpack_require__(309);
	var global = __webpack_require__(310);
	var SHARED = '__core-js_shared__';
	var store = global[SHARED] || (global[SHARED] = {});

	(module.exports = function (key, value) {
	  return store[key] || (store[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: core.version,
	  mode: __webpack_require__(311) ? 'pure' : 'global',
	  copyright: '© 2018 Denis Pushkarev (zloirock.ru)'
	});


/***/ }),
/* 309 */
/***/ (function(module, exports) {

	var core = module.exports = { version: '2.5.7' };
	if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 310 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self
	  // eslint-disable-next-line no-new-func
	  : Function('return this')();
	if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 311 */
/***/ (function(module, exports) {

	module.exports = true;


/***/ }),
/* 312 */
/***/ (function(module, exports) {

	var id = 0;
	var px = Math.random();
	module.exports = function (key) {
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};


/***/ }),
/* 313 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(315);
	var core = __webpack_require__(309);
	var fails = __webpack_require__(324);
	module.exports = function (KEY, exec) {
	  var fn = (core.Object || {})[KEY] || Object[KEY];
	  var exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
	};


/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(310);
	var core = __webpack_require__(309);
	var ctx = __webpack_require__(316);
	var hide = __webpack_require__(318);
	var has = __webpack_require__(299);
	var PROTOTYPE = 'prototype';

	var $export = function (type, name, source) {
	  var IS_FORCED = type & $export.F;
	  var IS_GLOBAL = type & $export.G;
	  var IS_STATIC = type & $export.S;
	  var IS_PROTO = type & $export.P;
	  var IS_BIND = type & $export.B;
	  var IS_WRAP = type & $export.W;
	  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
	  var expProto = exports[PROTOTYPE];
	  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
	  var key, own, out;
	  if (IS_GLOBAL) source = name;
	  for (key in source) {
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if (own && has(exports, key)) continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function (C) {
	      var F = function (a, b, c) {
	        if (this instanceof C) {
	          switch (arguments.length) {
	            case 0: return new C();
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if (IS_PROTO) {
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library`
	module.exports = $export;


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(317);
	module.exports = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};


/***/ }),
/* 317 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
	  return it;
	};


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(319);
	var createDesc = __webpack_require__(327);
	module.exports = __webpack_require__(323) ? function (object, key, value) {
	  return dP.f(object, key, createDesc(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(320);
	var IE8_DOM_DEFINE = __webpack_require__(322);
	var toPrimitive = __webpack_require__(326);
	var dP = Object.defineProperty;

	exports.f = __webpack_require__(323) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (IE8_DOM_DEFINE) try {
	    return dP(O, P, Attributes);
	  } catch (e) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(321);
	module.exports = function (it) {
	  if (!isObject(it)) throw TypeError(it + ' is not an object!');
	  return it;
	};


/***/ }),
/* 321 */
/***/ (function(module, exports) {

	module.exports = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(323) && !__webpack_require__(324)(function () {
	  return Object.defineProperty(__webpack_require__(325)('div'), 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(324)(function () {
	  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
	});


/***/ }),
/* 324 */
/***/ (function(module, exports) {

	module.exports = function (exec) {
	  try {
	    return !!exec();
	  } catch (e) {
	    return true;
	  }
	};


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(321);
	var document = __webpack_require__(310).document;
	// typeof document.createElement is 'object' in old IE
	var is = isObject(document) && isObject(document.createElement);
	module.exports = function (it) {
	  return is ? document.createElement(it) : {};
	};


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(321);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function (it, S) {
	  if (!isObject(it)) return it;
	  var fn, val;
	  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
	  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};


/***/ }),
/* 327 */
/***/ (function(module, exports) {

	module.exports = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(329), __esModule: true };

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(330);
	module.exports = __webpack_require__(309).Object.assign;


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(315);

	$export($export.S + $export.F, 'Object', { assign: __webpack_require__(331) });


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys = __webpack_require__(297);
	var gOPS = __webpack_require__(332);
	var pIE = __webpack_require__(333);
	var toObject = __webpack_require__(295);
	var IObject = __webpack_require__(301);
	var $assign = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(324)(function () {
	  var A = {};
	  var B = {};
	  // eslint-disable-next-line no-undef
	  var S = Symbol();
	  var K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function (k) { B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
	  var T = toObject(target);
	  var aLen = arguments.length;
	  var index = 1;
	  var getSymbols = gOPS.f;
	  var isEnum = pIE.f;
	  while (aLen > index) {
	    var S = IObject(arguments[index++]);
	    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
	  } return T;
	} : $assign;


/***/ }),
/* 332 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 333 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 334 */
/***/ (function(module, exports) {

	"use strict";

	exports.__esModule = true;

	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(336);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(337), __esModule: true };

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(338);
	var $Object = __webpack_require__(309).Object;
	module.exports = function defineProperty(it, key, desc) {
	  return $Object.defineProperty(it, key, desc);
	};


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(315);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(323), 'Object', { defineProperty: __webpack_require__(319).f });


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Manager = undefined;

	var _globals = __webpack_require__(340);

	var _hammerOverrides = __webpack_require__(374);

	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var hammerjs = void 0;
	if (_globals.isBrowser) {
	  hammerjs = __webpack_require__(375);
	}

	// Hammer.Manager mock for use in environments without `document` / `window`.
	function HammerManagerMock(m) {
	  var instance = {};
	  var chainedNoop = function chainedNoop() {
	    return instance;
	  };
	  instance.get = function () {
	    return null;
	  };
	  instance.set = chainedNoop;
	  instance.on = chainedNoop;
	  instance.off = chainedNoop;
	  instance.destroy = chainedNoop;
	  instance.emit = chainedNoop;
	  return instance;
	}

	if (hammerjs) {
	  (0, _hammerOverrides.enhancePointerEventInput)(hammerjs.PointerEventInput);
	  (0, _hammerOverrides.enhanceMouseInput)(hammerjs.MouseInput);
	}

	var Manager = exports.Manager = hammerjs ? hammerjs.Manager : HammerManagerMock;

	exports.default = hammerjs;
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9oYW1tZXIuanMiXSwibmFtZXMiOlsiaGFtbWVyanMiLCJyZXF1aXJlIiwiSGFtbWVyTWFuYWdlck1vY2siLCJtIiwiaW5zdGFuY2UiLCJjaGFpbmVkTm9vcCIsImdldCIsInNldCIsIm9uIiwib2ZmIiwiZGVzdHJveSIsImVtaXQiLCJQb2ludGVyRXZlbnRJbnB1dCIsIk1vdXNlSW5wdXQiLCJNYW5hZ2VyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBb0JBOztBQUNBOztBQXJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQSxJQUFJQSxpQkFBSjtBQUNBLHdCQUFlO0FBQ2JBLGFBQVdDLFFBQVEsVUFBUixDQUFYO0FBQ0Q7O0FBRUQ7QUFDQSxTQUFTQyxpQkFBVCxDQUEyQkMsQ0FBM0IsRUFBOEI7QUFDNUIsTUFBTUMsV0FBVyxFQUFqQjtBQUNBLE1BQU1DLGNBQWMsU0FBZEEsV0FBYztBQUFBLFdBQU1ELFFBQU47QUFBQSxHQUFwQjtBQUNBQSxXQUFTRSxHQUFULEdBQWU7QUFBQSxXQUFNLElBQU47QUFBQSxHQUFmO0FBQ0FGLFdBQVNHLEdBQVQsR0FBZUYsV0FBZjtBQUNBRCxXQUFTSSxFQUFULEdBQWNILFdBQWQ7QUFDQUQsV0FBU0ssR0FBVCxHQUFlSixXQUFmO0FBQ0FELFdBQVNNLE9BQVQsR0FBbUJMLFdBQW5CO0FBQ0FELFdBQVNPLElBQVQsR0FBZ0JOLFdBQWhCO0FBQ0EsU0FBT0QsUUFBUDtBQUNEOztBQUVELElBQUlKLFFBQUosRUFBYztBQUNaLGlEQUF5QkEsU0FBU1ksaUJBQWxDO0FBQ0EsMENBQWtCWixTQUFTYSxVQUEzQjtBQUNEOztBQUVNLElBQU1DLDRCQUFVZCxXQUFXQSxTQUFTYyxPQUFwQixHQUE4QlosaUJBQTlDOztrQkFFUUYsUSIsImZpbGUiOiJoYW1tZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge2lzQnJvd3Nlcn0gZnJvbSAnLi9nbG9iYWxzJztcbmltcG9ydCB7ZW5oYW5jZVBvaW50ZXJFdmVudElucHV0LCBlbmhhbmNlTW91c2VJbnB1dH0gZnJvbSAnLi9oYW1tZXItb3ZlcnJpZGVzJztcblxubGV0IGhhbW1lcmpzO1xuaWYgKGlzQnJvd3Nlcikge1xuICBoYW1tZXJqcyA9IHJlcXVpcmUoJ2hhbW1lcmpzJyk7XG59XG5cbi8vIEhhbW1lci5NYW5hZ2VyIG1vY2sgZm9yIHVzZSBpbiBlbnZpcm9ubWVudHMgd2l0aG91dCBgZG9jdW1lbnRgIC8gYHdpbmRvd2AuXG5mdW5jdGlvbiBIYW1tZXJNYW5hZ2VyTW9jayhtKSB7XG4gIGNvbnN0IGluc3RhbmNlID0ge307XG4gIGNvbnN0IGNoYWluZWROb29wID0gKCkgPT4gaW5zdGFuY2U7XG4gIGluc3RhbmNlLmdldCA9ICgpID0+IG51bGw7XG4gIGluc3RhbmNlLnNldCA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5vbiA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5vZmYgPSBjaGFpbmVkTm9vcDtcbiAgaW5zdGFuY2UuZGVzdHJveSA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5lbWl0ID0gY2hhaW5lZE5vb3A7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKGhhbW1lcmpzKSB7XG4gIGVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dChoYW1tZXJqcy5Qb2ludGVyRXZlbnRJbnB1dCk7XG4gIGVuaGFuY2VNb3VzZUlucHV0KGhhbW1lcmpzLk1vdXNlSW5wdXQpO1xufVxuXG5leHBvcnQgY29uc3QgTWFuYWdlciA9IGhhbW1lcmpzID8gaGFtbWVyanMuTWFuYWdlciA6IEhhbW1lck1hbmFnZXJNb2NrO1xuXG5leHBvcnQgZGVmYXVsdCBoYW1tZXJqcztcbiJdfQ==

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';

	var _typeof2 = __webpack_require__(341);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	// Purpose: include this in your module to avoids adding dependencies on
	// micro modules like 'global' and 'is-browser';

	/* global process, window, global, document, navigator */
	var isBrowser = (typeof process === 'undefined' ? 'undefined' : (0, _typeof3.default)(process)) !== 'object' || String(process) !== '[object process]' || process.browser;

	var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';

	module.exports = {
	  window: typeof window !== 'undefined' ? window : global,
	  global: typeof global !== 'undefined' ? global : window,
	  document: typeof document !== 'undefined' ? document : {},
	  isBrowser: isBrowser,
	  userAgent: userAgent
	};
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9nbG9iYWxzLmpzIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsInByb2Nlc3MiLCJTdHJpbmciLCJicm93c2VyIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwidG9Mb3dlckNhc2UiLCJtb2R1bGUiLCJleHBvcnRzIiwid2luZG93IiwiZ2xvYmFsIiwiZG9jdW1lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQU1BLFlBQ0osUUFBT0MsT0FBUCx1REFBT0EsT0FBUCxPQUFtQixRQUFuQixJQUNBQyxPQUFPRCxPQUFQLE1BQW9CLGtCQURwQixJQUVBQSxRQUFRRSxPQUhWOztBQUtBLElBQU1DLFlBQVksT0FBT0MsU0FBUCxLQUFxQixXQUFyQixHQUNoQkEsVUFBVUQsU0FBVixDQUFvQkUsV0FBcEIsRUFEZ0IsR0FDb0IsRUFEdEM7O0FBR0FDLE9BQU9DLE9BQVAsR0FBaUI7QUFDZkMsVUFBUSxPQUFPQSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5Q0MsTUFEbEM7QUFFZkEsVUFBUSxPQUFPQSxNQUFQLEtBQWtCLFdBQWxCLEdBQWdDQSxNQUFoQyxHQUF5Q0QsTUFGbEM7QUFHZkUsWUFBVSxPQUFPQSxRQUFQLEtBQW9CLFdBQXBCLEdBQWtDQSxRQUFsQyxHQUE2QyxFQUh4QztBQUlmWCxzQkFKZTtBQUtmSTtBQUxlLENBQWpCIiwiZmlsZSI6Imdsb2JhbHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUgLSAyMDE3IFViZXIgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuLy8gUHVycG9zZTogaW5jbHVkZSB0aGlzIGluIHlvdXIgbW9kdWxlIHRvIGF2b2lkcyBhZGRpbmcgZGVwZW5kZW5jaWVzIG9uXG4vLyBtaWNybyBtb2R1bGVzIGxpa2UgJ2dsb2JhbCcgYW5kICdpcy1icm93c2VyJztcblxuLyogZ2xvYmFsIHByb2Nlc3MsIHdpbmRvdywgZ2xvYmFsLCBkb2N1bWVudCwgbmF2aWdhdG9yICovXG5jb25zdCBpc0Jyb3dzZXIgPVxuICB0eXBlb2YgcHJvY2VzcyAhPT0gJ29iamVjdCcgfHxcbiAgU3RyaW5nKHByb2Nlc3MpICE9PSAnW29iamVjdCBwcm9jZXNzXScgfHxcbiAgcHJvY2Vzcy5icm93c2VyO1xuXG5jb25zdCB1c2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/XG4gIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSA6ICcnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCxcbiAgZ2xvYmFsOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyxcbiAgZG9jdW1lbnQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9LFxuICBpc0Jyb3dzZXIsXG4gIHVzZXJBZ2VudFxufTtcbiJdfQ==
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(30), (function() { return this; }())))

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(342);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(361);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(343), __esModule: true };

/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(344);
	__webpack_require__(356);
	module.exports = __webpack_require__(360).f('iterator');


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at = __webpack_require__(345)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(346)(String, 'String', function (iterated) {
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var index = this._i;
	  var point;
	  if (index >= O.length) return { value: undefined, done: true };
	  point = $at(O, index);
	  this._i += point.length;
	  return { value: point, done: false };
	});


/***/ }),
/* 345 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(305);
	var defined = __webpack_require__(296);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function (TO_STRING) {
	  return function (that, pos) {
	    var s = String(defined(that));
	    var i = toInteger(pos);
	    var l = s.length;
	    var a, b;
	    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY = __webpack_require__(311);
	var $export = __webpack_require__(315);
	var redefine = __webpack_require__(347);
	var hide = __webpack_require__(318);
	var Iterators = __webpack_require__(348);
	var $iterCreate = __webpack_require__(349);
	var setToStringTag = __webpack_require__(353);
	var getPrototypeOf = __webpack_require__(355);
	var ITERATOR = __webpack_require__(354)('iterator');
	var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
	var FF_ITERATOR = '@@iterator';
	var KEYS = 'keys';
	var VALUES = 'values';

	var returnThis = function () { return this; };

	module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function (kind) {
	    if (!BUGGY && kind in proto) return proto[kind];
	    switch (kind) {
	      case KEYS: return function keys() { return new Constructor(this, kind); };
	      case VALUES: return function values() { return new Constructor(this, kind); };
	    } return function entries() { return new Constructor(this, kind); };
	  };
	  var TAG = NAME + ' Iterator';
	  var DEF_VALUES = DEFAULT == VALUES;
	  var VALUES_BUG = false;
	  var proto = Base.prototype;
	  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
	  var $default = $native || getMethod(DEFAULT);
	  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
	  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
	  var methods, key, IteratorPrototype;
	  // Fix native
	  if ($anyNative) {
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
	    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEF_VALUES && $native && $native.name !== VALUES) {
	    VALUES_BUG = true;
	    $default = function values() { return $native.call(this); };
	  }
	  // Define iterator
	  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG] = returnThis;
	  if (DEFAULT) {
	    methods = {
	      values: DEF_VALUES ? $default : getMethod(VALUES),
	      keys: IS_SET ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if (FORCED) for (key in methods) {
	      if (!(key in proto)) redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(318);


/***/ }),
/* 348 */
/***/ (function(module, exports) {

	module.exports = {};


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create = __webpack_require__(350);
	var descriptor = __webpack_require__(327);
	var setToStringTag = __webpack_require__(353);
	var IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(318)(IteratorPrototype, __webpack_require__(354)('iterator'), function () { return this; });

	module.exports = function (Constructor, NAME, next) {
	  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
	  setToStringTag(Constructor, NAME + ' Iterator');
	};


/***/ }),
/* 350 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject = __webpack_require__(320);
	var dPs = __webpack_require__(351);
	var enumBugKeys = __webpack_require__(313);
	var IE_PROTO = __webpack_require__(307)('IE_PROTO');
	var Empty = function () { /* empty */ };
	var PROTOTYPE = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(325)('iframe');
	  var i = enumBugKeys.length;
	  var lt = '<';
	  var gt = '>';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(352).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty();
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

	var dP = __webpack_require__(319);
	var anObject = __webpack_require__(320);
	var getKeys = __webpack_require__(297);

	module.exports = __webpack_require__(323) ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = getKeys(Properties);
	  var length = keys.length;
	  var i = 0;
	  var P;
	  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

	var document = __webpack_require__(310).document;
	module.exports = document && document.documentElement;


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(319).f;
	var has = __webpack_require__(299);
	var TAG = __webpack_require__(354)('toStringTag');

	module.exports = function (it, tag, stat) {
	  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
	};


/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

	var store = __webpack_require__(308)('wks');
	var uid = __webpack_require__(312);
	var Symbol = __webpack_require__(310).Symbol;
	var USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function (name) {
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has = __webpack_require__(299);
	var toObject = __webpack_require__(295);
	var IE_PROTO = __webpack_require__(307)('IE_PROTO');
	var ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(357);
	var global = __webpack_require__(310);
	var hide = __webpack_require__(318);
	var Iterators = __webpack_require__(348);
	var TO_STRING_TAG = __webpack_require__(354)('toStringTag');

	var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
	  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
	  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
	  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
	  'TextTrackList,TouchList').split(',');

	for (var i = 0; i < DOMIterables.length; i++) {
	  var NAME = DOMIterables[i];
	  var Collection = global[NAME];
	  var proto = Collection && Collection.prototype;
	  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(358);
	var step = __webpack_require__(359);
	var Iterators = __webpack_require__(348);
	var toIObject = __webpack_require__(300);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(346)(Array, 'Array', function (iterated, kind) {
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function () {
	  var O = this._t;
	  var kind = this._k;
	  var index = this._i++;
	  if (!O || index >= O.length) {
	    this._t = undefined;
	    return step(1);
	  }
	  if (kind == 'keys') return step(0, index);
	  if (kind == 'values') return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');


/***/ }),
/* 358 */
/***/ (function(module, exports) {

	module.exports = function () { /* empty */ };


/***/ }),
/* 359 */
/***/ (function(module, exports) {

	module.exports = function (done, value) {
	  return { value: value, done: !!done };
	};


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(354);


/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(362), __esModule: true };

/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(363);
	__webpack_require__(371);
	__webpack_require__(372);
	__webpack_require__(373);
	module.exports = __webpack_require__(309).Symbol;


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global = __webpack_require__(310);
	var has = __webpack_require__(299);
	var DESCRIPTORS = __webpack_require__(323);
	var $export = __webpack_require__(315);
	var redefine = __webpack_require__(347);
	var META = __webpack_require__(364).KEY;
	var $fails = __webpack_require__(324);
	var shared = __webpack_require__(308);
	var setToStringTag = __webpack_require__(353);
	var uid = __webpack_require__(312);
	var wks = __webpack_require__(354);
	var wksExt = __webpack_require__(360);
	var wksDefine = __webpack_require__(365);
	var enumKeys = __webpack_require__(366);
	var isArray = __webpack_require__(367);
	var anObject = __webpack_require__(320);
	var isObject = __webpack_require__(321);
	var toIObject = __webpack_require__(300);
	var toPrimitive = __webpack_require__(326);
	var createDesc = __webpack_require__(327);
	var _create = __webpack_require__(350);
	var gOPNExt = __webpack_require__(368);
	var $GOPD = __webpack_require__(370);
	var $DP = __webpack_require__(319);
	var $keys = __webpack_require__(297);
	var gOPD = $GOPD.f;
	var dP = $DP.f;
	var gOPN = gOPNExt.f;
	var $Symbol = global.Symbol;
	var $JSON = global.JSON;
	var _stringify = $JSON && $JSON.stringify;
	var PROTOTYPE = 'prototype';
	var HIDDEN = wks('_hidden');
	var TO_PRIMITIVE = wks('toPrimitive');
	var isEnum = {}.propertyIsEnumerable;
	var SymbolRegistry = shared('symbol-registry');
	var AllSymbols = shared('symbols');
	var OPSymbols = shared('op-symbols');
	var ObjectProto = Object[PROTOTYPE];
	var USE_NATIVE = typeof $Symbol == 'function';
	var QObject = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function () {
	  return _create(dP({}, 'a', {
	    get: function () { return dP(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (it, key, D) {
	  var protoDesc = gOPD(ObjectProto, key);
	  if (protoDesc) delete ObjectProto[key];
	  dP(it, key, D);
	  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function (tag) {
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D) {
	  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if (has(AllSymbols, key)) {
	    if (!D.enumerable) {
	      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
	      D = _create(D, { enumerable: createDesc(0, false) });
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P) {
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P));
	  var i = 0;
	  var l = keys.length;
	  var key;
	  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P) {
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key) {
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
	  it = toIObject(it);
	  key = toPrimitive(key, true);
	  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
	  var D = gOPD(it, key);
	  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it) {
	  var names = gOPN(toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
	  var IS_OP = it === ObjectProto;
	  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
	  var result = [];
	  var i = 0;
	  var key;
	  while (names.length > i) {
	    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if (!USE_NATIVE) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function (value) {
	      if (this === ObjectProto) $set.call(OPSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f = $defineProperty;
	  __webpack_require__(369).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(333).f = $propertyIsEnumerable;
	  __webpack_require__(332).f = $getOwnPropertySymbols;

	  if (DESCRIPTORS && !__webpack_require__(311)) {
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function (name) {
	    return wrap(wks(name));
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

	for (var es6Symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

	for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function (key) {
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
	    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
	  },
	  useSetter: function () { setter = true; },
	  useSimple: function () { setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it) {
	    var args = [it];
	    var i = 1;
	    var replacer, $replacer;
	    while (arguments.length > i) args.push(arguments[i++]);
	    $replacer = replacer = args[1];
	    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	    if (!isArray(replacer)) replacer = function (key, value) {
	      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	      if (!isSymbol(value)) return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(318)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

	var META = __webpack_require__(312)('meta');
	var isObject = __webpack_require__(321);
	var has = __webpack_require__(299);
	var setDesc = __webpack_require__(319).f;
	var id = 0;
	var isExtensible = Object.isExtensible || function () {
	  return true;
	};
	var FREEZE = !__webpack_require__(324)(function () {
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function (it) {
	  setDesc(it, META, { value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  } });
	};
	var fastKey = function (it, create) {
	  // return primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function (it, create) {
	  if (!has(it, META)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY: META,
	  NEED: false,
	  fastKey: fastKey,
	  getWeak: getWeak,
	  onFreeze: onFreeze
	};


/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(310);
	var core = __webpack_require__(309);
	var LIBRARY = __webpack_require__(311);
	var wksExt = __webpack_require__(360);
	var defineProperty = __webpack_require__(319).f;
	module.exports = function (name) {
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
	};


/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(297);
	var gOPS = __webpack_require__(332);
	var pIE = __webpack_require__(333);
	module.exports = function (it) {
	  var result = getKeys(it);
	  var getSymbols = gOPS.f;
	  if (getSymbols) {
	    var symbols = getSymbols(it);
	    var isEnum = pIE.f;
	    var i = 0;
	    var key;
	    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
	  } return result;
	};


/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(302);
	module.exports = Array.isArray || function isArray(arg) {
	  return cof(arg) == 'Array';
	};


/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(300);
	var gOPN = __webpack_require__(369).f;
	var toString = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return gOPN(it);
	  } catch (e) {
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it) {
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys = __webpack_require__(298);
	var hiddenKeys = __webpack_require__(313).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return $keys(O, hiddenKeys);
	};


/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE = __webpack_require__(333);
	var createDesc = __webpack_require__(327);
	var toIObject = __webpack_require__(300);
	var toPrimitive = __webpack_require__(326);
	var has = __webpack_require__(299);
	var IE8_DOM_DEFINE = __webpack_require__(322);
	var gOPD = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(323) ? gOPD : function getOwnPropertyDescriptor(O, P) {
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if (IE8_DOM_DEFINE) try {
	    return gOPD(O, P);
	  } catch (e) { /* empty */ }
	  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
	};


/***/ }),
/* 371 */
/***/ (function(module, exports) {

	

/***/ }),
/* 372 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(365)('asyncIterator');


/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(365)('observable');


/***/ }),
/* 374 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.enhancePointerEventInput = enhancePointerEventInput;
	exports.enhanceMouseInput = enhanceMouseInput;
	/**
	 * This file contains overrides the default
	 * hammer.js functions to add our own utility
	 */

	/* Hammer.js constants */
	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var MOUSE_INPUT_MAP = {
	  mousedown: INPUT_START,
	  mousemove: INPUT_MOVE,
	  mouseup: INPUT_END
	};

	/**
	 * Helper function that returns true if any element in an array meets given criteria.
	 * Because older browsers do not support `Array.prototype.some`
	 * @params array {Array}
	 * @params predict {Function}
	 */
	function some(array, predict) {
	  for (var i = 0; i < array.length; i++) {
	    if (predict(array[i])) {
	      return true;
	    }
	  }
	  return false;
	}

	/* eslint-disable no-invalid-this */
	function enhancePointerEventInput(PointerEventInput) {
	  var oldHandler = PointerEventInput.prototype.handler;

	  // overrides PointerEventInput.handler to accept right mouse button
	  PointerEventInput.prototype.handler = function handler(ev) {
	    var store = this.store;

	    // Allow non-left mouse buttons through
	    if (ev.button > 0) {
	      if (!some(store, function (e) {
	        return e.pointerId === ev.pointerId;
	      })) {
	        store.push(ev);
	      }
	    }

	    oldHandler.call(this, ev);
	  };
	}

	// overrides MouseInput.handler to accept right mouse button
	function enhanceMouseInput(MouseInput) {
	  MouseInput.prototype.handler = function handler(ev) {
	    var eventType = MOUSE_INPUT_MAP[ev.type];

	    // on start we want to have the mouse button down
	    if (eventType & INPUT_START && ev.button >= 0) {
	      this.pressed = true;
	    }

	    if (eventType & INPUT_MOVE && ev.which === 0) {
	      eventType = INPUT_END;
	    }

	    // mouse must be down
	    if (!this.pressed) {
	      return;
	    }

	    if (eventType & INPUT_END) {
	      this.pressed = false;
	    }

	    this.callback(this.manager, eventType, {
	      pointers: [ev],
	      changedPointers: [ev],
	      pointerType: 'mouse',
	      srcEvent: ev
	    });
	  };
	}
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9oYW1tZXItb3ZlcnJpZGVzLmpzIl0sIm5hbWVzIjpbImVuaGFuY2VQb2ludGVyRXZlbnRJbnB1dCIsImVuaGFuY2VNb3VzZUlucHV0IiwiSU5QVVRfU1RBUlQiLCJJTlBVVF9NT1ZFIiwiSU5QVVRfRU5EIiwiTU9VU0VfSU5QVVRfTUFQIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsInNvbWUiLCJhcnJheSIsInByZWRpY3QiLCJpIiwibGVuZ3RoIiwiUG9pbnRlckV2ZW50SW5wdXQiLCJvbGRIYW5kbGVyIiwicHJvdG90eXBlIiwiaGFuZGxlciIsImV2Iiwic3RvcmUiLCJidXR0b24iLCJlIiwicG9pbnRlcklkIiwicHVzaCIsImNhbGwiLCJNb3VzZUlucHV0IiwiZXZlbnRUeXBlIiwidHlwZSIsInByZXNzZWQiLCJ3aGljaCIsImNhbGxiYWNrIiwibWFuYWdlciIsInBvaW50ZXJzIiwiY2hhbmdlZFBvaW50ZXJzIiwicG9pbnRlclR5cGUiLCJzcmNFdmVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7UUErQmdCQSx3QixHQUFBQSx3QjtRQW1CQUMsaUIsR0FBQUEsaUI7QUFsRGhCOzs7OztBQUtBO0FBQ0EsSUFBTUMsY0FBYyxDQUFwQjtBQUNBLElBQU1DLGFBQWEsQ0FBbkI7QUFDQSxJQUFNQyxZQUFZLENBQWxCO0FBQ0EsSUFBTUMsa0JBQWtCO0FBQ3RCQyxhQUFXSixXQURXO0FBRXRCSyxhQUFXSixVQUZXO0FBR3RCSyxXQUFTSjtBQUhhLENBQXhCOztBQU1BOzs7Ozs7QUFNQSxTQUFTSyxJQUFULENBQWNDLEtBQWQsRUFBcUJDLE9BQXJCLEVBQThCO0FBQzVCLE9BQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJRixNQUFNRyxNQUExQixFQUFrQ0QsR0FBbEMsRUFBdUM7QUFDckMsUUFBSUQsUUFBUUQsTUFBTUUsQ0FBTixDQUFSLENBQUosRUFBdUI7QUFDckIsYUFBTyxJQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ08sU0FBU1osd0JBQVQsQ0FBa0NjLGlCQUFsQyxFQUFxRDtBQUMxRCxNQUFNQyxhQUFhRCxrQkFBa0JFLFNBQWxCLENBQTRCQyxPQUEvQzs7QUFFQTtBQUNBSCxvQkFBa0JFLFNBQWxCLENBQTRCQyxPQUE1QixHQUFzQyxTQUFTQSxPQUFULENBQWlCQyxFQUFqQixFQUFxQjtBQUN6RCxRQUFNQyxRQUFRLEtBQUtBLEtBQW5COztBQUVBO0FBQ0EsUUFBSUQsR0FBR0UsTUFBSCxHQUFZLENBQWhCLEVBQW1CO0FBQ2pCLFVBQUksQ0FBQ1gsS0FBS1UsS0FBTCxFQUFZO0FBQUEsZUFBS0UsRUFBRUMsU0FBRixLQUFnQkosR0FBR0ksU0FBeEI7QUFBQSxPQUFaLENBQUwsRUFBcUQ7QUFDbkRILGNBQU1JLElBQU4sQ0FBV0wsRUFBWDtBQUNEO0FBQ0Y7O0FBRURILGVBQVdTLElBQVgsQ0FBZ0IsSUFBaEIsRUFBc0JOLEVBQXRCO0FBQ0QsR0FYRDtBQVlEOztBQUVEO0FBQ08sU0FBU2pCLGlCQUFULENBQTJCd0IsVUFBM0IsRUFBdUM7QUFDNUNBLGFBQVdULFNBQVgsQ0FBcUJDLE9BQXJCLEdBQStCLFNBQVNBLE9BQVQsQ0FBaUJDLEVBQWpCLEVBQXFCO0FBQ2xELFFBQUlRLFlBQVlyQixnQkFBZ0JhLEdBQUdTLElBQW5CLENBQWhCOztBQUVBO0FBQ0EsUUFBSUQsWUFBWXhCLFdBQVosSUFBMkJnQixHQUFHRSxNQUFILElBQWEsQ0FBNUMsRUFBK0M7QUFDN0MsV0FBS1EsT0FBTCxHQUFlLElBQWY7QUFDRDs7QUFFRCxRQUFJRixZQUFZdkIsVUFBWixJQUEwQmUsR0FBR1csS0FBSCxLQUFhLENBQTNDLEVBQThDO0FBQzVDSCxrQkFBWXRCLFNBQVo7QUFDRDs7QUFFRDtBQUNBLFFBQUksQ0FBQyxLQUFLd0IsT0FBVixFQUFtQjtBQUNqQjtBQUNEOztBQUVELFFBQUlGLFlBQVl0QixTQUFoQixFQUEyQjtBQUN6QixXQUFLd0IsT0FBTCxHQUFlLEtBQWY7QUFDRDs7QUFFRCxTQUFLRSxRQUFMLENBQWMsS0FBS0MsT0FBbkIsRUFBNEJMLFNBQTVCLEVBQXVDO0FBQ3JDTSxnQkFBVSxDQUFDZCxFQUFELENBRDJCO0FBRXJDZSx1QkFBaUIsQ0FBQ2YsRUFBRCxDQUZvQjtBQUdyQ2dCLG1CQUFhLE9BSHdCO0FBSXJDQyxnQkFBVWpCO0FBSjJCLEtBQXZDO0FBTUQsR0EzQkQ7QUE0QkQiLCJmaWxlIjoiaGFtbWVyLW92ZXJyaWRlcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIG92ZXJyaWRlcyB0aGUgZGVmYXVsdFxuICogaGFtbWVyLmpzIGZ1bmN0aW9ucyB0byBhZGQgb3VyIG93biB1dGlsaXR5XG4gKi9cblxuLyogSGFtbWVyLmpzIGNvbnN0YW50cyAqL1xuY29uc3QgSU5QVVRfU1RBUlQgPSAxO1xuY29uc3QgSU5QVVRfTU9WRSA9IDI7XG5jb25zdCBJTlBVVF9FTkQgPSA0O1xuY29uc3QgTU9VU0VfSU5QVVRfTUFQID0ge1xuICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gIG1vdXNldXA6IElOUFVUX0VORFxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW55IGVsZW1lbnQgaW4gYW4gYXJyYXkgbWVldHMgZ2l2ZW4gY3JpdGVyaWEuXG4gKiBCZWNhdXNlIG9sZGVyIGJyb3dzZXJzIGRvIG5vdCBzdXBwb3J0IGBBcnJheS5wcm90b3R5cGUuc29tZWBcbiAqIEBwYXJhbXMgYXJyYXkge0FycmF5fVxuICogQHBhcmFtcyBwcmVkaWN0IHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gc29tZShhcnJheSwgcHJlZGljdCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHByZWRpY3QoYXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlUG9pbnRlckV2ZW50SW5wdXQoUG9pbnRlckV2ZW50SW5wdXQpIHtcbiAgY29uc3Qgb2xkSGFuZGxlciA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZS5oYW5kbGVyO1xuXG4gIC8vIG92ZXJyaWRlcyBQb2ludGVyRXZlbnRJbnB1dC5oYW5kbGVyIHRvIGFjY2VwdCByaWdodCBtb3VzZSBidXR0b25cbiAgUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB0aGlzLnN0b3JlO1xuXG4gICAgLy8gQWxsb3cgbm9uLWxlZnQgbW91c2UgYnV0dG9ucyB0aHJvdWdoXG4gICAgaWYgKGV2LmJ1dHRvbiA+IDApIHtcbiAgICAgIGlmICghc29tZShzdG9yZSwgZSA9PiBlLnBvaW50ZXJJZCA9PT0gZXYucG9pbnRlcklkKSkge1xuICAgICAgICBzdG9yZS5wdXNoKGV2KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvbGRIYW5kbGVyLmNhbGwodGhpcywgZXYpO1xuICB9O1xufVxuXG4vLyBvdmVycmlkZXMgTW91c2VJbnB1dC5oYW5kbGVyIHRvIGFjY2VwdCByaWdodCBtb3VzZSBidXR0b25cbmV4cG9ydCBmdW5jdGlvbiBlbmhhbmNlTW91c2VJbnB1dChNb3VzZUlucHV0KSB7XG4gIE1vdXNlSW5wdXQucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgbGV0IGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgIC8vIG9uIHN0YXJ0IHdlIHdhbnQgdG8gaGF2ZSB0aGUgbW91c2UgYnV0dG9uIGRvd25cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID49IDApIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX01PVkUgJiYgZXYud2hpY2ggPT09IDApIHtcbiAgICAgIGV2ZW50VHlwZSA9IElOUFVUX0VORDtcbiAgICB9XG5cbiAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICBpZiAoIXRoaXMucHJlc3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCBldmVudFR5cGUsIHtcbiAgICAgIHBvaW50ZXJzOiBbZXZdLFxuICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcbiAgfTtcbn1cbiJdfQ==

/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }

	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        assign(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */

	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;

	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);

	    this.primaryTouch = null;
	    this.lastTouches = [];
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }

	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}

	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];

	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}

	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture

	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;

	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }

	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});

	    this.id = uniqueId();

	    this.manager = null;

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(event) {
	            self.manager.emit(event, input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }

	        emit(self.options.event); // simple 'eventName' events

	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {

	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);

	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});

	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        recognizer = this.get(recognizer);

	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);

	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }

	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	        if (handler === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;

	if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(328);

	var _assign2 = _interopRequireDefault(_assign);

	var _classCallCheck2 = __webpack_require__(334);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(335);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _constants = __webpack_require__(377);

	var _globals = __webpack_require__(340);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var firefox = _globals.userAgent.indexOf('firefox') !== -1;

	var WHEEL_EVENTS = _constants.INPUT_EVENT_TYPES.WHEEL_EVENTS;

	var EVENT_TYPE = 'wheel';

	// Constants for normalizing input delta
	var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
	var WHEEL_DELTA_PER_LINE = 40;
	// Slow down zoom if shift key is held for more precise zooming
	var SHIFT_MULTIPLIER = 0.25;

	var WheelInput = function () {
	  function WheelInput(element, callback) {
	    var _this = this;

	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    (0, _classCallCheck3.default)(this, WheelInput);

	    this.element = element;
	    this.callback = callback;

	    this.options = (0, _assign2.default)({ enable: true }, options);

	    this.events = WHEEL_EVENTS.concat(options.events || []);

	    this.handleEvent = this.handleEvent.bind(this);
	    this.events.forEach(function (event) {
	      return element.addEventListener(event, _this.handleEvent);
	    });
	  }

	  (0, _createClass3.default)(WheelInput, [{
	    key: 'destroy',
	    value: function destroy() {
	      var _this2 = this;

	      this.events.forEach(function (event) {
	        return _this2.element.removeEventListener(event, _this2.handleEvent);
	      });
	    }

	    /**
	     * Enable this input (begin processing events)
	     * if the specified event type is among those handled by this input.
	     */

	  }, {
	    key: 'enableEventType',
	    value: function enableEventType(eventType, enabled) {
	      if (eventType === EVENT_TYPE) {
	        this.options.enable = enabled;
	      }
	    }

	    /* eslint-disable complexity, max-statements */

	  }, {
	    key: 'handleEvent',
	    value: function handleEvent(event) {
	      if (!this.options.enable) {
	        return;
	      }
	      if (this.options.legacyBlockScroll) {
	        event.preventDefault();
	      }

	      var value = event.deltaY;
	      if (_globals.window.WheelEvent) {
	        // Firefox doubles the values on retina screens...
	        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {
	          value /= _globals.window.devicePixelRatio;
	        }
	        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {
	          value *= WHEEL_DELTA_PER_LINE;
	        }
	      }

	      var wheelPosition = {
	        x: event.clientX,
	        y: event.clientY
	      };

	      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
	        // This one is definitely a mouse wheel event.
	        // Normalize this value to match trackpad.
	        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
	      }

	      if (event.shiftKey && value) {
	        value = value * SHIFT_MULTIPLIER;
	      }

	      this._onWheel(event, -value, wheelPosition);
	    }
	  }, {
	    key: '_onWheel',
	    value: function _onWheel(srcEvent, delta, position) {
	      this.callback({
	        type: EVENT_TYPE,
	        center: position,
	        delta: delta,
	        srcEvent: srcEvent,
	        pointerType: 'mouse',
	        target: srcEvent.target
	      });
	    }
	  }]);
	  return WheelInput;
	}();

	exports.default = WheelInput;
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnB1dHMvd2hlZWwtaW5wdXQuanMiXSwibmFtZXMiOlsiZmlyZWZveCIsImluZGV4T2YiLCJXSEVFTF9FVkVOVFMiLCJFVkVOVF9UWVBFIiwiV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSIiwiV0hFRUxfREVMVEFfUEVSX0xJTkUiLCJTSElGVF9NVUxUSVBMSUVSIiwiV2hlZWxJbnB1dCIsImVsZW1lbnQiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJlbmFibGUiLCJldmVudHMiLCJjb25jYXQiLCJoYW5kbGVFdmVudCIsImJpbmQiLCJmb3JFYWNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2ZW50VHlwZSIsImVuYWJsZWQiLCJsZWdhY3lCbG9ja1Njcm9sbCIsInByZXZlbnREZWZhdWx0IiwidmFsdWUiLCJkZWx0YVkiLCJXaGVlbEV2ZW50IiwiZGVsdGFNb2RlIiwiRE9NX0RFTFRBX1BJWEVMIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIkRPTV9ERUxUQV9MSU5FIiwid2hlZWxQb3NpdGlvbiIsIngiLCJjbGllbnRYIiwieSIsImNsaWVudFkiLCJNYXRoIiwiZmxvb3IiLCJzaGlmdEtleSIsIl9vbldoZWVsIiwic3JjRXZlbnQiLCJkZWx0YSIsInBvc2l0aW9uIiwidHlwZSIsImNlbnRlciIsInBvaW50ZXJUeXBlIiwidGFyZ2V0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7O0FBQ0E7Ozs7QUFyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0EsSUFBTUEsVUFBVSxtQkFBVUMsT0FBVixDQUFrQixTQUFsQixNQUFpQyxDQUFDLENBQWxEOztJQUVPQyxZLGdDQUFBQSxZOztBQUNQLElBQU1DLGFBQWEsT0FBbkI7O0FBRUE7QUFDQSxJQUFNQywyQkFBMkIsY0FBakM7QUFDQSxJQUFNQyx1QkFBdUIsRUFBN0I7QUFDQTtBQUNBLElBQU1DLG1CQUFtQixJQUF6Qjs7SUFFcUJDLFU7QUFFbkIsc0JBQVlDLE9BQVosRUFBcUJDLFFBQXJCLEVBQTZDO0FBQUE7O0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7O0FBQzNDLFNBQUtGLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCOztBQUVBLFNBQUtDLE9BQUwsR0FBZSxzQkFBYyxFQUFDQyxRQUFRLElBQVQsRUFBZCxFQUE4QkQsT0FBOUIsQ0FBZjs7QUFFQSxTQUFLRSxNQUFMLEdBQWNWLGFBQWFXLE1BQWIsQ0FBb0JILFFBQVFFLE1BQVIsSUFBa0IsRUFBdEMsQ0FBZDs7QUFFQSxTQUFLRSxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJDLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0EsU0FBS0gsTUFBTCxDQUFZSSxPQUFaLENBQW9CO0FBQUEsYUFBU1IsUUFBUVMsZ0JBQVIsQ0FBeUJDLEtBQXpCLEVBQWdDLE1BQUtKLFdBQXJDLENBQVQ7QUFBQSxLQUFwQjtBQUNEOzs7OzhCQUVTO0FBQUE7O0FBQ1IsV0FBS0YsTUFBTCxDQUFZSSxPQUFaLENBQW9CO0FBQUEsZUFBUyxPQUFLUixPQUFMLENBQWFXLG1CQUFiLENBQWlDRCxLQUFqQyxFQUF3QyxPQUFLSixXQUE3QyxDQUFUO0FBQUEsT0FBcEI7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJZ0JNLFMsRUFBV0MsTyxFQUFTO0FBQ2xDLFVBQUlELGNBQWNqQixVQUFsQixFQUE4QjtBQUM1QixhQUFLTyxPQUFMLENBQWFDLE1BQWIsR0FBc0JVLE9BQXRCO0FBQ0Q7QUFDRjs7QUFFRDs7OztnQ0FDWUgsSyxFQUFPO0FBQ2pCLFVBQUksQ0FBQyxLQUFLUixPQUFMLENBQWFDLE1BQWxCLEVBQTBCO0FBQ3hCO0FBQ0Q7QUFDRCxVQUFJLEtBQUtELE9BQUwsQ0FBYVksaUJBQWpCLEVBQW9DO0FBQ2xDSixjQUFNSyxjQUFOO0FBQ0Q7O0FBRUQsVUFBSUMsUUFBUU4sTUFBTU8sTUFBbEI7QUFDQSxVQUFJLGdCQUFPQyxVQUFYLEVBQXVCO0FBQ3JCO0FBQ0EsWUFBSTFCLFdBQVdrQixNQUFNUyxTQUFOLEtBQW9CLGdCQUFPRCxVQUFQLENBQWtCRSxlQUFyRCxFQUFzRTtBQUNwRUosbUJBQVMsZ0JBQU9LLGdCQUFoQjtBQUNEO0FBQ0QsWUFBSVgsTUFBTVMsU0FBTixLQUFvQixnQkFBT0QsVUFBUCxDQUFrQkksY0FBMUMsRUFBMEQ7QUFDeEROLG1CQUFTbkIsb0JBQVQ7QUFDRDtBQUNGOztBQUVELFVBQU0wQixnQkFBZ0I7QUFDcEJDLFdBQUdkLE1BQU1lLE9BRFc7QUFFcEJDLFdBQUdoQixNQUFNaUI7QUFGVyxPQUF0Qjs7QUFLQSxVQUFJWCxVQUFVLENBQVYsSUFBZUEsUUFBUXBCLHdCQUFSLEtBQXFDLENBQXhELEVBQTJEO0FBQ3pEO0FBQ0E7QUFDQW9CLGdCQUFRWSxLQUFLQyxLQUFMLENBQVdiLFFBQVFwQix3QkFBbkIsQ0FBUjtBQUNEOztBQUVELFVBQUljLE1BQU1vQixRQUFOLElBQWtCZCxLQUF0QixFQUE2QjtBQUMzQkEsZ0JBQVFBLFFBQVFsQixnQkFBaEI7QUFDRDs7QUFFRCxXQUFLaUMsUUFBTCxDQUFjckIsS0FBZCxFQUFxQixDQUFDTSxLQUF0QixFQUE2Qk8sYUFBN0I7QUFDRDs7OzZCQUVRUyxRLEVBQVVDLEssRUFBT0MsUSxFQUFVO0FBQ2xDLFdBQUtqQyxRQUFMLENBQWM7QUFDWmtDLGNBQU14QyxVQURNO0FBRVp5QyxnQkFBUUYsUUFGSTtBQUdaRCxvQkFIWTtBQUlaRCwwQkFKWTtBQUtaSyxxQkFBYSxPQUxEO0FBTVpDLGdCQUFRTixTQUFTTTtBQU5MLE9BQWQ7QUFRRDs7Ozs7a0JBM0VrQnZDLFUiLCJmaWxlIjoid2hlZWwtaW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0lOUFVUX0VWRU5UX1RZUEVTfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHt3aW5kb3csIHVzZXJBZ2VudH0gZnJvbSAnLi4vdXRpbHMvZ2xvYmFscyc7XG5cbmNvbnN0IGZpcmVmb3ggPSB1c2VyQWdlbnQuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcblxuY29uc3Qge1dIRUVMX0VWRU5UU30gPSBJTlBVVF9FVkVOVF9UWVBFUztcbmNvbnN0IEVWRU5UX1RZUEUgPSAnd2hlZWwnO1xuXG4vLyBDb25zdGFudHMgZm9yIG5vcm1hbGl6aW5nIGlucHV0IGRlbHRhXG5jb25zdCBXSEVFTF9ERUxUQV9NQUdJQ19TQ0FMRVIgPSA0LjAwMDI0NDE0MDYyNTtcbmNvbnN0IFdIRUVMX0RFTFRBX1BFUl9MSU5FID0gNDA7XG4vLyBTbG93IGRvd24gem9vbSBpZiBzaGlmdCBrZXkgaXMgaGVsZCBmb3IgbW9yZSBwcmVjaXNlIHpvb21pbmdcbmNvbnN0IFNISUZUX01VTFRJUExJRVIgPSAwLjI1O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaGVlbElucHV0IHtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtlbmFibGU6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIHRoaXMuZXZlbnRzID0gV0hFRUxfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gRVZFTlRfVFlQRSkge1xuICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY29tcGxleGl0eSwgbWF4LXN0YXRlbWVudHMgKi9cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5sZWdhY3lCbG9ja1Njcm9sbCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWUgPSBldmVudC5kZWx0YVk7XG4gICAgaWYgKHdpbmRvdy5XaGVlbEV2ZW50KSB7XG4gICAgICAvLyBGaXJlZm94IGRvdWJsZXMgdGhlIHZhbHVlcyBvbiByZXRpbmEgc2NyZWVucy4uLlxuICAgICAgaWYgKGZpcmVmb3ggJiYgZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfUElYRUwpIHtcbiAgICAgICAgdmFsdWUgLz0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQuZGVsdGFNb2RlID09PSB3aW5kb3cuV2hlZWxFdmVudC5ET01fREVMVEFfTElORSkge1xuICAgICAgICB2YWx1ZSAqPSBXSEVFTF9ERUxUQV9QRVJfTElORTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB3aGVlbFBvc2l0aW9uID0ge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICB9O1xuXG4gICAgaWYgKHZhbHVlICE9PSAwICYmIHZhbHVlICUgV0hFRUxfREVMVEFfTUFHSUNfU0NBTEVSID09PSAwKSB7XG4gICAgICAvLyBUaGlzIG9uZSBpcyBkZWZpbml0ZWx5IGEgbW91c2Ugd2hlZWwgZXZlbnQuXG4gICAgICAvLyBOb3JtYWxpemUgdGhpcyB2YWx1ZSB0byBtYXRjaCB0cmFja3BhZC5cbiAgICAgIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSAvIFdIRUVMX0RFTFRBX01BR0lDX1NDQUxFUik7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIHZhbHVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICogU0hJRlRfTVVMVElQTElFUjtcbiAgICB9XG5cbiAgICB0aGlzLl9vbldoZWVsKGV2ZW50LCAtdmFsdWUsIHdoZWVsUG9zaXRpb24pO1xuICB9XG5cbiAgX29uV2hlZWwoc3JjRXZlbnQsIGRlbHRhLCBwb3NpdGlvbikge1xuICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgdHlwZTogRVZFTlRfVFlQRSxcbiAgICAgIGNlbnRlcjogcG9zaXRpb24sXG4gICAgICBkZWx0YSxcbiAgICAgIHNyY0V2ZW50LFxuICAgICAgcG9pbnRlclR5cGU6ICdtb3VzZScsXG4gICAgICB0YXJnZXQ6IHNyY0V2ZW50LnRhcmdldFxuICAgIH0pO1xuICB9XG59XG4iXX0=

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.GESTURE_EVENT_ALIASES = exports.EVENT_RECOGNIZER_MAP = exports.INPUT_EVENT_TYPES = exports.BASIC_EVENT_ALIASES = exports.RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZERS = undefined;

	var _hammer = __webpack_require__(339);

	var _hammer2 = _interopRequireDefault(_hammer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// This module contains constants that must be conditionally required
	// due to `window`/`document` references downstream.
	var RECOGNIZERS = exports.RECOGNIZERS = _hammer2.default ? [[_hammer2.default.Rotate, { enable: false }], [_hammer2.default.Pinch, { enable: false }], [_hammer2.default.Swipe, { enable: false }], [_hammer2.default.Pan, { threshold: 0, enable: false }], [_hammer2.default.Press, { enable: false }], [_hammer2.default.Tap, { event: 'doubletap', taps: 2, enable: false }], [_hammer2.default.Tap, { enable: false }]] : null;

	// Recognize the following gestures even if a given recognizer succeeds
	// Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var RECOGNIZER_COMPATIBLE_MAP = exports.RECOGNIZER_COMPATIBLE_MAP = {
	  rotate: ['pinch']
	};

	// Recognize the folling gestures only if a given recognizer fails
	var RECOGNIZER_FALLBACK_MAP = exports.RECOGNIZER_FALLBACK_MAP = {
	  doubletap: ['tap']
	};

	/**
	 * Only one set of basic input events will be fired by Hammer.js:
	 * either pointer, touch, or mouse, depending on system support.
	 * In order to enable an application to be agnostic of system support,
	 * alias basic input events into "classes" of events: down, move, and up.
	 * See `_onBasicInput()` for usage of these aliases.
	 */
	var BASIC_EVENT_ALIASES = exports.BASIC_EVENT_ALIASES = {
	  pointerdown: 'pointerdown',
	  pointermove: 'pointermove',
	  pointerup: 'pointerup',
	  touchstart: 'pointerdown',
	  touchmove: 'pointermove',
	  touchend: 'pointerup',
	  mousedown: 'pointerdown',
	  mousemove: 'pointermove',
	  mouseup: 'pointerup'
	};

	var INPUT_EVENT_TYPES = exports.INPUT_EVENT_TYPES = {
	  KEY_EVENTS: ['keydown', 'keyup'],
	  MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseleave'],
	  WHEEL_EVENTS: [
	  // Chrome, Safari
	  'wheel',
	  // IE
	  'mousewheel',
	  // legacy Firefox
	  'DOMMouseScroll']
	};

	/**
	 * "Gestural" events are those that have semantic meaning beyond the basic input event,
	 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
	 * Hammer.js handles these with its Recognizer system;
	 * this block maps event names to the Recognizers required to detect the events.
	 */
	var EVENT_RECOGNIZER_MAP = exports.EVENT_RECOGNIZER_MAP = {
	  tap: 'tap',
	  doubletap: 'doubletap',
	  press: 'press',
	  pinch: 'pinch',
	  pinchin: 'pinch',
	  pinchout: 'pinch',
	  pinchstart: 'pinch',
	  pinchmove: 'pinch',
	  pinchend: 'pinch',
	  pinchcancel: 'pinch',
	  rotate: 'rotate',
	  rotatestart: 'rotate',
	  rotatemove: 'rotate',
	  rotateend: 'rotate',
	  rotatecancel: 'rotate',
	  pan: 'pan',
	  panstart: 'pan',
	  panmove: 'pan',
	  panup: 'pan',
	  pandown: 'pan',
	  panleft: 'pan',
	  panright: 'pan',
	  panend: 'pan',
	  pancancel: 'pan',
	  swipe: 'swipe',
	  swipeleft: 'swipe',
	  swiperight: 'swipe',
	  swipeup: 'swipe',
	  swipedown: 'swipe'
	};

	/**
	 * Map gestural events typically provided by browsers
	 * that are not reported in 'hammer.input' events
	 * to corresponding Hammer.js gestures.
	 */
	var GESTURE_EVENT_ALIASES = exports.GESTURE_EVENT_ALIASES = {
	  click: 'tap',
	  dblclick: 'doubletap',
	  mousedown: 'pointerdown',
	  mousemove: 'pointermove',
	  mouseup: 'pointerup',
	  mouseleave: 'pointerleave'
	};
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9jb25zdGFudHMuanMiXSwibmFtZXMiOlsiUkVDT0dOSVpFUlMiLCJSb3RhdGUiLCJlbmFibGUiLCJQaW5jaCIsIlN3aXBlIiwiUGFuIiwidGhyZXNob2xkIiwiUHJlc3MiLCJUYXAiLCJldmVudCIsInRhcHMiLCJSRUNPR05JWkVSX0NPTVBBVElCTEVfTUFQIiwicm90YXRlIiwiUkVDT0dOSVpFUl9GQUxMQkFDS19NQVAiLCJkb3VibGV0YXAiLCJCQVNJQ19FVkVOVF9BTElBU0VTIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsIm1vdXNlZG93biIsIm1vdXNlbW92ZSIsIm1vdXNldXAiLCJJTlBVVF9FVkVOVF9UWVBFUyIsIktFWV9FVkVOVFMiLCJNT1VTRV9FVkVOVFMiLCJXSEVFTF9FVkVOVFMiLCJFVkVOVF9SRUNPR05JWkVSX01BUCIsInRhcCIsInByZXNzIiwicGluY2giLCJwaW5jaGluIiwicGluY2hvdXQiLCJwaW5jaHN0YXJ0IiwicGluY2htb3ZlIiwicGluY2hlbmQiLCJwaW5jaGNhbmNlbCIsInJvdGF0ZXN0YXJ0Iiwicm90YXRlbW92ZSIsInJvdGF0ZWVuZCIsInJvdGF0ZWNhbmNlbCIsInBhbiIsInBhbnN0YXJ0IiwicGFubW92ZSIsInBhbnVwIiwicGFuZG93biIsInBhbmxlZnQiLCJwYW5yaWdodCIsInBhbmVuZCIsInBhbmNhbmNlbCIsInN3aXBlIiwic3dpcGVsZWZ0Iiwic3dpcGVyaWdodCIsInN3aXBldXAiLCJzd2lwZWRvd24iLCJHRVNUVVJFX0VWRU5UX0FMSUFTRVMiLCJjbGljayIsImRibGNsaWNrIiwibW91c2VsZWF2ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQW9CQTs7Ozs7O0FBRUE7QUFDQTtBQUNPLElBQU1BLG9DQUFjLG1CQUFTLENBQ2xDLENBQUMsaUJBQU9DLE1BQVIsRUFBZ0IsRUFBQ0MsUUFBUSxLQUFULEVBQWhCLENBRGtDLEVBRWxDLENBQUMsaUJBQU9DLEtBQVIsRUFBZSxFQUFDRCxRQUFRLEtBQVQsRUFBZixDQUZrQyxFQUdsQyxDQUFDLGlCQUFPRSxLQUFSLEVBQWUsRUFBQ0YsUUFBUSxLQUFULEVBQWYsQ0FIa0MsRUFJbEMsQ0FBQyxpQkFBT0csR0FBUixFQUFhLEVBQUNDLFdBQVcsQ0FBWixFQUFlSixRQUFRLEtBQXZCLEVBQWIsQ0FKa0MsRUFLbEMsQ0FBQyxpQkFBT0ssS0FBUixFQUFlLEVBQUNMLFFBQVEsS0FBVCxFQUFmLENBTGtDLEVBTWxDLENBQUMsaUJBQU9NLEdBQVIsRUFBYSxFQUFDQyxPQUFPLFdBQVIsRUFBcUJDLE1BQU0sQ0FBM0IsRUFBOEJSLFFBQVEsS0FBdEMsRUFBYixDQU5rQyxFQU9sQyxDQUFDLGlCQUFPTSxHQUFSLEVBQWEsRUFBQ04sUUFBUSxLQUFULEVBQWIsQ0FQa0MsQ0FBVCxHQVF2QixJQVJHOztBQVVQO0FBbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWlCTyxJQUFNUyxnRUFBNEI7QUFDdkNDLFVBQVEsQ0FBQyxPQUFEO0FBRCtCLENBQWxDOztBQUlQO0FBQ08sSUFBTUMsNERBQTBCO0FBQ3JDQyxhQUFXLENBQUMsS0FBRDtBQUQwQixDQUFoQzs7QUFJUDs7Ozs7OztBQU9PLElBQU1DLG9EQUFzQjtBQUNqQ0MsZUFBYSxhQURvQjtBQUVqQ0MsZUFBYSxhQUZvQjtBQUdqQ0MsYUFBVyxXQUhzQjtBQUlqQ0MsY0FBWSxhQUpxQjtBQUtqQ0MsYUFBVyxhQUxzQjtBQU1qQ0MsWUFBVSxXQU51QjtBQU9qQ0MsYUFBVyxhQVBzQjtBQVFqQ0MsYUFBVyxhQVJzQjtBQVNqQ0MsV0FBUztBQVR3QixDQUE1Qjs7QUFZQSxJQUFNQyxnREFBb0I7QUFDL0JDLGNBQVksQ0FDVixTQURVLEVBRVYsT0FGVSxDQURtQjtBQUsvQkMsZ0JBQWMsQ0FDWixXQURZLEVBRVosV0FGWSxFQUdaLFNBSFksRUFJWixZQUpZLENBTGlCO0FBVy9CQyxnQkFBYztBQUNaO0FBQ0EsU0FGWTtBQUdaO0FBQ0EsY0FKWTtBQUtaO0FBQ0Esa0JBTlk7QUFYaUIsQ0FBMUI7O0FBcUJQOzs7Ozs7QUFNTyxJQUFNQyxzREFBdUI7QUFDbENDLE9BQUssS0FENkI7QUFFbENoQixhQUFXLFdBRnVCO0FBR2xDaUIsU0FBTyxPQUgyQjtBQUlsQ0MsU0FBTyxPQUoyQjtBQUtsQ0MsV0FBUyxPQUx5QjtBQU1sQ0MsWUFBVSxPQU53QjtBQU9sQ0MsY0FBWSxPQVBzQjtBQVFsQ0MsYUFBVyxPQVJ1QjtBQVNsQ0MsWUFBVSxPQVR3QjtBQVVsQ0MsZUFBYSxPQVZxQjtBQVdsQzFCLFVBQVEsUUFYMEI7QUFZbEMyQixlQUFhLFFBWnFCO0FBYWxDQyxjQUFZLFFBYnNCO0FBY2xDQyxhQUFXLFFBZHVCO0FBZWxDQyxnQkFBYyxRQWZvQjtBQWdCbENDLE9BQUssS0FoQjZCO0FBaUJsQ0MsWUFBVSxLQWpCd0I7QUFrQmxDQyxXQUFTLEtBbEJ5QjtBQW1CbENDLFNBQU8sS0FuQjJCO0FBb0JsQ0MsV0FBUyxLQXBCeUI7QUFxQmxDQyxXQUFTLEtBckJ5QjtBQXNCbENDLFlBQVUsS0F0QndCO0FBdUJsQ0MsVUFBUSxLQXZCMEI7QUF3QmxDQyxhQUFXLEtBeEJ1QjtBQXlCbENDLFNBQU8sT0F6QjJCO0FBMEJsQ0MsYUFBVyxPQTFCdUI7QUEyQmxDQyxjQUFZLE9BM0JzQjtBQTRCbENDLFdBQVMsT0E1QnlCO0FBNkJsQ0MsYUFBVztBQTdCdUIsQ0FBN0I7O0FBZ0NQOzs7OztBQUtPLElBQU1DLHdEQUF3QjtBQUNuQ0MsU0FBTyxLQUQ0QjtBQUVuQ0MsWUFBVSxXQUZ5QjtBQUduQ3JDLGFBQVcsYUFId0I7QUFJbkNDLGFBQVcsYUFKd0I7QUFLbkNDLFdBQVMsV0FMMEI7QUFNbkNvQyxjQUFZO0FBTnVCLENBQTlCIiwiZmlsZSI6ImNvbnN0YW50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCBIYW1tZXIgZnJvbSAnLi91dGlscy9oYW1tZXInO1xuXG4vLyBUaGlzIG1vZHVsZSBjb250YWlucyBjb25zdGFudHMgdGhhdCBtdXN0IGJlIGNvbmRpdGlvbmFsbHkgcmVxdWlyZWRcbi8vIGR1ZSB0byBgd2luZG93YC9gZG9jdW1lbnRgIHJlZmVyZW5jZXMgZG93bnN0cmVhbS5cbmV4cG9ydCBjb25zdCBSRUNPR05JWkVSUyA9IEhhbW1lciA/IFtcbiAgW0hhbW1lci5Sb3RhdGUsIHtlbmFibGU6IGZhbHNlfV0sXG4gIFtIYW1tZXIuUGluY2gsIHtlbmFibGU6IGZhbHNlfV0sXG4gIFtIYW1tZXIuU3dpcGUsIHtlbmFibGU6IGZhbHNlfV0sXG4gIFtIYW1tZXIuUGFuLCB7dGhyZXNob2xkOiAwLCBlbmFibGU6IGZhbHNlfV0sXG4gIFtIYW1tZXIuUHJlc3MsIHtlbmFibGU6IGZhbHNlfV0sXG4gIFtIYW1tZXIuVGFwLCB7ZXZlbnQ6ICdkb3VibGV0YXAnLCB0YXBzOiAyLCBlbmFibGU6IGZhbHNlfV0sXG4gIFtIYW1tZXIuVGFwLCB7ZW5hYmxlOiBmYWxzZX1dXG5dIDogbnVsbDtcblxuLy8gUmVjb2duaXplIHRoZSBmb2xsb3dpbmcgZ2VzdHVyZXMgZXZlbiBpZiBhIGdpdmVuIHJlY29nbml6ZXIgc3VjY2VlZHNcbmV4cG9ydCBjb25zdCBSRUNPR05JWkVSX0NPTVBBVElCTEVfTUFQID0ge1xuICByb3RhdGU6IFsncGluY2gnXVxufTtcblxuLy8gUmVjb2duaXplIHRoZSBmb2xsaW5nIGdlc3R1cmVzIG9ubHkgaWYgYSBnaXZlbiByZWNvZ25pemVyIGZhaWxzXG5leHBvcnQgY29uc3QgUkVDT0dOSVpFUl9GQUxMQkFDS19NQVAgPSB7XG4gIGRvdWJsZXRhcDogWyd0YXAnXVxufTtcblxuLyoqXG4gKiBPbmx5IG9uZSBzZXQgb2YgYmFzaWMgaW5wdXQgZXZlbnRzIHdpbGwgYmUgZmlyZWQgYnkgSGFtbWVyLmpzOlxuICogZWl0aGVyIHBvaW50ZXIsIHRvdWNoLCBvciBtb3VzZSwgZGVwZW5kaW5nIG9uIHN5c3RlbSBzdXBwb3J0LlxuICogSW4gb3JkZXIgdG8gZW5hYmxlIGFuIGFwcGxpY2F0aW9uIHRvIGJlIGFnbm9zdGljIG9mIHN5c3RlbSBzdXBwb3J0LFxuICogYWxpYXMgYmFzaWMgaW5wdXQgZXZlbnRzIGludG8gXCJjbGFzc2VzXCIgb2YgZXZlbnRzOiBkb3duLCBtb3ZlLCBhbmQgdXAuXG4gKiBTZWUgYF9vbkJhc2ljSW5wdXQoKWAgZm9yIHVzYWdlIG9mIHRoZXNlIGFsaWFzZXMuXG4gKi9cbmV4cG9ydCBjb25zdCBCQVNJQ19FVkVOVF9BTElBU0VTID0ge1xuICBwb2ludGVyZG93bjogJ3BvaW50ZXJkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdwb2ludGVybW92ZScsXG4gIHBvaW50ZXJ1cDogJ3BvaW50ZXJ1cCcsXG4gIHRvdWNoc3RhcnQ6ICdwb2ludGVyZG93bicsXG4gIHRvdWNobW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdwb2ludGVydXAnLFxuICBtb3VzZWRvd246ICdwb2ludGVyZG93bicsXG4gIG1vdXNlbW92ZTogJ3BvaW50ZXJtb3ZlJyxcbiAgbW91c2V1cDogJ3BvaW50ZXJ1cCdcbn07XG5cbmV4cG9ydCBjb25zdCBJTlBVVF9FVkVOVF9UWVBFUyA9IHtcbiAgS0VZX0VWRU5UUzogW1xuICAgICdrZXlkb3duJyxcbiAgICAna2V5dXAnXG4gIF0sXG4gIE1PVVNFX0VWRU5UUzogW1xuICAgICdtb3VzZWRvd24nLFxuICAgICdtb3VzZW1vdmUnLFxuICAgICdtb3VzZXVwJyxcbiAgICAnbW91c2VsZWF2ZSdcbiAgXSxcbiAgV0hFRUxfRVZFTlRTOiBbXG4gICAgLy8gQ2hyb21lLCBTYWZhcmlcbiAgICAnd2hlZWwnLFxuICAgIC8vIElFXG4gICAgJ21vdXNld2hlZWwnLFxuICAgIC8vIGxlZ2FjeSBGaXJlZm94XG4gICAgJ0RPTU1vdXNlU2Nyb2xsJ1xuICBdXG59O1xuXG4vKipcbiAqIFwiR2VzdHVyYWxcIiBldmVudHMgYXJlIHRob3NlIHRoYXQgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGJleW9uZCB0aGUgYmFzaWMgaW5wdXQgZXZlbnQsXG4gKiBlLmcuIGEgY2xpY2sgb3IgdGFwIGlzIGEgc2VxdWVuY2Ugb2YgYGRvd25gIGFuZCBgdXBgIGV2ZW50cyB3aXRoIG5vIGBtb3ZlYCBldmVudCBpbiBiZXR3ZWVuLlxuICogSGFtbWVyLmpzIGhhbmRsZXMgdGhlc2Ugd2l0aCBpdHMgUmVjb2duaXplciBzeXN0ZW07XG4gKiB0aGlzIGJsb2NrIG1hcHMgZXZlbnQgbmFtZXMgdG8gdGhlIFJlY29nbml6ZXJzIHJlcXVpcmVkIHRvIGRldGVjdCB0aGUgZXZlbnRzLlxuICovXG5leHBvcnQgY29uc3QgRVZFTlRfUkVDT0dOSVpFUl9NQVAgPSB7XG4gIHRhcDogJ3RhcCcsXG4gIGRvdWJsZXRhcDogJ2RvdWJsZXRhcCcsXG4gIHByZXNzOiAncHJlc3MnLFxuICBwaW5jaDogJ3BpbmNoJyxcbiAgcGluY2hpbjogJ3BpbmNoJyxcbiAgcGluY2hvdXQ6ICdwaW5jaCcsXG4gIHBpbmNoc3RhcnQ6ICdwaW5jaCcsXG4gIHBpbmNobW92ZTogJ3BpbmNoJyxcbiAgcGluY2hlbmQ6ICdwaW5jaCcsXG4gIHBpbmNoY2FuY2VsOiAncGluY2gnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByb3RhdGVzdGFydDogJ3JvdGF0ZScsXG4gIHJvdGF0ZW1vdmU6ICdyb3RhdGUnLFxuICByb3RhdGVlbmQ6ICdyb3RhdGUnLFxuICByb3RhdGVjYW5jZWw6ICdyb3RhdGUnLFxuICBwYW46ICdwYW4nLFxuICBwYW5zdGFydDogJ3BhbicsXG4gIHBhbm1vdmU6ICdwYW4nLFxuICBwYW51cDogJ3BhbicsXG4gIHBhbmRvd246ICdwYW4nLFxuICBwYW5sZWZ0OiAncGFuJyxcbiAgcGFucmlnaHQ6ICdwYW4nLFxuICBwYW5lbmQ6ICdwYW4nLFxuICBwYW5jYW5jZWw6ICdwYW4nLFxuICBzd2lwZTogJ3N3aXBlJyxcbiAgc3dpcGVsZWZ0OiAnc3dpcGUnLFxuICBzd2lwZXJpZ2h0OiAnc3dpcGUnLFxuICBzd2lwZXVwOiAnc3dpcGUnLFxuICBzd2lwZWRvd246ICdzd2lwZSdcbn07XG5cbi8qKlxuICogTWFwIGdlc3R1cmFsIGV2ZW50cyB0eXBpY2FsbHkgcHJvdmlkZWQgYnkgYnJvd3NlcnNcbiAqIHRoYXQgYXJlIG5vdCByZXBvcnRlZCBpbiAnaGFtbWVyLmlucHV0JyBldmVudHNcbiAqIHRvIGNvcnJlc3BvbmRpbmcgSGFtbWVyLmpzIGdlc3R1cmVzLlxuICovXG5leHBvcnQgY29uc3QgR0VTVFVSRV9FVkVOVF9BTElBU0VTID0ge1xuICBjbGljazogJ3RhcCcsXG4gIGRibGNsaWNrOiAnZG91YmxldGFwJyxcbiAgbW91c2Vkb3duOiAncG9pbnRlcmRvd24nLFxuICBtb3VzZW1vdmU6ICdwb2ludGVybW92ZScsXG4gIG1vdXNldXA6ICdwb2ludGVydXAnLFxuICBtb3VzZWxlYXZlOiAncG9pbnRlcmxlYXZlJ1xufTtcbiJdfQ==

/***/ }),
/* 378 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(328);

	var _assign2 = _interopRequireDefault(_assign);

	var _classCallCheck2 = __webpack_require__(334);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(335);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _constants = __webpack_require__(377);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var MOUSE_EVENTS = _constants.INPUT_EVENT_TYPES.MOUSE_EVENTS; // Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var MOVE_EVENT_TYPE = 'pointermove';
	var LEAVE_EVENT_TYPE = 'pointerleave';

	/**
	 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
	 * when the pointer is not down. This class sets up a handler
	 * specifically for these events to work around this limitation.
	 * Note that this could be extended to more intelligently handle
	 * move events across input types, e.g. storing multiple simultaneous
	 * pointer/touch events, calculating speed/direction, etc.
	 */

	var MoveInput = function () {
	  function MoveInput(element, callback) {
	    var _this = this;

	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    (0, _classCallCheck3.default)(this, MoveInput);

	    this.element = element;
	    this.callback = callback;
	    this.pressed = false;

	    this.options = (0, _assign2.default)({ enable: true }, options);
	    this.enableMoveEvent = this.options.enable;
	    this.enableLeaveEvent = this.options.enable;

	    this.events = MOUSE_EVENTS.concat(options.events || []);

	    this.handleEvent = this.handleEvent.bind(this);
	    this.events.forEach(function (event) {
	      return element.addEventListener(event, _this.handleEvent);
	    });
	  }

	  (0, _createClass3.default)(MoveInput, [{
	    key: 'destroy',
	    value: function destroy() {
	      var _this2 = this;

	      this.events.forEach(function (event) {
	        return _this2.element.removeEventListener(event, _this2.handleEvent);
	      });
	    }

	    /**
	     * Enable this input (begin processing events)
	     * if the specified event type is among those handled by this input.
	     */

	  }, {
	    key: 'enableEventType',
	    value: function enableEventType(eventType, enabled) {
	      if (eventType === MOVE_EVENT_TYPE) {
	        this.enableMoveEvent = enabled;
	      }
	      if (eventType === LEAVE_EVENT_TYPE) {
	        this.enableLeaveEvent = enabled;
	      }
	    }
	  }, {
	    key: 'handleEvent',
	    value: function handleEvent(event) {
	      if (this.enableLeaveEvent) {
	        if (event.type === 'mouseleave') {
	          this.callback({
	            type: LEAVE_EVENT_TYPE,
	            srcEvent: event,
	            pointerType: 'mouse',
	            target: event.target
	          });
	        }
	      }

	      if (this.enableMoveEvent) {
	        switch (event.type) {
	          case 'mousedown':
	            if (event.button >= 0) {
	              // Button is down
	              this.pressed = true;
	            }
	            break;
	          case 'mousemove':
	            // Move events use `which` to track the button being pressed
	            if (event.which === 0) {
	              // Button is not down
	              this.pressed = false;
	            }
	            if (!this.pressed) {
	              // Drag events are emitted by hammer already
	              // we just need to emit the move event on hover
	              this.callback({
	                type: MOVE_EVENT_TYPE,
	                srcEvent: event,
	                pointerType: 'mouse',
	                target: event.target
	              });
	            }
	            break;
	          case 'mouseup':
	            this.pressed = false;
	            break;
	          default:
	        }
	      }
	    }
	  }]);
	  return MoveInput;
	}();

	exports.default = MoveInput;
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnB1dHMvbW92ZS1pbnB1dC5qcyJdLCJuYW1lcyI6WyJNT1VTRV9FVkVOVFMiLCJNT1ZFX0VWRU5UX1RZUEUiLCJMRUFWRV9FVkVOVF9UWVBFIiwiTW92ZUlucHV0IiwiZWxlbWVudCIsImNhbGxiYWNrIiwib3B0aW9ucyIsInByZXNzZWQiLCJlbmFibGUiLCJlbmFibGVNb3ZlRXZlbnQiLCJlbmFibGVMZWF2ZUV2ZW50IiwiZXZlbnRzIiwiY29uY2F0IiwiaGFuZGxlRXZlbnQiLCJiaW5kIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudFR5cGUiLCJlbmFibGVkIiwidHlwZSIsInNyY0V2ZW50IiwicG9pbnRlclR5cGUiLCJ0YXJnZXQiLCJidXR0b24iLCJ3aGljaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7O0lBRU9BLFksZ0NBQUFBLFksRUF0QlA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0EsSUFBTUMsa0JBQWtCLGFBQXhCO0FBQ0EsSUFBTUMsbUJBQW1CLGNBQXpCOztBQUVBOzs7Ozs7Ozs7SUFRcUJDLFM7QUFFbkIscUJBQVlDLE9BQVosRUFBcUJDLFFBQXJCLEVBQTZDO0FBQUE7O0FBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJO0FBQUE7O0FBQzNDLFNBQUtGLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUtDLFFBQUwsR0FBZ0JBLFFBQWhCO0FBQ0EsU0FBS0UsT0FBTCxHQUFlLEtBQWY7O0FBRUEsU0FBS0QsT0FBTCxHQUFlLHNCQUFjLEVBQUNFLFFBQVEsSUFBVCxFQUFkLEVBQThCRixPQUE5QixDQUFmO0FBQ0EsU0FBS0csZUFBTCxHQUF1QixLQUFLSCxPQUFMLENBQWFFLE1BQXBDO0FBQ0EsU0FBS0UsZ0JBQUwsR0FBd0IsS0FBS0osT0FBTCxDQUFhRSxNQUFyQzs7QUFFQSxTQUFLRyxNQUFMLEdBQWNYLGFBQWFZLE1BQWIsQ0FBb0JOLFFBQVFLLE1BQVIsSUFBa0IsRUFBdEMsQ0FBZDs7QUFFQSxTQUFLRSxXQUFMLEdBQW1CLEtBQUtBLFdBQUwsQ0FBaUJDLElBQWpCLENBQXNCLElBQXRCLENBQW5CO0FBQ0EsU0FBS0gsTUFBTCxDQUFZSSxPQUFaLENBQW9CO0FBQUEsYUFBU1gsUUFBUVksZ0JBQVIsQ0FBeUJDLEtBQXpCLEVBQWdDLE1BQUtKLFdBQXJDLENBQVQ7QUFBQSxLQUFwQjtBQUNEOzs7OzhCQUVTO0FBQUE7O0FBQ1IsV0FBS0YsTUFBTCxDQUFZSSxPQUFaLENBQW9CO0FBQUEsZUFBUyxPQUFLWCxPQUFMLENBQWFjLG1CQUFiLENBQWlDRCxLQUFqQyxFQUF3QyxPQUFLSixXQUE3QyxDQUFUO0FBQUEsT0FBcEI7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJZ0JNLFMsRUFBV0MsTyxFQUFTO0FBQ2xDLFVBQUlELGNBQWNsQixlQUFsQixFQUFtQztBQUNqQyxhQUFLUSxlQUFMLEdBQXVCVyxPQUF2QjtBQUNEO0FBQ0QsVUFBSUQsY0FBY2pCLGdCQUFsQixFQUFvQztBQUNsQyxhQUFLUSxnQkFBTCxHQUF3QlUsT0FBeEI7QUFDRDtBQUNGOzs7Z0NBRVdILEssRUFBTztBQUNqQixVQUFJLEtBQUtQLGdCQUFULEVBQTJCO0FBQ3pCLFlBQUlPLE1BQU1JLElBQU4sS0FBZSxZQUFuQixFQUFpQztBQUMvQixlQUFLaEIsUUFBTCxDQUFjO0FBQ1pnQixrQkFBTW5CLGdCQURNO0FBRVpvQixzQkFBVUwsS0FGRTtBQUdaTSx5QkFBYSxPQUhEO0FBSVpDLG9CQUFRUCxNQUFNTztBQUpGLFdBQWQ7QUFNRDtBQUNGOztBQUVELFVBQUksS0FBS2YsZUFBVCxFQUEwQjtBQUN4QixnQkFBUVEsTUFBTUksSUFBZDtBQUNBLGVBQUssV0FBTDtBQUNFLGdCQUFJSixNQUFNUSxNQUFOLElBQWdCLENBQXBCLEVBQXVCO0FBQ3JCO0FBQ0EsbUJBQUtsQixPQUFMLEdBQWUsSUFBZjtBQUNEO0FBQ0Q7QUFDRixlQUFLLFdBQUw7QUFDRTtBQUNBLGdCQUFJVSxNQUFNUyxLQUFOLEtBQWdCLENBQXBCLEVBQXVCO0FBQ3JCO0FBQ0EsbUJBQUtuQixPQUFMLEdBQWUsS0FBZjtBQUNEO0FBQ0QsZ0JBQUksQ0FBQyxLQUFLQSxPQUFWLEVBQW1CO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBS0YsUUFBTCxDQUFjO0FBQ1pnQixzQkFBTXBCLGVBRE07QUFFWnFCLDBCQUFVTCxLQUZFO0FBR1pNLDZCQUFhLE9BSEQ7QUFJWkMsd0JBQVFQLE1BQU1PO0FBSkYsZUFBZDtBQU1EO0FBQ0Q7QUFDRixlQUFLLFNBQUw7QUFDRSxpQkFBS2pCLE9BQUwsR0FBZSxLQUFmO0FBQ0E7QUFDRjtBQTNCQTtBQTZCRDtBQUVGOzs7OztrQkE5RWtCSixTIiwiZmlsZSI6Im1vdmUtaW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0lOUFVUX0VWRU5UX1RZUEVTfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB7TU9VU0VfRVZFTlRTfSA9IElOUFVUX0VWRU5UX1RZUEVTO1xuY29uc3QgTU9WRV9FVkVOVF9UWVBFID0gJ3BvaW50ZXJtb3ZlJztcbmNvbnN0IExFQVZFX0VWRU5UX1RZUEUgPSAncG9pbnRlcmxlYXZlJztcblxuLyoqXG4gKiBIYW1tZXIuanMgc3dhbGxvd3MgJ21vdmUnIGV2ZW50cyAoZm9yIHBvaW50ZXIvdG91Y2gvbW91c2UpXG4gKiB3aGVuIHRoZSBwb2ludGVyIGlzIG5vdCBkb3duLiBUaGlzIGNsYXNzIHNldHMgdXAgYSBoYW5kbGVyXG4gKiBzcGVjaWZpY2FsbHkgZm9yIHRoZXNlIGV2ZW50cyB0byB3b3JrIGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3VsZCBiZSBleHRlbmRlZCB0byBtb3JlIGludGVsbGlnZW50bHkgaGFuZGxlXG4gKiBtb3ZlIGV2ZW50cyBhY3Jvc3MgaW5wdXQgdHlwZXMsIGUuZy4gc3RvcmluZyBtdWx0aXBsZSBzaW11bHRhbmVvdXNcbiAqIHBvaW50ZXIvdG91Y2ggZXZlbnRzLCBjYWxjdWxhdGluZyBzcGVlZC9kaXJlY3Rpb24sIGV0Yy5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTW92ZUlucHV0IHtcblxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtlbmFibGU6IHRydWV9LCBvcHRpb25zKTtcbiAgICB0aGlzLmVuYWJsZU1vdmVFdmVudCA9IHRoaXMub3B0aW9ucy5lbmFibGU7XG4gICAgdGhpcy5lbmFibGVMZWF2ZUV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcblxuICAgIHRoaXMuZXZlbnRzID0gTU9VU0VfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gTU9WRV9FVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLmVuYWJsZU1vdmVFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgPT09IExFQVZFX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMuZW5hYmxlTGVhdmVFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5lbmFibGVMZWF2ZUV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbGVhdmUnKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2soe1xuICAgICAgICAgIHR5cGU6IExFQVZFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHBvaW50ZXJUeXBlOiAnbW91c2UnLFxuICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuYWJsZU1vdmVFdmVudCkge1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZWRvd24nOlxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uID49IDApIHtcbiAgICAgICAgICAvLyBCdXR0b24gaXMgZG93blxuICAgICAgICAgIHRoaXMucHJlc3NlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgICAvLyBNb3ZlIGV2ZW50cyB1c2UgYHdoaWNoYCB0byB0cmFjayB0aGUgYnV0dG9uIGJlaW5nIHByZXNzZWRcbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAwKSB7XG4gICAgICAgICAgLy8gQnV0dG9uIGlzIG5vdCBkb3duXG4gICAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAvLyBEcmFnIGV2ZW50cyBhcmUgZW1pdHRlZCBieSBoYW1tZXIgYWxyZWFkeVxuICAgICAgICAgIC8vIHdlIGp1c3QgbmVlZCB0byBlbWl0IHRoZSBtb3ZlIGV2ZW50IG9uIGhvdmVyXG4gICAgICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgICAgICB0eXBlOiBNT1ZFX0VWRU5UX1RZUEUsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZlbnQsXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogJ21vdXNlJyxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxufVxuIl19

/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _assign = __webpack_require__(328);

	var _assign2 = _interopRequireDefault(_assign);

	var _classCallCheck2 = __webpack_require__(334);

	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

	var _createClass2 = __webpack_require__(335);

	var _createClass3 = _interopRequireDefault(_createClass2);

	var _constants = __webpack_require__(377);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var KEY_EVENTS = _constants.INPUT_EVENT_TYPES.KEY_EVENTS; // Copyright (c) 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.

	var DOWN_EVENT_TYPE = 'keydown';
	var UP_EVENT_TYPE = 'keyup';

	var KeyInput = function () {
	  function KeyInput(element, callback) {
	    var _this = this;

	    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	    (0, _classCallCheck3.default)(this, KeyInput);

	    this.element = element;
	    this.callback = callback;

	    this.options = (0, _assign2.default)({ enable: true }, options);
	    this.enableDownEvent = this.options.enable;
	    this.enableUpEvent = this.options.enable;

	    this.events = KEY_EVENTS.concat(options.events || []);

	    this.handleEvent = this.handleEvent.bind(this);

	    element.tabIndex = 1;
	    element.style.outline = 'none';
	    this.events.forEach(function (event) {
	      return element.addEventListener(event, _this.handleEvent);
	    });
	  }

	  (0, _createClass3.default)(KeyInput, [{
	    key: 'destroy',
	    value: function destroy() {
	      var _this2 = this;

	      this.events.forEach(function (event) {
	        return _this2.element.removeEventListener(event, _this2.handleEvent);
	      });
	    }

	    /**
	     * Enable this input (begin processing events)
	     * if the specified event type is among those handled by this input.
	     */

	  }, {
	    key: 'enableEventType',
	    value: function enableEventType(eventType, enabled) {
	      if (eventType === DOWN_EVENT_TYPE) {
	        this.enableDownEvent = enabled;
	      }
	      if (eventType === UP_EVENT_TYPE) {
	        this.enableUpEvent = enabled;
	      }
	    }
	  }, {
	    key: 'handleEvent',
	    value: function handleEvent(event) {
	      // Ignore if focused on text input
	      var targetElement = event.target || event.srcElement;
	      if (targetElement.tagName === 'INPUT' && targetElement.type === 'text' || targetElement.tagName === 'TEXTAREA') {
	        return;
	      }

	      if (this.enableDownEvent && event.type === 'keydown') {
	        this.callback({
	          type: DOWN_EVENT_TYPE,
	          srcEvent: event,
	          key: event.key,
	          target: event.target
	        });
	      }

	      if (this.enableUpEvent && event.type === 'keyup') {
	        this.callback({
	          type: UP_EVENT_TYPE,
	          srcEvent: event,
	          key: event.key,
	          target: event.target
	        });
	      }
	    }
	  }]);
	  return KeyInput;
	}();

	exports.default = KeyInput;
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9pbnB1dHMva2V5LWlucHV0LmpzIl0sIm5hbWVzIjpbIktFWV9FVkVOVFMiLCJET1dOX0VWRU5UX1RZUEUiLCJVUF9FVkVOVF9UWVBFIiwiS2V5SW5wdXQiLCJlbGVtZW50IiwiY2FsbGJhY2siLCJvcHRpb25zIiwiZW5hYmxlIiwiZW5hYmxlRG93bkV2ZW50IiwiZW5hYmxlVXBFdmVudCIsImV2ZW50cyIsImNvbmNhdCIsImhhbmRsZUV2ZW50IiwiYmluZCIsInRhYkluZGV4Iiwic3R5bGUiLCJvdXRsaW5lIiwiZm9yRWFjaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudFR5cGUiLCJlbmFibGVkIiwidGFyZ2V0RWxlbWVudCIsInRhcmdldCIsInNyY0VsZW1lbnQiLCJ0YWdOYW1lIiwidHlwZSIsInNyY0V2ZW50Iiwia2V5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7SUFFT0EsVSxnQ0FBQUEsVSxFQXRCUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQSxJQUFNQyxrQkFBa0IsU0FBeEI7QUFDQSxJQUFNQyxnQkFBZ0IsT0FBdEI7O0lBRXFCQyxRO0FBQ25CLG9CQUFZQyxPQUFaLEVBQXFCQyxRQUFyQixFQUE2QztBQUFBOztBQUFBLFFBQWRDLE9BQWMsdUVBQUosRUFBSTtBQUFBOztBQUMzQyxTQUFLRixPQUFMLEdBQWVBLE9BQWY7QUFDQSxTQUFLQyxRQUFMLEdBQWdCQSxRQUFoQjs7QUFFQSxTQUFLQyxPQUFMLEdBQWUsc0JBQWMsRUFBQ0MsUUFBUSxJQUFULEVBQWQsRUFBOEJELE9BQTlCLENBQWY7QUFDQSxTQUFLRSxlQUFMLEdBQXVCLEtBQUtGLE9BQUwsQ0FBYUMsTUFBcEM7QUFDQSxTQUFLRSxhQUFMLEdBQXFCLEtBQUtILE9BQUwsQ0FBYUMsTUFBbEM7O0FBRUEsU0FBS0csTUFBTCxHQUFjVixXQUFXVyxNQUFYLENBQWtCTCxRQUFRSSxNQUFSLElBQWtCLEVBQXBDLENBQWQ7O0FBRUEsU0FBS0UsV0FBTCxHQUFtQixLQUFLQSxXQUFMLENBQWlCQyxJQUFqQixDQUFzQixJQUF0QixDQUFuQjs7QUFFQVQsWUFBUVUsUUFBUixHQUFtQixDQUFuQjtBQUNBVixZQUFRVyxLQUFSLENBQWNDLE9BQWQsR0FBd0IsTUFBeEI7QUFDQSxTQUFLTixNQUFMLENBQVlPLE9BQVosQ0FBb0I7QUFBQSxhQUFTYixRQUFRYyxnQkFBUixDQUF5QkMsS0FBekIsRUFBZ0MsTUFBS1AsV0FBckMsQ0FBVDtBQUFBLEtBQXBCO0FBQ0Q7Ozs7OEJBRVM7QUFBQTs7QUFDUixXQUFLRixNQUFMLENBQVlPLE9BQVosQ0FBb0I7QUFBQSxlQUFTLE9BQUtiLE9BQUwsQ0FBYWdCLG1CQUFiLENBQWlDRCxLQUFqQyxFQUF3QyxPQUFLUCxXQUE3QyxDQUFUO0FBQUEsT0FBcEI7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJZ0JTLFMsRUFBV0MsTyxFQUFTO0FBQ2xDLFVBQUlELGNBQWNwQixlQUFsQixFQUFtQztBQUNqQyxhQUFLTyxlQUFMLEdBQXVCYyxPQUF2QjtBQUNEO0FBQ0QsVUFBSUQsY0FBY25CLGFBQWxCLEVBQWlDO0FBQy9CLGFBQUtPLGFBQUwsR0FBcUJhLE9BQXJCO0FBQ0Q7QUFDRjs7O2dDQUVXSCxLLEVBQU87QUFDakI7QUFDQSxVQUFNSSxnQkFBZ0JKLE1BQU1LLE1BQU4sSUFBZ0JMLE1BQU1NLFVBQTVDO0FBQ0EsVUFBS0YsY0FBY0csT0FBZCxLQUEwQixPQUExQixJQUFxQ0gsY0FBY0ksSUFBZCxLQUF1QixNQUE3RCxJQUNGSixjQUFjRyxPQUFkLEtBQTBCLFVBRDVCLEVBQ3dDO0FBQ3RDO0FBQ0Q7O0FBRUQsVUFBSSxLQUFLbEIsZUFBTCxJQUF3QlcsTUFBTVEsSUFBTixLQUFlLFNBQTNDLEVBQXNEO0FBQ3BELGFBQUt0QixRQUFMLENBQWM7QUFDWnNCLGdCQUFNMUIsZUFETTtBQUVaMkIsb0JBQVVULEtBRkU7QUFHWlUsZUFBS1YsTUFBTVUsR0FIQztBQUlaTCxrQkFBUUwsTUFBTUs7QUFKRixTQUFkO0FBTUQ7O0FBRUQsVUFBSSxLQUFLZixhQUFMLElBQXNCVSxNQUFNUSxJQUFOLEtBQWUsT0FBekMsRUFBa0Q7QUFDaEQsYUFBS3RCLFFBQUwsQ0FBYztBQUNac0IsZ0JBQU16QixhQURNO0FBRVowQixvQkFBVVQsS0FGRTtBQUdaVSxlQUFLVixNQUFNVSxHQUhDO0FBSVpMLGtCQUFRTCxNQUFNSztBQUpGLFNBQWQ7QUFNRDtBQUNGOzs7OztrQkE1RGtCckIsUSIsImZpbGUiOiJrZXktaW5wdXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgVWJlciBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5pbXBvcnQge0lOUFVUX0VWRU5UX1RZUEVTfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5jb25zdCB7S0VZX0VWRU5UU30gPSBJTlBVVF9FVkVOVF9UWVBFUztcbmNvbnN0IERPV05fRVZFTlRfVFlQRSA9ICdrZXlkb3duJztcbmNvbnN0IFVQX0VWRU5UX1RZUEUgPSAna2V5dXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlJbnB1dCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe2VuYWJsZTogdHJ1ZX0sIG9wdGlvbnMpO1xuICAgIHRoaXMuZW5hYmxlRG93bkV2ZW50ID0gdGhpcy5vcHRpb25zLmVuYWJsZTtcbiAgICB0aGlzLmVuYWJsZVVwRXZlbnQgPSB0aGlzLm9wdGlvbnMuZW5hYmxlO1xuXG4gICAgdGhpcy5ldmVudHMgPSBLRVlfRVZFTlRTLmNvbmNhdChvcHRpb25zLmV2ZW50cyB8fCBbXSk7XG5cbiAgICB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpO1xuXG4gICAgZWxlbWVudC50YWJJbmRleCA9IDE7XG4gICAgZWxlbWVudC5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmhhbmRsZUV2ZW50KSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaGFuZGxlRXZlbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGUgdGhpcyBpbnB1dCAoYmVnaW4gcHJvY2Vzc2luZyBldmVudHMpXG4gICAqIGlmIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZSBpcyBhbW9uZyB0aG9zZSBoYW5kbGVkIGJ5IHRoaXMgaW5wdXQuXG4gICAqL1xuICBlbmFibGVFdmVudFR5cGUoZXZlbnRUeXBlLCBlbmFibGVkKSB7XG4gICAgaWYgKGV2ZW50VHlwZSA9PT0gRE9XTl9FVkVOVF9UWVBFKSB7XG4gICAgICB0aGlzLmVuYWJsZURvd25FdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIGlmIChldmVudFR5cGUgPT09IFVQX0VWRU5UX1RZUEUpIHtcbiAgICAgIHRoaXMuZW5hYmxlVXBFdmVudCA9IGVuYWJsZWQ7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgaWYgZm9jdXNlZCBvbiB0ZXh0IGlucHV0XG4gICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuICAgIGlmICgodGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnSU5QVVQnICYmIHRhcmdldEVsZW1lbnQudHlwZSA9PT0gJ3RleHQnKSB8fFxuICAgICAgdGFyZ2V0RWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW5hYmxlRG93bkV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJykge1xuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IERPV05fRVZFTlRfVFlQRSxcbiAgICAgICAgc3JjRXZlbnQ6IGV2ZW50LFxuICAgICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgICAgdGFyZ2V0OiBldmVudC50YXJnZXRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVuYWJsZVVwRXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgdGhpcy5jYWxsYmFjayh7XG4gICAgICAgIHR5cGU6IFVQX0VWRU5UX1RZUEUsXG4gICAgICAgIHNyY0V2ZW50OiBldmVudCxcbiAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbiJdfQ==

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _isFinite = __webpack_require__(381);

	var _isFinite2 = _interopRequireDefault(_isFinite);

	exports.whichButtons = whichButtons;
	exports.getOffsetPosition = getOffsetPosition;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/* Constants */
	var DOWN_EVENT = 1;
	var MOVE_EVENT = 2;
	var UP_EVENT = 4;
	var MOUSE_EVENTS = {
	  pointerdown: DOWN_EVENT,
	  pointermove: MOVE_EVENT,
	  pointerup: UP_EVENT,
	  mousedown: DOWN_EVENT,
	  mousemove: MOVE_EVENT,
	  mouseup: UP_EVENT
	};

	// MouseEvent.which https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which
	var MOUSE_EVENT_WHICH_LEFT = 1;
	var MOUSE_EVENT_WHICH_MIDDLE = 2;
	var MOUSE_EVENT_WHICH_RIGHT = 3;
	// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
	var MOUSE_EVENT_BUTTON_LEFT = 0;
	var MOUSE_EVENT_BUTTON_MIDDLE = 1;
	var MOUSE_EVENT_BUTTON_RIGHT = 2;
	// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
	var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
	var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
	var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;

	/**
	 * Extract the involved mouse button
	 */
	function whichButtons(event) {
	  var eventType = MOUSE_EVENTS[event.srcEvent.type];
	  if (!eventType) {
	    // Not a mouse evet
	    return null;
	  }

	  var _event$srcEvent = event.srcEvent,
	      buttons = _event$srcEvent.buttons,
	      button = _event$srcEvent.button,
	      which = _event$srcEvent.which;

	  var leftButton = false;
	  var middleButton = false;
	  var rightButton = false;

	  if (
	  // button is up, need to find out which one was pressed before
	  eventType === UP_EVENT ||
	  // moving but does not support `buttons` API
	  eventType === MOVE_EVENT && !(0, _isFinite2.default)(buttons)) {
	    leftButton = which === MOUSE_EVENT_WHICH_LEFT;
	    middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
	    rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
	  } else if (eventType === MOVE_EVENT) {
	    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
	    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
	    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
	  } else if (eventType === DOWN_EVENT) {
	    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
	    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
	    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
	  }

	  return { leftButton: leftButton, middleButton: middleButton, rightButton: rightButton };
	}

	/**
	 * Calculate event position relative to the root element
	 */
	function getOffsetPosition(event, rootElement) {
	  var srcEvent = event.srcEvent;

	  // `center` is a hammer.js event property

	  if (!event.center && !(0, _isFinite2.default)(srcEvent.clientX)) {
	    // Not a gestural event
	    return null;
	  }

	  var center = event.center || {
	    x: srcEvent.clientX,
	    y: srcEvent.clientY
	  };

	  var rect = rootElement.getBoundingClientRect();

	  // Fix scale for map affected by a CSS transform.
	  // See https://stackoverflow.com/a/26893663/3528533
	  var scaleX = rect.width / rootElement.offsetWidth;
	  var scaleY = rect.height / rootElement.offsetHeight;

	  // Calculate center relative to the root element
	  var offsetCenter = {
	    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
	    y: (center.y - rect.top - rootElement.clientTop) / scaleY
	  };

	  return { center: center, offsetCenter: offsetCenter };
	}
	//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9ldmVudC11dGlscy5qcyJdLCJuYW1lcyI6WyJ3aGljaEJ1dHRvbnMiLCJnZXRPZmZzZXRQb3NpdGlvbiIsIkRPV05fRVZFTlQiLCJNT1ZFX0VWRU5UIiwiVVBfRVZFTlQiLCJNT1VTRV9FVkVOVFMiLCJwb2ludGVyZG93biIsInBvaW50ZXJtb3ZlIiwicG9pbnRlcnVwIiwibW91c2Vkb3duIiwibW91c2Vtb3ZlIiwibW91c2V1cCIsIk1PVVNFX0VWRU5UX1dISUNIX0xFRlQiLCJNT1VTRV9FVkVOVF9XSElDSF9NSURETEUiLCJNT1VTRV9FVkVOVF9XSElDSF9SSUdIVCIsIk1PVVNFX0VWRU5UX0JVVFRPTl9MRUZUIiwiTU9VU0VfRVZFTlRfQlVUVE9OX01JRERMRSIsIk1PVVNFX0VWRU5UX0JVVFRPTl9SSUdIVCIsIk1PVVNFX0VWRU5UX0JVVFRPTlNfTEVGVF9NQVNLIiwiTU9VU0VfRVZFTlRfQlVUVE9OU19SSUdIVF9NQVNLIiwiTU9VU0VfRVZFTlRfQlVUVE9OU19NSURETEVfTUFTSyIsImV2ZW50IiwiZXZlbnRUeXBlIiwic3JjRXZlbnQiLCJ0eXBlIiwiYnV0dG9ucyIsImJ1dHRvbiIsIndoaWNoIiwibGVmdEJ1dHRvbiIsIm1pZGRsZUJ1dHRvbiIsInJpZ2h0QnV0dG9uIiwiQm9vbGVhbiIsInJvb3RFbGVtZW50IiwiY2VudGVyIiwiY2xpZW50WCIsIngiLCJ5IiwiY2xpZW50WSIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzY2FsZVgiLCJ3aWR0aCIsIm9mZnNldFdpZHRoIiwic2NhbGVZIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwib2Zmc2V0Q2VudGVyIiwibGVmdCIsImNsaWVudExlZnQiLCJ0b3AiLCJjbGllbnRUb3AiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7UUE2QmdCQSxZLEdBQUFBLFk7UUFxQ0FDLGlCLEdBQUFBLGlCOzs7O0FBbEVoQjtBQUNBLElBQU1DLGFBQWEsQ0FBbkI7QUFDQSxJQUFNQyxhQUFhLENBQW5CO0FBQ0EsSUFBTUMsV0FBVyxDQUFqQjtBQUNBLElBQU1DLGVBQWU7QUFDbkJDLGVBQWFKLFVBRE07QUFFbkJLLGVBQWFKLFVBRk07QUFHbkJLLGFBQVdKLFFBSFE7QUFJbkJLLGFBQVdQLFVBSlE7QUFLbkJRLGFBQVdQLFVBTFE7QUFNbkJRLFdBQVNQO0FBTlUsQ0FBckI7O0FBU0E7QUFDQSxJQUFNUSx5QkFBeUIsQ0FBL0I7QUFDQSxJQUFNQywyQkFBMkIsQ0FBakM7QUFDQSxJQUFNQywwQkFBMEIsQ0FBaEM7QUFDQTtBQUNBLElBQU1DLDBCQUEwQixDQUFoQztBQUNBLElBQU1DLDRCQUE0QixDQUFsQztBQUNBLElBQU1DLDJCQUEyQixDQUFqQztBQUNBO0FBQ0EsSUFBTUMsZ0NBQWdDLENBQXRDO0FBQ0EsSUFBTUMsaUNBQWlDLENBQXZDO0FBQ0EsSUFBTUMsa0NBQWtDLENBQXhDOztBQUVBOzs7QUFHTyxTQUFTcEIsWUFBVCxDQUFzQnFCLEtBQXRCLEVBQTZCO0FBQ2xDLE1BQU1DLFlBQVlqQixhQUFhZ0IsTUFBTUUsUUFBTixDQUFlQyxJQUE1QixDQUFsQjtBQUNBLE1BQUksQ0FBQ0YsU0FBTCxFQUFnQjtBQUNkO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBTGlDLHdCQU9ERCxNQUFNRSxRQVBMO0FBQUEsTUFPM0JFLE9BUDJCLG1CQU8zQkEsT0FQMkI7QUFBQSxNQU9sQkMsTUFQa0IsbUJBT2xCQSxNQVBrQjtBQUFBLE1BT1ZDLEtBUFUsbUJBT1ZBLEtBUFU7O0FBUWxDLE1BQUlDLGFBQWEsS0FBakI7QUFDQSxNQUFJQyxlQUFlLEtBQW5CO0FBQ0EsTUFBSUMsY0FBYyxLQUFsQjs7QUFFQTtBQUNFO0FBQ0FSLGdCQUFjbEIsUUFBZDtBQUNBO0FBQ0NrQixnQkFBY25CLFVBQWQsSUFBNEIsQ0FBQyx3QkFBZ0JzQixPQUFoQixDQUpoQyxFQUtFO0FBQ0FHLGlCQUFhRCxVQUFVZixzQkFBdkI7QUFDQWlCLG1CQUFlRixVQUFVZCx3QkFBekI7QUFDQWlCLGtCQUFjSCxVQUFVYix1QkFBeEI7QUFDRCxHQVRELE1BU08sSUFBSVEsY0FBY25CLFVBQWxCLEVBQThCO0FBQ25DeUIsaUJBQWFHLFFBQVFOLFVBQVVQLDZCQUFsQixDQUFiO0FBQ0FXLG1CQUFlRSxRQUFRTixVQUFVTCwrQkFBbEIsQ0FBZjtBQUNBVSxrQkFBY0MsUUFBUU4sVUFBVU4sOEJBQWxCLENBQWQ7QUFDRCxHQUpNLE1BSUEsSUFBSUcsY0FBY3BCLFVBQWxCLEVBQThCO0FBQ25DMEIsaUJBQWFGLFdBQVdYLHVCQUF4QjtBQUNBYyxtQkFBZUgsV0FBV1YseUJBQTFCO0FBQ0FjLGtCQUFjSixXQUFXVCx3QkFBekI7QUFDRDs7QUFFRCxTQUFPLEVBQUNXLHNCQUFELEVBQWFDLDBCQUFiLEVBQTJCQyx3QkFBM0IsRUFBUDtBQUNEOztBQUVEOzs7QUFHTyxTQUFTN0IsaUJBQVQsQ0FBMkJvQixLQUEzQixFQUFrQ1csV0FBbEMsRUFBK0M7QUFBQSxNQUM3Q1QsUUFENkMsR0FDakNGLEtBRGlDLENBQzdDRSxRQUQ2Qzs7QUFHcEQ7O0FBQ0EsTUFBSSxDQUFDRixNQUFNWSxNQUFQLElBQWlCLENBQUMsd0JBQWdCVixTQUFTVyxPQUF6QixDQUF0QixFQUF5RDtBQUN2RDtBQUNBLFdBQU8sSUFBUDtBQUNEOztBQUVELE1BQU1ELFNBQVNaLE1BQU1ZLE1BQU4sSUFBZ0I7QUFDN0JFLE9BQUdaLFNBQVNXLE9BRGlCO0FBRTdCRSxPQUFHYixTQUFTYztBQUZpQixHQUEvQjs7QUFLQSxNQUFNQyxPQUFPTixZQUFZTyxxQkFBWixFQUFiOztBQUVBO0FBQ0E7QUFDQSxNQUFNQyxTQUFTRixLQUFLRyxLQUFMLEdBQWFULFlBQVlVLFdBQXhDO0FBQ0EsTUFBTUMsU0FBU0wsS0FBS00sTUFBTCxHQUFjWixZQUFZYSxZQUF6Qzs7QUFFQTtBQUNBLE1BQU1DLGVBQWU7QUFDbkJYLE9BQUcsQ0FBQ0YsT0FBT0UsQ0FBUCxHQUFXRyxLQUFLUyxJQUFoQixHQUF1QmYsWUFBWWdCLFVBQXBDLElBQWtEUixNQURsQztBQUVuQkosT0FBRyxDQUFDSCxPQUFPRyxDQUFQLEdBQVdFLEtBQUtXLEdBQWhCLEdBQXNCakIsWUFBWWtCLFNBQW5DLElBQWdEUDtBQUZoQyxHQUFyQjs7QUFLQSxTQUFPLEVBQUNWLGNBQUQsRUFBU2EsMEJBQVQsRUFBUDtBQUNEIiwiZmlsZSI6ImV2ZW50LXV0aWxzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQ29uc3RhbnRzICovXG5jb25zdCBET1dOX0VWRU5UID0gMTtcbmNvbnN0IE1PVkVfRVZFTlQgPSAyO1xuY29uc3QgVVBfRVZFTlQgPSA0O1xuY29uc3QgTU9VU0VfRVZFTlRTID0ge1xuICBwb2ludGVyZG93bjogRE9XTl9FVkVOVCxcbiAgcG9pbnRlcm1vdmU6IE1PVkVfRVZFTlQsXG4gIHBvaW50ZXJ1cDogVVBfRVZFTlQsXG4gIG1vdXNlZG93bjogRE9XTl9FVkVOVCxcbiAgbW91c2Vtb3ZlOiBNT1ZFX0VWRU5ULFxuICBtb3VzZXVwOiBVUF9FVkVOVFxufTtcblxuLy8gTW91c2VFdmVudC53aGljaCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC93aGljaFxuY29uc3QgTU9VU0VfRVZFTlRfV0hJQ0hfTEVGVCA9IDE7XG5jb25zdCBNT1VTRV9FVkVOVF9XSElDSF9NSURETEUgPSAyO1xuY29uc3QgTU9VU0VfRVZFTlRfV0hJQ0hfUklHSFQgPSAzO1xuLy8gTW91c2VFdmVudC5idXR0b24gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uXG5jb25zdCBNT1VTRV9FVkVOVF9CVVRUT05fTEVGVCA9IDA7XG5jb25zdCBNT1VTRV9FVkVOVF9CVVRUT05fTUlERExFID0gMTtcbmNvbnN0IE1PVVNFX0VWRU5UX0JVVFRPTl9SSUdIVCA9IDI7XG4vLyBNb3VzZUV2ZW50LmJ1dHRvbnMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvYnV0dG9uc1xuY29uc3QgTU9VU0VfRVZFTlRfQlVUVE9OU19MRUZUX01BU0sgPSAxO1xuY29uc3QgTU9VU0VfRVZFTlRfQlVUVE9OU19SSUdIVF9NQVNLID0gMjtcbmNvbnN0IE1PVVNFX0VWRU5UX0JVVFRPTlNfTUlERExFX01BU0sgPSA0O1xuXG4vKipcbiAqIEV4dHJhY3QgdGhlIGludm9sdmVkIG1vdXNlIGJ1dHRvblxuICovXG5leHBvcnQgZnVuY3Rpb24gd2hpY2hCdXR0b25zKGV2ZW50KSB7XG4gIGNvbnN0IGV2ZW50VHlwZSA9IE1PVVNFX0VWRU5UU1tldmVudC5zcmNFdmVudC50eXBlXTtcbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICAvLyBOb3QgYSBtb3VzZSBldmV0XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB7YnV0dG9ucywgYnV0dG9uLCB3aGljaH0gPSBldmVudC5zcmNFdmVudDtcbiAgbGV0IGxlZnRCdXR0b24gPSBmYWxzZTtcbiAgbGV0IG1pZGRsZUJ1dHRvbiA9IGZhbHNlO1xuICBsZXQgcmlnaHRCdXR0b24gPSBmYWxzZTtcblxuICBpZiAoXG4gICAgLy8gYnV0dG9uIGlzIHVwLCBuZWVkIHRvIGZpbmQgb3V0IHdoaWNoIG9uZSB3YXMgcHJlc3NlZCBiZWZvcmVcbiAgICBldmVudFR5cGUgPT09IFVQX0VWRU5UIHx8XG4gICAgLy8gbW92aW5nIGJ1dCBkb2VzIG5vdCBzdXBwb3J0IGBidXR0b25zYCBBUElcbiAgICAoZXZlbnRUeXBlID09PSBNT1ZFX0VWRU5UICYmICFOdW1iZXIuaXNGaW5pdGUoYnV0dG9ucykpXG4gICkge1xuICAgIGxlZnRCdXR0b24gPSB3aGljaCA9PT0gTU9VU0VfRVZFTlRfV0hJQ0hfTEVGVDtcbiAgICBtaWRkbGVCdXR0b24gPSB3aGljaCA9PT0gTU9VU0VfRVZFTlRfV0hJQ0hfTUlERExFO1xuICAgIHJpZ2h0QnV0dG9uID0gd2hpY2ggPT09IE1PVVNFX0VWRU5UX1dISUNIX1JJR0hUO1xuICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gTU9WRV9FVkVOVCkge1xuICAgIGxlZnRCdXR0b24gPSBCb29sZWFuKGJ1dHRvbnMgJiBNT1VTRV9FVkVOVF9CVVRUT05TX0xFRlRfTUFTSyk7XG4gICAgbWlkZGxlQnV0dG9uID0gQm9vbGVhbihidXR0b25zICYgTU9VU0VfRVZFTlRfQlVUVE9OU19NSURETEVfTUFTSyk7XG4gICAgcmlnaHRCdXR0b24gPSBCb29sZWFuKGJ1dHRvbnMgJiBNT1VTRV9FVkVOVF9CVVRUT05TX1JJR0hUX01BU0spO1xuICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gRE9XTl9FVkVOVCkge1xuICAgIGxlZnRCdXR0b24gPSBidXR0b24gPT09IE1PVVNFX0VWRU5UX0JVVFRPTl9MRUZUO1xuICAgIG1pZGRsZUJ1dHRvbiA9IGJ1dHRvbiA9PT0gTU9VU0VfRVZFTlRfQlVUVE9OX01JRERMRTtcbiAgICByaWdodEJ1dHRvbiA9IGJ1dHRvbiA9PT0gTU9VU0VfRVZFTlRfQlVUVE9OX1JJR0hUO1xuICB9XG5cbiAgcmV0dXJuIHtsZWZ0QnV0dG9uLCBtaWRkbGVCdXR0b24sIHJpZ2h0QnV0dG9ufTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgZXZlbnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHJvb3QgZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T2Zmc2V0UG9zaXRpb24oZXZlbnQsIHJvb3RFbGVtZW50KSB7XG4gIGNvbnN0IHtzcmNFdmVudH0gPSBldmVudDtcblxuICAvLyBgY2VudGVyYCBpcyBhIGhhbW1lci5qcyBldmVudCBwcm9wZXJ0eVxuICBpZiAoIWV2ZW50LmNlbnRlciAmJiAhTnVtYmVyLmlzRmluaXRlKHNyY0V2ZW50LmNsaWVudFgpKSB7XG4gICAgLy8gTm90IGEgZ2VzdHVyYWwgZXZlbnRcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IGNlbnRlciA9IGV2ZW50LmNlbnRlciB8fCB7XG4gICAgeDogc3JjRXZlbnQuY2xpZW50WCxcbiAgICB5OiBzcmNFdmVudC5jbGllbnRZXG4gIH07XG5cbiAgY29uc3QgcmVjdCA9IHJvb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIC8vIEZpeCBzY2FsZSBmb3IgbWFwIGFmZmVjdGVkIGJ5IGEgQ1NTIHRyYW5zZm9ybS5cbiAgLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjg5MzY2My8zNTI4NTMzXG4gIGNvbnN0IHNjYWxlWCA9IHJlY3Qud2lkdGggLyByb290RWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgY29uc3Qgc2NhbGVZID0gcmVjdC5oZWlnaHQgLyByb290RWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgLy8gQ2FsY3VsYXRlIGNlbnRlciByZWxhdGl2ZSB0byB0aGUgcm9vdCBlbGVtZW50XG4gIGNvbnN0IG9mZnNldENlbnRlciA9IHtcbiAgICB4OiAoY2VudGVyLnggLSByZWN0LmxlZnQgLSByb290RWxlbWVudC5jbGllbnRMZWZ0KSAvIHNjYWxlWCxcbiAgICB5OiAoY2VudGVyLnkgLSByZWN0LnRvcCAtIHJvb3RFbGVtZW50LmNsaWVudFRvcCkgLyBzY2FsZVlcbiAgfTtcblxuICByZXR1cm4ge2NlbnRlciwgb2Zmc2V0Q2VudGVyfTtcbn1cbiJdfQ==

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(382), __esModule: true };

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(383);
	module.exports = __webpack_require__(309).Number.isFinite;


/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

	// 20.1.2.2 Number.isFinite(number)
	var $export = __webpack_require__(315);
	var _isFinite = __webpack_require__(310).isFinite;

	$export($export.S, 'Number', {
	  isFinite: function isFinite(it) {
	    return typeof it == 'number' && _isFinite(it);
	  }
	});


/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.testExports = exports.default = exports.MAPBOX_LIMITS = void 0;

	var _math = __webpack_require__(109);

	var _controller = _interopRequireDefault(__webpack_require__(385));

	var _viewState = _interopRequireDefault(__webpack_require__(389));

	var _viewportMercatorProject = _interopRequireWildcard(__webpack_require__(240));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	// MAPBOX LIMITS
	var MAPBOX_LIMITS = {
	  minZoom: 0,
	  maxZoom: 20,
	  minPitch: 0,
	  maxPitch: 60
	};
	exports.MAPBOX_LIMITS = MAPBOX_LIMITS;
	var DEFAULT_STATE = {
	  pitch: 0,
	  bearing: 0,
	  altitude: 1.5
	};
	/* Utils */

	var MapState =
	/*#__PURE__*/
	function (_ViewState) {
	  _inherits(MapState, _ViewState);

	  function MapState() {
	    var _this;

	    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
	        width = _ref.width,
	        height = _ref.height,
	        latitude = _ref.latitude,
	        longitude = _ref.longitude,
	        zoom = _ref.zoom,
	        _ref$bearing = _ref.bearing,
	        bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing,
	        _ref$pitch = _ref.pitch,
	        pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch,
	        _ref$altitude = _ref.altitude,
	        altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude,
	        _ref$maxZoom = _ref.maxZoom,
	        maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom,
	        _ref$minZoom = _ref.minZoom,
	        minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom,
	        _ref$maxPitch = _ref.maxPitch,
	        maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch,
	        _ref$minPitch = _ref.minPitch,
	        minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch,
	        startPanLngLat = _ref.startPanLngLat,
	        startZoomLngLat = _ref.startZoomLngLat,
	        startBearing = _ref.startBearing,
	        startPitch = _ref.startPitch,
	        startZoom = _ref.startZoom;

	    _classCallCheck(this, MapState);

	    (0, _assert.default)(Number.isFinite(longitude), '`longitude` must be supplied');
	    (0, _assert.default)(Number.isFinite(latitude), '`latitude` must be supplied');
	    (0, _assert.default)(Number.isFinite(zoom), '`zoom` must be supplied');
	    _this = _possibleConstructorReturn(this, (MapState.__proto__ || Object.getPrototypeOf(MapState)).call(this, {
	      width: width,
	      height: height,
	      latitude: latitude,
	      longitude: longitude,
	      zoom: zoom,
	      bearing: bearing,
	      pitch: pitch,
	      altitude: altitude,
	      maxZoom: maxZoom,
	      minZoom: minZoom,
	      maxPitch: maxPitch,
	      minPitch: minPitch
	    }));
	    _this._interactiveState = {
	      startPanLngLat: startPanLngLat,
	      startZoomLngLat: startZoomLngLat,
	      startBearing: startBearing,
	      startPitch: startPitch,
	      startZoom: startZoom
	    };
	    return _this;
	  }
	  /* Public API */


	  _createClass(MapState, [{
	    key: "getViewportProps",
	    value: function getViewportProps() {
	      return this._viewportProps;
	    }
	  }, {
	    key: "getInteractiveState",
	    value: function getInteractiveState() {
	      return this._interactiveState;
	    }
	    /**
	     * Start panning
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "panStart",
	    value: function panStart(_ref2) {
	      var pos = _ref2.pos;
	      return this._getUpdatedState({
	        startPanLngLat: this._unproject(pos)
	      });
	    }
	    /**
	     * Pan
	     * @param {[Number, Number]} pos - position on screen where the pointer is
	     * @param {[Number, Number], optional} startPos - where the pointer grabbed at
	     *   the start of the operation. Must be supplied of `panStart()` was not called
	     */

	  }, {
	    key: "pan",
	    value: function pan(_ref3) {
	      var pos = _ref3.pos,
	          startPos = _ref3.startPos;

	      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos);

	      if (!startPanLngLat) {
	        return this;
	      }

	      var _this$_calculateNewLn = this._calculateNewLngLat({
	        startPanLngLat: startPanLngLat,
	        pos: pos
	      }),
	          _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2),
	          longitude = _this$_calculateNewLn2[0],
	          latitude = _this$_calculateNewLn2[1];

	      return this._getUpdatedState({
	        longitude: longitude,
	        latitude: latitude
	      });
	    }
	    /**
	     * End panning
	     * Must call if `panStart()` was called
	     */

	  }, {
	    key: "panEnd",
	    value: function panEnd() {
	      return this._getUpdatedState({
	        startPanLngLat: null
	      });
	    }
	    /**
	     * Start rotating
	     * @param {[Number, Number]} pos - position on screen where the center is
	     */

	  }, {
	    key: "rotateStart",
	    value: function rotateStart(_ref4) {
	      var pos = _ref4.pos;
	      return this._getUpdatedState({
	        startBearing: this._viewportProps.bearing,
	        startPitch: this._viewportProps.pitch
	      });
	    }
	    /**
	     * Rotate
	     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the
	     *   change to bearing.
	     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the
	     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.
	     */

	  }, {
	    key: "rotate",
	    value: function rotate(_ref5) {
	      var _ref5$deltaScaleX = _ref5.deltaScaleX,
	          deltaScaleX = _ref5$deltaScaleX === void 0 ? 0 : _ref5$deltaScaleX,
	          _ref5$deltaScaleY = _ref5.deltaScaleY,
	          deltaScaleY = _ref5$deltaScaleY === void 0 ? 0 : _ref5$deltaScaleY;
	      var _this$_interactiveSta = this._interactiveState,
	          startBearing = _this$_interactiveSta.startBearing,
	          startPitch = _this$_interactiveSta.startPitch;

	      if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
	        return this;
	      }

	      var _this$_calculateNewPi = this._calculateNewPitchAndBearing({
	        deltaScaleX: deltaScaleX,
	        deltaScaleY: deltaScaleY,
	        startBearing: startBearing,
	        startPitch: startPitch
	      }),
	          pitch = _this$_calculateNewPi.pitch,
	          bearing = _this$_calculateNewPi.bearing;

	      return this._getUpdatedState({
	        bearing: bearing,
	        pitch: pitch
	      });
	    }
	    /**
	     * End rotating
	     * Must call if `rotateStart()` was called
	     */

	  }, {
	    key: "rotateEnd",
	    value: function rotateEnd() {
	      return this._getUpdatedState({
	        startBearing: null,
	        startPitch: null
	      });
	    }
	    /**
	     * Start zooming
	     * @param {[Number, Number]} pos - position on screen where the center is
	     */

	  }, {
	    key: "zoomStart",
	    value: function zoomStart(_ref6) {
	      var pos = _ref6.pos;
	      return this._getUpdatedState({
	        startZoomLngLat: this._unproject(pos),
	        startZoom: this._viewportProps.zoom
	      });
	    }
	    /**
	     * Zoom
	     * @param {[Number, Number]} pos - position on screen where the current center is
	     * @param {[Number, Number]} startPos - the center position at
	     *   the start of the operation. Must be supplied of `zoomStart()` was not called
	     * @param {Number} scale - a number between [0, 1] specifying the accumulated
	     *   relative scale.
	     */

	  }, {
	    key: "zoom",
	    value: function zoom(_ref7) {
	      var pos = _ref7.pos,
	          startPos = _ref7.startPos,
	          scale = _ref7.scale;
	      (0, _assert.default)(scale > 0, '`scale` must be a positive number'); // Make sure we zoom around the current mouse position rather than map center

	      var _this$_interactiveSta2 = this._interactiveState,
	          startZoom = _this$_interactiveSta2.startZoom,
	          startZoomLngLat = _this$_interactiveSta2.startZoomLngLat;

	      if (!Number.isFinite(startZoom)) {
	        // We have two modes of zoom:
	        // scroll zoom that are discrete events (transform from the current zoom level),
	        // and pinch zoom that are continuous events (transform from the zoom level when
	        // pinch started).
	        // If startZoom state is defined, then use the startZoom state;
	        // otherwise assume discrete zooming
	        startZoom = this._viewportProps.zoom;
	        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
	      } // take the start lnglat and put it where the mouse is down.


	      (0, _assert.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');

	      var zoom = this._calculateNewZoom({
	        scale: scale,
	        startZoom: startZoom
	      });

	      var zoomedViewport = new _viewportMercatorProject.default(Object.assign({}, this._viewportProps, {
	        zoom: zoom
	      }));

	      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({
	        lngLat: startZoomLngLat,
	        pos: pos
	      }),
	          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),
	          longitude = _zoomedViewport$getLo2[0],
	          latitude = _zoomedViewport$getLo2[1];

	      return this._getUpdatedState({
	        zoom: zoom,
	        longitude: longitude,
	        latitude: latitude
	      });
	    }
	    /**
	     * End zooming
	     * Must call if `zoomStart()` was called
	     */

	  }, {
	    key: "zoomEnd",
	    value: function zoomEnd() {
	      return this._getUpdatedState({
	        startZoomLngLat: null,
	        startZoom: null
	      });
	    }
	  }, {
	    key: "zoomIn",
	    value: function zoomIn() {
	      return this._zoomFromCenter(2);
	    }
	  }, {
	    key: "zoomOut",
	    value: function zoomOut() {
	      return this._zoomFromCenter(0.5);
	    }
	  }, {
	    key: "moveLeft",
	    value: function moveLeft() {
	      return this._panFromCenter([100, 0]);
	    }
	  }, {
	    key: "moveRight",
	    value: function moveRight() {
	      return this._panFromCenter([-100, 0]);
	    }
	  }, {
	    key: "moveUp",
	    value: function moveUp() {
	      return this._panFromCenter([0, 100]);
	    }
	  }, {
	    key: "moveDown",
	    value: function moveDown() {
	      return this._panFromCenter([0, -100]);
	    }
	  }, {
	    key: "rotateLeft",
	    value: function rotateLeft() {
	      return this._getUpdatedState({
	        bearing: this._viewportProps.bearing - 15
	      });
	    }
	  }, {
	    key: "rotateRight",
	    value: function rotateRight() {
	      return this._getUpdatedState({
	        bearing: this._viewportProps.bearing + 15
	      });
	    }
	  }, {
	    key: "rotateUp",
	    value: function rotateUp() {
	      return this._getUpdatedState({
	        pitch: this._viewportProps.pitch + 10
	      });
	    }
	  }, {
	    key: "rotateDown",
	    value: function rotateDown() {
	      return this._getUpdatedState({
	        pitch: this._viewportProps.pitch - 10
	      });
	    }
	  }, {
	    key: "shortestPathFrom",
	    value: function shortestPathFrom(viewState) {
	      // const endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
	      var fromProps = viewState.getViewportProps();
	      var props = Object.assign({}, this._viewportProps);
	      var bearing = props.bearing,
	          longitude = props.longitude;

	      if (Math.abs(bearing - fromProps.bearing) > 180) {
	        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
	      }

	      if (Math.abs(longitude - fromProps.longitude) > 180) {
	        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
	      }

	      return props;
	    }
	    /* Private methods */

	  }, {
	    key: "_zoomFromCenter",
	    value: function _zoomFromCenter(scale) {
	      var _this$_viewportProps = this._viewportProps,
	          width = _this$_viewportProps.width,
	          height = _this$_viewportProps.height;
	      return this.zoom({
	        pos: [width / 2, height / 2],
	        scale: scale
	      });
	    }
	  }, {
	    key: "_panFromCenter",
	    value: function _panFromCenter(offset) {
	      var _this$_viewportProps2 = this._viewportProps,
	          width = _this$_viewportProps2.width,
	          height = _this$_viewportProps2.height;
	      return this.pan({
	        startPos: [width / 2, height / 2],
	        pos: [width / 2 + offset[0], height / 2 + offset[1]]
	      });
	    }
	  }, {
	    key: "_getUpdatedState",
	    value: function _getUpdatedState(newProps) {
	      // Update _viewportProps
	      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
	    } // Apply any constraints (mathematical or defined by _viewportProps) to map state

	  }, {
	    key: "_applyConstraints",
	    value: function _applyConstraints(props) {
	      // Ensure zoom is within specified range
	      var maxZoom = props.maxZoom,
	          minZoom = props.minZoom,
	          zoom = props.zoom;
	      props.zoom = (0, _math.clamp)(zoom, minZoom, maxZoom); // Ensure pitch is within specified range

	      var maxPitch = props.maxPitch,
	          minPitch = props.minPitch,
	          pitch = props.pitch;
	      props.pitch = (0, _math.clamp)(pitch, minPitch, maxPitch);
	      Object.assign(props, (0, _viewportMercatorProject.normalizeViewportProps)(props));
	      return props;
	    }
	  }, {
	    key: "_unproject",
	    value: function _unproject(pos) {
	      var viewport = new _viewportMercatorProject.default(this._viewportProps);
	      return pos && viewport.unproject(pos);
	    } // Calculate a new lnglat based on pixel dragging position

	  }, {
	    key: "_calculateNewLngLat",
	    value: function _calculateNewLngLat(_ref8) {
	      var startPanLngLat = _ref8.startPanLngLat,
	          pos = _ref8.pos;
	      var viewport = new _viewportMercatorProject.default(this._viewportProps);
	      return viewport.getMapCenterByLngLatPosition({
	        lngLat: startPanLngLat,
	        pos: pos
	      });
	    } // Calculates new zoom

	  }, {
	    key: "_calculateNewZoom",
	    value: function _calculateNewZoom(_ref9) {
	      var scale = _ref9.scale,
	          startZoom = _ref9.startZoom;
	      var _this$_viewportProps3 = this._viewportProps,
	          maxZoom = _this$_viewportProps3.maxZoom,
	          minZoom = _this$_viewportProps3.minZoom;
	      var zoom = startZoom + Math.log2(scale);
	      return (0, _math.clamp)(zoom, minZoom, maxZoom);
	    } // Calculates a new pitch and bearing from a position (coming from an event)

	  }, {
	    key: "_calculateNewPitchAndBearing",
	    value: function _calculateNewPitchAndBearing(_ref10) {
	      var deltaScaleX = _ref10.deltaScaleX,
	          deltaScaleY = _ref10.deltaScaleY,
	          startBearing = _ref10.startBearing,
	          startPitch = _ref10.startPitch;
	      // clamp deltaScaleY to [-1, 1] so that rotation is constrained between minPitch and maxPitch.
	      // deltaScaleX does not need to be clamped as bearing does not have constraints.
	      deltaScaleY = (0, _math.clamp)(deltaScaleY, -1, 1);
	      var _this$_viewportProps4 = this._viewportProps,
	          minPitch = _this$_viewportProps4.minPitch,
	          maxPitch = _this$_viewportProps4.maxPitch;
	      var bearing = startBearing + 180 * deltaScaleX;
	      var pitch = startPitch;

	      if (deltaScaleY > 0) {
	        // Gradually increase pitch
	        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
	      } else if (deltaScaleY < 0) {
	        // Gradually decrease pitch
	        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
	      }

	      return {
	        pitch: pitch,
	        bearing: bearing
	      };
	    }
	  }]);

	  return MapState;
	}(_viewState.default);

	var MapController =
	/*#__PURE__*/
	function (_Controller) {
	  _inherits(MapController, _Controller);

	  function MapController(props) {
	    var _this2;

	    _classCallCheck(this, MapController);

	    _this2 = _possibleConstructorReturn(this, (MapController.__proto__ || Object.getPrototypeOf(MapController)).call(this, MapState, props));
	    _this2.invertPan = true;
	    return _this2;
	  }

	  return MapController;
	}(_controller.default);

	exports.default = MapController;
	var testExports = {
	  MapState: MapState
	};
	exports.testExports = testExports;
	//# sourceMappingURL=map-controller.js.map

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _linearInterpolator = _interopRequireDefault(__webpack_require__(386));

	var _transitionManager = _interopRequireWildcard(__webpack_require__(388));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var NO_TRANSITION_PROPS = {
	  transitionDuration: 0
	};
	var LINEAR_TRANSITION_PROPS = {
	  transitionDuration: 300,
	  transitionEasing: function transitionEasing(t) {
	    return t;
	  },
	  transitionInterpolator: new _linearInterpolator.default(),
	  transitionInterruption: _transitionManager.TRANSITION_EVENTS.BREAK
	}; // EVENT HANDLING PARAMETERS

	var PITCH_MOUSE_THRESHOLD = 5;
	var PITCH_ACCEL = 1.2;
	var ZOOM_ACCEL = 0.01;
	var EVENT_TYPES = {
	  WHEEL: ['wheel'],
	  PAN: ['panstart', 'panmove', 'panend'],
	  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],
	  DOUBLE_TAP: ['doubletap'],
	  KEYBOARD: ['keydown']
	};

	var Controller =
	/*#__PURE__*/
	function () {
	  function Controller(ControllerState) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, Controller);

	    (0, _assert.default)(ControllerState);
	    this.ControllerState = ControllerState;
	    this.controllerState = null;
	    this.controllerStateProps = null;
	    this.eventManager = null;
	    this.transitionManager = new _transitionManager.default(ControllerState, options);
	    this._events = null;
	    this._state = {
	      isDragging: false
	    };
	    this.events = [];
	    this.onViewportChange = null;
	    this.onViewStateChange = null;
	    this.onStateChange = null;
	    this.invertPan = false;
	    this.handleEvent = this.handleEvent.bind(this);
	    this.setProps(options);
	  }

	  _createClass(Controller, [{
	    key: "finalize",
	    value: function finalize() {}
	    /**
	     * Callback for events
	     * @param {hammer.Event} event
	     */

	  }, {
	    key: "handleEvent",
	    value: function handleEvent(event) {
	      var ControllerState = this.ControllerState;
	      this.controllerState = new ControllerState(Object.assign({}, this.controllerStateProps, this._state));

	      switch (event.type) {
	        case 'panstart':
	          return this._onPanStart(event);

	        case 'panmove':
	          return this._onPan(event);

	        case 'panend':
	          return this._onPanEnd(event);

	        case 'pinchstart':
	          return this._onPinchStart(event);

	        case 'pinchmove':
	          return this._onPinch(event);

	        case 'pinchend':
	          return this._onPinchEnd(event);

	        case 'doubletap':
	          return this._onDoubleTap(event);

	        case 'wheel':
	          return this._onWheel(event);

	        case 'keydown':
	          return this._onKeyDown(event);

	        default:
	          return false;
	      }
	    }
	    /* Event utils */
	    // Event object: http://hammerjs.github.io/api/#event-object

	  }, {
	    key: "getCenter",
	    value: function getCenter(event) {
	      var _event$offsetCenter = event.offsetCenter,
	          x = _event$offsetCenter.x,
	          y = _event$offsetCenter.y;
	      return [x, y];
	    }
	  }, {
	    key: "isFunctionKeyPressed",
	    value: function isFunctionKeyPressed(event) {
	      var srcEvent = event.srcEvent;
	      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
	    }
	  }, {
	    key: "isDragging",
	    value: function isDragging() {
	      return this._state.isDragging;
	    }
	    /**
	     * Extract interactivity options
	     */

	    /* eslint-disable complexity, max-statements */

	  }, {
	    key: "setProps",
	    value: function setProps(props) {
	      if ('onViewportChange' in props) {
	        this.onViewportChange = props.onViewportChange;
	      }

	      if ('onViewStateChange' in props) {
	        this.onViewStateChange = props.onViewStateChange;
	      }

	      if ('onStateChange' in props) {
	        this.onStateChange = props.onStateChange;
	      }

	      if ('viewState' in props) {
	        this.controllerStateProps = Object.assign({}, props, props.viewState);
	      } else {
	        // TODO - deprecated, props on top level
	        this.controllerStateProps = props;
	      }

	      if ('eventManager' in props && this.eventManager !== props.eventManager) {
	        // EventManager has changed
	        this.eventManager = props.eventManager;
	        this._events = {};
	        this.toggleEvents(this.events, true);
	      }

	      this.transitionManager.processViewStateChange(props); // TODO - make sure these are not reset on every setProps

	      var _props$scrollZoom = props.scrollZoom,
	          scrollZoom = _props$scrollZoom === void 0 ? true : _props$scrollZoom,
	          _props$dragPan = props.dragPan,
	          dragPan = _props$dragPan === void 0 ? true : _props$dragPan,
	          _props$dragRotate = props.dragRotate,
	          dragRotate = _props$dragRotate === void 0 ? true : _props$dragRotate,
	          _props$doubleClickZoo = props.doubleClickZoom,
	          doubleClickZoom = _props$doubleClickZoo === void 0 ? true : _props$doubleClickZoo,
	          _props$touchZoom = props.touchZoom,
	          touchZoom = _props$touchZoom === void 0 ? true : _props$touchZoom,
	          _props$touchRotate = props.touchRotate,
	          touchRotate = _props$touchRotate === void 0 ? false : _props$touchRotate,
	          _props$keyboard = props.keyboard,
	          keyboard = _props$keyboard === void 0 ? true : _props$keyboard; // Register/unregister events

	      var isInteractive = Boolean(this.onViewportChange || this.onViewStateChange);
	      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
	      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));
	      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
	      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
	      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard); // Interaction toggles

	      this.scrollZoom = scrollZoom;
	      this.dragPan = dragPan;
	      this.dragRotate = dragRotate;
	      this.doubleClickZoom = doubleClickZoom;
	      this.touchZoom = touchZoom;
	      this.touchRotate = touchRotate;
	      this.keyboard = keyboard;
	    }
	    /* eslint-enable complexity, max-statements */

	  }, {
	    key: "toggleEvents",
	    value: function toggleEvents(eventNames, enabled) {
	      var _this = this;

	      if (this.eventManager) {
	        eventNames.forEach(function (eventName) {
	          if (_this._events[eventName] !== enabled) {
	            _this._events[eventName] = enabled;

	            if (enabled) {
	              _this.eventManager.on(eventName, _this.handleEvent);
	            } else {
	              _this.eventManager.off(eventName, _this.handleEvent);
	            }
	          }
	        });
	      }
	    } // DEPRECATED

	  }, {
	    key: "setOptions",
	    value: function setOptions(props) {
	      return this.setProps(props);
	    } // Private Methods

	    /* Callback util */
	    // formats map state and invokes callback function

	  }, {
	    key: "updateViewport",
	    value: function updateViewport(newControllerState) {
	      var extraProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	      var interactionState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
	      var viewState = Object.assign({}, newControllerState.getViewportProps(), extraProps); // TODO - to restore diffing, we need to include interactionState

	      var changed = true; // const oldViewState = this.controllerState.getViewportProps();
	      // const changed = Object.keys(viewState).some(key => oldViewState[key] !== viewState[key]);

	      if (changed) {
	        if (this.onViewportChange) {
	          var viewport = this.controllerState.getViewport ? this.controllerState.getViewport() : null;
	          this.onViewportChange(viewState, interactionState, viewport);
	        }

	        if (this.onViewStateChange) {
	          this.onViewStateChange({
	            viewState: viewState,
	            interactionState: interactionState
	          });
	        }
	      }

	      Object.assign(this._state, Object.assign({}, newControllerState.getInteractiveState(), interactionState));

	      if (this.onStateChange) {
	        this.onStateChange(this._state);
	      } // this.setState(Object.assign({}, newControllerState.getInteractiveState(), extraState));

	    }
	    /* Event handlers */
	    // Default handler for the `panstart` event.

	  }, {
	    key: "_onPanStart",
	    value: function _onPanStart(event) {
	      var pos = this.getCenter(event);
	      var newControllerState = this.controllerState.panStart({
	        pos: pos
	      }).rotateStart({
	        pos: pos
	      });
	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
	        isDragging: true
	      });
	    } // Default handler for the `panmove` event.

	  }, {
	    key: "_onPan",
	    value: function _onPan(event) {
	      var alternateMode = this.isFunctionKeyPressed(event) || event.rightButton;
	      alternateMode = this.invertPan ? !alternateMode : alternateMode;
	      return alternateMode ? this._onPanMove(event) : this._onPanRotate(event);
	    } // Default handler for the `panend` event.

	  }, {
	    key: "_onPanEnd",
	    value: function _onPanEnd(event) {
	      var newControllerState = this.controllerState.panEnd().rotateEnd();
	      return this.updateViewport(newControllerState, null, {
	        isDragging: false
	      });
	    } // Default handler for panning to move.
	    // Called by `_onPan` when panning without function key pressed.

	  }, {
	    key: "_onPanMove",
	    value: function _onPanMove(event) {
	      if (!this.dragPan) {
	        return false;
	      }

	      var pos = this.getCenter(event);
	      var newControllerState = this.controllerState.pan({
	        pos: pos
	      });
	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
	        isDragging: true
	      });
	    } // Default handler for panning to rotate.
	    // Called by `_onPan` when panning with function key pressed.

	  }, {
	    key: "_onPanRotate",
	    value: function _onPanRotate(event) {
	      if (!this.dragRotate) {
	        return false;
	      }

	      return this.invertPan ? this._onPanRotateMap(event) : this._onPanRotateStandard(event);
	    } // Normal pan to rotate

	  }, {
	    key: "_onPanRotateStandard",
	    value: function _onPanRotateStandard(event) {
	      var deltaX = event.deltaX,
	          deltaY = event.deltaY;

	      var _this$controllerState = this.controllerState.getViewportProps(),
	          width = _this$controllerState.width,
	          height = _this$controllerState.height;

	      var deltaScaleX = deltaX / width;
	      var deltaScaleY = deltaY / height;
	      var newControllerState = this.controllerState.rotate({
	        deltaScaleX: deltaScaleX,
	        deltaScaleY: deltaScaleY
	      });
	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
	        isDragging: true
	      });
	    }
	  }, {
	    key: "_onPanRotateMap",
	    value: function _onPanRotateMap(event) {
	      var deltaX = event.deltaX,
	          deltaY = event.deltaY;

	      var _this$getCenter = this.getCenter(event),
	          _this$getCenter2 = _slicedToArray(_this$getCenter, 2),
	          centerY = _this$getCenter2[1];

	      var startY = centerY - deltaY;

	      var _this$controllerState2 = this.controllerState.getViewportProps(),
	          width = _this$controllerState2.width,
	          height = _this$controllerState2.height;

	      var deltaScaleX = deltaX / width;
	      var deltaScaleY = 0;

	      if (deltaY > 0) {
	        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {
	          // Move from 0 to -1 as we drag upwards
	          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;
	        }
	      } else if (deltaY < 0) {
	        if (startY > PITCH_MOUSE_THRESHOLD) {
	          // Move from 0 to 1 as we drag upwards
	          deltaScaleY = 1 - centerY / startY;
	        }
	      }

	      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
	      var newControllerState = this.controllerState.rotate({
	        deltaScaleX: deltaScaleX,
	        deltaScaleY: deltaScaleY
	      });
	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
	        isDragging: true
	      });
	    } // Default handler for the `wheel` event.

	  }, {
	    key: "_onWheel",
	    value: function _onWheel(event) {
	      if (!this.scrollZoom) {
	        return false;
	      }

	      var pos = this.getCenter(event);
	      var delta = event.delta; // Map wheel delta to relative scale

	      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));

	      if (delta < 0 && scale !== 0) {
	        scale = 1 / scale;
	      }

	      var newControllerState = this.controllerState.zoom({
	        pos: pos,
	        scale: scale
	      });
	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS);
	    } // Default handler for the `pinchstart` event.

	  }, {
	    key: "_onPinchStart",
	    value: function _onPinchStart(event) {
	      var pos = this.getCenter(event);
	      var newControllerState = this.controllerState.zoomStart({
	        pos: pos
	      }).rotateStart({
	        pos: pos
	      }); // hack - hammer's `rotation` field doesn't seem to produce the correct angle

	      this._state.startPinchRotation = event.rotation;
	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
	        isDragging: true
	      });
	    } // Default handler for the `pinch` event.

	  }, {
	    key: "_onPinch",
	    value: function _onPinch(event) {
	      if (!this.touchZoom && !this.touchRotate) {
	        return false;
	      }

	      var newControllerState = this.controllerState;

	      if (this.touchZoom) {
	        var scale = event.scale;
	        var pos = this.getCenter(event);
	        newControllerState = newControllerState.zoom({
	          pos: pos,
	          scale: scale
	        });
	      }

	      if (this.touchRotate) {
	        var rotation = event.rotation;
	        var startPinchRotation = this._state.startPinchRotation;
	        newControllerState = newControllerState.rotate({
	          deltaScaleX: -(rotation - startPinchRotation) / 180
	        });
	      }

	      return this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
	        isDragging: true
	      });
	    } // Default handler for the `pinchend` event.

	  }, {
	    key: "_onPinchEnd",
	    value: function _onPinchEnd(event) {
	      var newControllerState = this.controllerState.zoomEnd().rotateEnd();
	      this._state.startPinchRotation = 0;
	      return this.updateViewport(newControllerState, null, {
	        isDragging: false
	      });
	    } // Default handler for the `doubletap` event.

	  }, {
	    key: "_onDoubleTap",
	    value: function _onDoubleTap(event) {
	      if (!this.doubleClickZoom) {
	        return false;
	      }

	      var pos = this.getCenter(event);
	      var isZoomOut = this.isFunctionKeyPressed(event);
	      var newControllerState = this.controllerState.zoom({
	        pos: pos,
	        scale: isZoomOut ? 0.5 : 2
	      });
	      return this.updateViewport(newControllerState, LINEAR_TRANSITION_PROPS);
	    }
	    /* eslint-disable complexity */
	    // Default handler for the `keydown` event

	  }, {
	    key: "_onKeyDown",
	    value: function _onKeyDown(event) {
	      if (!this.keyboard) {
	        return false;
	      }

	      var funcKey = this.isFunctionKeyPressed(event);
	      var controllerState = this.controllerState;
	      var newControllerState;

	      switch (event.srcEvent.keyCode) {
	        case 189:
	          // -
	          newControllerState = funcKey ? controllerState.zoomOut().zoomOut() : controllerState.zoomOut();
	          break;

	        case 187:
	          // +
	          newControllerState = funcKey ? controllerState.zoomIn().zoomIn() : controllerState.zoomIn();
	          break;

	        case 37:
	          // left
	          newControllerState = funcKey ? controllerState.rotateLeft() : controllerState.moveLeft();
	          break;

	        case 39:
	          // right
	          newControllerState = funcKey ? controllerState.rotateRight() : controllerState.moveRight();
	          break;

	        case 38:
	          // up
	          newControllerState = funcKey ? controllerState.rotateUp() : controllerState.moveUp();
	          break;

	        case 40:
	          // down
	          newControllerState = funcKey ? controllerState.rotateDown() : controllerState.moveDown();
	          break;

	        default:
	          return false;
	      }

	      return this.updateViewport(newControllerState, LINEAR_TRANSITION_PROPS);
	    }
	    /* eslint-enable complexity */

	  }]);

	  return Controller;
	}();

	exports.default = Controller;
	//# sourceMappingURL=controller.js.map

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _transitionInterpolator = _interopRequireDefault(__webpack_require__(387));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'];
	/**
	 * Performs linear interpolation of two view states.
	 */

	var LinearInterpolator =
	/*#__PURE__*/
	function (_TransitionInterpolat) {
	  _inherits(LinearInterpolator, _TransitionInterpolat);

	  /**
	   * @param {Array} transitionProps - list of props to apply linear transition to.
	   */
	  function LinearInterpolator() {
	    var transitionProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : VIEWPORT_TRANSITION_PROPS;

	    _classCallCheck(this, LinearInterpolator);

	    return _possibleConstructorReturn(this, (LinearInterpolator.__proto__ || Object.getPrototypeOf(LinearInterpolator)).call(this, transitionProps));
	  }

	  _createClass(LinearInterpolator, [{
	    key: "interpolateProps",
	    value: function interpolateProps(startProps, endProps, t) {
	      var viewport = {};

	      for (var key in endProps) {
	        viewport[key] = (0, _math.lerp)(startProps[key], endProps[key], t);
	      }

	      return viewport;
	    }
	  }]);

	  return LinearInterpolator;
	}(_transitionInterpolator.default);

	exports.default = LinearInterpolator;
	//# sourceMappingURL=linear-interpolator.js.map

/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _math = __webpack_require__(109);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var TransitionInterpolator =
	/*#__PURE__*/
	function () {
	  /**
	   * @param opts {array|object}
	   * @param opts.compare {array} - prop names used in equality check
	   * @param opts.extract {array} - prop names needed for interpolation
	   * @param opts.required {array} - prop names that must be supplied
	   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
	   */
	  function TransitionInterpolator() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, TransitionInterpolator);

	    if (Array.isArray(opts)) {
	      opts = {
	        compare: opts,
	        extract: opts,
	        required: opts
	      };
	    }

	    var _opts = opts,
	        compare = _opts.compare,
	        extract = _opts.extract,
	        required = _opts.required;
	    this._propsToCompare = compare;
	    this._propsToExtract = extract;
	    this._requiredProps = required;
	  }
	  /**
	   * Checks if two sets of props need transition in between
	   * @param currentProps {object} - a list of viewport props
	   * @param nextProps {object} - a list of viewport props
	   * @returns {bool} - true if two props are equivalent
	   */


	  _createClass(TransitionInterpolator, [{
	    key: "arePropsEqual",
	    value: function arePropsEqual(currentProps, nextProps) {
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = (this._propsToCompare || Object.keys(nextProps))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;

	          if (!(0, _math.equals)(currentProps[key], nextProps[key])) {
	            return false;
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return true;
	    }
	    /**
	     * Called before transition starts to validate/pre-process start and end props
	     * @param startProps {object} - a list of starting viewport props
	     * @param endProps {object} - a list of target viewport props
	     * @returns {Object} {start, end} - start and end props to be passed
	     *   to `interpolateProps`
	     */

	  }, {
	    key: "initializeProps",
	    value: function initializeProps(startProps, endProps) {
	      var result;

	      if (this._propsToExtract) {
	        var startViewStateProps = {};
	        var endViewStateProps = {};
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = this._propsToExtract[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var key = _step2.value;
	            startViewStateProps[key] = startProps[key];
	            endViewStateProps[key] = endProps[key];
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }

	        result = {
	          start: startViewStateProps,
	          end: endViewStateProps
	        };
	      } else {
	        result = {
	          start: startProps,
	          end: endProps
	        };
	      }

	      this._checkRequiredProps(result.start);

	      this._checkRequiredProps(result.end);

	      return result;
	    }
	    /**
	     * Returns viewport props in transition
	     * @param startProps {object} - a list of starting viewport props
	     * @param endProps {object} - a list of target viewport props
	     * @param t {number} - a time factor between [0, 1]
	     * @returns {object} - a list of interpolated viewport props
	     */

	  }, {
	    key: "interpolateProps",
	    value: function interpolateProps(startProps, endProps, t) {
	      (0, _assert.default)(false, 'interpolateProps is not implemented');
	    }
	  }, {
	    key: "_checkRequiredProps",
	    value: function _checkRequiredProps(props) {
	      if (!this._requiredProps) {
	        return;
	      }

	      this._requiredProps.forEach(function (propName) {
	        var value = props[propName];
	        (0, _assert.default)(Number.isFinite(value) || Array.isArray(value), "".concat(propName, " is required for transition"));
	      });
	    }
	  }]);

	  return TransitionInterpolator;
	}();

	exports.default = TransitionInterpolator;
	//# sourceMappingURL=transition-interpolator.js.map

/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = exports.TRANSITION_EVENTS = void 0;

	var _linearInterpolator = _interopRequireDefault(__webpack_require__(386));

	var _transition = _interopRequireDefault(__webpack_require__(267));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var noop = function noop() {};

	var TRANSITION_EVENTS = {
	  BREAK: 1,
	  SNAP_TO_END: 2,
	  IGNORE: 3
	};
	exports.TRANSITION_EVENTS = TRANSITION_EVENTS;
	var DEFAULT_PROPS = {
	  transitionDuration: 0,
	  transitionEasing: function transitionEasing(t) {
	    return t;
	  },
	  transitionInterpolator: new _linearInterpolator.default(),
	  transitionInterruption: TRANSITION_EVENTS.BREAK,
	  onTransitionStart: noop,
	  onTransitionInterrupt: noop,
	  onTransitionEnd: noop
	};

	var TransitionManager =
	/*#__PURE__*/
	function () {
	  function TransitionManager(ControllerState) {
	    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	    _classCallCheck(this, TransitionManager);

	    (0, _assert.default)(ControllerState);
	    this.ControllerState = ControllerState;
	    this.props = Object.assign({}, DEFAULT_PROPS, props);
	    this.animation = null;
	    this.propsInTransition = null;
	    this.transition = new _transition.default();
	    this._onTransitionFrame = this._onTransitionFrame.bind(this);
	    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);
	  } // Returns current transitioned viewport.


	  _createClass(TransitionManager, [{
	    key: "getViewportInTransition",
	    value: function getViewportInTransition() {
	      return this.propsInTransition;
	    } // Process the vewiport change, either ignore or trigger a new transition.
	    // Return true if a new transition is triggered, false otherwise.

	  }, {
	    key: "processViewStateChange",
	    value: function processViewStateChange(nextProps) {
	      var transitionTriggered = false;
	      var currentProps = this.props; // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.

	      nextProps = Object.assign({}, this.props, nextProps);
	      this.props = nextProps; // NOTE: Be cautious re-ordering statements in this function.

	      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {
	        return transitionTriggered;
	      }

	      if (this._isTransitionEnabled(nextProps)) {
	        var startProps = Object.assign({}, currentProps, this.transition.interruption === TRANSITION_EVENTS.SNAP_TO_END ? this.transition.endProps : this.propsInTransition || currentProps);

	        this._triggerTransition(startProps, nextProps);

	        transitionTriggered = true;
	      } else {
	        this.transition.cancel();
	      }

	      return transitionTriggered;
	    } // Helper methods

	  }, {
	    key: "_isTransitionEnabled",
	    value: function _isTransitionEnabled(props) {
	      return props.transitionDuration > 0 && props.transitionInterpolator;
	    }
	  }, {
	    key: "_isUpdateDueToCurrentTransition",
	    value: function _isUpdateDueToCurrentTransition(props) {
	      if (this.transition.inProgress) {
	        return this.transition.interpolator.arePropsEqual(props, this.propsInTransition);
	      }

	      return false;
	    }
	  }, {
	    key: "_shouldIgnoreViewportChange",
	    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
	      if (this.transition.inProgress) {
	        // Ignore update if it is requested to be ignored
	        return this.transition.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.
	        this._isUpdateDueToCurrentTransition(nextProps);
	      } else if (this._isTransitionEnabled(nextProps)) {
	        // Ignore if none of the viewport props changed.
	        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
	      }

	      return true;
	    }
	  }, {
	    key: "_triggerTransition",
	    value: function _triggerTransition(startProps, endProps) {
	      (0, _assert.default)(this._isTransitionEnabled(endProps), 'Transition is not enabled');
	      cancelAnimationFrame(this.animation);
	      var startViewstate = new this.ControllerState(startProps);
	      var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);
	      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);
	      this.propsInTransition = {};
	      this.transition.start({
	        duration: endProps.transitionDuration,
	        easing: endProps.transitionEasing,
	        interpolator: endProps.transitionInterpolator,
	        interruption: endProps.transitionInterruption,
	        startProps: initialProps.start,
	        endProps: initialProps.end,
	        onStart: endProps.onTransitionStart,
	        onUpdate: this._onTransitionUpdate,
	        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
	        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
	      });

	      this._onTransitionFrame();
	    }
	  }, {
	    key: "_onTransitionFrame",
	    value: function _onTransitionFrame() {
	      // _updateViewport() may cancel the animation
	      this.animation = requestAnimationFrame(this._onTransitionFrame);
	      this.transition.update(Date.now());
	    }
	  }, {
	    key: "_onTransitionEnd",
	    value: function _onTransitionEnd(callback) {
	      var _this = this;

	      return function (transition) {
	        cancelAnimationFrame(_this.animation);
	        _this.propsInTransition = null;
	        callback(transition);
	      };
	    }
	  }, {
	    key: "_onTransitionUpdate",
	    value: function _onTransitionUpdate(transition) {
	      // NOTE: Be cautious re-ordering statements in this function.
	      var interpolator = transition.interpolator,
	          startProps = transition.startProps,
	          endProps = transition.endProps,
	          time = transition.time;
	      var viewport = interpolator.interpolateProps(startProps, endProps, time); // This gurantees all props (e.g. bearing, longitude) are normalized
	      // So when viewports are compared they are in same range.

	      this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();

	      if (this.props.onViewportChange) {
	        this.props.onViewportChange(this.propsInTransition, {
	          inTransition: true
	        });
	      }
	    }
	  }]);

	  return TransitionManager;
	}();

	exports.default = TransitionManager;
	TransitionManager.defaultProps = DEFAULT_PROPS;
	//# sourceMappingURL=transition-manager.js.map

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _math = __webpack_require__(109);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var SphericalCoordinates = _math.experimental.SphericalCoordinates;
	var defaultState = {
	  position: [0, 0, 0],
	  lookAt: [0, 0, 0],
	  up: [0, 0, 1],
	  rotationX: 0,
	  rotationY: 0,
	  fov: 50,
	  near: 1,
	  far: 100
	};
	/* Helpers */

	var ViewState =
	/*#__PURE__*/
	function () {
	  function ViewState(opts) {
	    _classCallCheck(this, ViewState);

	    var width = opts.width,
	        height = opts.height,
	        _opts$position = opts.position,
	        position = _opts$position === void 0 ? defaultState.position : _opts$position;
	    (0, _assert.default)(Number.isFinite(width), '`width` must be supplied');
	    (0, _assert.default)(Number.isFinite(height), '`height` must be supplied');
	    this._viewportProps = this._applyConstraints(Object.assign({}, opts, {
	      position: new _math.Vector3(position)
	    }));
	  }

	  _createClass(ViewState, [{
	    key: "getViewportProps",
	    value: function getViewportProps() {
	      return this._viewportProps;
	    }
	  }, {
	    key: "getDirection",
	    value: function getDirection() {
	      var spherical = new SphericalCoordinates({
	        bearing: this._viewportProps.bearing,
	        pitch: this._viewportProps.pitch
	      });
	      var direction = spherical.toVector3().normalize();
	      return direction;
	    }
	  }, {
	    key: "getDirectionFromBearing",
	    value: function getDirectionFromBearing(bearing) {
	      var spherical = new SphericalCoordinates({
	        bearing: bearing,
	        pitch: 90
	      });
	      var direction = spherical.toVector3().normalize();
	      return direction;
	    }
	  }, {
	    key: "shortestPathFrom",
	    value: function shortestPathFrom(viewState) {
	      return this._viewportProps;
	    } // Redefined by subclass
	    // Apply any constraints (mathematical or defined by _viewportProps) to map state

	  }, {
	    key: "_applyConstraints",
	    value: function _applyConstraints(props) {
	      return props;
	    }
	  }]);

	  return ViewState;
	}();

	exports.default = ViewState;
	//# sourceMappingURL=view-state.js.map

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _layer = _interopRequireDefault(__webpack_require__(261));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _flatten = __webpack_require__(266);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var CompositeLayer =
	/*#__PURE__*/
	function (_Layer) {
	  _inherits(CompositeLayer, _Layer);

	  function CompositeLayer(props) {
	    _classCallCheck(this, CompositeLayer);

	    return _possibleConstructorReturn(this, (CompositeLayer.__proto__ || Object.getPrototypeOf(CompositeLayer)).call(this, props));
	  }

	  _createClass(CompositeLayer, [{
	    key: "getSubLayers",
	    value: function getSubLayers() {
	      return this.internalState && this.internalState.subLayers || [];
	    } // initializeState is usually not needed for composite layers
	    // Provide empty definition to disable check for missing definition

	  }, {
	    key: "initializeState",
	    value: function initializeState() {} // called to augment the info object that is bubbled up from a sublayer
	    // override Layer.getPickingInfo() because decoding / setting uniform do
	    // not apply to a composite layer.
	    // @return null to cancel event

	  }, {
	    key: "getPickingInfo",
	    value: function getPickingInfo(_ref) {
	      var info = _ref.info;
	      return info;
	    } // Implement to generate subLayers

	  }, {
	    key: "renderLayers",
	    value: function renderLayers() {
	      return null;
	    } // Returns sub layer props for a specific sublayer

	  }, {
	    key: "getSubLayerProps",
	    value: function getSubLayerProps(sublayerProps) {
	      var _this$props = this.props,
	          opacity = _this$props.opacity,
	          pickable = _this$props.pickable,
	          visible = _this$props.visible,
	          parameters = _this$props.parameters,
	          getPolygonOffset = _this$props.getPolygonOffset,
	          highlightedObjectIndex = _this$props.highlightedObjectIndex,
	          autoHighlight = _this$props.autoHighlight,
	          highlightColor = _this$props.highlightColor,
	          coordinateSystem = _this$props.coordinateSystem,
	          coordinateOrigin = _this$props.coordinateOrigin,
	          modelMatrix = _this$props.modelMatrix;
	      var newProps = {
	        opacity: opacity,
	        pickable: pickable,
	        visible: visible,
	        parameters: parameters,
	        getPolygonOffset: getPolygonOffset,
	        highlightedObjectIndex: highlightedObjectIndex,
	        autoHighlight: autoHighlight,
	        highlightColor: highlightColor,
	        coordinateSystem: coordinateSystem,
	        coordinateOrigin: coordinateOrigin,
	        modelMatrix: modelMatrix
	      };

	      if (sublayerProps) {
	        Object.assign(newProps, sublayerProps, {
	          id: "".concat(this.props.id, "-").concat(sublayerProps.id),
	          updateTriggers: Object.assign({
	            all: this.props.updateTriggers.all
	          }, sublayerProps.updateTriggers)
	        });
	      }

	      return newProps;
	    } // Called by layer manager to render subLayers

	  }, {
	    key: "_renderLayers",
	    value: function _renderLayers() {
	      var subLayers = this.internalState.subLayers;

	      if (subLayers && !this.needsUpdate()) {
	        _log.default.log(3, "Composite layer reused subLayers ".concat(this), this.internalState.subLayers)();
	      } else {
	        subLayers = this.renderLayers(); // Flatten the returned array, removing any null, undefined or false
	        // this allows layers to render sublayers conditionally
	        // (see CompositeLayer.renderLayers docs)

	        subLayers = (0, _flatten.flatten)(subLayers, {
	          filter: Boolean
	        });
	        this.internalState.subLayers = subLayers;

	        _log.default.log(2, "Composite layer rendered new subLayers ".concat(this), subLayers)();
	      } // populate reference to parent layer (this layer)
	      // NOTE: needs to be done even when reusing layers as the parent may have changed


	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = subLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var layer = _step.value;
	          layer.parent = this;
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return != null) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }
	    }
	  }, {
	    key: "isComposite",
	    get: function get() {
	      return true;
	    }
	  }]);

	  return CompositeLayer;
	}(_layer.default);

	exports.default = CompositeLayer;
	CompositeLayer.layerName = 'CompositeLayer';
	//# sourceMappingURL=composite-layer.js.map

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var SphericalCoordinates = _math.experimental.SphericalCoordinates;

	function getDirectionFromBearingAndPitch(_ref) {
	  var bearing = _ref.bearing,
	      pitch = _ref.pitch;
	  var spherical = new SphericalCoordinates({
	    bearing: bearing,
	    pitch: pitch
	  });
	  var direction = spherical.toVector3().normalize();
	  return direction;
	}

	var FirstPersonView =
	/*#__PURE__*/
	function (_View) {
	  _inherits(FirstPersonView, _View);

	  function FirstPersonView() {
	    _classCallCheck(this, FirstPersonView);

	    return _possibleConstructorReturn(this, (FirstPersonView.__proto__ || Object.getPrototypeOf(FirstPersonView)).apply(this, arguments));
	  }

	  _createClass(FirstPersonView, [{
	    key: "_getViewport",
	    value: function _getViewport(props) {
	      // TODO - push direction handling into Matrix4.lookAt
	      var _props$viewState = props.viewState,
	          _props$viewState$mode = _props$viewState.modelMatrix,
	          modelMatrix = _props$viewState$mode === void 0 ? null : _props$viewState$mode,
	          bearing = _props$viewState.bearing,
	          _props$viewState$up = _props$viewState.up,
	          up = _props$viewState$up === void 0 ? [0, 0, 1] : _props$viewState$up; // Always calculate direction from bearing and pitch

	      var dir = getDirectionFromBearingAndPitch({
	        bearing: bearing,
	        pitch: 89
	      }); // Direction is relative to model coordinates, of course

	      var center = modelMatrix ? modelMatrix.transformDirection(dir) : dir; // Just the direction. All the positioning is done in viewport.js

	      var viewMatrix = new _math.Matrix4().lookAt({
	        eye: [0, 0, 0],
	        center: center,
	        up: up
	      });
	      return new _viewport.default(Object.assign({}, props, {
	        zoom: null,
	        // triggers meter level zoom
	        viewMatrix: viewMatrix
	      }));
	    }
	  }]);

	  return FirstPersonView;
	}(_view.default);

	exports.default = FirstPersonView;
	FirstPersonView.displayName = 'FirstPersonView';
	//# sourceMappingURL=first-person-view.js.map

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var SphericalCoordinates = _math.experimental.SphericalCoordinates;

	function getDirectionFromBearingAndPitch(_ref) {
	  var bearing = _ref.bearing,
	      pitch = _ref.pitch;
	  var spherical = new SphericalCoordinates({
	    bearing: bearing,
	    pitch: pitch
	  });
	  return spherical.toVector3().normalize();
	}

	var ThirdPersonView =
	/*#__PURE__*/
	function (_View) {
	  _inherits(ThirdPersonView, _View);

	  function ThirdPersonView() {
	    _classCallCheck(this, ThirdPersonView);

	    return _possibleConstructorReturn(this, (ThirdPersonView.__proto__ || Object.getPrototypeOf(ThirdPersonView)).apply(this, arguments));
	  }

	  _createClass(ThirdPersonView, [{
	    key: "_getViewport",
	    value: function _getViewport(props) {
	      var _props$viewState = props.viewState,
	          bearing = _props$viewState.bearing,
	          pitch = _props$viewState.pitch,
	          position = _props$viewState.position,
	          up = _props$viewState.up,
	          zoom = _props$viewState.zoom;
	      var direction = getDirectionFromBearingAndPitch({
	        bearing: bearing,
	        pitch: pitch
	      });
	      var distance = zoom * 50; // TODO somehow need to flip z to make it work
	      // check if the position offset is done in the base viewport

	      var eye = direction.scale(-distance).multiply(new _math.Vector3(1, 1, -1));
	      var viewMatrix = new _math.Matrix4().multiplyRight(new _math.Matrix4().lookAt({
	        eye: eye,
	        center: position,
	        up: up
	      }));
	      return new _viewport.default(Object.assign({}, props, {
	        id: this.id,
	        zoom: null,
	        // triggers meter level zoom
	        viewMatrix: viewMatrix
	      }));
	    }
	  }]);

	  return ThirdPersonView;
	}(_view.default);

	exports.default = ThirdPersonView;
	ThirdPersonView.displayName = 'ThirdPersonView';
	//# sourceMappingURL=third-person-view.js.map

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _mathUtils = __webpack_require__(283);

	var _multiply = _interopRequireDefault(__webpack_require__(135));

	var _lookAt = _interopRequireDefault(__webpack_require__(129));

	var _scale = _interopRequireDefault(__webpack_require__(137));

	var _perspective = _interopRequireDefault(__webpack_require__(132));

	var _translate = _interopRequireDefault(__webpack_require__(138));

	var _rotateX = _interopRequireDefault(__webpack_require__(142));

	var _rotateY = _interopRequireDefault(__webpack_require__(143));

	var _rotateZ = _interopRequireDefault(__webpack_require__(144));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var DEGREES_TO_RADIANS = Math.PI / 180; // TODO - remove need for custom project overrides

	var OrbitViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(OrbitViewport, _Viewport);

	  function OrbitViewport() {
	    _classCallCheck(this, OrbitViewport);

	    return _possibleConstructorReturn(this, (OrbitViewport.__proto__ || Object.getPrototypeOf(OrbitViewport)).apply(this, arguments));
	  }

	  _createClass(OrbitViewport, [{
	    key: "project",
	    value: function project(xyz) {
	      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref$topLeft = _ref.topLeft,
	          topLeft = _ref$topLeft === void 0 ? false : _ref$topLeft;

	      var v = (0, _mathUtils.transformVector)(this.pixelProjectionMatrix, _toConsumableArray(xyz).concat([1]));

	      var _v = _slicedToArray(v, 3),
	          x = _v[0],
	          y = _v[1],
	          z = _v[2];

	      var y2 = topLeft ? this.height - y : y;
	      return [x, y2, z];
	    }
	  }, {
	    key: "unproject",
	    value: function unproject(xyz) {
	      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref2$topLeft = _ref2.topLeft,
	          topLeft = _ref2$topLeft === void 0 ? false : _ref2$topLeft;

	      var _xyz = _slicedToArray(xyz, 3),
	          x = _xyz[0],
	          y = _xyz[1],
	          z = _xyz[2];

	      var y2 = topLeft ? this.height - y : y;
	      return (0, _mathUtils.transformVector)(this.pixelUnprojectionMatrix, [x, y2, z, 1]);
	    }
	  }]);

	  return OrbitViewport;
	}(_viewport.default);

	var OrbitView =
	/*#__PURE__*/
	function (_View) {
	  _inherits(OrbitView, _View);

	  function OrbitView() {
	    _classCallCheck(this, OrbitView);

	    return _possibleConstructorReturn(this, (OrbitView.__proto__ || Object.getPrototypeOf(OrbitView)).apply(this, arguments));
	  }

	  _createClass(OrbitView, [{
	    key: "_getViewport",

	    /* eslint-disable complexity, max-statements */
	    value: function _getViewport(props) {
	      var viewState = props.viewState;
	      var width = props.width || 1;
	      var height = props.height || 1; // Get view matrix parameters from view state
	      // Projection matrix arguments
	      // TODO - Extracting from viewState is deprecated

	      var fovy = props.fov || props.fovy || viewState.fovy || 75; // Field of view covered by camera

	      var near = props.near || viewState.near || 1; // Distance of near clipping plane

	      var far = props.far || viewState.far || 100; // Distance of far clipping plane

	      var aspect = Number.isFinite(viewState.aspect) ? viewState.aspect : width / height;
	      var fovyRadians = fovy * DEGREES_TO_RADIANS;
	      return new OrbitViewport({
	        id: this.id,
	        viewMatrix: this._getViewMatrix(props.viewState),
	        projectionMatrix: (0, _perspective.default)([], fovyRadians, aspect, near, far),
	        x: props.x,
	        y: props.y,
	        width: width,
	        height: height
	      });
	    }
	    /* eslint-enable complexity, max-statements */

	  }, {
	    key: "_getViewMatrix",
	    value: function _getViewMatrix(viewState) {
	      var distance = viewState.distance,
	          _viewState$rotationX = viewState.rotationX,
	          rotationX = _viewState$rotationX === void 0 ? 0 : _viewState$rotationX,
	          _viewState$rotationOr = viewState.rotationOrbit,
	          rotationOrbit = _viewState$rotationOr === void 0 ? 0 : _viewState$rotationOr,
	          _viewState$orbitAxis = viewState.orbitAxis,
	          orbitAxis = _viewState$orbitAxis === void 0 ? 'Z' : _viewState$orbitAxis,
	          _viewState$lookAt = viewState.lookAt,
	          lookAt = _viewState$lookAt === void 0 ? [0, 0, 0] : _viewState$lookAt,
	          _viewState$up = viewState.up,
	          up = _viewState$up === void 0 ? [0, 1, 0] : _viewState$up,
	          _viewState$zoom = viewState.zoom,
	          zoom = _viewState$zoom === void 0 ? 1 : _viewState$zoom;
	      var rotationMatrix = (0, _rotateX.default)([], (0, _mathUtils.createMat4)(), -rotationX / 180 * Math.PI);

	      if (orbitAxis === 'Z') {
	        (0, _rotateZ.default)(rotationMatrix, rotationMatrix, -rotationOrbit / 180 * Math.PI);
	      } else {
	        (0, _rotateY.default)(rotationMatrix, rotationMatrix, -rotationOrbit / 180 * Math.PI);
	      }

	      var translateMatrix = (0, _mathUtils.createMat4)();
	      (0, _scale.default)(translateMatrix, translateMatrix, [zoom, zoom, zoom]);
	      (0, _translate.default)(translateMatrix, translateMatrix, [-lookAt[0], -lookAt[1], -lookAt[2]]);
	      var viewMatrix = (0, _lookAt.default)([], [0, 0, distance], [0, 0, 0], up);
	      (0, _multiply.default)(viewMatrix, viewMatrix, (0, _multiply.default)(rotationMatrix, rotationMatrix, translateMatrix));
	      return viewMatrix;
	    }
	    /** Move camera to make a model bounding box centered at lookat position fit in the viewport.
	     * @param {Array} boundingBox - [sizeX, sizeY, sizeZ]], define the dimensions of bounding box
	     * @returns a new OrbitViewport object
	     */

	  }, {
	    key: "fitBounds",
	    value: function fitBounds(boundingBox, viewState) {
	      var width = this.width,
	          height = this.height,
	          fov = this.fov,
	          near = this.near,
	          far = this.far;
	      return this._getViewport({
	        width: width,
	        height: height,
	        fov: fov,
	        near: near,
	        far: far
	      });
	    }
	  }], [{
	    key: "getDistance",
	    // Get camera `distance` to make view fit a box centered at lookat position in the viewport.
	    // @param {Array} boundingBox - [sizeX, sizeY, sizeZ]], defines the dimensions of bounding box
	    value: function getDistance(_ref3) {
	      var boundingBox = _ref3.boundingBox,
	          fov = _ref3.fov;
	      var halfMaxSide = Math.max(boundingBox[0], boundingBox[1], boundingBox[2]) / 2;
	      var distance = halfMaxSide / Math.tan(fov / 180 * Math.PI / 2);
	      return distance;
	    }
	  }]);

	  return OrbitView;
	}(_view.default);

	exports.default = OrbitView;
	OrbitView.displayName = 'OrbitView';
	//# sourceMappingURL=orbit-view.js.map

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _lookAt = _interopRequireDefault(__webpack_require__(129));

	var _perspective = _interopRequireDefault(__webpack_require__(132));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var DEGREES_TO_RADIANS = Math.PI / 180;

	var PerspectiveView =
	/*#__PURE__*/
	function (_View) {
	  _inherits(PerspectiveView, _View);

	  function PerspectiveView() {
	    _classCallCheck(this, PerspectiveView);

	    return _possibleConstructorReturn(this, (PerspectiveView.__proto__ || Object.getPrototypeOf(PerspectiveView)).apply(this, arguments));
	  }

	  _createClass(PerspectiveView, [{
	    key: "_getViewport",
	    value: function _getViewport(props) {
	      var x = props.x,
	          y = props.y,
	          width = props.width,
	          height = props.height,
	          viewState = props.viewState;
	      var eye = viewState.eye,
	          _viewState$lookAt = viewState.lookAt,
	          lookAt = _viewState$lookAt === void 0 ? [0, 0, 0] : _viewState$lookAt,
	          _viewState$up = viewState.up,
	          up = _viewState$up === void 0 ? [0, 1, 0] : _viewState$up; // Projection matrix arguments
	      // TODO - Extracting from viewState is deprecated

	      var fovy = props.fovy || viewState.fovy || 75; // Field of view covered by camera

	      var near = props.near || viewState.near || 1; // Distance of near clipping plane

	      var far = props.far || viewState.far || 100; // Distance of far clipping plane

	      var aspect = Number.isFinite(viewState.aspect) ? viewState.aspect : width / height;
	      var fovyRadians = fovy * DEGREES_TO_RADIANS;
	      return new _viewport.default({
	        id: this.id,
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        viewMatrix: (0, _lookAt.default)([], eye, lookAt, up),
	        projectionMatrix: (0, _perspective.default)([], fovyRadians, aspect, near, far)
	      });
	    }
	  }]);

	  return PerspectiveView;
	}(_view.default);

	exports.default = PerspectiveView;
	PerspectiveView.displayName = 'PerspectiveView';
	//# sourceMappingURL=perspective-view.js.map

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _view = _interopRequireDefault(__webpack_require__(281));

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var OrthographicView =
	/*#__PURE__*/
	function (_View) {
	  _inherits(OrthographicView, _View);

	  function OrthographicView() {
	    _classCallCheck(this, OrthographicView);

	    return _possibleConstructorReturn(this, (OrthographicView.__proto__ || Object.getPrototypeOf(OrthographicView)).apply(this, arguments));
	  }

	  _createClass(OrthographicView, [{
	    key: "_getViewport",
	    value: function _getViewport(_ref) {
	      var x = _ref.x,
	          y = _ref.y,
	          width = _ref.width,
	          height = _ref.height,
	          viewState = _ref.viewState;
	      // Get view matrix parameters from view state
	      var _viewState$eye = viewState.eye,
	          eye = _viewState$eye === void 0 ? [0, 0, 1] : _viewState$eye,
	          _viewState$lookAt = viewState.lookAt,
	          lookAt = _viewState$lookAt === void 0 ? [0, 0, 0] : _viewState$lookAt,
	          _viewState$up = viewState.up,
	          up = _viewState$up === void 0 ? [0, 1, 0] : _viewState$up; // Make sure Matrix4.ortho doesn't crash on 0 width/height

	      width = width || 1;
	      height = height || 1; // Get projection matrix parameters from the view itself
	      // NOTE: automatically calculated from width and height if not provided

	      var _this$props = this.props,
	          _this$props$left = _this$props.left,
	          left = _this$props$left === void 0 ? -width / 2 : _this$props$left,
	          _this$props$top = _this$props.top,
	          top = _this$props$top === void 0 ? -height / 2 : _this$props$top,
	          _this$props$near = _this$props.near,
	          near = _this$props$near === void 0 ? 1 : _this$props$near,
	          _this$props$far = _this$props.far,
	          far = _this$props$far === void 0 ? 100 : _this$props$far;
	      var _this$props2 = this.props,
	          _this$props2$right = _this$props2.right,
	          right = _this$props2$right === void 0 ? null : _this$props2$right,
	          _this$props2$bottom = _this$props2.bottom,
	          bottom = _this$props2$bottom === void 0 ? null : _this$props2$bottom;
	      right = Number.isFinite(right) ? right : left + width;
	      bottom = Number.isFinite(bottom) ? bottom : top + height;
	      return new _viewport.default({
	        id: this.id,
	        x: x,
	        y: y,
	        width: width,
	        height: height,
	        viewMatrix: new _math.Matrix4().lookAt({
	          eye: eye,
	          lookAt: lookAt,
	          up: up
	        }),
	        projectionMatrix: new _math.Matrix4().ortho({
	          left: left,
	          right: right,
	          bottom: bottom,
	          top: top,
	          near: near,
	          far: far
	        })
	      });
	    }
	  }]);

	  return OrthographicView;
	}(_view.default);

	exports.default = OrthographicView;
	OrthographicView.displayName = 'OrthographicView';
	//# sourceMappingURL=orthographic-view.js.map

/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _controller = _interopRequireDefault(__webpack_require__(385));

	var _viewState = _interopRequireDefault(__webpack_require__(389));

	var _math = __webpack_require__(109);

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var MOVEMENT_SPEED = 1; // 1 meter per keyboard click

	var ROTATION_STEP_DEGREES = 2;
	/* Helpers */

	function ensureFinite(value, fallbackValue) {
	  return Number.isFinite(value) ? value : fallbackValue;
	}

	var FirstPersonState =
	/*#__PURE__*/
	function (_ViewState) {
	  _inherits(FirstPersonState, _ViewState);

	  function FirstPersonState(_ref) {
	    var _this;

	    var width = _ref.width,
	        height = _ref.height,
	        position = _ref.position,
	        bearing = _ref.bearing,
	        pitch = _ref.pitch,
	        longitude = _ref.longitude,
	        latitude = _ref.latitude,
	        zoom = _ref.zoom,
	        _ref$syncBearing = _ref.syncBearing,
	        syncBearing = _ref$syncBearing === void 0 ? true : _ref$syncBearing,
	        bounds = _ref.bounds,
	        startPanEventPosition = _ref.startPanEventPosition,
	        startPanPosition = _ref.startPanPosition,
	        startRotateCenter = _ref.startRotateCenter,
	        startRotateViewport = _ref.startRotateViewport,
	        startZoomPos = _ref.startZoomPos,
	        startZoom = _ref.startZoom;

	    _classCallCheck(this, FirstPersonState);

	    _this = _possibleConstructorReturn(this, (FirstPersonState.__proto__ || Object.getPrototypeOf(FirstPersonState)).call(this, {
	      width: width,
	      height: height,
	      position: position,
	      bearing: bearing,
	      pitch: pitch,
	      longitude: longitude,
	      latitude: latitude,
	      zoom: zoom
	    }));
	    _this._interactiveState = {
	      startPanEventPosition: startPanEventPosition,
	      startPanPosition: startPanPosition,
	      startRotateCenter: startRotateCenter,
	      startRotateViewport: startRotateViewport,
	      startZoomPos: startZoomPos,
	      startZoom: startZoom
	    };
	    return _this;
	  }
	  /* Public API */


	  _createClass(FirstPersonState, [{
	    key: "getInteractiveState",
	    value: function getInteractiveState() {
	      return this._interactiveState;
	    }
	    /**
	     * Start panning
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "panStart",
	    value: function panStart(_ref2) {
	      var pos = _ref2.pos;
	      var _this$_viewportProps = this._viewportProps,
	          translationX = _this$_viewportProps.translationX,
	          translationY = _this$_viewportProps.translationY;
	      return this._getUpdatedState({
	        startPanPosition: [translationX, translationY],
	        startPanEventPosition: pos
	      });
	    }
	    /**
	     * Pan
	     * @param {[Number, Number]} pos - position on screen where the pointer is
	     */

	  }, {
	    key: "pan",
	    value: function pan(_ref3) {
	      var pos = _ref3.pos,
	          startPos = _ref3.startPos;
	      var startPanEventPosition = this._interactiveState.startPanEventPosition || startPos;
	      (0, _assert.default)(startPanEventPosition, '`startPanEventPosition` props is required');

	      var _ref4 = this._interactiveState.startPanPosition || [],
	          _ref5 = _slicedToArray(_ref4, 2),
	          translationX = _ref5[0],
	          translationY = _ref5[1];

	      translationX = ensureFinite(translationX, this._viewportProps.translationX);
	      translationY = ensureFinite(translationY, this._viewportProps.translationY);
	      var deltaX = pos[0] - startPanEventPosition[0];
	      var deltaY = pos[1] - startPanEventPosition[1];
	      return this._getUpdatedState({
	        translationX: translationX + deltaX,
	        translationY: translationY - deltaY
	      });
	    }
	    /**
	     * End panning
	     * Must call if `panStart()` was called
	     */

	  }, {
	    key: "panEnd",
	    value: function panEnd() {
	      return this._getUpdatedState({
	        startPanPosition: null,
	        startPanPos: null
	      });
	    }
	    /**
	     * Start rotating
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "rotateStart",
	    value: function rotateStart(_ref6) {
	      var pos = _ref6.pos;
	      return this._getUpdatedState({
	        startRotateCenter: this._viewportProps.position,
	        startRotateViewport: this._viewportProps
	      });
	    }
	    /**
	     * Rotate
	     * @param {[Number, Number]} pos - position on screen where the pointer is
	     */

	  }, {
	    key: "rotate",
	    value: function rotate(_ref7) {
	      var deltaScaleX = _ref7.deltaScaleX,
	          deltaScaleY = _ref7.deltaScaleY;
	      var _this$_viewportProps2 = this._viewportProps,
	          bearing = _this$_viewportProps2.bearing,
	          pitch = _this$_viewportProps2.pitch;
	      return this._getUpdatedState({
	        bearing: bearing + deltaScaleX * 10,
	        pitch: pitch - deltaScaleY * 10
	      });
	    }
	    /**
	     * End rotating
	     * Must call if `rotateStart()` was called
	     */

	  }, {
	    key: "rotateEnd",
	    value: function rotateEnd() {
	      return this._getUpdatedState({
	        startRotateCenter: null,
	        startRotateViewport: null
	      });
	    }
	    /**
	     * Start zooming
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "zoomStart",
	    value: function zoomStart(_ref8) {
	      var pos = _ref8.pos;
	      return this._getUpdatedState({
	        startZoomPos: pos,
	        startZoom: this._viewportProps.zoom
	      });
	    }
	    /**
	     * Zoom
	     * @param {[Number, Number]} pos - position on screen where the current center is
	     * @param {[Number, Number]} startPos - the center position at
	     *   the start of the operation. Must be supplied of `zoomStart()` was not called
	     * @param {Number} scale - a number between [0, 1] specifying the accumulated
	     *   relative scale.
	     */

	  }, {
	    key: "zoom",
	    value: function zoom(_ref9) {
	      var pos = _ref9.pos,
	          startPos = _ref9.startPos,
	          scale = _ref9.scale;
	      var _this$_viewportProps3 = this._viewportProps,
	          zoom = _this$_viewportProps3.zoom,
	          minZoom = _this$_viewportProps3.minZoom,
	          maxZoom = _this$_viewportProps3.maxZoom,
	          width = _this$_viewportProps3.width,
	          height = _this$_viewportProps3.height,
	          translationX = _this$_viewportProps3.translationX,
	          translationY = _this$_viewportProps3.translationY;
	      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;
	      var newZoom = (0, _math.clamp)(zoom * scale, minZoom, maxZoom);
	      var deltaX = pos[0] - startZoomPos[0];
	      var deltaY = pos[1] - startZoomPos[1]; // Zoom around the center position

	      var cx = startZoomPos[0] - width / 2;
	      var cy = height / 2 - startZoomPos[1];
	      /* eslint-disable no-unused-vars */

	      var newTranslationX = cx - (cx - translationX) * newZoom / zoom + deltaX;
	      var newTranslationY = cy - (cy - translationY) * newZoom / zoom - deltaY;
	      /* eslint-enable no-unused-vars */
	      // return this._getUpdatedState({
	      //   position
	      //   translationX: newTranslationX,
	      //   translationY: newTranslationY
	      // });
	      // TODO HACK

	      return newZoom / zoom < 1 ? this.moveBackward() : this.moveForward();
	    }
	    /**
	     * End zooming
	     * Must call if `zoomStart()` was called
	     */

	  }, {
	    key: "zoomEnd",
	    value: function zoomEnd() {
	      return this._getUpdatedState({
	        startZoomPos: null,
	        startZoom: null
	      });
	    }
	  }, {
	    key: "moveLeft",
	    value: function moveLeft() {
	      var bearing = this._viewportProps.bearing;
	      var newBearing = bearing - ROTATION_STEP_DEGREES;
	      return this._getUpdatedState({
	        bearing: newBearing
	      });
	    }
	  }, {
	    key: "moveRight",
	    value: function moveRight() {
	      var bearing = this._viewportProps.bearing;
	      var newBearing = bearing + ROTATION_STEP_DEGREES;
	      return this._getUpdatedState({
	        bearing: newBearing
	      });
	    }
	  }, {
	    key: "moveForward",
	    value: function moveForward() {
	      var position = this._viewportProps.position;
	      var direction = this.getDirection();
	      var delta = new _math.Vector3(direction).normalize().scale(MOVEMENT_SPEED);
	      return this._getUpdatedState({
	        position: new _math.Vector3(position).add(delta)
	      });
	    }
	  }, {
	    key: "moveBackward",
	    value: function moveBackward() {
	      var position = this._viewportProps.position;
	      var direction = this.getDirection();
	      var delta = new _math.Vector3(direction).normalize().scale(-MOVEMENT_SPEED);
	      return this._getUpdatedState({
	        position: new _math.Vector3(position).add(delta)
	      });
	    }
	  }, {
	    key: "moveUp",
	    value: function moveUp() {
	      var position = this._viewportProps.position;
	      var delta = [0, 0, 1];
	      return this._getUpdatedState({
	        position: new _math.Vector3(position).add(delta)
	      });
	    }
	  }, {
	    key: "moveDown",
	    value: function moveDown() {
	      var position = this._viewportProps.position;
	      var delta = position[2] >= 1 ? [0, 0, -1] : [0, 0, 0];
	      return this._getUpdatedState({
	        position: new _math.Vector3(position).add(delta)
	      });
	    }
	  }, {
	    key: "zoomIn",
	    value: function zoomIn() {
	      return this._getUpdatedState({
	        zoom: this._viewportProps.zoom + 0.2
	      });
	    }
	  }, {
	    key: "zoomOut",
	    value: function zoomOut() {
	      return this._getUpdatedState({
	        zoom: this._viewportProps.zoom - 0.2
	      });
	    }
	    /* Private methods */

	  }, {
	    key: "_getUpdatedState",
	    value: function _getUpdatedState(newProps) {
	      // Update _viewportProps
	      return new FirstPersonState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
	    }
	  }]);

	  return FirstPersonState;
	}(_viewState.default);

	var FirstPersonController =
	/*#__PURE__*/
	function (_Controller) {
	  _inherits(FirstPersonController, _Controller);

	  function FirstPersonController(props) {
	    _classCallCheck(this, FirstPersonController);

	    return _possibleConstructorReturn(this, (FirstPersonController.__proto__ || Object.getPrototypeOf(FirstPersonController)).call(this, FirstPersonState, props));
	  }

	  return FirstPersonController;
	}(_controller.default);

	exports.default = FirstPersonController;
	//# sourceMappingURL=first-person-controller.js.map

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _math = __webpack_require__(109);

	var _controller = _interopRequireDefault(__webpack_require__(385));

	var _orbitViewport = _interopRequireDefault(__webpack_require__(398));

	var _assert = _interopRequireDefault(__webpack_require__(239));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	var defaultState = {
	  lookAt: [0, 0, 0],
	  rotationX: 0,
	  rotationOrbit: 0,
	  fov: 50,
	  near: 1,
	  far: 100,
	  translationX: 0,
	  translationY: 0,
	  zoom: 1
	};
	var defaultConstraints = {
	  minZoom: 0,
	  maxZoom: Infinity
	};
	/* Helpers */

	function ensureFinite(value, fallbackValue) {
	  return Number.isFinite(value) ? value : fallbackValue;
	}

	var OrbitState =
	/*#__PURE__*/
	function () {
	  function OrbitState(_ref) {
	    var width = _ref.width,
	        height = _ref.height,
	        distance = _ref.distance,
	        rotationX = _ref.rotationX,
	        rotationOrbit = _ref.rotationOrbit,
	        orbitAxis = _ref.orbitAxis,
	        bounds = _ref.bounds,
	        lookAt = _ref.lookAt,
	        fov = _ref.fov,
	        near = _ref.near,
	        far = _ref.far,
	        translationX = _ref.translationX,
	        translationY = _ref.translationY,
	        zoom = _ref.zoom,
	        minZoom = _ref.minZoom,
	        maxZoom = _ref.maxZoom,
	        startPanViewport = _ref.startPanViewport,
	        startPanPos = _ref.startPanPos,
	        isPanning = _ref.isPanning,
	        startRotateViewport = _ref.startRotateViewport,
	        isRotating = _ref.isRotating,
	        startZoomViewport = _ref.startZoomViewport,
	        startZoomPos = _ref.startZoomPos;

	    _classCallCheck(this, OrbitState);

	    (0, _assert.default)(Number.isFinite(width), '`width` must be supplied');
	    (0, _assert.default)(Number.isFinite(height), '`height` must be supplied');
	    (0, _assert.default)(Number.isFinite(distance), '`distance` must be supplied');
	    this._viewportProps = this._applyConstraints({
	      width: width,
	      height: height,
	      distance: distance,
	      rotationX: ensureFinite(rotationX, defaultState.rotationX),
	      rotationOrbit: ensureFinite(rotationOrbit, defaultState.rotationOrbit),
	      orbitAxis: orbitAxis,
	      bounds: bounds,
	      lookAt: lookAt || defaultState.lookAt,
	      fov: ensureFinite(fov, defaultState.fov),
	      near: ensureFinite(near, defaultState.near),
	      far: ensureFinite(far, defaultState.far),
	      translationX: ensureFinite(translationX, defaultState.translationX),
	      translationY: ensureFinite(translationY, defaultState.translationY),
	      zoom: ensureFinite(zoom, defaultState.zoom),
	      minZoom: ensureFinite(minZoom, defaultConstraints.minZoom),
	      maxZoom: ensureFinite(maxZoom, defaultConstraints.maxZoom)
	    });
	    this._interactiveState = {
	      startPanViewport: startPanViewport,
	      startPanPos: startPanPos,
	      isPanning: isPanning,
	      startRotateViewport: startRotateViewport,
	      isRotating: isRotating,
	      startZoomViewport: startZoomViewport,
	      startZoomPos: startZoomPos
	    };
	  }
	  /* Public API */


	  _createClass(OrbitState, [{
	    key: "getViewportProps",
	    value: function getViewportProps() {
	      return this._viewportProps;
	    }
	  }, {
	    key: "getInteractiveState",
	    value: function getInteractiveState() {
	      return this._interactiveState;
	    }
	    /**
	     * Start panning
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "panStart",
	    value: function panStart(_ref2) {
	      var pos = _ref2.pos;
	      var viewport = new _orbitViewport.default(this._viewportProps);
	      return this._getUpdatedOrbitState({
	        startPanPos: pos,
	        startPanViewport: viewport
	      });
	    }
	    /**
	     * Pan
	     * @param {[Number, Number]} pos - position on screen where the pointer is
	     */

	  }, {
	    key: "pan",
	    value: function pan(_ref3) {
	      var pos = _ref3.pos,
	          startPos = _ref3.startPos;

	      if (this._interactiveState.isRotating) {
	        return this._getUpdatedOrbitState();
	      }

	      var startPanPos = this._interactiveState.startPanPos || startPos;
	      (0, _assert.default)(startPanPos, '`startPanPos` props is required');
	      var viewport = this._interactiveState.startPanViewport || new _orbitViewport.default(this._viewportProps);
	      var deltaX = pos[0] - startPanPos[0];
	      var deltaY = pos[1] - startPanPos[1];
	      var center = viewport.project(viewport.lookAt);
	      var newLookAt = viewport.unproject([center[0] - deltaX, center[1] - deltaY, center[2]]);
	      return this._getUpdatedOrbitState({
	        lookAt: newLookAt,
	        isPanning: true
	      });
	    }
	    /**
	     * End panning
	     * Must call if `panStart()` was called
	     */

	  }, {
	    key: "panEnd",
	    value: function panEnd() {
	      return this._getUpdatedOrbitState({
	        startPanViewport: null,
	        startPanPos: null,
	        isPanning: null
	      });
	    }
	    /**
	     * Start rotating
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "rotateStart",
	    value: function rotateStart(_ref4) {
	      var pos = _ref4.pos;
	      // Rotation center should be the worldspace position at the center of the
	      // the screen. If not found, use the last one.
	      var viewport = new _orbitViewport.default(this._viewportProps);
	      return this._getUpdatedOrbitState({
	        startRotateViewport: viewport
	      });
	    }
	    /**
	     * Rotate
	     * @param {[Number, Number]} pos - position on screen where the pointer is
	     */

	  }, {
	    key: "rotate",
	    value: function rotate(_ref5) {
	      var deltaScaleX = _ref5.deltaScaleX,
	          deltaScaleY = _ref5.deltaScaleY;

	      if (this._interactiveState.isPanning) {
	        return this._getUpdatedOrbitState();
	      }

	      var startRotateViewport = this._interactiveState.startRotateViewport;

	      var _ref6 = startRotateViewport || {},
	          rotationX = _ref6.rotationX,
	          rotationOrbit = _ref6.rotationOrbit;

	      rotationX = ensureFinite(rotationX, this._viewportProps.rotationX);
	      rotationOrbit = ensureFinite(rotationOrbit, this._viewportProps.rotationOrbit);
	      var newRotationX = (0, _math.clamp)(rotationX - deltaScaleY * 180, -89.999, 89.999);
	      var newRotationOrbit = (rotationOrbit - deltaScaleX * 180) % 360;
	      return this._getUpdatedOrbitState({
	        rotationX: newRotationX,
	        rotationOrbit: newRotationOrbit,
	        isRotating: true
	      });
	    }
	    /**
	     * End rotating
	     * Must call if `rotateStart()` was called
	     */

	  }, {
	    key: "rotateEnd",
	    value: function rotateEnd() {
	      return this._getUpdatedOrbitState({
	        startRotateViewport: null,
	        isRotating: null
	      });
	    }
	    /**
	     * Start zooming
	     * @param {[Number, Number]} pos - position on screen where the pointer grabs
	     */

	  }, {
	    key: "zoomStart",
	    value: function zoomStart(_ref7) {
	      var pos = _ref7.pos;
	      var viewport = new _orbitViewport.default(this._viewportProps);
	      return this._getUpdatedOrbitState({
	        startZoomViewport: viewport,
	        startZoomPos: pos
	      });
	    }
	    /**
	     * Zoom
	     * @param {[Number, Number]} pos - position on screen where the current center is
	     * @param {[Number, Number]} startPos - the center position at
	     *   the start of the operation. Must be supplied of `zoomStart()` was not called
	     * @param {Number} scale - a number between [0, 1] specifying the accumulated
	     *   relative scale.
	     */

	  }, {
	    key: "zoom",
	    value: function zoom(_ref8) {
	      var pos = _ref8.pos,
	          startPos = _ref8.startPos,
	          scale = _ref8.scale;
	      var _this$_viewportProps = this._viewportProps,
	          zoom = _this$_viewportProps.zoom,
	          minZoom = _this$_viewportProps.minZoom,
	          maxZoom = _this$_viewportProps.maxZoom,
	          width = _this$_viewportProps.width,
	          height = _this$_viewportProps.height;
	      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;
	      var viewport = this._interactiveState.startZoomViewport || new _orbitViewport.default(this._viewportProps);
	      var newZoom = (0, _math.clamp)(zoom * scale, minZoom, maxZoom);
	      var deltaX = pos[0] - startZoomPos[0];
	      var deltaY = pos[1] - startZoomPos[1]; // Zoom around the center position

	      var cx = startZoomPos[0] - width / 2;
	      var cy = height / 2 - startZoomPos[1];
	      var center = viewport.project(viewport.lookAt);
	      var newCenterX = center[0] - cx + cx * newZoom / zoom + deltaX;
	      var newCenterY = center[1] + cy - cy * newZoom / zoom - deltaY;
	      var newLookAt = viewport.unproject([newCenterX, newCenterY, center[2]]);
	      return this._getUpdatedOrbitState({
	        lookAt: newLookAt,
	        zoom: newZoom
	      });
	    }
	    /**
	     * End zooming
	     * Must call if `zoomStart()` was called
	     */

	  }, {
	    key: "zoomEnd",
	    value: function zoomEnd() {
	      return this._getUpdatedOrbitState({
	        startZoomPos: null
	      });
	    }
	    /* Private methods */

	  }, {
	    key: "_getUpdatedOrbitState",
	    value: function _getUpdatedOrbitState(newProps) {
	      // Update _viewportProps
	      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));
	    } // Apply any constraints (mathematical or defined by _viewportProps) to map state

	  }, {
	    key: "_applyConstraints",
	    value: function _applyConstraints(props) {
	      // Ensure zoom is within specified range
	      var maxZoom = props.maxZoom,
	          minZoom = props.minZoom,
	          zoom = props.zoom;
	      props.zoom = zoom > maxZoom ? maxZoom : zoom;
	      props.zoom = zoom < minZoom ? minZoom : zoom;
	      return props;
	    }
	  }]);

	  return OrbitState;
	}();

	var OrbitController =
	/*#__PURE__*/
	function (_Controller) {
	  _inherits(OrbitController, _Controller);

	  function OrbitController(props) {
	    _classCallCheck(this, OrbitController);

	    return _possibleConstructorReturn(this, (OrbitController.__proto__ || Object.getPrototypeOf(OrbitController)).call(this, OrbitState, props));
	  }

	  return OrbitController;
	}(_controller.default);

	exports.default = OrbitController;
	//# sourceMappingURL=orbit-controller.js.map

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _mathUtils = __webpack_require__(283);

	var _multiply = _interopRequireDefault(__webpack_require__(135));

	var _lookAt = _interopRequireDefault(__webpack_require__(129));

	var _scale = _interopRequireDefault(__webpack_require__(137));

	var _perspective = _interopRequireDefault(__webpack_require__(132));

	var _translate = _interopRequireDefault(__webpack_require__(138));

	var _rotateX = _interopRequireDefault(__webpack_require__(142));

	var _rotateY = _interopRequireDefault(__webpack_require__(143));

	var _rotateZ = _interopRequireDefault(__webpack_require__(144));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

	function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

	function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

	function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var DEGREES_TO_RADIANS = Math.PI / 180;
	/*
	 * A deck.gl Viewport class used by OrbitController
	 * Adds zoom and pixel translation on top of the PerspectiveViewport
	 */

	var OrbitViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(OrbitViewport, _Viewport);

	  function OrbitViewport(_ref) {
	    var _this;

	    var _ref$id = _ref.id,
	        id = _ref$id === void 0 ? 'orbit-viewport' : _ref$id,
	        width = _ref.width,
	        height = _ref.height,
	        distance = _ref.distance,
	        _ref$rotationX = _ref.rotationX,
	        rotationX = _ref$rotationX === void 0 ? 0 : _ref$rotationX,
	        _ref$rotationOrbit = _ref.rotationOrbit,
	        rotationOrbit = _ref$rotationOrbit === void 0 ? 0 : _ref$rotationOrbit,
	        _ref$orbitAxis = _ref.orbitAxis,
	        orbitAxis = _ref$orbitAxis === void 0 ? 'Z' : _ref$orbitAxis,
	        _ref$lookAt = _ref.lookAt,
	        lookAt = _ref$lookAt === void 0 ? [0, 0, 0] : _ref$lookAt,
	        _ref$up = _ref.up,
	        up = _ref$up === void 0 ? [0, 1, 0] : _ref$up,
	        _ref$fov = _ref.fov,
	        fov = _ref$fov === void 0 ? 75 : _ref$fov,
	        _ref$near = _ref.near,
	        near = _ref$near === void 0 ? 1 : _ref$near,
	        _ref$far = _ref.far,
	        far = _ref$far === void 0 ? 100 : _ref$far,
	        _ref$zoom = _ref.zoom,
	        zoom = _ref$zoom === void 0 ? 1 : _ref$zoom;

	    _classCallCheck(this, OrbitViewport);

	    // TODO - Once OrbitViewport is aligned with the View system, deprecated it
	    // log.deprecated('OrbitViewport', 'OrbitView')();
	    var rotationMatrix = (0, _rotateX.default)([], (0, _mathUtils.createMat4)(), -rotationX / 180 * Math.PI);

	    if (orbitAxis === 'Z') {
	      (0, _rotateZ.default)(rotationMatrix, rotationMatrix, -rotationOrbit / 180 * Math.PI);
	    } else {
	      (0, _rotateY.default)(rotationMatrix, rotationMatrix, -rotationOrbit / 180 * Math.PI);
	    }

	    var translateMatrix = (0, _mathUtils.createMat4)();
	    (0, _scale.default)(translateMatrix, translateMatrix, [zoom, zoom, zoom]);
	    (0, _translate.default)(translateMatrix, translateMatrix, [-lookAt[0], -lookAt[1], -lookAt[2]]);
	    var viewMatrix = (0, _lookAt.default)([], [0, 0, distance], [0, 0, 0], up);
	    var fovRadians = fov * DEGREES_TO_RADIANS;
	    var aspect = width / height;
	    var perspectiveMatrix = (0, _perspective.default)([], fovRadians, aspect, near, far);
	    _this = _possibleConstructorReturn(this, (OrbitViewport.__proto__ || Object.getPrototypeOf(OrbitViewport)).call(this, {
	      id: id,
	      viewMatrix: (0, _multiply.default)(viewMatrix, viewMatrix, (0, _multiply.default)(rotationMatrix, rotationMatrix, translateMatrix)),
	      projectionMatrix: perspectiveMatrix,
	      width: width,
	      height: height
	    }));
	    _this.width = width;
	    _this.height = height;
	    _this.distance = distance;
	    _this.rotationX = rotationX;
	    _this.rotationOrbit = rotationOrbit;
	    _this.orbitAxis = orbitAxis;
	    _this.lookAt = lookAt;
	    _this.up = up;
	    _this.fov = fov;
	    _this.near = near;
	    _this.far = far;
	    _this.zoom = zoom;
	    return _this;
	  }

	  _createClass(OrbitViewport, [{
	    key: "project",
	    value: function project(xyz) {
	      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref2$topLeft = _ref2.topLeft,
	          topLeft = _ref2$topLeft === void 0 ? false : _ref2$topLeft;

	      var v = (0, _mathUtils.transformVector)(this.pixelProjectionMatrix, _toConsumableArray(xyz).concat([1]));

	      var _v = _slicedToArray(v, 3),
	          x = _v[0],
	          y = _v[1],
	          z = _v[2];

	      var y2 = topLeft ? this.height - y : y;
	      return [x, y2, z];
	    }
	  }, {
	    key: "unproject",
	    value: function unproject(xyz) {
	      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	          _ref3$topLeft = _ref3.topLeft,
	          topLeft = _ref3$topLeft === void 0 ? false : _ref3$topLeft;

	      var _xyz = _slicedToArray(xyz, 3),
	          x = _xyz[0],
	          y = _xyz[1],
	          z = _xyz[2];

	      var y2 = topLeft ? this.height - y : y;
	      return (0, _mathUtils.transformVector)(this.pixelUnprojectionMatrix, [x, y2, z, 1]);
	    }
	    /** Get camera `distance` to make view fit a box centered at lookat position in the viewport.
	     * @param {Array} sizes - [sizeX, sizeY, sizeZ]], define the dimensions of bounding box
	     * @returns {Nunber} the new distance parameter
	     */

	  }, {
	    key: "getDistance",
	    value: function getDistance(_ref4) {
	      var boundingBox = _ref4.boundingBox,
	          fov = _ref4.fov;
	      var halfMaxSide = Math.max(boundingBox[0], boundingBox[1], boundingBox[2]) / 2;
	      var distance = halfMaxSide / Math.tan(fov / 180 * Math.PI / 2);
	      return distance;
	    }
	    /** Move camera to make a model bounding box centered at lookat position fit in the viewport.
	     * @param {Array} boundingBox - [sizeX, sizeY, sizeZ]], define the dimensions of bounding box
	     * @returns a new OrbitViewport object
	     */

	  }, {
	    key: "fitBounds",
	    value: function fitBounds(boundingBox) {
	      var width = this.width,
	          height = this.height,
	          rotationX = this.rotationX,
	          rotationOrbit = this.rotationOrbit,
	          orbitAxis = this.orbitAxis,
	          lookAt = this.lookAt,
	          up = this.up,
	          fov = this.fov,
	          near = this.near,
	          far = this.far,
	          zoom = this.zoom;
	      return new OrbitViewport({
	        width: width,
	        height: height,
	        rotationX: rotationX,
	        rotationOrbit: rotationOrbit,
	        orbitAxis: orbitAxis,
	        up: up,
	        fov: fov,
	        near: near,
	        far: far,
	        zoom: zoom,
	        lookAt: lookAt,
	        distance: this.getDistance({
	          boundingBox: boundingBox,
	          fov: fov
	        })
	      });
	    }
	  }]);

	  return OrbitViewport;
	}(_viewport.default);

	exports.default = OrbitViewport;
	OrbitViewport.displayName = 'OrbitViewport';
	//# sourceMappingURL=orbit-viewport.js.map

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _transitionInterpolator = _interopRequireDefault(__webpack_require__(387));

	var _math = __webpack_require__(109);

	var _viewportMercatorProject = __webpack_require__(240);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var LINEARLY_INTERPOLATED_PROPS = ['bearing', 'pitch'];
	/**
	 * This class adapts mapbox-gl-js Map#flyTo animation so it can be used in
	 * react/redux architecture.
	 * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.
	 * It implements “Smooth and efficient zooming and panning.” algorithm by
	 * "Jarke J. van Wijk and Wim A.A. Nuij"
	 */

	var ViewportFlyToInterpolator =
	/*#__PURE__*/
	function (_TransitionInterpolat) {
	  _inherits(ViewportFlyToInterpolator, _TransitionInterpolat);

	  function ViewportFlyToInterpolator() {
	    _classCallCheck(this, ViewportFlyToInterpolator);

	    return _possibleConstructorReturn(this, (ViewportFlyToInterpolator.__proto__ || Object.getPrototypeOf(ViewportFlyToInterpolator)).call(this, {
	      compare: ['longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
	      extract: ['width', 'height', 'longitude', 'latitude', 'zoom', 'bearing', 'pitch'],
	      required: ['width', 'height', 'latitude', 'longitude', 'zoom']
	    }));
	  }

	  _createClass(ViewportFlyToInterpolator, [{
	    key: "interpolateProps",
	    value: function interpolateProps(startProps, endProps, t) {
	      var viewport = (0, _viewportMercatorProject.flyToViewport)(startProps, endProps, t); // Linearly interpolate 'bearing' and 'pitch'.
	      // If pitch/bearing are not supplied, they are interpreted as zeros in viewport calculation
	      // (fallback defined in WebMercatorViewport)
	      // Because there is no guarantee that the current controller's ViewState normalizes
	      // these props, safe guard is needed to avoid generating NaNs

	      for (var _i = 0; _i < LINEARLY_INTERPOLATED_PROPS.length; _i++) {
	        var key = LINEARLY_INTERPOLATED_PROPS[_i];
	        viewport[key] = (0, _math.lerp)(startProps[key] || 0, endProps[key] || 0, t);
	      }

	      return viewport;
	    }
	  }]);

	  return ViewportFlyToInterpolator;
	}(_transitionInterpolator.default);

	exports.default = ViewportFlyToInterpolator;
	//# sourceMappingURL=viewport-fly-to-interpolator.js.map

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _luma = __webpack_require__(46);

	var _effect = _interopRequireDefault(__webpack_require__(289));

	var _webMercatorViewport = _interopRequireDefault(__webpack_require__(287));

	var _reflectionEffectVertex = _interopRequireDefault(__webpack_require__(401));

	var _reflectionEffectFragment = _interopRequireDefault(__webpack_require__(402));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var ReflectionEffect =
	/*#__PURE__*/
	function (_Effect) {
	  _inherits(ReflectionEffect, _Effect);

	  /**
	   * @classdesc
	   * ReflectionEffect
	   *
	   * @class
	   * @param reflectivity How visible reflections should be over the map, between 0 and 1
	   * @param blur how blurry the reflection should be, between 0 and 1
	   */
	  function ReflectionEffect() {
	    var _this;

	    var reflectivity = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
	    var blur = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;

	    _classCallCheck(this, ReflectionEffect);

	    _this = _possibleConstructorReturn(this, (ReflectionEffect.__proto__ || Object.getPrototypeOf(ReflectionEffect)).call(this));
	    _this.reflectivity = reflectivity;
	    _this.blur = blur;
	    _this.framebuffer = null;

	    _this.setNeedsRedraw();

	    return _this;
	  }

	  _createClass(ReflectionEffect, [{
	    key: "getShaders",
	    value: function getShaders() {
	      return {
	        vs: _reflectionEffectVertex.default,
	        fs: _reflectionEffectFragment.default,
	        modules: [],
	        shaderCache: this.context.shaderCache
	      };
	    }
	  }, {
	    key: "initialize",
	    value: function initialize(_ref) {
	      var gl = _ref.gl,
	          layerManager = _ref.layerManager;
	      this.unitQuad = new _luma.Model(gl, Object.assign({}, this.getShaders(), {
	        id: 'reflection-effect',
	        geometry: new _luma.Geometry({
	          drawMode: _luma.GL.TRIANGLE_FAN,
	          vertices: new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0])
	        })
	      }));
	      this.framebuffer = new _luma.Framebuffer(gl, {
	        depth: true
	      });
	    }
	  }, {
	    key: "preDraw",
	    value: function preDraw(_ref2) {
	      var gl = _ref2.gl,
	          layerManager = _ref2.layerManager;
	      var viewport = layerManager.context.viewport;
	      /*
	       * the renderer already has a reference to this, but we don't have a reference to the renderer.
	       * when we refactor the camera code, we should make sure we get a reference to the renderer so
	       * that we can keep this in one place.
	       */

	      var dpi = typeof window !== 'undefined' && window.devicePixelRatio || 1;
	      this.framebuffer.resize({
	        width: dpi * viewport.width,
	        height: dpi * viewport.height
	      });
	      var pitch = viewport.pitch;
	      this.framebuffer.bind();
	      /* this is a huge hack around the existing viewport class.
	       * TODO in the future, once we implement bona-fide cameras, we really need to fix this.
	       */

	      layerManager.setViewport(new _webMercatorViewport.default(Object.assign({}, viewport, {
	        pitch: -180 - pitch
	      })));
	      gl.clear(_luma.GL.COLOR_BUFFER_BIT | _luma.GL.DEPTH_BUFFER_BIT);
	      layerManager.drawLayers({
	        pass: 'reflection'
	      });
	      layerManager.setViewport(viewport);
	      this.framebuffer.unbind();
	    }
	  }, {
	    key: "draw",
	    value: function draw(_ref3) {
	      var gl = _ref3.gl,
	          layerManager = _ref3.layerManager;

	      /*
	       * Render our unit quad.
	       * This will cover the entire screen, but will lie behind all other geometry.
	       * This quad will sample the previously generated reflection texture
	       * in order to create the reflection effect
	       */
	      this.unitQuad.render({
	        reflectionTexture: this.framebuffer.texture,
	        reflectionTextureWidth: this.framebuffer.width,
	        reflectionTextureHeight: this.framebuffer.height,
	        reflectivity: this.reflectivity,
	        blur: this.blur
	      });
	    }
	  }, {
	    key: "finalize",
	    value: function finalize(_ref4) {
	      /* TODO: Free resources? */

	      var gl = _ref4.gl,
	          layerManager = _ref4.layerManager;
	    }
	  }]);

	  return ReflectionEffect;
	}(_effect.default);

	exports.default = ReflectionEffect;
	//# sourceMappingURL=reflection-effect.js.map

/***/ }),
/* 401 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "#define SHADER_NAME reflection-effect-vs\n\nattribute vec3 vertices;\n\nvarying vec2 uv;\n\nvoid main(void) {\n  uv = vertices.xy;\n  gl_Position = vec4(2. * vertices.xy - vec2(1., 1.), 1., 1.);\n}\n";
	exports.default = _default;
	//# sourceMappingURL=reflection-effect-vertex.glsl.js.map

/***/ }),
/* 402 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var _default = "#define SHADER_NAME reflection-effect-fs\n\n#ifdef GL_ES\nprecision highp float;\n#endif\n\nuniform sampler2D reflectionTexture;\nuniform int reflectionTextureWidth;\nuniform int reflectionTextureHeight;\n\nuniform float reflectivity;\nuniform float blur;\n\n\nvarying vec2 uv;\n\n#define KERNEL_SIZE 7\n\n/*\n * Samples from tex with a gaussian-shaped patch, centered at uv and\n * with standard deviation sigma.  The size of the texture in\n * pixels must be specified by dim\n */\nvec4 sample_gaussian(sampler2D tex, vec2 dim, vec2 uv, float sigma) {\n  if (sigma == 0.0) {\n    return texture2D(tex, uv);\n  }\n\n  vec2 delta = 1.0 / dim;\n  vec2 top_left = uv - delta * float(KERNEL_SIZE+1) / 2.0;\n\n  vec4 color = vec4(0);\n  float sum = 0.0;\n  for (int i = 0; i <  KERNEL_SIZE; ++i) {\n    for (int j = 0; j < KERNEL_SIZE; ++j) {\n      vec2 uv2 = top_left + vec2(i, j) * delta;\n      float d = length((uv2 - uv) * dim);\n      float f = exp(-(d*d) / (2.0*sigma * sigma));\n      color += f * texture2D(tex, uv2);\n      sum += f;\n    }\n  }\n  return color / sum;\n}\n\nvoid main(void) {\n  //map blur in [0, 1] to sigma in [0, inf]\n  //alpha will determine the \"steepness\" of our curve.\n  //this was picked just to make the scale feel \"natural\"\n  //if our image is 1000 pixels wide, a blur of 0.5 should correspond\n  //to a sigma of 1 pixels\n  float alpha = 1000.0;\n  float sigma = blur / (alpha * (1.0 - blur));\n  //let this be our standard deviation in terms of screen-widths.\n  //rewrite this in terms of pixels.\n  sigma *= float(reflectionTextureWidth);\n\n\n  gl_FragColor = sample_gaussian(reflectionTexture, vec2(reflectionTextureWidth,\n    reflectionTextureHeight), vec2(uv.x, 1. - uv.y), sigma);\n  //because our canvas expects alphas to be pre-multiplied, we multiply by whole\n  //color vector by reflectivity, not just the alpha channel\n  gl_FragColor *= reflectivity;\n}\n";
	exports.default = _default;
	//# sourceMappingURL=reflection-effect-fragment.glsl.js.map

/***/ }),
/* 403 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

	function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

	function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

	function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

	function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// getValue takes an array of points returns a value to sort the bins on.
	// by default it returns the number of points
	// this is where to pass in a function to color the bins by
	// avg/mean/max of specific value of the point
	var defaultGetValue = function defaultGetValue(points) {
	  return points.length;
	};

	var BinSorter =
	/*#__PURE__*/
	function () {
	  function BinSorter() {
	    var bins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var getValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultGetValue;

	    _classCallCheck(this, BinSorter);

	    this.sortedBins = this.getSortedBins(bins, getValue);
	    this.maxCount = this.getMaxCount();
	    this.binMap = this.getBinMap();
	  }
	  /**
	   * Get an array of object with sorted values and index of bins
	   * @param {Array} bins
	   * @param {Function} getValue
	   * @return {Array} array of values and index lookup
	   */


	  _createClass(BinSorter, [{
	    key: "getSortedBins",
	    value: function getSortedBins(bins, getValue) {
	      return bins.reduce(function (accu, h, i) {
	        var value = getValue(h.points);

	        if (value !== null && value !== undefined) {
	          // filter bins if value is null or undefined
	          accu.push({
	            i: Number.isFinite(h.index) ? h.index : i,
	            value: value,
	            counts: h.points.length
	          });
	        }

	        return accu;
	      }, []).sort(function (a, b) {
	        return a.value - b.value;
	      });
	    }
	    /**
	     * Get range of values of all bins
	     * @param {Number[]} range
	     * @param {Number} range[0] - lower bound
	     * @param {Number} range[1] - upper bound
	     * @return {Array} array of new value range
	     */

	  }, {
	    key: "getValueRange",
	    value: function getValueRange(_ref) {
	      var _ref2 = _slicedToArray(_ref, 2),
	          lower = _ref2[0],
	          upper = _ref2[1];

	      var len = this.sortedBins.length;

	      if (!len) {
	        return [0, 0];
	      }

	      var lowerIdx = Math.ceil(lower / 100 * (len - 1));
	      var upperIdx = Math.floor(upper / 100 * (len - 1));
	      return [this.sortedBins[lowerIdx].value, this.sortedBins[upperIdx].value];
	    }
	    /**
	     * Get ths max count of all bins
	     * @return {Number | Boolean} max count
	     */

	  }, {
	    key: "getMaxCount",
	    value: function getMaxCount() {
	      var maxCount = 0;
	      this.sortedBins.forEach(function (x) {
	        return maxCount = maxCount > x.counts ? maxCount : x.counts;
	      });
	      return maxCount;
	    }
	    /**
	     * Get a mapping from cell/hexagon index to sorted bin
	     * This is used to retrieve bin value for color calculation
	     * @return {Object} bin index to sortedBins
	     */

	  }, {
	    key: "getBinMap",
	    value: function getBinMap() {
	      return this.sortedBins.reduce(function (mapper, curr) {
	        return Object.assign(mapper, _defineProperty({}, curr.i, curr));
	      }, {});
	    }
	  }]);

	  return BinSorter;
	}();

	exports.default = BinSorter;
	//# sourceMappingURL=bin-sorter.js.map

/***/ }),
/* 404 */
/***/ (function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.defaultColorRange = void 0;
	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	var defaultColorRange = [[255, 255, 178], [254, 217, 118], [254, 178, 76], [253, 141, 60], [240, 59, 32], [189, 0, 38]];
	exports.defaultColorRange = defaultColorRange;
	//# sourceMappingURL=color-utils.js.map

/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.linearScale = linearScale;
	exports.quantizeScale = quantizeScale;
	exports.getQuantizeScale = getQuantizeScale;
	exports.getLinearScale = getLinearScale;

	var _log = _interopRequireDefault(__webpack_require__(31));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the "Software"), to deal
	// in the Software without restriction, including without limitation the rights
	// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	// copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	// THE SOFTWARE.
	// Linear scale maps continuous domain to continuous range
	function linearScale(domain, range, value) {
	  return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];
	} // Quantize scale is similar to linear scales,
	// except it uses a discrete rather than continuous range


	function quantizeScale(domain, range, value) {
	  var domainRange = domain[1] - domain[0];

	  if (domainRange <= 0) {
	    _log.default.warn('quantizeScale: invalid domain, returning range[0]');

	    return range[0];
	  }

	  var step = domainRange / range.length;
	  var idx = Math.floor((value - domain[0]) / step);
	  var clampIdx = Math.max(Math.min(idx, range.length - 1), 0);
	  return range[clampIdx];
	} // return a quantize scale function


	function getQuantizeScale(domain, range) {
	  return function (value) {
	    return quantizeScale(domain, range, value);
	  };
	} // return a linear scale funciton


	function getLinearScale(domain, range) {
	  return function (value) {
	    return (value - domain[0]) / (domain[1] - domain[0]) * (range[1] - range[0]) + range[0];
	  };
	}
	//# sourceMappingURL=scale-utils.js.map

/***/ }),
/* 406 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _lookAt = _interopRequireDefault(__webpack_require__(129));

	var _perspective = _interopRequireDefault(__webpack_require__(132));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var DEGREES_TO_RADIANS = Math.PI / 180;

	var PerspectiveViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(PerspectiveViewport, _Viewport);

	  function PerspectiveViewport(_ref) {
	    var width = _ref.width,
	        height = _ref.height,
	        eye = _ref.eye,
	        _ref$lookAt = _ref.lookAt,
	        lookAt = _ref$lookAt === void 0 ? [0, 0, 0] : _ref$lookAt,
	        _ref$up = _ref.up,
	        up = _ref$up === void 0 ? [0, 1, 0] : _ref$up,
	        _ref$fovy = _ref.fovy,
	        fovy = _ref$fovy === void 0 ? 75 : _ref$fovy,
	        _ref$near = _ref.near,
	        near = _ref$near === void 0 ? 1 : _ref$near,
	        _ref$far = _ref.far,
	        far = _ref$far === void 0 ? 100 : _ref$far,
	        _ref$aspect = _ref.aspect,
	        aspect = _ref$aspect === void 0 ? null : _ref$aspect;

	    _classCallCheck(this, PerspectiveViewport);

	    _log.default.deprecated('PerspectiveViewport', 'PerspectiveView')();

	    var fovyRadians = fovy * DEGREES_TO_RADIANS;
	    aspect = Number.isFinite(aspect) ? aspect : width / height;
	    return _possibleConstructorReturn(this, (PerspectiveViewport.__proto__ || Object.getPrototypeOf(PerspectiveViewport)).call(this, {
	      viewMatrix: (0, _lookAt.default)([], eye, lookAt, up),
	      projectionMatrix: (0, _perspective.default)([], fovyRadians, aspect, near, far),
	      width: width,
	      height: height
	    }));
	  }

	  return PerspectiveViewport;
	}(_viewport.default);

	exports.default = PerspectiveViewport;
	//# sourceMappingURL=perspective-viewport.js.map

/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _lookAt = _interopRequireDefault(__webpack_require__(129));

	var _ortho = _interopRequireDefault(__webpack_require__(131));

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var OrthographicViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(OrthographicViewport, _Viewport);

	  function OrthographicViewport(_ref) {
	    var width = _ref.width,
	        height = _ref.height,
	        _ref$eye = _ref.eye,
	        eye = _ref$eye === void 0 ? [0, 0, 1] : _ref$eye,
	        _ref$lookAt = _ref.lookAt,
	        lookAt = _ref$lookAt === void 0 ? [0, 0, 0] : _ref$lookAt,
	        _ref$up = _ref.up,
	        up = _ref$up === void 0 ? [0, 1, 0] : _ref$up,
	        _ref$near = _ref.near,
	        near = _ref$near === void 0 ? 1 : _ref$near,
	        _ref$far = _ref.far,
	        far = _ref$far === void 0 ? 100 : _ref$far,
	        left = _ref.left,
	        top = _ref.top,
	        _ref$right = _ref.right,
	        right = _ref$right === void 0 ? null : _ref$right,
	        _ref$bottom = _ref.bottom,
	        bottom = _ref$bottom === void 0 ? null : _ref$bottom;

	    _classCallCheck(this, OrthographicViewport);

	    _log.default.deprecated('OrthographicViewport', 'OrthographicView')();

	    right = Number.isFinite(right) ? right : left + width;
	    bottom = Number.isFinite(bottom) ? bottom : top + height;
	    return _possibleConstructorReturn(this, (OrthographicViewport.__proto__ || Object.getPrototypeOf(OrthographicViewport)).call(this, {
	      viewMatrix: (0, _lookAt.default)([], eye, lookAt, up),
	      projectionMatrix: (0, _ortho.default)([], left, right, bottom, top, near, far),
	      width: width,
	      height: height
	    }));
	  }

	  return OrthographicViewport;
	}(_viewport.default);

	exports.default = OrthographicViewport;
	//# sourceMappingURL=orthographic-viewport.js.map

/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var SphericalCoordinates = _math.experimental.SphericalCoordinates;

	function getDirectionFromBearingAndPitch(_ref) {
	  var bearing = _ref.bearing,
	      pitch = _ref.pitch;
	  var spherical = new SphericalCoordinates({
	    bearing: bearing,
	    pitch: pitch
	  });
	  var direction = spherical.toVector3().normalize();
	  return direction;
	}

	var FirstPersonViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(FirstPersonViewport, _Viewport);

	  function FirstPersonViewport() {
	    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

	    _classCallCheck(this, FirstPersonViewport);

	    _log.default.deprecated('FirstPersonViewport', 'FirstPersonView')(); // TODO - push direction handling into Matrix4.lookAt


	    var _opts$modelMatrix = opts.modelMatrix,
	        modelMatrix = _opts$modelMatrix === void 0 ? null : _opts$modelMatrix,
	        bearing = opts.bearing,
	        _opts$up = opts.up,
	        up = _opts$up === void 0 ? [0, 0, 1] : _opts$up; // Always calculate direction from bearing and pitch

	    var dir = getDirectionFromBearingAndPitch({
	      bearing: bearing,
	      pitch: 89
	    }); // Direction is relative to model coordinates, of course

	    var center = modelMatrix ? modelMatrix.transformDirection(dir) : dir; // Just the direction. All the positioning is done in viewport.js

	    var viewMatrix = new _math.Matrix4().lookAt({
	      eye: [0, 0, 0],
	      center: center,
	      up: up
	    });
	    return _possibleConstructorReturn(this, (FirstPersonViewport.__proto__ || Object.getPrototypeOf(FirstPersonViewport)).call(this, Object.assign({}, opts, {
	      zoom: null,
	      // triggers meter level zoom
	      viewMatrix: viewMatrix
	    })));
	  }

	  return FirstPersonViewport;
	}(_viewport.default);

	exports.default = FirstPersonViewport;
	//# sourceMappingURL=first-person-viewport.js.map

/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = void 0;

	var _viewport = _interopRequireDefault(__webpack_require__(282));

	var _log = _interopRequireDefault(__webpack_require__(31));

	var _math = __webpack_require__(109);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _instanceof(left, right) { if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) { return right[Symbol.hasInstance](left); } else { return left instanceof right; } }

	function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

	function _classCallCheck(instance, Constructor) { if (!_instanceof(instance, Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

	function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } _setPrototypeOf(subClass.prototype, superClass && superClass.prototype); if (superClass) _setPrototypeOf(subClass, superClass); }

	function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

	var SphericalCoordinates = _math.experimental.SphericalCoordinates;

	function getDirectionFromBearingAndPitch(_ref) {
	  var bearing = _ref.bearing,
	      pitch = _ref.pitch;
	  var spherical = new SphericalCoordinates({
	    bearing: bearing,
	    pitch: pitch
	  });
	  return spherical.toVector3().normalize();
	}

	var ThirdPersonViewport =
	/*#__PURE__*/
	function (_Viewport) {
	  _inherits(ThirdPersonViewport, _Viewport);

	  function ThirdPersonViewport(opts) {
	    _classCallCheck(this, ThirdPersonViewport);

	    _log.default.deprecated('ThirdPersonViewport', 'ThirdPersonView')();

	    var bearing = opts.bearing,
	        pitch = opts.pitch,
	        position = opts.position,
	        up = opts.up,
	        zoom = opts.zoom;
	    var direction = getDirectionFromBearingAndPitch({
	      bearing: bearing,
	      pitch: pitch
	    });
	    var distance = zoom * 50; // TODO somehow need to flip z to make it work
	    // check if the position offset is done in the base viewport

	    var eye = direction.scale(-distance).multiply(new _math.Vector3(1, 1, -1));
	    var viewMatrix = new _math.Matrix4().multiplyRight(new _math.Matrix4().lookAt({
	      eye: eye,
	      center: position,
	      up: up
	    }));
	    return _possibleConstructorReturn(this, (ThirdPersonViewport.__proto__ || Object.getPrototypeOf(ThirdPersonViewport)).call(this, Object.assign({}, opts, {
	      // use meter level
	      zoom: null,
	      viewMatrix: viewMatrix
	    })));
	  }

	  return ThirdPersonViewport;
	}(_viewport.default);

	exports.default = ThirdPersonViewport;
	//# sourceMappingURL=third-person-viewport.js.map

/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(L) {/*! @asymmetrik/leaflet-d3 - 3.1.1 - Copyright (c) 2007-2017 Asymmetrik Ltd, a Maryland Corporation */
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(411), __webpack_require__(443), __webpack_require__(1)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3', 'd3-hexbin', 'leaflet'], factory) :
		(factory((global.leafletD3 = {}),global.d3,global.d3.hexbin));
	}(this, (function (exports,d3,d3Hexbin) { 'use strict';

	/**
	 * This is a convoluted way of getting ahold of the hexbin function.
	 * - When imported globally, d3 is exposed in the global namespace as 'd3'
	 * - When imported using a module system, it's a named import (and can't collide with d3)
	 * - When someone isn't importing d3-hexbin, the named import will be undefined
	 *
	 * As a result, we have to figure out how it's being imported and get the function reference
	 * (which is why we have this convoluted nested ternary statement
	 */
	var d3_hexbin = (null != d3.hexbin)? d3.hexbin : (null != d3Hexbin)? d3Hexbin.hexbin : null;

	/**
	 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
	 * We extend L.SVG to take advantage of built-in zoom animations.
	 */
	L.HexbinLayer = L.SVG.extend({
		includes: [ L.Mixin.Events ],

		/**
		 * Default options
		 */
		options : {
			radius : 12,
			opacity: 0.6,
			duration: 200,

			colorScaleExtent: [ 1, undefined ],
			radiusScaleExtent: [ 1, undefined ],
			colorRange: [ '#f7fbff', '#08306b' ],
			radiusRange: [ 4, 12 ],

			pointerEvents: 'all'
		},


		/**
		 * Standard Leaflet initialize function, accepting an options argument provided by the
		 * user when they create the layer
		 * @param options Options object where the options override the defaults
		 */
		initialize : function(options) {
			L.setOptions(this, options);

			// Set up the various overrideable functions
			this._fn = {
				lng: function(d) { return d[0]; },
				lat: function(d) { return d[1]; },
				colorValue: function(d) { return d.length; },
				radiusValue: function(d) { return Number.MAX_VALUE; },

				fill: function(d) {
					var val = this._fn.colorValue(d);
					return (null != val) ? this._scale.color(val) : 'none';
				}
			};

			// Set up the customizable scale
			this._scale = {
				color: d3.scaleLinear(),
				radius: d3.scaleLinear()
			};

			// Set up the Dispatcher for managing events and callbacks
			this._dispatch = d3.dispatch('mouseover', 'mouseout', 'click');

			// Set up the default hover handler
			this._hoverHandler = L.HexbinHoverHandler.none();

			// Create the hex layout
			this._hexLayout = d3_hexbin()
				.radius(this.options.radius)
				.x(function(d) { return d.point[0]; })
				.y(function(d) { return d.point[1]; });

			// Initialize the data array to be empty
			this._data = [];

			this._scale.color
				.range(this.options.colorRange)
				.clamp(true);

			this._scale.radius
				.range(this.options.radiusRange)
				.clamp(true);

		},

		/**
		 * Callback made by Leaflet when the layer is added to the map
		 * @param map Reference to the map to which this layer has been added
		 */
		onAdd : function(map) {

			L.SVG.prototype.onAdd.call(this);

			// Store a reference to the map for later use
			this._map = map;

			// Redraw on moveend
			map.on({ 'moveend': this.redraw }, this);

			// Initial draw
			this.redraw();

		},

		/**
		 * Callback made by Leaflet when the layer is removed from the map
		 * @param map Reference to the map from which this layer is being removed
		 */
		onRemove : function(map) {

			L.SVG.prototype.onRemove.call(this);

			// Destroy the svg container
			this._destroyContainer();

			// Remove events
			map.off({ 'moveend': this.redraw }, this);

			this._map = null;

			// Explicitly will leave the data array alone in case the layer will be shown again
			//this._data = [];

		},

		/**
		 * Create the SVG container for the hexbins
		 * @private
		 */
		_initContainer : function() {

			L.SVG.prototype._initContainer.call(this);
			this._d3Container = d3.select(this._container).select('g');
		},

		/**
		 * Clean up the svg container
		 * @private
		 */
		_destroyContainer: function() {

			// Don't do anything

		},

		/**
		 * (Re)draws the hexbins data on the container
		 * @private
		 */
		redraw : function() {
			var that = this;

			if (!that._map) {
				return;
			}

			// Generate the mapped version of the data
			var data = that._data.map(function(d) {
				var lng = that._fn.lng(d);
				var lat = that._fn.lat(d);

				var point = that._project([ lng, lat ]);
				return { o: d, point: point };
			});

			// Select the hex group for the current zoom level. This has
			// the effect of recreating the group if the zoom level has changed
			var join = this._d3Container.selectAll('g.hexbin')
				.data([ this._map.getZoom() ], function(d) { return d; });

			// enter
			var enter = join.enter().append('g')
				.attr('class', function(d) { return 'hexbin zoom-' + d; });

			// enter + update
			var enterUpdate = enter.merge(join);

			// exit
			join.exit().remove();

			// add the hexagons to the select
			this._createHexagons(enterUpdate, data);

		},

		_createHexagons : function(g, data) {
			var that = this;

			// Create the bins using the hexbin layout
			var bounds = that._map.getBounds();

			var bins = that._hexLayout(data);

			// Derive the extents of the data values for each dimension
			var colorExtent = that._getExtent(bins, that._fn.colorValue, that.options.colorScaleExtent);
			var radiusExtent = that._getExtent(bins, that._fn.radiusValue, that.options.radiusScaleExtent);

			// Match the domain cardinality to that of the color range, to allow for a polylinear scale
			var colorDomain = that._linearlySpace(colorExtent[0], colorExtent[1], that._scale.color.range().length);

			// Set the scale domains
			that._scale.color.domain(colorDomain);
			that._scale.radius.domain(radiusExtent);


			/*
			 * Join
			 *    Join the Hexagons to the data
			 *    Use a deterministic id for tracking bins based on position
			 */
			bins = bins.filter(function(d) {
				return bounds.contains(that._map.layerPointToLatLng(L.point(d.x, d.y)));
			});
			var join = g.selectAll('g.hexbin-container')
				.data(bins, function(d) {
					return d.x + ':' + d.y;
				});


			/*
			 * Update
			 *    Set the fill and opacity on a transition
			 *    opacity is re-applied in case the enter transition was cancelled
			 *    the path is applied as well to resize the bins
			 */
			join.select('path.hexbin-hexagon').transition().duration(that.options.duration)
				.attr('fill', that._fn.fill.bind(that))
				.attr('fill-opacity', that.options.opacity)
				.attr('stroke-opacity', that.options.opacity)
				.attr('d', function(d) {
					return that._hexLayout.hexagon(that._scale.radius(that._fn.radiusValue.call(that, d)));
				});


			/*
			 * Enter
			 *    Establish the path, size, fill, and the initial opacity
			 *    Transition to the final opacity and size
			 */
			var enter = join.enter().append('g').attr('class', 'hexbin-container');

			enter.append('path').attr('class', 'hexbin-hexagon')
				.attr('transform', function(d) {
					return 'translate(' + d.x + ',' + d.y + ')';
				})
				.attr('d', function(d) {
					return that._hexLayout.hexagon(that._scale.radius.range()[0]);
				})
				.attr('fill', that._fn.fill.bind(that))
				.attr('fill-opacity', 0.01)
				.attr('stroke-opacity', 0.01)
				.transition().duration(that.options.duration)
					.attr('fill-opacity', that.options.opacity)
					.attr('stroke-opacity', that.options.opacity)
					.attr('d', function(d) {
						return that._hexLayout.hexagon(that._scale.radius(that._fn.radiusValue.call(that, d)));
					});

			// Grid
			enter.append('path').attr('class', 'hexbin-grid')
				.attr('transform', function(d) {
					return 'translate(' + d.x + ',' + d.y + ')';
				})
				.attr('d', function(d) {
					return that._hexLayout.hexagon(that.options.radius);
				})
				.attr('fill', 'none')
				.attr('stroke', 'none')
				.style('pointer-events', that.options.pointerEvents)
				.on('mouseover', function(d, i) {
					that._hoverHandler.mouseover.call(this, that, d, i);
					that._dispatch.call('mouseover', this, d, i);
				})
				.on('mouseout', function(d, i) {
					that._dispatch.call('mouseout', this, d, i);
					that._hoverHandler.mouseout.call(this, that, d, i);
				})
				.on('click', function(d, i) {
					that._dispatch.call('click', this, d, i);
				});


			// Exit
			var exit = join.exit();

			exit.select('path.hexbin-hexagon')
				.transition().duration(that.options.duration)
				.attr('fill-opacity', 0)
				.attr('stroke-opacity', 0)
				.attr('d', function(d) {
					return that._hexLayout.hexagon(0);
				});

			exit.transition().duration(that.options.duration)
				.remove();

		},

		_getExtent: function(bins, valueFn, scaleExtent) {

			// Determine the extent of the values
			var extent$$1 = d3.extent(bins, valueFn.bind(this));

			// If either's null, initialize them to 0
			if (null == extent$$1[0]) extent$$1[0] = 0;
			if (null == extent$$1[1]) extent$$1[1] = 0;

			// Now apply the optional clipping of the extent
			if (null != scaleExtent[0]) extent$$1[0] = scaleExtent[0];
			if (null != scaleExtent[1]) extent$$1[1] = scaleExtent[1];

			return extent$$1;

		},

		_project : function(coord) {
			var point = this._map.latLngToLayerPoint([ coord[1], coord[0] ]);
			return [ point.x, point.y ];
		},

		_getBounds: function(data) {
			if(null == data || data.length < 1) {
				return { min: [ 0, 0 ], max: [ 0, 0 ]};
			}

			// bounds is [[min long, min lat], [max long, max lat]]
			var bounds = [ [ 999, 999 ], [ -999, -999 ] ];

			data.forEach(function(element) {
				var x = element.point[0];
				var y = element.point[1];

				bounds[0][0] = Math.min(bounds[0][0], x);
				bounds[0][1] = Math.min(bounds[0][1], y);
				bounds[1][0] = Math.max(bounds[1][0], x);
				bounds[1][1] = Math.max(bounds[1][1], y);
			});

			return { min: bounds[0], max: bounds[1] };
		},

		_linearlySpace: function(from, to, length) {
			var arr = new Array(length);
			var step = (to - from) / Math.max(length - 1, 1);

			for (var i = 0; i < length; ++i) {
				arr[i] = from + (i * step);
			}

			return arr;
		},


		// ------------------------------------
		// Public API
		// ------------------------------------

		radius: function(v) {
			if (!arguments.length) { return this.options.radius; }

			this.options.radius = v;
			this._hexLayout.radius(v);

			return this;
		},

		opacity: function(v) {
			if (!arguments.length) { return this.options.opacity; }
			this.options.opacity = v;

			return this;
		},

		duration: function(v) {
			if (!arguments.length) { return this.options.duration; }
			this.options.duration = v;

			return this;
		},

		colorScaleExtent: function(v) {
			if (!arguments.length) { return this.options.colorScaleExtent; }
			this.options.colorScaleExtent = v;

			return this;
		},

		radiusScaleExtent: function(v) {
			if (!arguments.length) { return this.options.radiusScaleExtent; }
			this.options.radiusScaleExtent = v;

			return this;
		},

		colorRange: function(v) {
			if (!arguments.length) { return this.options.colorRange; }
			this.options.colorRange = v;
			this._scale.color.range(v);

			return this;
		},

		radiusRange: function(v) {
			if (!arguments.length) { return this.options.radiusRange; }
			this.options.radiusRange = v;
			this._scale.radius.range(v);

			return this;
		},

		colorScale: function(v) {
			if (!arguments.length) { return this._scale.color; }
			this._scale.color = v;

			return this;
		},

		radiusScale: function(v) {
			if (!arguments.length) { return this._scale.radius; }
			this._scale.radius = v;

			return this;
		},

		lng: function(v) {
			if (!arguments.length) { return this._fn.lng; }
			this._fn.lng = v;

			return this;
		},

		lat: function(v) {
			if (!arguments.length) { return this._fn.lat; }
			this._fn.lat = v;

			return this;
		},

		colorValue: function(v) {
			if (!arguments.length) { return this._fn.colorValue; }
			this._fn.colorValue = v;

			return this;
		},

		radiusValue: function(v) {
			if (!arguments.length) { return this._fn.radiusValue; }
			this._fn.radiusValue = v;

			return this;
		},

		fill: function(v) {
			if (!arguments.length) { return this._fn.fill; }
			this._fn.fill = v;

			return this;
		},

		data: function(v) {
			if (!arguments.length) { return this._data; }
			this._data = (null != v) ? v : [];

			this.redraw();

			return this;
		},

		/*
		 * Getter for the event dispatcher
		 */
		dispatch: function() {
			return this._dispatch;
		},

		hoverHandler: function(v) {
			if (!arguments.length) { return this._hoverHandler; }
			this._hoverHandler = (null != v) ? v : L.HexbinHoverHandler.none();

			this.redraw();

			return this;
		},

		/*
		 * Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
		 */
		getLatLngs: function () {
			var that = this;

			// Map the data into an array of latLngs using the configured lat/lng accessors
			return this._data.map(function(d) {
				return L.latLng(that.options.lat(d), that.options.lng(d));
			});
		},

		/*
		 * Get path geometry as GeoJSON
		 */
		toGeoJSON: function () {
			return L.GeoJSON.getFeature(this, {
				type: 'LineString',
				coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs(), 0)
			});
		}

	});

	// Hover Handlers modify the hexagon and can be combined
	L.HexbinHoverHandler = {

		tooltip: function(options) {

			// merge options with defaults
			options = options || {};
			if (null == options.tooltipContent) { options.tooltipContent = function(d) { return 'Count: ' + d.length; }; }

			// Generate the tooltip
			var tooltip = d3.select('body').append('div')
				.attr('class', 'hexbin-tooltip')
				.style('z-index', 9999)
				.style('pointer-events', 'none')
				.style('visibility', 'hidden')
				.style('position', 'absolute');

			tooltip.append('div').attr('class', 'tooltip-content');

			// return the handler instance
			return {
				mouseover: function (hexLayer, data) {
					var event$$1 = d3.event;
					var gCoords = d3.mouse(this);

					tooltip
						.style('visibility', 'visible')
						.html(options.tooltipContent(data, hexLayer));

					var div = null;
					if (null != tooltip._groups && tooltip._groups.length > 0 && tooltip._groups[0].length > 0) {
						div = tooltip._groups[0][0];
					}
					var h = div.clientHeight, w = div.clientWidth;

					tooltip
						.style('top', '' + event$$1.clientY - gCoords[1] - h - 16 + 'px')
						.style('left', '' + event$$1.clientX - gCoords[0] - w/2 + 'px');

				},
				mouseout: function (hexLayer, data) {
					tooltip
						.style('visibility', 'hidden')
						.html();
				}
			};

		},

		resizeFill: function() {

			// return the handler instance
			return {
				mouseover: function (hexLayer, data) {
					var o = d3.select(this.parentNode);
					o.select('path.hexbin-hexagon')
						.attr('d', function (d) {
							return hexLayer._hexLayout.hexagon(hexLayer.options.radius);
						});
				},
				mouseout: function (hexLayer, data) {
					var o = d3.select(this.parentNode);
					o.select('path.hexbin-hexagon')
						.attr('d', function (d) {
							return hexLayer._hexLayout.hexagon(hexLayer._scale.radius(hexLayer._fn.radiusValue.call(hexLayer, d)));
						});
				}
			};

		},

		resizeScale: function(options) {

			// merge options with defaults
			options = options || {};
			if (null == options.radiusScale) options.radiusScale = 0.5;

			// return the handler instance
			return {
				mouseover: function (hexLayer, data) {
					var o = d3.select(this.parentNode);
					o.select('path.hexbin-hexagon')
						.attr('d', function (d) {
							return hexLayer._hexLayout.hexagon(hexLayer._scale.radius.range()[1] * (1 + options.radiusScale));
						});
				},
				mouseout: function (hexLayer, data) {
					var o = d3.select(this.parentNode);
					o.select('path.hexbin-hexagon')
						.attr('d', function (d) {
							return hexLayer._hexLayout.hexagon(hexLayer._scale.radius(hexLayer._fn.radiusValue.call(hexLayer, d)));
						});
				}
			};

		},

		compound: function(options) {

			options = options || {};
			if (null == options.handlers) options.handlers = [ L.HexbinHoverHandler.none() ];

			return {
				mouseover: function (hexLayer, data) {
					var that = this;
					options.handlers.forEach(function(h) { h.mouseover.call(that, hexLayer, data); });
				},
				mouseout: function (hexLayer, data) {
					var that = this;
					options.handlers.forEach(function(h) { h.mouseout.call(that, hexLayer, data); });
				}
			};

		},

		none: function() {
			return {
				mouseover: function () {},
				mouseout: function () {}
			};
		}
	};

	L.hexbinLayer = function(options) {
		return new L.HexbinLayer(options);
	};

	/**
	 * L is defined by the Leaflet library, see git://github.com/Leaflet/Leaflet.git for documentation
	 * We extend L.SVG to take advantage of built-in zoom animations.
	 */
	L.PingLayer = L.SVG.extend({
		includes: [ L.Mixin.Events ],

		/*
		 * Default options
		 */
		options : {
			duration: 800,
			fps: 32,
			opacityRange: [ 1, 0 ],
			radiusRange: [ 3, 15 ]
		},


		// Initialization of the plugin
		initialize : function(options) {
			L.setOptions(this, options);

			this._fn = {
				lng: function(d) { return d[0]; },
				lat: function(d) { return d[1]; },
				radiusScaleFactor: function(d) { return 1; }
			};

			this._scale = {
				radius: d3.scalePow().exponent(0.35),
				opacity: d3.scaleLinear()
			};

			this._lastUpdate = Date.now();
			this._fps = 0;

			this._scale.radius
				.domain([ 0, this.options.duration ])
				.range(this.options.radiusRange)
				.clamp(true);
			this._scale.opacity
				.domain([ 0, this.options.duration ])
				.range(this.options.opacityRange)
				.clamp(true);
		},

		// Called when the plugin layer is added to the map
		onAdd : function(map) {

			L.SVG.prototype.onAdd.call(this);

			// Store a reference to the map for later use
			this._map = map;

			// Init the state of the simulation
			this._running = false;

			// Set up events
			map.on({'move': this._updateContainer}, this);

		},

		// Called when the plugin layer is removed from the map
		onRemove : function(map) {

			L.SVG.prototype.onRemove.call(this);

			// Destroy the svg container
			this._destroyContainer();

			// Remove events
			map.off({'move': this._updateContainer}, this);

			this._map = null;
			this._data = null;

		},


		/*
		 * Private Methods
		 */

		// Initialize the Container - creates the svg pane
		_initContainer : function() {

			L.SVG.prototype._initContainer.call(this);
			this._d3Container = d3.select(this._container).select('g');

		},

		// Update the container - Updates the dimensions of the svg pane
		_updateContainer : function() {

			this._updatePings(true);

		},

		// Cleanup the svg pane
		_destroyContainer: function() {

			// Don't do anything

		},


		// Calculate the circle coordinates for the provided data
		_getCircleCoords: function(geo) {
			var point = this._map.latLngToLayerPoint(geo);
			return { x: point.x, y: point.y };
		},


		// Add a ping to the map
		_addPing : function(data, cssClass) {
			// Lazy init the data array
			if (null == this._data) this._data = [];

			// Derive the spatial data
			var geo = [ this._fn.lat(data), this._fn.lng(data) ];
			var coords = this._getCircleCoords(geo);

			// Add the data to the list of pings
			var circle = {
				data: data,
				geo: geo,
				ts: Date.now(),
				nts: 0
			};
			circle.c = this._d3Container.append('circle')
				.attr('class', (null != cssClass)? 'ping ' + cssClass : 'ping')
				.attr('cx', coords.x)
				.attr('cy', coords.y)
				.attr('r', this._fn.radiusScaleFactor.call(this, data) * this._scale.radius.range()[0]);

			// Push new circles
			this._data.push(circle);
		},

		// Main update loop
		_updatePings : function(immediate) {
			var nowTs = Date.now();
			if (null == this._data) this._data = [];

			var maxIndex = -1;

			// Update everything
			for (var i=0; i < this._data.length; i++) {

				var d = this._data[i];
				var age = nowTs - d.ts;

				if (this.options.duration < age) {

					// If the blip is beyond it's life, remove it from the dom and track the lowest index to remove
					d.c.remove();
					maxIndex = i;

				}
				else {

					// If the blip is still alive, process it
					if (immediate || d.nts < nowTs) {

						var coords = this._getCircleCoords(d.geo);

						d.c.attr('cx', coords.x)
						   .attr('cy', coords.y)
						   .attr('r', this._fn.radiusScaleFactor.call(this, d.data) * this._scale.radius(age))
						   .attr('fill-opacity', this._scale.opacity(age))
						   .attr('stroke-opacity', this._scale.opacity(age));
						d.nts = Math.round(nowTs + 1000/this.options.fps);

					}
				}
			}

			// Delete all the aged off data at once
			if (maxIndex > -1) {
				this._data.splice(0, maxIndex + 1);
			}

			// The return function dictates whether the timer loop will continue
			this._running = (this._data.length > 0);

			if (this._running) {
				this._fps = 1000/(nowTs - this._lastUpdate);
				this._lastUpdate = nowTs;
			}

			return !this._running;
		},

		// Expire old pings
		_expirePings : function() {
			var maxIndex = -1;
			var nowTs = Date.now();

			// Search from the front of the array
			for (var i=0; i < this._data.length; i++) {
				var d = this._data[i];
				var age = nowTs - d.ts;

				if(this.options.duration < age) {
					// If the blip is beyond it's life, remove it from the dom and track the lowest index to remove
					d.c.remove();
					maxIndex = i;
				}
				else {
					break;
				}
			}

			// Delete all the aged off data at once
			if (maxIndex > -1) {
				this._data.splice(0, maxIndex + 1);
			}
		},

		/*
		 * Public Methods
		 */

		duration: function(v) {
			if (!arguments.length) { return this.options.duration; }
			this.options.duration = v;

			return this;
		},

		fps: function(v) {
			if (!arguments.length) { return this.options.fps; }
			this.options.fps = v;

			return this;
		},

		lng: function(v) {
			if (!arguments.length) { return this._fn.lng; }
			this._fn.lng = v;

			return this;
		},

		lat: function(v) {
			if (!arguments.length) { return this._fn.lat; }
			this._fn.lat = v;

			return this;
		},

		radiusRange: function(v) {
			if (!arguments.length) { return this.options.radiusRange; }
			this.options.radiusRange = v;
			this._scale.radius().range(v);

			return this;
		},

		opacityRange: function(v) {
			if (!arguments.length) { return this.options.opacityRange; }
			this.options.opacityRange = v;
			this._scale.opacity().range(v);

			return this;
		},

		radiusScale: function(v) {
			if (!arguments.length) { return this._scale.radius; }
			this._scale.radius = v;

			return this;
		},

		opacityScale: function(v) {
			if (!arguments.length) { return this._scale.opacity; }
			this._scale.opacity = v;

			return this;
		},

		radiusScaleFactor: function(v) {
			if (!arguments.length) { return this._fn.radiusScaleFactor; }
			this._fn.radiusScaleFactor = v;

			return this;
		},

		/*
		 * Method by which to "add" pings
		 */
		ping : function(data, cssClass) {
			this._addPing(data, cssClass);
			this._expirePings();

			// Start timer if not active
			if (!this._running && this._data.length > 0) {
				this._running = true;
				this._lastUpdate = Date.now();

				var that = this;
				d3.timer(function() { that._updatePings.call(that, false); });
			}

			return this;
		},

		getActualFps : function() {
			return this._fps;
		},

		data : function() {
			return this._data;
		},

	});

	L.pingLayer = function(options) {
		return new L.PingLayer(options);
	};

	Object.defineProperty(exports, '__esModule', { value: true });

	})));
	//# sourceMappingURL=leaflet-d3.js.map

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, '__esModule', { value: true });

	var d3Array = __webpack_require__(412);
	var d3Axis = __webpack_require__(413);
	var d3Brush = __webpack_require__(414);
	var d3Chord = __webpack_require__(423);
	var d3Collection = __webpack_require__(425);
	var d3Color = __webpack_require__(419);
	var d3Contour = __webpack_require__(426);
	var d3Dispatch = __webpack_require__(415);
	var d3Drag = __webpack_require__(416);
	var d3Dsv = __webpack_require__(427);
	var d3Ease = __webpack_require__(422);
	var d3Fetch = __webpack_require__(428);
	var d3Force = __webpack_require__(429);
	var d3Format = __webpack_require__(431);
	var d3Geo = __webpack_require__(432);
	var d3Hierarchy = __webpack_require__(433);
	var d3Interpolate = __webpack_require__(418);
	var d3Path = __webpack_require__(424);
	var d3Polygon = __webpack_require__(434);
	var d3Quadtree = __webpack_require__(430);
	var d3Random = __webpack_require__(435);
	var d3Scale = __webpack_require__(436);
	var d3ScaleChromatic = __webpack_require__(439);
	var d3Selection = __webpack_require__(417);
	var d3Shape = __webpack_require__(440);
	var d3Time = __webpack_require__(437);
	var d3TimeFormat = __webpack_require__(438);
	var d3Timer = __webpack_require__(421);
	var d3Transition = __webpack_require__(420);
	var d3Voronoi = __webpack_require__(441);
	var d3Zoom = __webpack_require__(442);

	var version = "5.4.0";

	Object.keys(d3Array).forEach(function (key) { exports[key] = d3Array[key]; });
	Object.keys(d3Axis).forEach(function (key) { exports[key] = d3Axis[key]; });
	Object.keys(d3Brush).forEach(function (key) { exports[key] = d3Brush[key]; });
	Object.keys(d3Chord).forEach(function (key) { exports[key] = d3Chord[key]; });
	Object.keys(d3Collection).forEach(function (key) { exports[key] = d3Collection[key]; });
	Object.keys(d3Color).forEach(function (key) { exports[key] = d3Color[key]; });
	Object.keys(d3Contour).forEach(function (key) { exports[key] = d3Contour[key]; });
	Object.keys(d3Dispatch).forEach(function (key) { exports[key] = d3Dispatch[key]; });
	Object.keys(d3Drag).forEach(function (key) { exports[key] = d3Drag[key]; });
	Object.keys(d3Dsv).forEach(function (key) { exports[key] = d3Dsv[key]; });
	Object.keys(d3Ease).forEach(function (key) { exports[key] = d3Ease[key]; });
	Object.keys(d3Fetch).forEach(function (key) { exports[key] = d3Fetch[key]; });
	Object.keys(d3Force).forEach(function (key) { exports[key] = d3Force[key]; });
	Object.keys(d3Format).forEach(function (key) { exports[key] = d3Format[key]; });
	Object.keys(d3Geo).forEach(function (key) { exports[key] = d3Geo[key]; });
	Object.keys(d3Hierarchy).forEach(function (key) { exports[key] = d3Hierarchy[key]; });
	Object.keys(d3Interpolate).forEach(function (key) { exports[key] = d3Interpolate[key]; });
	Object.keys(d3Path).forEach(function (key) { exports[key] = d3Path[key]; });
	Object.keys(d3Polygon).forEach(function (key) { exports[key] = d3Polygon[key]; });
	Object.keys(d3Quadtree).forEach(function (key) { exports[key] = d3Quadtree[key]; });
	Object.keys(d3Random).forEach(function (key) { exports[key] = d3Random[key]; });
	Object.keys(d3Scale).forEach(function (key) { exports[key] = d3Scale[key]; });
	Object.keys(d3ScaleChromatic).forEach(function (key) { exports[key] = d3ScaleChromatic[key]; });
	Object.keys(d3Selection).forEach(function (key) { exports[key] = d3Selection[key]; });
	Object.keys(d3Shape).forEach(function (key) { exports[key] = d3Shape[key]; });
	Object.keys(d3Time).forEach(function (key) { exports[key] = d3Time[key]; });
	Object.keys(d3TimeFormat).forEach(function (key) { exports[key] = d3TimeFormat[key]; });
	Object.keys(d3Timer).forEach(function (key) { exports[key] = d3Timer[key]; });
	Object.keys(d3Transition).forEach(function (key) { exports[key] = d3Transition[key]; });
	Object.keys(d3Voronoi).forEach(function (key) { exports[key] = d3Voronoi[key]; });
	Object.keys(d3Zoom).forEach(function (key) { exports[key] = d3Zoom[key]; });
	exports.version = version;
	Object.defineProperty(exports, "event", {get: function() { return d3Selection.event; }});


/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-array/ Version 1.2.1. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var ascending = function(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	};

	var bisector = function(compare) {
	  if (compare.length === 1) compare = ascendingComparator(compare);
	  return {
	    left: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) < 0) lo = mid + 1;
	        else hi = mid;
	      }
	      return lo;
	    },
	    right: function(a, x, lo, hi) {
	      if (lo == null) lo = 0;
	      if (hi == null) hi = a.length;
	      while (lo < hi) {
	        var mid = lo + hi >>> 1;
	        if (compare(a[mid], x) > 0) hi = mid;
	        else lo = mid + 1;
	      }
	      return lo;
	    }
	  };
	};

	function ascendingComparator(f) {
	  return function(d, x) {
	    return ascending(f(d), x);
	  };
	}

	var ascendingBisect = bisector(ascending);
	var bisectRight = ascendingBisect.right;
	var bisectLeft = ascendingBisect.left;

	var pairs = function(array, f) {
	  if (f == null) f = pair;
	  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
	  while (i < n) pairs[i] = f(p, p = array[++i]);
	  return pairs;
	};

	function pair(a, b) {
	  return [a, b];
	}

	var cross = function(values0, values1, reduce) {
	  var n0 = values0.length,
	      n1 = values1.length,
	      values = new Array(n0 * n1),
	      i0,
	      i1,
	      i,
	      value0;

	  if (reduce == null) reduce = pair;

	  for (i0 = i = 0; i0 < n0; ++i0) {
	    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
	      values[i] = reduce(value0, values1[i1]);
	    }
	  }

	  return values;
	};

	var descending = function(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	};

	var number = function(x) {
	  return x === null ? NaN : +x;
	};

	var variance = function(values, valueof) {
	  var n = values.length,
	      m = 0,
	      i = -1,
	      mean = 0,
	      value,
	      delta,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        delta = value - mean;
	        mean += delta / ++m;
	        sum += delta * (value - mean);
	      }
	    }
	  }

	  if (m > 1) return sum / (m - 1);
	};

	var deviation = function(array, f) {
	  var v = variance(array, f);
	  return v ? Math.sqrt(v) : v;
	};

	var extent = function(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null) {
	            if (min > value) min = value;
	            if (max < value) max = value;
	          }
	        }
	      }
	    }
	  }

	  return [min, max];
	};

	var array = Array.prototype;

	var slice = array.slice;
	var map = array.map;

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	var identity = function(x) {
	  return x;
	};

	var range = function(start, stop, step) {
	  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

	  var i = -1,
	      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
	      range = new Array(n);

	  while (++i < n) {
	    range[i] = start + i * step;
	  }

	  return range;
	};

	var e10 = Math.sqrt(50);
	var e5 = Math.sqrt(10);
	var e2 = Math.sqrt(2);

	var ticks = function(start, stop, count) {
	  var reverse,
	      i = -1,
	      n,
	      ticks,
	      step;

	  stop = +stop, start = +start, count = +count;
	  if (start === stop && count > 0) return [start];
	  if (reverse = stop < start) n = start, start = stop, stop = n;
	  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

	  if (step > 0) {
	    start = Math.ceil(start / step);
	    stop = Math.floor(stop / step);
	    ticks = new Array(n = Math.ceil(stop - start + 1));
	    while (++i < n) ticks[i] = (start + i) * step;
	  } else {
	    start = Math.floor(start * step);
	    stop = Math.ceil(stop * step);
	    ticks = new Array(n = Math.ceil(start - stop + 1));
	    while (++i < n) ticks[i] = (start - i) / step;
	  }

	  if (reverse) ticks.reverse();

	  return ticks;
	};

	function tickIncrement(start, stop, count) {
	  var step = (stop - start) / Math.max(0, count),
	      power = Math.floor(Math.log(step) / Math.LN10),
	      error = step / Math.pow(10, power);
	  return power >= 0
	      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
	      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
	}

	function tickStep(start, stop, count) {
	  var step0 = Math.abs(stop - start) / Math.max(0, count),
	      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
	      error = step0 / step1;
	  if (error >= e10) step1 *= 10;
	  else if (error >= e5) step1 *= 5;
	  else if (error >= e2) step1 *= 2;
	  return stop < start ? -step1 : step1;
	}

	var sturges = function(values) {
	  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
	};

	var histogram = function() {
	  var value = identity,
	      domain = extent,
	      threshold = sturges;

	  function histogram(data) {
	    var i,
	        n = data.length,
	        x,
	        values = new Array(n);

	    for (i = 0; i < n; ++i) {
	      values[i] = value(data[i], i, data);
	    }

	    var xz = domain(values),
	        x0 = xz[0],
	        x1 = xz[1],
	        tz = threshold(values, x0, x1);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      tz = tickStep(x0, x1, tz);
	      tz = range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
	    }

	    // Remove any thresholds outside the domain.
	    var m = tz.length;
	    while (tz[0] <= x0) tz.shift(), --m;
	    while (tz[m - 1] > x1) tz.pop(), --m;

	    var bins = new Array(m + 1),
	        bin;

	    // Initialize bins.
	    for (i = 0; i <= m; ++i) {
	      bin = bins[i] = [];
	      bin.x0 = i > 0 ? tz[i - 1] : x0;
	      bin.x1 = i < m ? tz[i] : x1;
	    }

	    // Assign data to bins by value, ignoring any outside the domain.
	    for (i = 0; i < n; ++i) {
	      x = values[i];
	      if (x0 <= x && x <= x1) {
	        bins[bisectRight(tz, x, 0, m)].push(data[i]);
	      }
	    }

	    return bins;
	  }

	  histogram.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
	  };

	  histogram.domain = function(_) {
	    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
	  };

	  histogram.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
	  };

	  return histogram;
	};

	var quantile = function(values, p, valueof) {
	  if (valueof == null) valueof = number;
	  if (!(n = values.length)) return;
	  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
	  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
	  var n,
	      i = (n - 1) * p,
	      i0 = Math.floor(i),
	      value0 = +valueof(values[i0], i0, values),
	      value1 = +valueof(values[i0 + 1], i0 + 1, values);
	  return value0 + (value1 - value0) * (i - i0);
	};

	var freedmanDiaconis = function(values, min, max) {
	  values = map.call(values, number).sort(ascending);
	  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
	};

	var scott = function(values, min, max) {
	  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
	};

	var max = function(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      max;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        max = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && value > max) {
	            max = value;
	          }
	        }
	      }
	    }
	  }

	  return max;
	};

	var mean = function(values, valueof) {
	  var n = values.length,
	      m = n,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) sum += value;
	      else --m;
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
	      else --m;
	    }
	  }

	  if (m) return sum / m;
	};

	var median = function(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      numbers = [];

	  if (valueof == null) {
	    while (++i < n) {
	      if (!isNaN(value = number(values[i]))) {
	        numbers.push(value);
	      }
	    }
	  }

	  else {
	    while (++i < n) {
	      if (!isNaN(value = number(valueof(values[i], i, values)))) {
	        numbers.push(value);
	      }
	    }
	  }

	  return quantile(numbers.sort(ascending), 0.5);
	};

	var merge = function(arrays) {
	  var n = arrays.length,
	      m,
	      i = -1,
	      j = 0,
	      merged,
	      array;

	  while (++i < n) j += arrays[i].length;
	  merged = new Array(j);

	  while (--n >= 0) {
	    array = arrays[n];
	    m = array.length;
	    while (--m >= 0) {
	      merged[--j] = array[m];
	    }
	  }

	  return merged;
	};

	var min = function(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      min;

	  if (valueof == null) {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = values[i]) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = values[i]) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  else {
	    while (++i < n) { // Find the first comparable value.
	      if ((value = valueof(values[i], i, values)) != null && value >= value) {
	        min = value;
	        while (++i < n) { // Compare the remaining values.
	          if ((value = valueof(values[i], i, values)) != null && min > value) {
	            min = value;
	          }
	        }
	      }
	    }
	  }

	  return min;
	};

	var permute = function(array, indexes) {
	  var i = indexes.length, permutes = new Array(i);
	  while (i--) permutes[i] = array[indexes[i]];
	  return permutes;
	};

	var scan = function(values, compare) {
	  if (!(n = values.length)) return;
	  var n,
	      i = 0,
	      j = 0,
	      xi,
	      xj = values[j];

	  if (compare == null) compare = ascending;

	  while (++i < n) {
	    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
	      xj = xi, j = i;
	    }
	  }

	  if (compare(xj, xj) === 0) return j;
	};

	var shuffle = function(array, i0, i1) {
	  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m + i0];
	    array[m + i0] = array[i + i0];
	    array[i + i0] = t;
	  }

	  return array;
	};

	var sum = function(values, valueof) {
	  var n = values.length,
	      i = -1,
	      value,
	      sum = 0;

	  if (valueof == null) {
	    while (++i < n) {
	      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
	    }
	  }

	  else {
	    while (++i < n) {
	      if (value = +valueof(values[i], i, values)) sum += value;
	    }
	  }

	  return sum;
	};

	var transpose = function(matrix) {
	  if (!(n = matrix.length)) return [];
	  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
	    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
	      row[j] = matrix[j][i];
	    }
	  }
	  return transpose;
	};

	function length(d) {
	  return d.length;
	}

	var zip = function() {
	  return transpose(arguments);
	};

	exports.bisect = bisectRight;
	exports.bisectRight = bisectRight;
	exports.bisectLeft = bisectLeft;
	exports.ascending = ascending;
	exports.bisector = bisector;
	exports.cross = cross;
	exports.descending = descending;
	exports.deviation = deviation;
	exports.extent = extent;
	exports.histogram = histogram;
	exports.thresholdFreedmanDiaconis = freedmanDiaconis;
	exports.thresholdScott = scott;
	exports.thresholdSturges = sturges;
	exports.max = max;
	exports.mean = mean;
	exports.median = median;
	exports.merge = merge;
	exports.min = min;
	exports.pairs = pairs;
	exports.permute = permute;
	exports.quantile = quantile;
	exports.range = range;
	exports.scan = scan;
	exports.shuffle = shuffle;
	exports.sum = sum;
	exports.ticks = ticks;
	exports.tickIncrement = tickIncrement;
	exports.tickStep = tickStep;
	exports.transpose = transpose;
	exports.variance = variance;
	exports.zip = zip;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-axis/ Version 1.0.8. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var slice = Array.prototype.slice;

	var identity = function(x) {
	  return x;
	};

	var top = 1;
	var right = 2;
	var bottom = 3;
	var left = 4;
	var epsilon = 1e-6;

	function translateX(x) {
	  return "translate(" + (x + 0.5) + ",0)";
	}

	function translateY(y) {
	  return "translate(0," + (y + 0.5) + ")";
	}

	function number(scale) {
	  return function(d) {
	    return +scale(d);
	  };
	}

	function center(scale) {
	  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
	  if (scale.round()) offset = Math.round(offset);
	  return function(d) {
	    return +scale(d) + offset;
	  };
	}

	function entering() {
	  return !this.__axis;
	}

	function axis(orient, scale) {
	  var tickArguments = [],
	      tickValues = null,
	      tickFormat = null,
	      tickSizeInner = 6,
	      tickSizeOuter = 6,
	      tickPadding = 3,
	      k = orient === top || orient === left ? -1 : 1,
	      x = orient === left || orient === right ? "x" : "y",
	      transform = orient === top || orient === bottom ? translateX : translateY;

	  function axis(context) {
	    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
	        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
	        spacing = Math.max(tickSizeInner, 0) + tickPadding,
	        range = scale.range(),
	        range0 = +range[0] + 0.5,
	        range1 = +range[range.length - 1] + 0.5,
	        position = (scale.bandwidth ? center : number)(scale.copy()),
	        selection = context.selection ? context.selection() : context,
	        path = selection.selectAll(".domain").data([null]),
	        tick = selection.selectAll(".tick").data(values, scale).order(),
	        tickExit = tick.exit(),
	        tickEnter = tick.enter().append("g").attr("class", "tick"),
	        line = tick.select("line"),
	        text = tick.select("text");

	    path = path.merge(path.enter().insert("path", ".tick")
	        .attr("class", "domain")
	        .attr("stroke", "#000"));

	    tick = tick.merge(tickEnter);

	    line = line.merge(tickEnter.append("line")
	        .attr("stroke", "#000")
	        .attr(x + "2", k * tickSizeInner));

	    text = text.merge(tickEnter.append("text")
	        .attr("fill", "#000")
	        .attr(x, k * spacing)
	        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

	    if (context !== selection) {
	      path = path.transition(context);
	      tick = tick.transition(context);
	      line = line.transition(context);
	      text = text.transition(context);

	      tickExit = tickExit.transition(context)
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

	      tickEnter
	          .attr("opacity", epsilon)
	          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
	    }

	    tickExit.remove();

	    path
	        .attr("d", orient === left || orient == right
	            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
	            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

	    tick
	        .attr("opacity", 1)
	        .attr("transform", function(d) { return transform(position(d)); });

	    line
	        .attr(x + "2", k * tickSizeInner);

	    text
	        .attr(x, k * spacing)
	        .text(format);

	    selection.filter(entering)
	        .attr("fill", "none")
	        .attr("font-size", 10)
	        .attr("font-family", "sans-serif")
	        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

	    selection
	        .each(function() { this.__axis = position; });
	  }

	  axis.scale = function(_) {
	    return arguments.length ? (scale = _, axis) : scale;
	  };

	  axis.ticks = function() {
	    return tickArguments = slice.call(arguments), axis;
	  };

	  axis.tickArguments = function(_) {
	    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
	  };

	  axis.tickValues = function(_) {
	    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
	  };

	  axis.tickFormat = function(_) {
	    return arguments.length ? (tickFormat = _, axis) : tickFormat;
	  };

	  axis.tickSize = function(_) {
	    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeInner = function(_) {
	    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
	  };

	  axis.tickSizeOuter = function(_) {
	    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
	  };

	  axis.tickPadding = function(_) {
	    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
	  };

	  return axis;
	}

	function axisTop(scale) {
	  return axis(top, scale);
	}

	function axisRight(scale) {
	  return axis(right, scale);
	}

	function axisBottom(scale) {
	  return axis(bottom, scale);
	}

	function axisLeft(scale) {
	  return axis(left, scale);
	}

	exports.axisTop = axisTop;
	exports.axisRight = axisRight;
	exports.axisBottom = axisBottom;
	exports.axisLeft = axisLeft;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-brush/ Version 1.0.4. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(415), __webpack_require__(416), __webpack_require__(418), __webpack_require__(417), __webpack_require__(420)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	var BrushEvent = function(target, type, selection) {
	  this.target = target;
	  this.type = type;
	  this.selection = selection;
	};

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	var noevent = function() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	};

	var MODE_DRAG = {name: "drag"};
	var MODE_SPACE = {name: "space"};
	var MODE_HANDLE = {name: "handle"};
	var MODE_CENTER = {name: "center"};

	var X = {
	  name: "x",
	  handles: ["e", "w"].map(type),
	  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
	  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
	};

	var Y = {
	  name: "y",
	  handles: ["n", "s"].map(type),
	  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
	  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
	};

	var XY = {
	  name: "xy",
	  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
	  input: function(xy) { return xy; },
	  output: function(xy) { return xy; }
	};

	var cursors = {
	  overlay: "crosshair",
	  selection: "move",
	  n: "ns-resize",
	  e: "ew-resize",
	  s: "ns-resize",
	  w: "ew-resize",
	  nw: "nwse-resize",
	  ne: "nesw-resize",
	  se: "nwse-resize",
	  sw: "nesw-resize"
	};

	var flipX = {
	  e: "w",
	  w: "e",
	  nw: "ne",
	  ne: "nw",
	  se: "sw",
	  sw: "se"
	};

	var flipY = {
	  n: "s",
	  s: "n",
	  nw: "sw",
	  ne: "se",
	  se: "ne",
	  sw: "nw"
	};

	var signsX = {
	  overlay: +1,
	  selection: +1,
	  n: null,
	  e: +1,
	  s: null,
	  w: -1,
	  nw: -1,
	  ne: +1,
	  se: +1,
	  sw: -1
	};

	var signsY = {
	  overlay: +1,
	  selection: +1,
	  n: -1,
	  e: null,
	  s: +1,
	  w: null,
	  nw: -1,
	  ne: -1,
	  se: +1,
	  sw: +1
	};

	function type(t) {
	  return {type: t};
	}

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.button;
	}

	function defaultExtent() {
	  var svg = this.ownerSVGElement || this;
	  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
	}

	// Like d3.local, but with the name “__brush” rather than auto-generated.
	function local(node) {
	  while (!node.__brush) if (!(node = node.parentNode)) return;
	  return node.__brush;
	}

	function empty(extent) {
	  return extent[0][0] === extent[1][0]
	      || extent[0][1] === extent[1][1];
	}

	function brushSelection(node) {
	  var state = node.__brush;
	  return state ? state.dim.output(state.selection) : null;
	}

	function brushX() {
	  return brush$1(X);
	}

	function brushY() {
	  return brush$1(Y);
	}

	var brush = function() {
	  return brush$1(XY);
	};

	function brush$1(dim) {
	  var extent = defaultExtent,
	      filter = defaultFilter,
	      listeners = d3Dispatch.dispatch(brush, "start", "brush", "end"),
	      handleSize = 6,
	      touchending;

	  function brush(group) {
	    var overlay = group
	        .property("__brush", initialize)
	      .selectAll(".overlay")
	      .data([type("overlay")]);

	    overlay.enter().append("rect")
	        .attr("class", "overlay")
	        .attr("pointer-events", "all")
	        .attr("cursor", cursors.overlay)
	      .merge(overlay)
	        .each(function() {
	          var extent = local(this).extent;
	          d3Selection.select(this)
	              .attr("x", extent[0][0])
	              .attr("y", extent[0][1])
	              .attr("width", extent[1][0] - extent[0][0])
	              .attr("height", extent[1][1] - extent[0][1]);
	        });

	    group.selectAll(".selection")
	      .data([type("selection")])
	      .enter().append("rect")
	        .attr("class", "selection")
	        .attr("cursor", cursors.selection)
	        .attr("fill", "#777")
	        .attr("fill-opacity", 0.3)
	        .attr("stroke", "#fff")
	        .attr("shape-rendering", "crispEdges");

	    var handle = group.selectAll(".handle")
	      .data(dim.handles, function(d) { return d.type; });

	    handle.exit().remove();

	    handle.enter().append("rect")
	        .attr("class", function(d) { return "handle handle--" + d.type; })
	        .attr("cursor", function(d) { return cursors[d.type]; });

	    group
	        .each(redraw)
	        .attr("fill", "none")
	        .attr("pointer-events", "all")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
	        .on("mousedown.brush touchstart.brush", started);
	  }

	  brush.move = function(group, selection) {
	    if (group.selection) {
	      group
	          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
	          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
	          .tween("brush", function() {
	            var that = this,
	                state = that.__brush,
	                emit = emitter(that, arguments),
	                selection0 = state.selection,
	                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
	                i = d3Interpolate.interpolate(selection0, selection1);

	            function tween(t) {
	              state.selection = t === 1 && empty(selection1) ? null : i(t);
	              redraw.call(that);
	              emit.brush();
	            }

	            return selection0 && selection1 ? tween : tween(1);
	          });
	    } else {
	      group
	          .each(function() {
	            var that = this,
	                args = arguments,
	                state = that.__brush,
	                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
	                emit = emitter(that, args).beforestart();

	            d3Transition.interrupt(that);
	            state.selection = selection1 == null || empty(selection1) ? null : selection1;
	            redraw.call(that);
	            emit.start().brush().end();
	          });
	    }
	  };

	  function redraw() {
	    var group = d3Selection.select(this),
	        selection = local(this).selection;

	    if (selection) {
	      group.selectAll(".selection")
	          .style("display", null)
	          .attr("x", selection[0][0])
	          .attr("y", selection[0][1])
	          .attr("width", selection[1][0] - selection[0][0])
	          .attr("height", selection[1][1] - selection[0][1]);

	      group.selectAll(".handle")
	          .style("display", null)
	          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
	          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
	          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
	          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
	    }

	    else {
	      group.selectAll(".selection,.handle")
	          .style("display", "none")
	          .attr("x", null)
	          .attr("y", null)
	          .attr("width", null)
	          .attr("height", null);
	    }
	  }

	  function emitter(that, args) {
	    return that.__brush.emitter || new Emitter(that, args);
	  }

	  function Emitter(that, args) {
	    this.that = that;
	    this.args = args;
	    this.state = that.__brush;
	    this.active = 0;
	  }

	  Emitter.prototype = {
	    beforestart: function() {
	      if (++this.active === 1) this.state.emitter = this, this.starting = true;
	      return this;
	    },
	    start: function() {
	      if (this.starting) this.starting = false, this.emit("start");
	      return this;
	    },
	    brush: function() {
	      this.emit("brush");
	      return this;
	    },
	    end: function() {
	      if (--this.active === 0) delete this.state.emitter, this.emit("end");
	      return this;
	    },
	    emit: function(type) {
	      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
	    }
	  };

	  function started() {
	    if (d3Selection.event.touches) { if (d3Selection.event.changedTouches.length < d3Selection.event.touches.length) return noevent(); }
	    else if (touchending) return;
	    if (!filter.apply(this, arguments)) return;

	    var that = this,
	        type = d3Selection.event.target.__data__.type,
	        mode = (d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
	        signX = dim === Y ? null : signsX[type],
	        signY = dim === X ? null : signsY[type],
	        state = local(that),
	        extent = state.extent,
	        selection = state.selection,
	        W = extent[0][0], w0, w1,
	        N = extent[0][1], n0, n1,
	        E = extent[1][0], e0, e1,
	        S = extent[1][1], s0, s1,
	        dx,
	        dy,
	        moving,
	        shifting = signX && signY && d3Selection.event.shiftKey,
	        lockX,
	        lockY,
	        point0 = d3Selection.mouse(that),
	        point = point0,
	        emit = emitter(that, arguments).beforestart();

	    if (type === "overlay") {
	      state.selection = selection = [
	        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
	        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
	      ];
	    } else {
	      w0 = selection[0][0];
	      n0 = selection[0][1];
	      e0 = selection[1][0];
	      s0 = selection[1][1];
	    }

	    w1 = w0;
	    n1 = n0;
	    e1 = e0;
	    s1 = s0;

	    var group = d3Selection.select(that)
	        .attr("pointer-events", "none");

	    var overlay = group.selectAll(".overlay")
	        .attr("cursor", cursors[type]);

	    if (d3Selection.event.touches) {
	      group
	          .on("touchmove.brush", moved, true)
	          .on("touchend.brush touchcancel.brush", ended, true);
	    } else {
	      var view = d3Selection.select(d3Selection.event.view)
	          .on("keydown.brush", keydowned, true)
	          .on("keyup.brush", keyupped, true)
	          .on("mousemove.brush", moved, true)
	          .on("mouseup.brush", ended, true);

	      d3Drag.dragDisable(d3Selection.event.view);
	    }

	    nopropagation();
	    d3Transition.interrupt(that);
	    redraw.call(that);
	    emit.start();

	    function moved() {
	      var point1 = d3Selection.mouse(that);
	      if (shifting && !lockX && !lockY) {
	        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
	        else lockX = true;
	      }
	      point = point1;
	      moving = true;
	      noevent();
	      move();
	    }

	    function move() {
	      var t;

	      dx = point[0] - point0[0];
	      dy = point[1] - point0[1];

	      switch (mode) {
	        case MODE_SPACE:
	        case MODE_DRAG: {
	          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
	          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
	          break;
	        }
	        case MODE_HANDLE: {
	          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
	          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
	          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
	          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
	          break;
	        }
	        case MODE_CENTER: {
	          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
	          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
	          break;
	        }
	      }

	      if (e1 < w1) {
	        signX *= -1;
	        t = w0, w0 = e0, e0 = t;
	        t = w1, w1 = e1, e1 = t;
	        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
	      }

	      if (s1 < n1) {
	        signY *= -1;
	        t = n0, n0 = s0, s0 = t;
	        t = n1, n1 = s1, s1 = t;
	        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
	      }

	      if (state.selection) selection = state.selection; // May be set by brush.move!
	      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
	      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

	      if (selection[0][0] !== w1
	          || selection[0][1] !== n1
	          || selection[1][0] !== e1
	          || selection[1][1] !== s1) {
	        state.selection = [[w1, n1], [e1, s1]];
	        redraw.call(that);
	        emit.brush();
	      }
	    }

	    function ended() {
	      nopropagation();
	      if (d3Selection.event.touches) {
	        if (d3Selection.event.touches.length) return;
	        if (touchending) clearTimeout(touchending);
	        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
	      } else {
	        d3Drag.dragEnable(d3Selection.event.view, moving);
	        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
	      }
	      group.attr("pointer-events", "all");
	      overlay.attr("cursor", cursors.overlay);
	      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
	      if (empty(selection)) state.selection = null, redraw.call(that);
	      emit.end();
	    }

	    function keydowned() {
	      switch (d3Selection.event.keyCode) {
	        case 16: { // SHIFT
	          shifting = signX && signY;
	          break;
	        }
	        case 18: { // ALT
	          if (mode === MODE_HANDLE) {
	            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
	            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
	            mode = MODE_CENTER;
	            move();
	          }
	          break;
	        }
	        case 32: { // SPACE; takes priority over ALT
	          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
	            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
	            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
	            mode = MODE_SPACE;
	            overlay.attr("cursor", cursors.selection);
	            move();
	          }
	          break;
	        }
	        default: return;
	      }
	      noevent();
	    }

	    function keyupped() {
	      switch (d3Selection.event.keyCode) {
	        case 16: { // SHIFT
	          if (shifting) {
	            lockX = lockY = shifting = false;
	            move();
	          }
	          break;
	        }
	        case 18: { // ALT
	          if (mode === MODE_CENTER) {
	            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
	            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
	            mode = MODE_HANDLE;
	            move();
	          }
	          break;
	        }
	        case 32: { // SPACE
	          if (mode === MODE_SPACE) {
	            if (d3Selection.event.altKey) {
	              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
	              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
	              mode = MODE_CENTER;
	            } else {
	              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
	              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
	              mode = MODE_HANDLE;
	            }
	            overlay.attr("cursor", cursors[type]);
	            move();
	          }
	          break;
	        }
	        default: return;
	      }
	      noevent();
	    }
	  }

	  function initialize() {
	    var state = this.__brush || {selection: null};
	    state.extent = extent.apply(this, arguments);
	    state.dim = dim;
	    return state;
	  }

	  brush.extent = function(_) {
	    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
	  };

	  brush.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
	  };

	  brush.handleSize = function(_) {
	    return arguments.length ? (handleSize = +_, brush) : handleSize;
	  };

	  brush.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? brush : value;
	  };

	  return brush;
	}

	exports.brush = brush;
	exports.brushX = brushX;
	exports.brushY = brushY;
	exports.brushSelection = brushSelection;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var noop = {value: function() {}};

	function dispatch() {
	  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
	    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
	    _[t] = [];
	  }
	  return new Dispatch(_);
	}

	function Dispatch(_) {
	  this._ = _;
	}

	function parseTypenames(typenames, types) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
	    return {type: t, name: name};
	  });
	}

	Dispatch.prototype = dispatch.prototype = {
	  constructor: Dispatch,
	  on: function(typename, callback) {
	    var _ = this._,
	        T = parseTypenames(typename + "", _),
	        t,
	        i = -1,
	        n = T.length;

	    // If no callback was specified, return the callback of the given type and name.
	    if (arguments.length < 2) {
	      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
	      return;
	    }

	    // If a type was specified, set the callback for the given type and name.
	    // Otherwise, if a null callback was specified, remove callbacks of the given name.
	    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
	    while (++i < n) {
	      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
	      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
	    }

	    return this;
	  },
	  copy: function() {
	    var copy = {}, _ = this._;
	    for (var t in _) copy[t] = _[t].slice();
	    return new Dispatch(copy);
	  },
	  call: function(type, that) {
	    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  },
	  apply: function(type, that, args) {
	    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
	    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
	  }
	};

	function get(type, name) {
	  for (var i = 0, n = type.length, c; i < n; ++i) {
	    if ((c = type[i]).name === name) {
	      return c.value;
	    }
	  }
	}

	function set(type, name, callback) {
	  for (var i = 0, n = type.length; i < n; ++i) {
	    if (type[i].name === name) {
	      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
	      break;
	    }
	  }
	  if (callback != null) type.push({name: name, value: callback});
	  return type;
	}

	exports.dispatch = dispatch;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-drag/ Version 1.2.1. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(415), __webpack_require__(417)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
	}(this, (function (exports,d3Dispatch,d3Selection) { 'use strict';

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	var noevent = function() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	};

	var nodrag = function(view) {
	  var root = view.document.documentElement,
	      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
	  if ("onselectstart" in root) {
	    selection.on("selectstart.drag", noevent, true);
	  } else {
	    root.__noselect = root.style.MozUserSelect;
	    root.style.MozUserSelect = "none";
	  }
	};

	function yesdrag(view, noclick) {
	  var root = view.document.documentElement,
	      selection = d3Selection.select(view).on("dragstart.drag", null);
	  if (noclick) {
	    selection.on("click.drag", noevent, true);
	    setTimeout(function() { selection.on("click.drag", null); }, 0);
	  }
	  if ("onselectstart" in root) {
	    selection.on("selectstart.drag", null);
	  } else {
	    root.style.MozUserSelect = root.__noselect;
	    delete root.__noselect;
	  }
	}

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch$$1) {
	  this.target = target;
	  this.type = type;
	  this.subject = subject;
	  this.identifier = id;
	  this.active = active;
	  this.x = x;
	  this.y = y;
	  this.dx = dx;
	  this.dy = dy;
	  this._ = dispatch$$1;
	}

	DragEvent.prototype.on = function() {
	  var value = this._.on.apply(this._, arguments);
	  return value === this._ ? this : value;
	};

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.button;
	}

	function defaultContainer() {
	  return this.parentNode;
	}

	function defaultSubject(d) {
	  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
	}

	function defaultTouchable() {
	  return "ontouchstart" in this;
	}

	var drag = function() {
	  var filter = defaultFilter,
	      container = defaultContainer,
	      subject = defaultSubject,
	      touchable = defaultTouchable,
	      gestures = {},
	      listeners = d3Dispatch.dispatch("start", "drag", "end"),
	      active = 0,
	      mousedownx,
	      mousedowny,
	      mousemoving,
	      touchending,
	      clickDistance2 = 0;

	  function drag(selection) {
	    selection
	        .on("mousedown.drag", mousedowned)
	      .filter(touchable)
	        .on("touchstart.drag", touchstarted)
	        .on("touchmove.drag", touchmoved)
	        .on("touchend.drag touchcancel.drag", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
	    if (!gesture) return;
	    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
	    nodrag(d3Selection.event.view);
	    nopropagation();
	    mousemoving = false;
	    mousedownx = d3Selection.event.clientX;
	    mousedowny = d3Selection.event.clientY;
	    gesture("start");
	  }

	  function mousemoved() {
	    noevent();
	    if (!mousemoving) {
	      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
	      mousemoving = dx * dx + dy * dy > clickDistance2;
	    }
	    gestures.mouse("drag");
	  }

	  function mouseupped() {
	    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
	    yesdrag(d3Selection.event.view, mousemoving);
	    noevent();
	    gestures.mouse("end");
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var touches = d3Selection.event.changedTouches,
	        c = container.apply(this, arguments),
	        n = touches.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
	        nopropagation();
	        gesture("start");
	      }
	    }
	  }

	  function touchmoved() {
	    var touches = d3Selection.event.changedTouches,
	        n = touches.length, i, gesture;

	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches[i].identifier]) {
	        noevent();
	        gesture("drag");
	      }
	    }
	  }

	  function touchended() {
	    var touches = d3Selection.event.changedTouches,
	        n = touches.length, i, gesture;

	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
	    for (i = 0; i < n; ++i) {
	      if (gesture = gestures[touches[i].identifier]) {
	        nopropagation();
	        gesture("end");
	      }
	    }
	  }

	  function beforestart(id, container, point, that, args) {
	    var p = point(container, id), s, dx, dy,
	        sublisteners = listeners.copy();

	    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
	      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
	      dx = s.x - p[0] || 0;
	      dy = s.y - p[1] || 0;
	      return true;
	    })) return;

	    return function gesture(type) {
	      var p0 = p, n;
	      switch (type) {
	        case "start": gestures[id] = gesture, n = active++; break;
	        case "end": delete gestures[id], --active; // nobreak
	        case "drag": p = point(container, id), n = active; break;
	      }
	      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
	    };
	  }

	  drag.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
	  };

	  drag.container = function(_) {
	    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
	  };

	  drag.subject = function(_) {
	    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
	  };

	  drag.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
	  };

	  drag.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? drag : value;
	  };

	  drag.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
	  };

	  return drag;
	};

	exports.drag = drag;
	exports.dragDisable = nodrag;
	exports.dragEnable = yesdrag;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-selection/ Version 1.3.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var xhtml = "http://www.w3.org/1999/xhtml";

	var namespaces = {
	  svg: "http://www.w3.org/2000/svg",
	  xhtml: xhtml,
	  xlink: "http://www.w3.org/1999/xlink",
	  xml: "http://www.w3.org/XML/1998/namespace",
	  xmlns: "http://www.w3.org/2000/xmlns/"
	};

	function namespace(name) {
	  var prefix = name += "", i = prefix.indexOf(":");
	  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
	  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
	}

	function creatorInherit(name) {
	  return function() {
	    var document = this.ownerDocument,
	        uri = this.namespaceURI;
	    return uri === xhtml && document.documentElement.namespaceURI === xhtml
	        ? document.createElement(name)
	        : document.createElementNS(uri, name);
	  };
	}

	function creatorFixed(fullname) {
	  return function() {
	    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
	  };
	}

	function creator(name) {
	  var fullname = namespace(name);
	  return (fullname.local
	      ? creatorFixed
	      : creatorInherit)(fullname);
	}

	function none() {}

	function selector(selector) {
	  return selector == null ? none : function() {
	    return this.querySelector(selector);
	  };
	}

	function selection_select(select) {
	  if (typeof select !== "function") select = selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function empty() {
	  return [];
	}

	function selectorAll(selector) {
	  return selector == null ? empty : function() {
	    return this.querySelectorAll(selector);
	  };
	}

	function selection_selectAll(select) {
	  if (typeof select !== "function") select = selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        subgroups.push(select.call(node, node.__data__, i, group));
	        parents.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, parents);
	}

	var matcher = function(selector) {
	  return function() {
	    return this.matches(selector);
	  };
	};

	if (typeof document !== "undefined") {
	  var element = document.documentElement;
	  if (!element.matches) {
	    var vendorMatches = element.webkitMatchesSelector
	        || element.msMatchesSelector
	        || element.mozMatchesSelector
	        || element.oMatchesSelector;
	    matcher = function(selector) {
	      return function() {
	        return vendorMatches.call(this, selector);
	      };
	    };
	  }
	}

	var matcher$1 = matcher;

	function selection_filter(match) {
	  if (typeof match !== "function") match = matcher$1(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Selection(subgroups, this._parents);
	}

	function sparse(update) {
	  return new Array(update.length);
	}

	function selection_enter() {
	  return new Selection(this._enter || this._groups.map(sparse), this._parents);
	}

	function EnterNode(parent, datum) {
	  this.ownerDocument = parent.ownerDocument;
	  this.namespaceURI = parent.namespaceURI;
	  this._next = null;
	  this._parent = parent;
	  this.__data__ = datum;
	}

	EnterNode.prototype = {
	  constructor: EnterNode,
	  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
	  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
	  querySelector: function(selector) { return this._parent.querySelector(selector); },
	  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
	};

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	var keyPrefix = "$"; // Protect against keys like “__proto__”.

	function bindIndex(parent, group, enter, update, exit, data) {
	  var i = 0,
	      node,
	      groupLength = group.length,
	      dataLength = data.length;

	  // Put any non-null nodes that fit into update.
	  // Put any null nodes into enter.
	  // Put any remaining data into enter.
	  for (; i < dataLength; ++i) {
	    if (node = group[i]) {
	      node.__data__ = data[i];
	      update[i] = node;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Put any non-null nodes that don’t fit into exit.
	  for (; i < groupLength; ++i) {
	    if (node = group[i]) {
	      exit[i] = node;
	    }
	  }
	}

	function bindKey(parent, group, enter, update, exit, data, key) {
	  var i,
	      node,
	      nodeByKeyValue = {},
	      groupLength = group.length,
	      dataLength = data.length,
	      keyValues = new Array(groupLength),
	      keyValue;

	  // Compute the key for each node.
	  // If multiple nodes have the same key, the duplicates are added to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if (node = group[i]) {
	      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
	      if (keyValue in nodeByKeyValue) {
	        exit[i] = node;
	      } else {
	        nodeByKeyValue[keyValue] = node;
	      }
	    }
	  }

	  // Compute the key for each datum.
	  // If there a node associated with this key, join and add it to update.
	  // If there is not (or the key is a duplicate), add it to enter.
	  for (i = 0; i < dataLength; ++i) {
	    keyValue = keyPrefix + key.call(parent, data[i], i, data);
	    if (node = nodeByKeyValue[keyValue]) {
	      update[i] = node;
	      node.__data__ = data[i];
	      nodeByKeyValue[keyValue] = null;
	    } else {
	      enter[i] = new EnterNode(parent, data[i]);
	    }
	  }

	  // Add any remaining nodes that were not bound to data to exit.
	  for (i = 0; i < groupLength; ++i) {
	    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
	      exit[i] = node;
	    }
	  }
	}

	function selection_data(value, key) {
	  if (!value) {
	    data = new Array(this.size()), j = -1;
	    this.each(function(d) { data[++j] = d; });
	    return data;
	  }

	  var bind = key ? bindKey : bindIndex,
	      parents = this._parents,
	      groups = this._groups;

	  if (typeof value !== "function") value = constant(value);

	  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
	    var parent = parents[j],
	        group = groups[j],
	        groupLength = group.length,
	        data = value.call(parent, parent && parent.__data__, j, parents),
	        dataLength = data.length,
	        enterGroup = enter[j] = new Array(dataLength),
	        updateGroup = update[j] = new Array(dataLength),
	        exitGroup = exit[j] = new Array(groupLength);

	    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

	    // Now connect the enter nodes to their following update node, such that
	    // appendChild can insert the materialized enter node before this node,
	    // rather than at the end of the parent node.
	    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
	      if (previous = enterGroup[i0]) {
	        if (i0 >= i1) i1 = i0 + 1;
	        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
	        previous._next = next || null;
	      }
	    }
	  }

	  update = new Selection(update, parents);
	  update._enter = enter;
	  update._exit = exit;
	  return update;
	}

	function selection_exit() {
	  return new Selection(this._exit || this._groups.map(sparse), this._parents);
	}

	function selection_merge(selection$$1) {

	  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Selection(merges, this._parents);
	}

	function selection_order() {

	  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
	    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
	      if (node = group[i]) {
	        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
	        next = node;
	      }
	    }
	  }

	  return this;
	}

	function selection_sort(compare) {
	  if (!compare) compare = ascending;

	  function compareNode(a, b) {
	    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
	  }

	  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        sortgroup[i] = node;
	      }
	    }
	    sortgroup.sort(compareNode);
	  }

	  return new Selection(sortgroups, this._parents).order();
	}

	function ascending(a, b) {
	  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
	}

	function selection_call() {
	  var callback = arguments[0];
	  arguments[0] = this;
	  callback.apply(null, arguments);
	  return this;
	}

	function selection_nodes() {
	  var nodes = new Array(this.size()), i = -1;
	  this.each(function() { nodes[++i] = this; });
	  return nodes;
	}

	function selection_node() {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
	      var node = group[i];
	      if (node) return node;
	    }
	  }

	  return null;
	}

	function selection_size() {
	  var size = 0;
	  this.each(function() { ++size; });
	  return size;
	}

	function selection_empty() {
	  return !this.node();
	}

	function selection_each(callback) {

	  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
	    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
	      if (node = group[i]) callback.call(node, node.__data__, i, group);
	    }
	  }

	  return this;
	}

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, value) {
	  return function() {
	    this.setAttribute(name, value);
	  };
	}

	function attrConstantNS(fullname, value) {
	  return function() {
	    this.setAttributeNS(fullname.space, fullname.local, value);
	  };
	}

	function attrFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttribute(name);
	    else this.setAttribute(name, v);
	  };
	}

	function attrFunctionNS(fullname, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
	    else this.setAttributeNS(fullname.space, fullname.local, v);
	  };
	}

	function selection_attr(name, value) {
	  var fullname = namespace(name);

	  if (arguments.length < 2) {
	    var node = this.node();
	    return fullname.local
	        ? node.getAttributeNS(fullname.space, fullname.local)
	        : node.getAttribute(fullname);
	  }

	  return this.each((value == null
	      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)
	      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
	}

	function defaultView(node) {
	  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
	      || (node.document && node) // node is a Window
	      || node.defaultView; // node is a Document
	}

	function styleRemove(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, value, priority) {
	  return function() {
	    this.style.setProperty(name, value, priority);
	  };
	}

	function styleFunction(name, value, priority) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) this.style.removeProperty(name);
	    else this.style.setProperty(name, v, priority);
	  };
	}

	function selection_style(name, value, priority) {
	  return arguments.length > 1
	      ? this.each((value == null
	            ? styleRemove : typeof value === "function"
	            ? styleFunction
	            : styleConstant)(name, value, priority == null ? "" : priority))
	      : styleValue(this.node(), name);
	}

	function styleValue(node, name) {
	  return node.style.getPropertyValue(name)
	      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
	}

	function propertyRemove(name) {
	  return function() {
	    delete this[name];
	  };
	}

	function propertyConstant(name, value) {
	  return function() {
	    this[name] = value;
	  };
	}

	function propertyFunction(name, value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    if (v == null) delete this[name];
	    else this[name] = v;
	  };
	}

	function selection_property(name, value) {
	  return arguments.length > 1
	      ? this.each((value == null
	          ? propertyRemove : typeof value === "function"
	          ? propertyFunction
	          : propertyConstant)(name, value))
	      : this.node()[name];
	}

	function classArray(string) {
	  return string.trim().split(/^|\s+/);
	}

	function classList(node) {
	  return node.classList || new ClassList(node);
	}

	function ClassList(node) {
	  this._node = node;
	  this._names = classArray(node.getAttribute("class") || "");
	}

	ClassList.prototype = {
	  add: function(name) {
	    var i = this._names.indexOf(name);
	    if (i < 0) {
	      this._names.push(name);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  remove: function(name) {
	    var i = this._names.indexOf(name);
	    if (i >= 0) {
	      this._names.splice(i, 1);
	      this._node.setAttribute("class", this._names.join(" "));
	    }
	  },
	  contains: function(name) {
	    return this._names.indexOf(name) >= 0;
	  }
	};

	function classedAdd(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.add(names[i]);
	}

	function classedRemove(node, names) {
	  var list = classList(node), i = -1, n = names.length;
	  while (++i < n) list.remove(names[i]);
	}

	function classedTrue(names) {
	  return function() {
	    classedAdd(this, names);
	  };
	}

	function classedFalse(names) {
	  return function() {
	    classedRemove(this, names);
	  };
	}

	function classedFunction(names, value) {
	  return function() {
	    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
	  };
	}

	function selection_classed(name, value) {
	  var names = classArray(name + "");

	  if (arguments.length < 2) {
	    var list = classList(this.node()), i = -1, n = names.length;
	    while (++i < n) if (!list.contains(names[i])) return false;
	    return true;
	  }

	  return this.each((typeof value === "function"
	      ? classedFunction : value
	      ? classedTrue
	      : classedFalse)(names, value));
	}

	function textRemove() {
	  this.textContent = "";
	}

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.textContent = v == null ? "" : v;
	  };
	}

	function selection_text(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? textRemove : (typeof value === "function"
	          ? textFunction
	          : textConstant)(value))
	      : this.node().textContent;
	}

	function htmlRemove() {
	  this.innerHTML = "";
	}

	function htmlConstant(value) {
	  return function() {
	    this.innerHTML = value;
	  };
	}

	function htmlFunction(value) {
	  return function() {
	    var v = value.apply(this, arguments);
	    this.innerHTML = v == null ? "" : v;
	  };
	}

	function selection_html(value) {
	  return arguments.length
	      ? this.each(value == null
	          ? htmlRemove : (typeof value === "function"
	          ? htmlFunction
	          : htmlConstant)(value))
	      : this.node().innerHTML;
	}

	function raise() {
	  if (this.nextSibling) this.parentNode.appendChild(this);
	}

	function selection_raise() {
	  return this.each(raise);
	}

	function lower() {
	  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
	}

	function selection_lower() {
	  return this.each(lower);
	}

	function selection_append(name) {
	  var create = typeof name === "function" ? name : creator(name);
	  return this.select(function() {
	    return this.appendChild(create.apply(this, arguments));
	  });
	}

	function constantNull() {
	  return null;
	}

	function selection_insert(name, before) {
	  var create = typeof name === "function" ? name : creator(name),
	      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
	  return this.select(function() {
	    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
	  });
	}

	function remove() {
	  var parent = this.parentNode;
	  if (parent) parent.removeChild(this);
	}

	function selection_remove() {
	  return this.each(remove);
	}

	function selection_cloneShallow() {
	  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
	}

	function selection_cloneDeep() {
	  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
	}

	function selection_clone(deep) {
	  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
	}

	function selection_datum(value) {
	  return arguments.length
	      ? this.property("__data__", value)
	      : this.node().__data__;
	}

	var filterEvents = {};

	exports.event = null;

	if (typeof document !== "undefined") {
	  var element$1 = document.documentElement;
	  if (!("onmouseenter" in element$1)) {
	    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
	  }
	}

	function filterContextListener(listener, index, group) {
	  listener = contextListener(listener, index, group);
	  return function(event) {
	    var related = event.relatedTarget;
	    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
	      listener.call(this, event);
	    }
	  };
	}

	function contextListener(listener, index, group) {
	  return function(event1) {
	    var event0 = exports.event; // Events can be reentrant (e.g., focus).
	    exports.event = event1;
	    try {
	      listener.call(this, this.__data__, index, group);
	    } finally {
	      exports.event = event0;
	    }
	  };
	}

	function parseTypenames(typenames) {
	  return typenames.trim().split(/^|\s+/).map(function(t) {
	    var name = "", i = t.indexOf(".");
	    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
	    return {type: t, name: name};
	  });
	}

	function onRemove(typename) {
	  return function() {
	    var on = this.__on;
	    if (!on) return;
	    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
	      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	      } else {
	        on[++i] = o;
	      }
	    }
	    if (++i) on.length = i;
	    else delete this.__on;
	  };
	}

	function onAdd(typename, value, capture) {
	  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
	  return function(d, i, group) {
	    var on = this.__on, o, listener = wrap(value, i, group);
	    if (on) for (var j = 0, m = on.length; j < m; ++j) {
	      if ((o = on[j]).type === typename.type && o.name === typename.name) {
	        this.removeEventListener(o.type, o.listener, o.capture);
	        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
	        o.value = value;
	        return;
	      }
	    }
	    this.addEventListener(typename.type, listener, capture);
	    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
	    if (!on) this.__on = [o];
	    else on.push(o);
	  };
	}

	function selection_on(typename, value, capture) {
	  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

	  if (arguments.length < 2) {
	    var on = this.node().__on;
	    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
	      for (i = 0, o = on[j]; i < n; ++i) {
	        if ((t = typenames[i]).type === o.type && t.name === o.name) {
	          return o.value;
	        }
	      }
	    }
	    return;
	  }

	  on = value ? onAdd : onRemove;
	  if (capture == null) capture = false;
	  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
	  return this;
	}

	function customEvent(event1, listener, that, args) {
	  var event0 = exports.event;
	  event1.sourceEvent = exports.event;
	  exports.event = event1;
	  try {
	    return listener.apply(that, args);
	  } finally {
	    exports.event = event0;
	  }
	}

	function dispatchEvent(node, type, params) {
	  var window = defaultView(node),
	      event = window.CustomEvent;

	  if (typeof event === "function") {
	    event = new event(type, params);
	  } else {
	    event = window.document.createEvent("Event");
	    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
	    else event.initEvent(type, false, false);
	  }

	  node.dispatchEvent(event);
	}

	function dispatchConstant(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params);
	  };
	}

	function dispatchFunction(type, params) {
	  return function() {
	    return dispatchEvent(this, type, params.apply(this, arguments));
	  };
	}

	function selection_dispatch(type, params) {
	  return this.each((typeof params === "function"
	      ? dispatchFunction
	      : dispatchConstant)(type, params));
	}

	var root = [null];

	function Selection(groups, parents) {
	  this._groups = groups;
	  this._parents = parents;
	}

	function selection() {
	  return new Selection([[document.documentElement]], root);
	}

	Selection.prototype = selection.prototype = {
	  constructor: Selection,
	  select: selection_select,
	  selectAll: selection_selectAll,
	  filter: selection_filter,
	  data: selection_data,
	  enter: selection_enter,
	  exit: selection_exit,
	  merge: selection_merge,
	  order: selection_order,
	  sort: selection_sort,
	  call: selection_call,
	  nodes: selection_nodes,
	  node: selection_node,
	  size: selection_size,
	  empty: selection_empty,
	  each: selection_each,
	  attr: selection_attr,
	  style: selection_style,
	  property: selection_property,
	  classed: selection_classed,
	  text: selection_text,
	  html: selection_html,
	  raise: selection_raise,
	  lower: selection_lower,
	  append: selection_append,
	  insert: selection_insert,
	  remove: selection_remove,
	  clone: selection_clone,
	  datum: selection_datum,
	  on: selection_on,
	  dispatch: selection_dispatch
	};

	function select(selector) {
	  return typeof selector === "string"
	      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
	      : new Selection([[selector]], root);
	}

	function create(name) {
	  return select(creator(name).call(document.documentElement));
	}

	var nextId = 0;

	function local() {
	  return new Local;
	}

	function Local() {
	  this._ = "@" + (++nextId).toString(36);
	}

	Local.prototype = local.prototype = {
	  constructor: Local,
	  get: function(node) {
	    var id = this._;
	    while (!(id in node)) if (!(node = node.parentNode)) return;
	    return node[id];
	  },
	  set: function(node, value) {
	    return node[this._] = value;
	  },
	  remove: function(node) {
	    return this._ in node && delete node[this._];
	  },
	  toString: function() {
	    return this._;
	  }
	};

	function sourceEvent() {
	  var current = exports.event, source;
	  while (source = current.sourceEvent) current = source;
	  return current;
	}

	function point(node, event) {
	  var svg = node.ownerSVGElement || node;

	  if (svg.createSVGPoint) {
	    var point = svg.createSVGPoint();
	    point.x = event.clientX, point.y = event.clientY;
	    point = point.matrixTransform(node.getScreenCTM().inverse());
	    return [point.x, point.y];
	  }

	  var rect = node.getBoundingClientRect();
	  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
	}

	function mouse(node) {
	  var event = sourceEvent();
	  if (event.changedTouches) event = event.changedTouches[0];
	  return point(node, event);
	}

	function selectAll(selector) {
	  return typeof selector === "string"
	      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
	      : new Selection([selector == null ? [] : selector], root);
	}

	function touch(node, touches, identifier) {
	  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

	  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
	    if ((touch = touches[i]).identifier === identifier) {
	      return point(node, touch);
	    }
	  }

	  return null;
	}

	function touches(node, touches) {
	  if (touches == null) touches = sourceEvent().touches;

	  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
	    points[i] = point(node, touches[i]);
	  }

	  return points;
	}

	exports.create = create;
	exports.creator = creator;
	exports.local = local;
	exports.matcher = matcher$1;
	exports.mouse = mouse;
	exports.namespace = namespace;
	exports.namespaces = namespaces;
	exports.clientPoint = point;
	exports.select = select;
	exports.selectAll = selectAll;
	exports.selection = selection;
	exports.selector = selector;
	exports.selectorAll = selectorAll;
	exports.style = styleValue;
	exports.touch = touch;
	exports.touches = touches;
	exports.window = defaultView;
	exports.customEvent = customEvent;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-interpolate/ Version 1.2.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(419)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Color) { 'use strict';

	function basis(t1, v0, v1, v2, v3) {
	  var t2 = t1 * t1, t3 = t2 * t1;
	  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
	      + (4 - 6 * t2 + 3 * t3) * v1
	      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
	      + t3 * v3) / 6;
	}

	var basis$1 = function(values) {
	  var n = values.length - 1;
	  return function(t) {
	    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
	        v1 = values[i],
	        v2 = values[i + 1],
	        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
	        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	};

	var basisClosed = function(values) {
	  var n = values.length;
	  return function(t) {
	    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
	        v0 = values[(i + n - 1) % n],
	        v1 = values[i % n],
	        v2 = values[(i + 1) % n],
	        v3 = values[(i + 2) % n];
	    return basis((t - i / n) * n, v0, v1, v2, v3);
	  };
	};

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	function linear(a, d) {
	  return function(t) {
	    return a + t * d;
	  };
	}

	function exponential(a, b, y) {
	  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
	    return Math.pow(a + t * b, y);
	  };
	}

	function hue(a, b) {
	  var d = b - a;
	  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
	}

	function gamma(y) {
	  return (y = +y) === 1 ? nogamma : function(a, b) {
	    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
	  };
	}

	function nogamma(a, b) {
	  var d = b - a;
	  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
	}

	var rgb$1 = ((function rgbGamma(y) {
	  var color$$1 = gamma(y);

	  function rgb$$1(start, end) {
	    var r = color$$1((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
	        g = color$$1(start.g, end.g),
	        b = color$$1(start.b, end.b),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.r = r(t);
	      start.g = g(t);
	      start.b = b(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }

	  rgb$$1.gamma = rgbGamma;

	  return rgb$$1;
	}))(1);

	function rgbSpline(spline) {
	  return function(colors) {
	    var n = colors.length,
	        r = new Array(n),
	        g = new Array(n),
	        b = new Array(n),
	        i, color$$1;
	    for (i = 0; i < n; ++i) {
	      color$$1 = d3Color.rgb(colors[i]);
	      r[i] = color$$1.r || 0;
	      g[i] = color$$1.g || 0;
	      b[i] = color$$1.b || 0;
	    }
	    r = spline(r);
	    g = spline(g);
	    b = spline(b);
	    color$$1.opacity = 1;
	    return function(t) {
	      color$$1.r = r(t);
	      color$$1.g = g(t);
	      color$$1.b = b(t);
	      return color$$1 + "";
	    };
	  };
	}

	var rgbBasis = rgbSpline(basis$1);
	var rgbBasisClosed = rgbSpline(basisClosed);

	var array = function(a, b) {
	  var nb = b ? b.length : 0,
	      na = a ? Math.min(nb, a.length) : 0,
	      x = new Array(na),
	      c = new Array(nb),
	      i;

	  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
	  for (; i < nb; ++i) c[i] = b[i];

	  return function(t) {
	    for (i = 0; i < na; ++i) c[i] = x[i](t);
	    return c;
	  };
	};

	var date = function(a, b) {
	  var d = new Date;
	  return a = +a, b -= a, function(t) {
	    return d.setTime(a + b * t), d;
	  };
	};

	var number = function(a, b) {
	  return a = +a, b -= a, function(t) {
	    return a + b * t;
	  };
	};

	var object = function(a, b) {
	  var i = {},
	      c = {},
	      k;

	  if (a === null || typeof a !== "object") a = {};
	  if (b === null || typeof b !== "object") b = {};

	  for (k in b) {
	    if (k in a) {
	      i[k] = value(a[k], b[k]);
	    } else {
	      c[k] = b[k];
	    }
	  }

	  return function(t) {
	    for (k in i) c[k] = i[k](t);
	    return c;
	  };
	};

	var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
	var reB = new RegExp(reA.source, "g");

	function zero(b) {
	  return function() {
	    return b;
	  };
	}

	function one(b) {
	  return function(t) {
	    return b(t) + "";
	  };
	}

	var string = function(a, b) {
	  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
	      am, // current match in a
	      bm, // current match in b
	      bs, // string preceding current number in b, if any
	      i = -1, // index in s
	      s = [], // string constants and placeholders
	      q = []; // number interpolators

	  // Coerce inputs to strings.
	  a = a + "", b = b + "";

	  // Interpolate pairs of numbers in a & b.
	  while ((am = reA.exec(a))
	      && (bm = reB.exec(b))) {
	    if ((bs = bm.index) > bi) { // a string precedes the next number in b
	      bs = b.slice(bi, bs);
	      if (s[i]) s[i] += bs; // coalesce with previous string
	      else s[++i] = bs;
	    }
	    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
	      if (s[i]) s[i] += bm; // coalesce with previous string
	      else s[++i] = bm;
	    } else { // interpolate non-matching numbers
	      s[++i] = null;
	      q.push({i: i, x: number(am, bm)});
	    }
	    bi = reB.lastIndex;
	  }

	  // Add remains of b.
	  if (bi < b.length) {
	    bs = b.slice(bi);
	    if (s[i]) s[i] += bs; // coalesce with previous string
	    else s[++i] = bs;
	  }

	  // Special optimization for only a single match.
	  // Otherwise, interpolate each of the numbers and rejoin the string.
	  return s.length < 2 ? (q[0]
	      ? one(q[0].x)
	      : zero(b))
	      : (b = q.length, function(t) {
	          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
	          return s.join("");
	        });
	};

	var value = function(a, b) {
	  var t = typeof b, c;
	  return b == null || t === "boolean" ? constant(b)
	      : (t === "number" ? number
	      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
	      : b instanceof d3Color.color ? rgb$1
	      : b instanceof Date ? date
	      : Array.isArray(b) ? array
	      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
	      : number)(a, b);
	};

	var round = function(a, b) {
	  return a = +a, b -= a, function(t) {
	    return Math.round(a + b * t);
	  };
	};

	var degrees = 180 / Math.PI;

	var identity = {
	  translateX: 0,
	  translateY: 0,
	  rotate: 0,
	  skewX: 0,
	  scaleX: 1,
	  scaleY: 1
	};

	var decompose = function(a, b, c, d, e, f) {
	  var scaleX, scaleY, skewX;
	  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
	  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
	  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
	  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
	  return {
	    translateX: e,
	    translateY: f,
	    rotate: Math.atan2(b, a) * degrees,
	    skewX: Math.atan(skewX) * degrees,
	    scaleX: scaleX,
	    scaleY: scaleY
	  };
	};

	var cssNode;
	var cssRoot;
	var cssView;
	var svgNode;

	function parseCss(value) {
	  if (value === "none") return identity;
	  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
	  cssNode.style.transform = value;
	  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
	  cssRoot.removeChild(cssNode);
	  value = value.slice(7, -1).split(",");
	  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
	}

	function parseSvg(value) {
	  if (value == null) return identity;
	  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
	  svgNode.setAttribute("transform", value);
	  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
	  value = value.matrix;
	  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
	}

	function interpolateTransform(parse, pxComma, pxParen, degParen) {

	  function pop(s) {
	    return s.length ? s.pop() + " " : "";
	  }

	  function translate(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push("translate(", null, pxComma, null, pxParen);
	      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	    } else if (xb || yb) {
	      s.push("translate(" + xb + pxComma + yb + pxParen);
	    }
	  }

	  function rotate(a, b, s, q) {
	    if (a !== b) {
	      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
	      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "rotate(" + b + degParen);
	    }
	  }

	  function skewX(a, b, s, q) {
	    if (a !== b) {
	      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
	    } else if (b) {
	      s.push(pop(s) + "skewX(" + b + degParen);
	    }
	  }

	  function scale(xa, ya, xb, yb, s, q) {
	    if (xa !== xb || ya !== yb) {
	      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
	      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
	    } else if (xb !== 1 || yb !== 1) {
	      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
	    }
	  }

	  return function(a, b) {
	    var s = [], // string constants and placeholders
	        q = []; // number interpolators
	    a = parse(a), b = parse(b);
	    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
	    rotate(a.rotate, b.rotate, s, q);
	    skewX(a.skewX, b.skewX, s, q);
	    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
	    a = b = null; // gc
	    return function(t) {
	      var i = -1, n = q.length, o;
	      while (++i < n) s[(o = q[i]).i] = o.x(t);
	      return s.join("");
	    };
	  };
	}

	var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
	var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

	var rho = Math.SQRT2;
	var rho2 = 2;
	var rho4 = 4;
	var epsilon2 = 1e-12;

	function cosh(x) {
	  return ((x = Math.exp(x)) + 1 / x) / 2;
	}

	function sinh(x) {
	  return ((x = Math.exp(x)) - 1 / x) / 2;
	}

	function tanh(x) {
	  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
	}

	// p0 = [ux0, uy0, w0]
	// p1 = [ux1, uy1, w1]
	var zoom = function(p0, p1) {
	  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
	      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
	      dx = ux1 - ux0,
	      dy = uy1 - uy0,
	      d2 = dx * dx + dy * dy,
	      i,
	      S;

	  // Special case for u0 ≅ u1.
	  if (d2 < epsilon2) {
	    S = Math.log(w1 / w0) / rho;
	    i = function(t) {
	      return [
	        ux0 + t * dx,
	        uy0 + t * dy,
	        w0 * Math.exp(rho * t * S)
	      ];
	    };
	  }

	  // General case.
	  else {
	    var d1 = Math.sqrt(d2),
	        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
	        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
	        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
	        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
	    S = (r1 - r0) / rho;
	    i = function(t) {
	      var s = t * S,
	          coshr0 = cosh(r0),
	          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
	      return [
	        ux0 + u * dx,
	        uy0 + u * dy,
	        w0 * coshr0 / cosh(rho * s + r0)
	      ];
	    };
	  }

	  i.duration = S * 1000;

	  return i;
	};

	function hsl$1(hue$$1) {
	  return function(start, end) {
	    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
	        s = nogamma(start.s, end.s),
	        l = nogamma(start.l, end.l),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.h = h(t);
	      start.s = s(t);
	      start.l = l(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }
	}

	var hsl$2 = hsl$1(hue);
	var hslLong = hsl$1(nogamma);

	function lab$1(start, end) {
	  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
	      a = nogamma(start.a, end.a),
	      b = nogamma(start.b, end.b),
	      opacity = nogamma(start.opacity, end.opacity);
	  return function(t) {
	    start.l = l(t);
	    start.a = a(t);
	    start.b = b(t);
	    start.opacity = opacity(t);
	    return start + "";
	  };
	}

	function hcl$1(hue$$1) {
	  return function(start, end) {
	    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
	        c = nogamma(start.c, end.c),
	        l = nogamma(start.l, end.l),
	        opacity = nogamma(start.opacity, end.opacity);
	    return function(t) {
	      start.h = h(t);
	      start.c = c(t);
	      start.l = l(t);
	      start.opacity = opacity(t);
	      return start + "";
	    };
	  }
	}

	var hcl$2 = hcl$1(hue);
	var hclLong = hcl$1(nogamma);

	function cubehelix$1(hue$$1) {
	  return (function cubehelixGamma(y) {
	    y = +y;

	    function cubehelix$$1(start, end) {
	      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
	          s = nogamma(start.s, end.s),
	          l = nogamma(start.l, end.l),
	          opacity = nogamma(start.opacity, end.opacity);
	      return function(t) {
	        start.h = h(t);
	        start.s = s(t);
	        start.l = l(Math.pow(t, y));
	        start.opacity = opacity(t);
	        return start + "";
	      };
	    }

	    cubehelix$$1.gamma = cubehelixGamma;

	    return cubehelix$$1;
	  })(1);
	}

	var cubehelix$2 = cubehelix$1(hue);
	var cubehelixLong = cubehelix$1(nogamma);

	function piecewise(interpolate, values) {
	  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
	  while (i < n) I[i] = interpolate(v, v = values[++i]);
	  return function(t) {
	    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
	    return I[i](t - i);
	  };
	}

	var quantize = function(interpolator, n) {
	  var samples = new Array(n);
	  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
	  return samples;
	};

	exports.interpolate = value;
	exports.interpolateArray = array;
	exports.interpolateBasis = basis$1;
	exports.interpolateBasisClosed = basisClosed;
	exports.interpolateDate = date;
	exports.interpolateNumber = number;
	exports.interpolateObject = object;
	exports.interpolateRound = round;
	exports.interpolateString = string;
	exports.interpolateTransformCss = interpolateTransformCss;
	exports.interpolateTransformSvg = interpolateTransformSvg;
	exports.interpolateZoom = zoom;
	exports.interpolateRgb = rgb$1;
	exports.interpolateRgbBasis = rgbBasis;
	exports.interpolateRgbBasisClosed = rgbBasisClosed;
	exports.interpolateHsl = hsl$2;
	exports.interpolateHslLong = hslLong;
	exports.interpolateLab = lab$1;
	exports.interpolateHcl = hcl$2;
	exports.interpolateHclLong = hclLong;
	exports.interpolateCubehelix = cubehelix$2;
	exports.interpolateCubehelixLong = cubehelixLong;
	exports.piecewise = piecewise;
	exports.quantize = quantize;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-color/ Version 1.2.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var define = function(constructor, factory, prototype) {
	  constructor.prototype = factory.prototype = prototype;
	  prototype.constructor = constructor;
	};

	function extend(parent, definition) {
	  var prototype = Object.create(parent.prototype);
	  for (var key in definition) prototype[key] = definition[key];
	  return prototype;
	}

	function Color() {}

	var darker = 0.7;
	var brighter = 1 / darker;

	var reI = "\\s*([+-]?\\d+)\\s*";
	var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
	var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
	var reHex3 = /^#([0-9a-f]{3})$/;
	var reHex6 = /^#([0-9a-f]{6})$/;
	var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
	var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
	var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
	var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
	var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
	var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

	var named = {
	  aliceblue: 0xf0f8ff,
	  antiquewhite: 0xfaebd7,
	  aqua: 0x00ffff,
	  aquamarine: 0x7fffd4,
	  azure: 0xf0ffff,
	  beige: 0xf5f5dc,
	  bisque: 0xffe4c4,
	  black: 0x000000,
	  blanchedalmond: 0xffebcd,
	  blue: 0x0000ff,
	  blueviolet: 0x8a2be2,
	  brown: 0xa52a2a,
	  burlywood: 0xdeb887,
	  cadetblue: 0x5f9ea0,
	  chartreuse: 0x7fff00,
	  chocolate: 0xd2691e,
	  coral: 0xff7f50,
	  cornflowerblue: 0x6495ed,
	  cornsilk: 0xfff8dc,
	  crimson: 0xdc143c,
	  cyan: 0x00ffff,
	  darkblue: 0x00008b,
	  darkcyan: 0x008b8b,
	  darkgoldenrod: 0xb8860b,
	  darkgray: 0xa9a9a9,
	  darkgreen: 0x006400,
	  darkgrey: 0xa9a9a9,
	  darkkhaki: 0xbdb76b,
	  darkmagenta: 0x8b008b,
	  darkolivegreen: 0x556b2f,
	  darkorange: 0xff8c00,
	  darkorchid: 0x9932cc,
	  darkred: 0x8b0000,
	  darksalmon: 0xe9967a,
	  darkseagreen: 0x8fbc8f,
	  darkslateblue: 0x483d8b,
	  darkslategray: 0x2f4f4f,
	  darkslategrey: 0x2f4f4f,
	  darkturquoise: 0x00ced1,
	  darkviolet: 0x9400d3,
	  deeppink: 0xff1493,
	  deepskyblue: 0x00bfff,
	  dimgray: 0x696969,
	  dimgrey: 0x696969,
	  dodgerblue: 0x1e90ff,
	  firebrick: 0xb22222,
	  floralwhite: 0xfffaf0,
	  forestgreen: 0x228b22,
	  fuchsia: 0xff00ff,
	  gainsboro: 0xdcdcdc,
	  ghostwhite: 0xf8f8ff,
	  gold: 0xffd700,
	  goldenrod: 0xdaa520,
	  gray: 0x808080,
	  green: 0x008000,
	  greenyellow: 0xadff2f,
	  grey: 0x808080,
	  honeydew: 0xf0fff0,
	  hotpink: 0xff69b4,
	  indianred: 0xcd5c5c,
	  indigo: 0x4b0082,
	  ivory: 0xfffff0,
	  khaki: 0xf0e68c,
	  lavender: 0xe6e6fa,
	  lavenderblush: 0xfff0f5,
	  lawngreen: 0x7cfc00,
	  lemonchiffon: 0xfffacd,
	  lightblue: 0xadd8e6,
	  lightcoral: 0xf08080,
	  lightcyan: 0xe0ffff,
	  lightgoldenrodyellow: 0xfafad2,
	  lightgray: 0xd3d3d3,
	  lightgreen: 0x90ee90,
	  lightgrey: 0xd3d3d3,
	  lightpink: 0xffb6c1,
	  lightsalmon: 0xffa07a,
	  lightseagreen: 0x20b2aa,
	  lightskyblue: 0x87cefa,
	  lightslategray: 0x778899,
	  lightslategrey: 0x778899,
	  lightsteelblue: 0xb0c4de,
	  lightyellow: 0xffffe0,
	  lime: 0x00ff00,
	  limegreen: 0x32cd32,
	  linen: 0xfaf0e6,
	  magenta: 0xff00ff,
	  maroon: 0x800000,
	  mediumaquamarine: 0x66cdaa,
	  mediumblue: 0x0000cd,
	  mediumorchid: 0xba55d3,
	  mediumpurple: 0x9370db,
	  mediumseagreen: 0x3cb371,
	  mediumslateblue: 0x7b68ee,
	  mediumspringgreen: 0x00fa9a,
	  mediumturquoise: 0x48d1cc,
	  mediumvioletred: 0xc71585,
	  midnightblue: 0x191970,
	  mintcream: 0xf5fffa,
	  mistyrose: 0xffe4e1,
	  moccasin: 0xffe4b5,
	  navajowhite: 0xffdead,
	  navy: 0x000080,
	  oldlace: 0xfdf5e6,
	  olive: 0x808000,
	  olivedrab: 0x6b8e23,
	  orange: 0xffa500,
	  orangered: 0xff4500,
	  orchid: 0xda70d6,
	  palegoldenrod: 0xeee8aa,
	  palegreen: 0x98fb98,
	  paleturquoise: 0xafeeee,
	  palevioletred: 0xdb7093,
	  papayawhip: 0xffefd5,
	  peachpuff: 0xffdab9,
	  peru: 0xcd853f,
	  pink: 0xffc0cb,
	  plum: 0xdda0dd,
	  powderblue: 0xb0e0e6,
	  purple: 0x800080,
	  rebeccapurple: 0x663399,
	  red: 0xff0000,
	  rosybrown: 0xbc8f8f,
	  royalblue: 0x4169e1,
	  saddlebrown: 0x8b4513,
	  salmon: 0xfa8072,
	  sandybrown: 0xf4a460,
	  seagreen: 0x2e8b57,
	  seashell: 0xfff5ee,
	  sienna: 0xa0522d,
	  silver: 0xc0c0c0,
	  skyblue: 0x87ceeb,
	  slateblue: 0x6a5acd,
	  slategray: 0x708090,
	  slategrey: 0x708090,
	  snow: 0xfffafa,
	  springgreen: 0x00ff7f,
	  steelblue: 0x4682b4,
	  tan: 0xd2b48c,
	  teal: 0x008080,
	  thistle: 0xd8bfd8,
	  tomato: 0xff6347,
	  turquoise: 0x40e0d0,
	  violet: 0xee82ee,
	  wheat: 0xf5deb3,
	  white: 0xffffff,
	  whitesmoke: 0xf5f5f5,
	  yellow: 0xffff00,
	  yellowgreen: 0x9acd32
	};

	define(Color, color, {
	  displayable: function() {
	    return this.rgb().displayable();
	  },
	  hex: function() {
	    return this.rgb().hex();
	  },
	  toString: function() {
	    return this.rgb() + "";
	  }
	});

	function color(format) {
	  var m;
	  format = (format + "").trim().toLowerCase();
	  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
	      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
	      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
	      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
	      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
	      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
	      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
	      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
	      : named.hasOwnProperty(format) ? rgbn(named[format])
	      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
	      : null;
	}

	function rgbn(n) {
	  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
	}

	function rgba(r, g, b, a) {
	  if (a <= 0) r = g = b = NaN;
	  return new Rgb(r, g, b, a);
	}

	function rgbConvert(o) {
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Rgb;
	  o = o.rgb();
	  return new Rgb(o.r, o.g, o.b, o.opacity);
	}

	function rgb(r, g, b, opacity) {
	  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
	}

	function Rgb(r, g, b, opacity) {
	  this.r = +r;
	  this.g = +g;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Rgb, rgb, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
	  },
	  rgb: function() {
	    return this;
	  },
	  displayable: function() {
	    return (0 <= this.r && this.r <= 255)
	        && (0 <= this.g && this.g <= 255)
	        && (0 <= this.b && this.b <= 255)
	        && (0 <= this.opacity && this.opacity <= 1);
	  },
	  hex: function() {
	    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
	  },
	  toString: function() {
	    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
	    return (a === 1 ? "rgb(" : "rgba(")
	        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
	        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
	        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
	        + (a === 1 ? ")" : ", " + a + ")");
	  }
	}));

	function hex(value) {
	  value = Math.max(0, Math.min(255, Math.round(value) || 0));
	  return (value < 16 ? "0" : "") + value.toString(16);
	}

	function hsla(h, s, l, a) {
	  if (a <= 0) h = s = l = NaN;
	  else if (l <= 0 || l >= 1) h = s = NaN;
	  else if (s <= 0) h = NaN;
	  return new Hsl(h, s, l, a);
	}

	function hslConvert(o) {
	  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Color)) o = color(o);
	  if (!o) return new Hsl;
	  if (o instanceof Hsl) return o;
	  o = o.rgb();
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      min = Math.min(r, g, b),
	      max = Math.max(r, g, b),
	      h = NaN,
	      s = max - min,
	      l = (max + min) / 2;
	  if (s) {
	    if (r === max) h = (g - b) / s + (g < b) * 6;
	    else if (g === max) h = (b - r) / s + 2;
	    else h = (r - g) / s + 4;
	    s /= l < 0.5 ? max + min : 2 - max - min;
	    h *= 60;
	  } else {
	    s = l > 0 && l < 1 ? 0 : h;
	  }
	  return new Hsl(h, s, l, o.opacity);
	}

	function hsl(h, s, l, opacity) {
	  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
	}

	function Hsl(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hsl, hsl, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Hsl(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = this.h % 360 + (this.h < 0) * 360,
	        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
	        l = this.l,
	        m2 = l + (l < 0.5 ? l : 1 - l) * s,
	        m1 = 2 * l - m2;
	    return new Rgb(
	      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
	      hsl2rgb(h, m1, m2),
	      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
	      this.opacity
	    );
	  },
	  displayable: function() {
	    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
	        && (0 <= this.l && this.l <= 1)
	        && (0 <= this.opacity && this.opacity <= 1);
	  }
	}));

	/* From FvD 13.37, CSS Color Module Level 3 */
	function hsl2rgb(h, m1, m2) {
	  return (h < 60 ? m1 + (m2 - m1) * h / 60
	      : h < 180 ? m2
	      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
	      : m1) * 255;
	}

	var deg2rad = Math.PI / 180;
	var rad2deg = 180 / Math.PI;

	// https://beta.observablehq.com/@mbostock/lab-and-rgb
	var K = 18;
	var Xn = 0.96422;
	var Yn = 1;
	var Zn = 0.82521;
	var t0 = 4 / 29;
	var t1 = 6 / 29;
	var t2 = 3 * t1 * t1;
	var t3 = t1 * t1 * t1;

	function labConvert(o) {
	  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
	  if (o instanceof Hcl) {
	    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
	    var h = o.h * deg2rad;
	    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
	  }
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = rgb2lrgb(o.r),
	      g = rgb2lrgb(o.g),
	      b = rgb2lrgb(o.b),
	      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
	  if (r === g && g === b) x = z = y; else {
	    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
	    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
	  }
	  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
	}

	function gray(l, opacity) {
	  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
	}

	function lab(l, a, b, opacity) {
	  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
	}

	function Lab(l, a, b, opacity) {
	  this.l = +l;
	  this.a = +a;
	  this.b = +b;
	  this.opacity = +opacity;
	}

	define(Lab, lab, extend(Color, {
	  brighter: function(k) {
	    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  darker: function(k) {
	    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
	  },
	  rgb: function() {
	    var y = (this.l + 16) / 116,
	        x = isNaN(this.a) ? y : y + this.a / 500,
	        z = isNaN(this.b) ? y : y - this.b / 200;
	    x = Xn * lab2xyz(x);
	    y = Yn * lab2xyz(y);
	    z = Zn * lab2xyz(z);
	    return new Rgb(
	      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
	      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
	      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
	      this.opacity
	    );
	  }
	}));

	function xyz2lab(t) {
	  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
	}

	function lab2xyz(t) {
	  return t > t1 ? t * t * t : t2 * (t - t0);
	}

	function lrgb2rgb(x) {
	  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
	}

	function rgb2lrgb(x) {
	  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
	}

	function hclConvert(o) {
	  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
	  if (!(o instanceof Lab)) o = labConvert(o);
	  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
	  var h = Math.atan2(o.b, o.a) * rad2deg;
	  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
	}

	function lch(l, c, h, opacity) {
	  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function hcl(h, c, l, opacity) {
	  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
	}

	function Hcl(h, c, l, opacity) {
	  this.h = +h;
	  this.c = +c;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Hcl, hcl, extend(Color, {
	  brighter: function(k) {
	    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
	  },
	  darker: function(k) {
	    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
	  },
	  rgb: function() {
	    return labConvert(this).rgb();
	  }
	}));

	var A = -0.14861;
	var B = +1.78277;
	var C = -0.29227;
	var D = -0.90649;
	var E = +1.97294;
	var ED = E * D;
	var EB = E * B;
	var BC_DA = B * C - D * A;

	function cubehelixConvert(o) {
	  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
	  if (!(o instanceof Rgb)) o = rgbConvert(o);
	  var r = o.r / 255,
	      g = o.g / 255,
	      b = o.b / 255,
	      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
	      bl = b - l,
	      k = (E * (g - l) - C * bl) / D,
	      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
	      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
	  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
	}

	function cubehelix(h, s, l, opacity) {
	  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
	}

	function Cubehelix(h, s, l, opacity) {
	  this.h = +h;
	  this.s = +s;
	  this.l = +l;
	  this.opacity = +opacity;
	}

	define(Cubehelix, cubehelix, extend(Color, {
	  brighter: function(k) {
	    k = k == null ? brighter : Math.pow(brighter, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  darker: function(k) {
	    k = k == null ? darker : Math.pow(darker, k);
	    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
	  },
	  rgb: function() {
	    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
	        l = +this.l,
	        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
	        cosh = Math.cos(h),
	        sinh = Math.sin(h);
	    return new Rgb(
	      255 * (l + a * (A * cosh + B * sinh)),
	      255 * (l + a * (C * cosh + D * sinh)),
	      255 * (l + a * (E * cosh)),
	      this.opacity
	    );
	  }
	}));

	exports.color = color;
	exports.rgb = rgb;
	exports.hsl = hsl;
	exports.lab = lab;
	exports.hcl = hcl;
	exports.lch = lch;
	exports.gray = gray;
	exports.cubehelix = cubehelix;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-transition/ Version 1.1.1. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(417), __webpack_require__(415), __webpack_require__(421), __webpack_require__(418), __webpack_require__(419), __webpack_require__(422)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Selection,d3Dispatch,d3Timer,d3Interpolate,d3Color,d3Ease) { 'use strict';

	var emptyOn = d3Dispatch.dispatch("start", "end", "interrupt");
	var emptyTween = [];

	var CREATED = 0;
	var SCHEDULED = 1;
	var STARTING = 2;
	var STARTED = 3;
	var RUNNING = 4;
	var ENDING = 5;
	var ENDED = 6;

	var schedule = function(node, name, id, index, group, timing) {
	  var schedules = node.__transition;
	  if (!schedules) node.__transition = {};
	  else if (id in schedules) return;
	  create(node, id, {
	    name: name,
	    index: index, // For context during callback.
	    group: group, // For context during callback.
	    on: emptyOn,
	    tween: emptyTween,
	    time: timing.time,
	    delay: timing.delay,
	    duration: timing.duration,
	    ease: timing.ease,
	    timer: null,
	    state: CREATED
	  });
	};

	function init(node, id) {
	  var schedule = get(node, id);
	  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
	  return schedule;
	}

	function set(node, id) {
	  var schedule = get(node, id);
	  if (schedule.state > STARTING) throw new Error("too late; already started");
	  return schedule;
	}

	function get(node, id) {
	  var schedule = node.__transition;
	  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
	  return schedule;
	}

	function create(node, id, self) {
	  var schedules = node.__transition,
	      tween;

	  // Initialize the self timer when the transition is created.
	  // Note the actual delay is not known until the first callback!
	  schedules[id] = self;
	  self.timer = d3Timer.timer(schedule, 0, self.time);

	  function schedule(elapsed) {
	    self.state = SCHEDULED;
	    self.timer.restart(start, self.delay, self.time);

	    // If the elapsed delay is less than our first sleep, start immediately.
	    if (self.delay <= elapsed) start(elapsed - self.delay);
	  }

	  function start(elapsed) {
	    var i, j, n, o;

	    // If the state is not SCHEDULED, then we previously errored on start.
	    if (self.state !== SCHEDULED) return stop();

	    for (i in schedules) {
	      o = schedules[i];
	      if (o.name !== self.name) continue;

	      // While this element already has a starting transition during this frame,
	      // defer starting an interrupting transition until that transition has a
	      // chance to tick (and possibly end); see d3/d3-transition#54!
	      if (o.state === STARTED) return d3Timer.timeout(start);

	      // Interrupt the active transition, if any.
	      // Dispatch the interrupt event.
	      if (o.state === RUNNING) {
	        o.state = ENDED;
	        o.timer.stop();
	        o.on.call("interrupt", node, node.__data__, o.index, o.group);
	        delete schedules[i];
	      }

	      // Cancel any pre-empted transitions. No interrupt event is dispatched
	      // because the cancelled transitions never started. Note that this also
	      // removes this transition from the pending list!
	      else if (+i < id) {
	        o.state = ENDED;
	        o.timer.stop();
	        delete schedules[i];
	      }
	    }

	    // Defer the first tick to end of the current frame; see d3/d3#1576.
	    // Note the transition may be canceled after start and before the first tick!
	    // Note this must be scheduled before the start event; see d3/d3-transition#16!
	    // Assuming this is successful, subsequent callbacks go straight to tick.
	    d3Timer.timeout(function() {
	      if (self.state === STARTED) {
	        self.state = RUNNING;
	        self.timer.restart(tick, self.delay, self.time);
	        tick(elapsed);
	      }
	    });

	    // Dispatch the start event.
	    // Note this must be done before the tween are initialized.
	    self.state = STARTING;
	    self.on.call("start", node, node.__data__, self.index, self.group);
	    if (self.state !== STARTING) return; // interrupted
	    self.state = STARTED;

	    // Initialize the tween, deleting null tween.
	    tween = new Array(n = self.tween.length);
	    for (i = 0, j = -1; i < n; ++i) {
	      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
	        tween[++j] = o;
	      }
	    }
	    tween.length = j + 1;
	  }

	  function tick(elapsed) {
	    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
	        i = -1,
	        n = tween.length;

	    while (++i < n) {
	      tween[i].call(null, t);
	    }

	    // Dispatch the end event.
	    if (self.state === ENDING) {
	      self.on.call("end", node, node.__data__, self.index, self.group);
	      stop();
	    }
	  }

	  function stop() {
	    self.state = ENDED;
	    self.timer.stop();
	    delete schedules[id];
	    for (var i in schedules) return; // eslint-disable-line no-unused-vars
	    delete node.__transition;
	  }
	}

	var interrupt = function(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      active,
	      empty = true,
	      i;

	  if (!schedules) return;

	  name = name == null ? null : name + "";

	  for (i in schedules) {
	    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
	    active = schedule.state > STARTING && schedule.state < ENDING;
	    schedule.state = ENDED;
	    schedule.timer.stop();
	    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
	    delete schedules[i];
	  }

	  if (empty) delete node.__transition;
	};

	var selection_interrupt = function(name) {
	  return this.each(function() {
	    interrupt(this, name);
	  });
	};

	function tweenRemove(id, name) {
	  var tween0, tween1;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = tween0 = tween;
	      for (var i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1 = tween1.slice();
	          tween1.splice(i, 1);
	          break;
	        }
	      }
	    }

	    schedule.tween = tween1;
	  };
	}

	function tweenFunction(id, name, value) {
	  var tween0, tween1;
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    var schedule = set(this, id),
	        tween = schedule.tween;

	    // If this node shared tween with the previous node,
	    // just assign the updated shared tween and we’re done!
	    // Otherwise, copy-on-write.
	    if (tween !== tween0) {
	      tween1 = (tween0 = tween).slice();
	      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
	        if (tween1[i].name === name) {
	          tween1[i] = t;
	          break;
	        }
	      }
	      if (i === n) tween1.push(t);
	    }

	    schedule.tween = tween1;
	  };
	}

	var transition_tween = function(name, value) {
	  var id = this._id;

	  name += "";

	  if (arguments.length < 2) {
	    var tween = get(this.node(), id).tween;
	    for (var i = 0, n = tween.length, t; i < n; ++i) {
	      if ((t = tween[i]).name === name) {
	        return t.value;
	      }
	    }
	    return null;
	  }

	  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
	};

	function tweenValue(transition, name, value) {
	  var id = transition._id;

	  transition.each(function() {
	    var schedule = set(this, id);
	    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
	  });

	  return function(node) {
	    return get(node, id).value[name];
	  };
	}

	var interpolate = function(a, b) {
	  var c;
	  return (typeof b === "number" ? d3Interpolate.interpolateNumber
	      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
	      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
	      : d3Interpolate.interpolateString)(a, b);
	};

	function attrRemove(name) {
	  return function() {
	    this.removeAttribute(name);
	  };
	}

	function attrRemoveNS(fullname) {
	  return function() {
	    this.removeAttributeNS(fullname.space, fullname.local);
	  };
	}

	function attrConstant(name, interpolate$$1, value1) {
	  var value00,
	      interpolate0;
	  return function() {
	    var value0 = this.getAttribute(name);
	    return value0 === value1 ? null
	        : value0 === value00 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value1);
	  };
	}

	function attrConstantNS(fullname, interpolate$$1, value1) {
	  var value00,
	      interpolate0;
	  return function() {
	    var value0 = this.getAttributeNS(fullname.space, fullname.local);
	    return value0 === value1 ? null
	        : value0 === value00 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value1);
	  };
	}

	function attrFunction(name, interpolate$$1, value) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0, value1 = value(this);
	    if (value1 == null) return void this.removeAttribute(name);
	    value0 = this.getAttribute(name);
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	function attrFunctionNS(fullname, interpolate$$1, value) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0, value1 = value(this);
	    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
	    value0 = this.getAttributeNS(fullname.space, fullname.local);
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	var transition_attr = function(name, value) {
	  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
	  return this.attrTween(name, typeof value === "function"
	      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
	      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
	      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
	};

	function attrTweenNS(fullname, value) {
	  function tween() {
	    var node = this, i = value.apply(node, arguments);
	    return i && function(t) {
	      node.setAttributeNS(fullname.space, fullname.local, i(t));
	    };
	  }
	  tween._value = value;
	  return tween;
	}

	function attrTween(name, value) {
	  function tween() {
	    var node = this, i = value.apply(node, arguments);
	    return i && function(t) {
	      node.setAttribute(name, i(t));
	    };
	  }
	  tween._value = value;
	  return tween;
	}

	var transition_attrTween = function(name, value) {
	  var key = "attr." + name;
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  var fullname = d3Selection.namespace(name);
	  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
	};

	function delayFunction(id, value) {
	  return function() {
	    init(this, id).delay = +value.apply(this, arguments);
	  };
	}

	function delayConstant(id, value) {
	  return value = +value, function() {
	    init(this, id).delay = value;
	  };
	}

	var transition_delay = function(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? delayFunction
	          : delayConstant)(id, value))
	      : get(this.node(), id).delay;
	};

	function durationFunction(id, value) {
	  return function() {
	    set(this, id).duration = +value.apply(this, arguments);
	  };
	}

	function durationConstant(id, value) {
	  return value = +value, function() {
	    set(this, id).duration = value;
	  };
	}

	var transition_duration = function(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each((typeof value === "function"
	          ? durationFunction
	          : durationConstant)(id, value))
	      : get(this.node(), id).duration;
	};

	function easeConstant(id, value) {
	  if (typeof value !== "function") throw new Error;
	  return function() {
	    set(this, id).ease = value;
	  };
	}

	var transition_ease = function(value) {
	  var id = this._id;

	  return arguments.length
	      ? this.each(easeConstant(id, value))
	      : get(this.node(), id).ease;
	};

	var transition_filter = function(match) {
	  if (typeof match !== "function") match = d3Selection.matcher(match);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
	      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
	        subgroup.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, this._name, this._id);
	};

	var transition_merge = function(transition) {
	  if (transition._id !== this._id) throw new Error;

	  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
	    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
	      if (node = group0[i] || group1[i]) {
	        merge[i] = node;
	      }
	    }
	  }

	  for (; j < m0; ++j) {
	    merges[j] = groups0[j];
	  }

	  return new Transition(merges, this._parents, this._name, this._id);
	};

	function start(name) {
	  return (name + "").trim().split(/^|\s+/).every(function(t) {
	    var i = t.indexOf(".");
	    if (i >= 0) t = t.slice(0, i);
	    return !t || t === "start";
	  });
	}

	function onFunction(id, name, listener) {
	  var on0, on1, sit = start(name) ? init : set;
	  return function() {
	    var schedule = sit(this, id),
	        on = schedule.on;

	    // If this node shared a dispatch with the previous node,
	    // just assign the updated shared dispatch and we’re done!
	    // Otherwise, copy-on-write.
	    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

	    schedule.on = on1;
	  };
	}

	var transition_on = function(name, listener) {
	  var id = this._id;

	  return arguments.length < 2
	      ? get(this.node(), id).on.on(name)
	      : this.each(onFunction(id, name, listener));
	};

	function removeFunction(id) {
	  return function() {
	    var parent = this.parentNode;
	    for (var i in this.__transition) if (+i !== id) return;
	    if (parent) parent.removeChild(this);
	  };
	}

	var transition_remove = function() {
	  return this.on("end.remove", removeFunction(this._id));
	};

	var transition_select = function(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = d3Selection.selector(select);

	  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
	      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
	        if ("__data__" in node) subnode.__data__ = node.__data__;
	        subgroup[i] = subnode;
	        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
	      }
	    }
	  }

	  return new Transition(subgroups, this._parents, name, id);
	};

	var transition_selectAll = function(select) {
	  var name = this._name,
	      id = this._id;

	  if (typeof select !== "function") select = d3Selection.selectorAll(select);

	  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
	          if (child = children[k]) {
	            schedule(child, name, id, k, children, inherit);
	          }
	        }
	        subgroups.push(children);
	        parents.push(node);
	      }
	    }
	  }

	  return new Transition(subgroups, parents, name, id);
	};

	var Selection = d3Selection.selection.prototype.constructor;

	var transition_selection = function() {
	  return new Selection(this._groups, this._parents);
	};

	function styleRemove(name, interpolate$$1) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0 = d3Selection.style(this, name),
	        value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	function styleRemoveEnd(name) {
	  return function() {
	    this.style.removeProperty(name);
	  };
	}

	function styleConstant(name, interpolate$$1, value1) {
	  var value00,
	      interpolate0;
	  return function() {
	    var value0 = d3Selection.style(this, name);
	    return value0 === value1 ? null
	        : value0 === value00 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value1);
	  };
	}

	function styleFunction(name, interpolate$$1, value) {
	  var value00,
	      value10,
	      interpolate0;
	  return function() {
	    var value0 = d3Selection.style(this, name),
	        value1 = value(this);
	    if (value1 == null) value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
	    return value0 === value1 ? null
	        : value0 === value00 && value1 === value10 ? interpolate0
	        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
	  };
	}

	var transition_style = function(name, value, priority) {
	  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
	  return value == null ? this
	          .styleTween(name, styleRemove(name, i))
	          .on("end.style." + name, styleRemoveEnd(name))
	      : this.styleTween(name, typeof value === "function"
	          ? styleFunction(name, i, tweenValue(this, "style." + name, value))
	          : styleConstant(name, i, value + ""), priority);
	};

	function styleTween(name, value, priority) {
	  function tween() {
	    var node = this, i = value.apply(node, arguments);
	    return i && function(t) {
	      node.style.setProperty(name, i(t), priority);
	    };
	  }
	  tween._value = value;
	  return tween;
	}

	var transition_styleTween = function(name, value, priority) {
	  var key = "style." + (name += "");
	  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
	  if (value == null) return this.tween(key, null);
	  if (typeof value !== "function") throw new Error;
	  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
	};

	function textConstant(value) {
	  return function() {
	    this.textContent = value;
	  };
	}

	function textFunction(value) {
	  return function() {
	    var value1 = value(this);
	    this.textContent = value1 == null ? "" : value1;
	  };
	}

	var transition_text = function(value) {
	  return this.tween("text", typeof value === "function"
	      ? textFunction(tweenValue(this, "text", value))
	      : textConstant(value == null ? "" : value + ""));
	};

	var transition_transition = function() {
	  var name = this._name,
	      id0 = this._id,
	      id1 = newId();

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        var inherit = get(node, id0);
	        schedule(node, name, id1, i, group, {
	          time: inherit.time + inherit.delay + inherit.duration,
	          delay: 0,
	          duration: inherit.duration,
	          ease: inherit.ease
	        });
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id1);
	};

	var id = 0;

	function Transition(groups, parents, name, id) {
	  this._groups = groups;
	  this._parents = parents;
	  this._name = name;
	  this._id = id;
	}

	function transition(name) {
	  return d3Selection.selection().transition(name);
	}

	function newId() {
	  return ++id;
	}

	var selection_prototype = d3Selection.selection.prototype;

	Transition.prototype = transition.prototype = {
	  constructor: Transition,
	  select: transition_select,
	  selectAll: transition_selectAll,
	  filter: transition_filter,
	  merge: transition_merge,
	  selection: transition_selection,
	  transition: transition_transition,
	  call: selection_prototype.call,
	  nodes: selection_prototype.nodes,
	  node: selection_prototype.node,
	  size: selection_prototype.size,
	  empty: selection_prototype.empty,
	  each: selection_prototype.each,
	  on: transition_on,
	  attr: transition_attr,
	  attrTween: transition_attrTween,
	  style: transition_style,
	  styleTween: transition_styleTween,
	  text: transition_text,
	  remove: transition_remove,
	  tween: transition_tween,
	  delay: transition_delay,
	  duration: transition_duration,
	  ease: transition_ease
	};

	var defaultTiming = {
	  time: null, // Set on use.
	  delay: 0,
	  duration: 250,
	  ease: d3Ease.easeCubicInOut
	};

	function inherit(node, id) {
	  var timing;
	  while (!(timing = node.__transition) || !(timing = timing[id])) {
	    if (!(node = node.parentNode)) {
	      return defaultTiming.time = d3Timer.now(), defaultTiming;
	    }
	  }
	  return timing;
	}

	var selection_transition = function(name) {
	  var id,
	      timing;

	  if (name instanceof Transition) {
	    id = name._id, name = name._name;
	  } else {
	    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
	  }

	  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
	    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
	      if (node = group[i]) {
	        schedule(node, name, id, i, group, timing || inherit(node, id));
	      }
	    }
	  }

	  return new Transition(groups, this._parents, name, id);
	};

	d3Selection.selection.prototype.interrupt = selection_interrupt;
	d3Selection.selection.prototype.transition = selection_transition;

	var root = [null];

	var active = function(node, name) {
	  var schedules = node.__transition,
	      schedule,
	      i;

	  if (schedules) {
	    name = name == null ? null : name + "";
	    for (i in schedules) {
	      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
	        return new Transition([[node]], root, name, +i);
	      }
	    }
	  }

	  return null;
	};

	exports.transition = transition;
	exports.active = active;
	exports.interrupt = interrupt;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-timer/ Version 1.0.7. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var frame = 0;
	var timeout = 0;
	var interval = 0;
	var pokeDelay = 1000;
	var taskHead;
	var taskTail;
	var clockLast = 0;
	var clockNow = 0;
	var clockSkew = 0;
	var clock = typeof performance === "object" && performance.now ? performance : Date;
	var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

	function now() {
	  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
	}

	function clearNow() {
	  clockNow = 0;
	}

	function Timer() {
	  this._call =
	  this._time =
	  this._next = null;
	}

	Timer.prototype = timer.prototype = {
	  constructor: Timer,
	  restart: function(callback, delay, time) {
	    if (typeof callback !== "function") throw new TypeError("callback is not a function");
	    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
	    if (!this._next && taskTail !== this) {
	      if (taskTail) taskTail._next = this;
	      else taskHead = this;
	      taskTail = this;
	    }
	    this._call = callback;
	    this._time = time;
	    sleep();
	  },
	  stop: function() {
	    if (this._call) {
	      this._call = null;
	      this._time = Infinity;
	      sleep();
	    }
	  }
	};

	function timer(callback, delay, time) {
	  var t = new Timer;
	  t.restart(callback, delay, time);
	  return t;
	}

	function timerFlush() {
	  now(); // Get the current time, if not already set.
	  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
	  var t = taskHead, e;
	  while (t) {
	    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
	    t = t._next;
	  }
	  --frame;
	}

	function wake() {
	  clockNow = (clockLast = clock.now()) + clockSkew;
	  frame = timeout = 0;
	  try {
	    timerFlush();
	  } finally {
	    frame = 0;
	    nap();
	    clockNow = 0;
	  }
	}

	function poke() {
	  var now = clock.now(), delay = now - clockLast;
	  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
	}

	function nap() {
	  var t0, t1 = taskHead, t2, time = Infinity;
	  while (t1) {
	    if (t1._call) {
	      if (time > t1._time) time = t1._time;
	      t0 = t1, t1 = t1._next;
	    } else {
	      t2 = t1._next, t1._next = null;
	      t1 = t0 ? t0._next = t2 : taskHead = t2;
	    }
	  }
	  taskTail = t0;
	  sleep(time);
	}

	function sleep(time) {
	  if (frame) return; // Soonest alarm already set, or will be.
	  if (timeout) timeout = clearTimeout(timeout);
	  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
	  if (delay > 24) {
	    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
	    if (interval) interval = clearInterval(interval);
	  } else {
	    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
	    frame = 1, setFrame(wake);
	  }
	}

	var timeout$1 = function(callback, delay, time) {
	  var t = new Timer;
	  delay = delay == null ? 0 : +delay;
	  t.restart(function(elapsed) {
	    t.stop();
	    callback(elapsed + delay);
	  }, delay, time);
	  return t;
	};

	var interval$1 = function(callback, delay, time) {
	  var t = new Timer, total = delay;
	  if (delay == null) return t.restart(callback, delay, time), t;
	  delay = +delay, time = time == null ? now() : +time;
	  t.restart(function tick(elapsed) {
	    elapsed += total;
	    t.restart(tick, total += delay, time);
	    callback(elapsed);
	  }, delay, time);
	  return t;
	};

	exports.now = now;
	exports.timer = timer;
	exports.timerFlush = timerFlush;
	exports.timeout = timeout$1;
	exports.interval = interval$1;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-ease/ Version 1.0.3. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function linear(t) {
	  return +t;
	}

	function quadIn(t) {
	  return t * t;
	}

	function quadOut(t) {
	  return t * (2 - t);
	}

	function quadInOut(t) {
	  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
	}

	function cubicIn(t) {
	  return t * t * t;
	}

	function cubicOut(t) {
	  return --t * t * t + 1;
	}

	function cubicInOut(t) {
	  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
	}

	var exponent = 3;

	var polyIn = (function custom(e) {
	  e = +e;

	  function polyIn(t) {
	    return Math.pow(t, e);
	  }

	  polyIn.exponent = custom;

	  return polyIn;
	})(exponent);

	var polyOut = (function custom(e) {
	  e = +e;

	  function polyOut(t) {
	    return 1 - Math.pow(1 - t, e);
	  }

	  polyOut.exponent = custom;

	  return polyOut;
	})(exponent);

	var polyInOut = (function custom(e) {
	  e = +e;

	  function polyInOut(t) {
	    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
	  }

	  polyInOut.exponent = custom;

	  return polyInOut;
	})(exponent);

	var pi = Math.PI;
	var halfPi = pi / 2;

	function sinIn(t) {
	  return 1 - Math.cos(t * halfPi);
	}

	function sinOut(t) {
	  return Math.sin(t * halfPi);
	}

	function sinInOut(t) {
	  return (1 - Math.cos(pi * t)) / 2;
	}

	function expIn(t) {
	  return Math.pow(2, 10 * t - 10);
	}

	function expOut(t) {
	  return 1 - Math.pow(2, -10 * t);
	}

	function expInOut(t) {
	  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
	}

	function circleIn(t) {
	  return 1 - Math.sqrt(1 - t * t);
	}

	function circleOut(t) {
	  return Math.sqrt(1 - --t * t);
	}

	function circleInOut(t) {
	  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
	}

	var b1 = 4 / 11;
	var b2 = 6 / 11;
	var b3 = 8 / 11;
	var b4 = 3 / 4;
	var b5 = 9 / 11;
	var b6 = 10 / 11;
	var b7 = 15 / 16;
	var b8 = 21 / 22;
	var b9 = 63 / 64;
	var b0 = 1 / b1 / b1;

	function bounceIn(t) {
	  return 1 - bounceOut(1 - t);
	}

	function bounceOut(t) {
	  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
	}

	function bounceInOut(t) {
	  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
	}

	var overshoot = 1.70158;

	var backIn = (function custom(s) {
	  s = +s;

	  function backIn(t) {
	    return t * t * ((s + 1) * t - s);
	  }

	  backIn.overshoot = custom;

	  return backIn;
	})(overshoot);

	var backOut = (function custom(s) {
	  s = +s;

	  function backOut(t) {
	    return --t * t * ((s + 1) * t + s) + 1;
	  }

	  backOut.overshoot = custom;

	  return backOut;
	})(overshoot);

	var backInOut = (function custom(s) {
	  s = +s;

	  function backInOut(t) {
	    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
	  }

	  backInOut.overshoot = custom;

	  return backInOut;
	})(overshoot);

	var tau = 2 * Math.PI;
	var amplitude = 1;
	var period = 0.3;

	var elasticIn = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticIn(t) {
	    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
	  }

	  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
	  elasticIn.period = function(p) { return custom(a, p); };

	  return elasticIn;
	})(amplitude, period);

	var elasticOut = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticOut(t) {
	    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
	  }

	  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
	  elasticOut.period = function(p) { return custom(a, p); };

	  return elasticOut;
	})(amplitude, period);

	var elasticInOut = (function custom(a, p) {
	  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

	  function elasticInOut(t) {
	    return ((t = t * 2 - 1) < 0
	        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
	        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
	  }

	  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
	  elasticInOut.period = function(p) { return custom(a, p); };

	  return elasticInOut;
	})(amplitude, period);

	exports.easeLinear = linear;
	exports.easeQuad = quadInOut;
	exports.easeQuadIn = quadIn;
	exports.easeQuadOut = quadOut;
	exports.easeQuadInOut = quadInOut;
	exports.easeCubic = cubicInOut;
	exports.easeCubicIn = cubicIn;
	exports.easeCubicOut = cubicOut;
	exports.easeCubicInOut = cubicInOut;
	exports.easePoly = polyInOut;
	exports.easePolyIn = polyIn;
	exports.easePolyOut = polyOut;
	exports.easePolyInOut = polyInOut;
	exports.easeSin = sinInOut;
	exports.easeSinIn = sinIn;
	exports.easeSinOut = sinOut;
	exports.easeSinInOut = sinInOut;
	exports.easeExp = expInOut;
	exports.easeExpIn = expIn;
	exports.easeExpOut = expOut;
	exports.easeExpInOut = expInOut;
	exports.easeCircle = circleInOut;
	exports.easeCircleIn = circleIn;
	exports.easeCircleOut = circleOut;
	exports.easeCircleInOut = circleInOut;
	exports.easeBounce = bounceOut;
	exports.easeBounceIn = bounceIn;
	exports.easeBounceOut = bounceOut;
	exports.easeBounceInOut = bounceInOut;
	exports.easeBack = backInOut;
	exports.easeBackIn = backIn;
	exports.easeBackOut = backOut;
	exports.easeBackInOut = backInOut;
	exports.easeElastic = elasticOut;
	exports.easeElasticIn = elasticIn;
	exports.easeElasticOut = elasticOut;
	exports.easeElasticInOut = elasticInOut;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-chord/ Version 1.0.4. Copyright 2017 Mike Bostock.
	(function (global, factory) {
	   true ? factory(exports, __webpack_require__(412), __webpack_require__(424)) :
	  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
	  (factory((global.d3 = global.d3 || {}),global.d3,global.d3));
	}(this, (function (exports,d3Array,d3Path) { 'use strict';

	var cos = Math.cos;
	var sin = Math.sin;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau = pi * 2;
	var max = Math.max;

	function compareValue(compare) {
	  return function(a, b) {
	    return compare(
	      a.source.value + a.target.value,
	      b.source.value + b.target.value
	    );
	  };
	}

	var chord = function() {
	  var padAngle = 0,
	      sortGroups = null,
	      sortSubgroups = null,
	      sortChords = null;

	  function chord(matrix) {
	    var n = matrix.length,
	        groupSums = [],
	        groupIndex = d3Array.range(n),
	        subgroupIndex = [],
	        chords = [],
	        groups = chords.groups = new Array(n),
	        subgroups = new Array(n * n),
	        k,
	        x,
	        x0,
	        dx,
	        i,
	        j;

	    // Compute the sum.
	    k = 0, i = -1; while (++i < n) {
	      x = 0, j = -1; while (++j < n) {
	        x += matrix[i][j];
	      }
	      groupSums.push(x);
	      subgroupIndex.push(d3Array.range(n));
	      k += x;
	    }

	    // Sort groups…
	    if (sortGroups) groupIndex.sort(function(a, b) {
	      return sortGroups(groupSums[a], groupSums[b]);
	    });

	    // Sort subgroups…
	    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
	      d.sort(function(a, b) {
	        return sortSubgroups(matrix[i][a], matrix[i][b]);
	      });
	    });

	    // Convert the sum to scaling factor for [0, 2pi].
	    // TODO Allow start and end angle to be specified?
	    // TODO Allow padding to be specified as percentage?
	    k = max(0, tau - padAngle * n) / k;
	    dx = k ? padAngle : tau / n;

	    // Compute the start and end angle for each group and subgroup.
	    // Note: Opera has a bug reordering object literal properties!
	    x = 0, i = -1; while (++i < n) {
	      x0 = x, j = -1; while (++j < n) {
	        var di = groupIndex[i],
	            dj = subgroupIndex[di][j],
	            v = matrix[di][dj],
	            a0 = x,
	            a1 = x += v * k;
	        subgroups[dj * n + di] = {
	          index: di,
	          subindex: dj,
	          startAngle: a0,
	          endAngle: a1,
	          value: v
	        };
	      }
	      groups[di] = {
	        index: di,
	        startAngle: x0,
	        endAngle: x,
	        value: groupSums[di]
	      };
	      x += dx;
	    }

	    // Generate chords for each (non-empty) subgroup-subgroup link.
	    i = -1; while (++i < n) {
	      j = i - 1; while (++j < n) {
	        var source = subgroups[j * n + i],
	            target = subgroups[i * n + j];
	        if (source.value || target.value) {
	          chords.push(source.value < target.value
	              ? {source: target, target: source}
	              : {source: source, target: target});
	        }
	      }
	    }

	    return sortChords ? chords.sort(sortChords) : chords;
	  }

	  chord.padAngle = function(_) {
	    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
	  };

	  chord.sortGroups = function(_) {
	    return arguments.length ? (sortGroups = _, chord) : sortGroups;
	  };

	  chord.sortSubgroups = function(_) {
	    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
	  };

	  chord.sortChords = function(_) {
	    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
	  };

	  return chord;
	};

	var slice = Array.prototype.slice;

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	function defaultSource(d) {
	  return d.source;
	}

	function defaultTarget(d) {
	  return d.target;
	}

	function defaultRadius(d) {
	  return d.radius;
	}

	function defaultStartAngle(d) {
	  return d.startAngle;
	}

	function defaultEndAngle(d) {
	  return d.endAngle;
	}

	var ribbon = function() {
	  var source = defaultSource,
	      target = defaultTarget,
	      radius = defaultRadius,
	      startAngle = defaultStartAngle,
	      endAngle = defaultEndAngle,
	      context = null;

	  function ribbon() {
	    var buffer,
	        argv = slice.call(arguments),
	        s = source.apply(this, argv),
	        t = target.apply(this, argv),
	        sr = +radius.apply(this, (argv[0] = s, argv)),
	        sa0 = startAngle.apply(this, argv) - halfPi,
	        sa1 = endAngle.apply(this, argv) - halfPi,
	        sx0 = sr * cos(sa0),
	        sy0 = sr * sin(sa0),
	        tr = +radius.apply(this, (argv[0] = t, argv)),
	        ta0 = startAngle.apply(this, argv) - halfPi,
	        ta1 = endAngle.apply(this, argv) - halfPi;

	    if (!context) context = buffer = d3Path.path();

	    context.moveTo(sx0, sy0);
	    context.arc(0, 0, sr, sa0, sa1);
	    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
	      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
	      context.arc(0, 0, tr, ta0, ta1);
	    }
	    context.quadraticCurveTo(0, 0, sx0, sy0);
	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  ribbon.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
	  };

	  ribbon.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
	  };

	  ribbon.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
	  };

	  ribbon.source = function(_) {
	    return arguments.length ? (source = _, ribbon) : source;
	  };

	  ribbon.target = function(_) {
	    return arguments.length ? (target = _, ribbon) : target;
	  };

	  ribbon.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
	  };

	  return ribbon;
	};

	exports.chord = chord;
	exports.ribbon = ribbon;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-path/ Version 1.0.5. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var pi = Math.PI;
	var tau = 2 * pi;
	var epsilon = 1e-6;
	var tauEpsilon = tau - epsilon;

	function Path() {
	  this._x0 = this._y0 = // start of current subpath
	  this._x1 = this._y1 = null; // end of current subpath
	  this._ = "";
	}

	function path() {
	  return new Path;
	}

	Path.prototype = path.prototype = {
	  constructor: Path,
	  moveTo: function(x, y) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
	  },
	  closePath: function() {
	    if (this._x1 !== null) {
	      this._x1 = this._x0, this._y1 = this._y0;
	      this._ += "Z";
	    }
	  },
	  lineTo: function(x, y) {
	    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  quadraticCurveTo: function(x1, y1, x, y) {
	    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
	    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
	  },
	  arcTo: function(x1, y1, x2, y2, r) {
	    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
	    var x0 = this._x1,
	        y0 = this._y1,
	        x21 = x2 - x1,
	        y21 = y2 - y1,
	        x01 = x0 - x1,
	        y01 = y0 - y1,
	        l01_2 = x01 * x01 + y01 * y01;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x1,y1).
	    if (this._x1 === null) {
	      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
	    else if (!(l01_2 > epsilon)) {}

	    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
	    // Equivalently, is (x1,y1) coincident with (x2,y2)?
	    // Or, is the radius zero? Line to (x1,y1).
	    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
	      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
	    }

	    // Otherwise, draw an arc!
	    else {
	      var x20 = x2 - x0,
	          y20 = y2 - y0,
	          l21_2 = x21 * x21 + y21 * y21,
	          l20_2 = x20 * x20 + y20 * y20,
	          l21 = Math.sqrt(l21_2),
	          l01 = Math.sqrt(l01_2),
	          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
	          t01 = l / l01,
	          t21 = l / l21;

	      // If the start tangent is not coincident with (x0,y0), line to.
	      if (Math.abs(t01 - 1) > epsilon) {
	        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
	      }

	      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
	    }
	  },
	  arc: function(x, y, r, a0, a1, ccw) {
	    x = +x, y = +y, r = +r;
	    var dx = r * Math.cos(a0),
	        dy = r * Math.sin(a0),
	        x0 = x + dx,
	        y0 = y + dy,
	        cw = 1 ^ ccw,
	        da = ccw ? a0 - a1 : a1 - a0;

	    // Is the radius negative? Error.
	    if (r < 0) throw new Error("negative radius: " + r);

	    // Is this path empty? Move to (x0,y0).
	    if (this._x1 === null) {
	      this._ += "M" + x0 + "," + y0;
	    }

	    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
	    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
	      this._ += "L" + x0 + "," + y0;
	    }

	    // Is this arc empty? We’re done.
	    if (!r) return;

	    // Does the angle go the wrong way? Flip the direction.
	    if (da < 0) da = da % tau + tau;

	    // Is this a complete circle? Draw two arcs to complete the circle.
	    if (da > tauEpsilon) {
	      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
	    }

	    // Is this arc non-empty? Draw an arc!
	    else if (da > epsilon) {
	      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
	    }
	  },
	  rect: function(x, y, w, h) {
	    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
	  },
	  toString: function() {
	    return this._;
	  }
	};

	exports.path = path;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-collection/ Version 1.0.4. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var prefix = "$";

	function Map() {}

	Map.prototype = map.prototype = {
	  constructor: Map,
	  has: function(key) {
	    return (prefix + key) in this;
	  },
	  get: function(key) {
	    return this[prefix + key];
	  },
	  set: function(key, value) {
	    this[prefix + key] = value;
	    return this;
	  },
	  remove: function(key) {
	    var property = prefix + key;
	    return property in this && delete this[property];
	  },
	  clear: function() {
	    for (var property in this) if (property[0] === prefix) delete this[property];
	  },
	  keys: function() {
	    var keys = [];
	    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
	    return keys;
	  },
	  values: function() {
	    var values = [];
	    for (var property in this) if (property[0] === prefix) values.push(this[property]);
	    return values;
	  },
	  entries: function() {
	    var entries = [];
	    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
	    return entries;
	  },
	  size: function() {
	    var size = 0;
	    for (var property in this) if (property[0] === prefix) ++size;
	    return size;
	  },
	  empty: function() {
	    for (var property in this) if (property[0] === prefix) return false;
	    return true;
	  },
	  each: function(f) {
	    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
	  }
	};

	function map(object, f) {
	  var map = new Map;

	  // Copy constructor.
	  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

	  // Index array by numeric index or specified key function.
	  else if (Array.isArray(object)) {
	    var i = -1,
	        n = object.length,
	        o;

	    if (f == null) while (++i < n) map.set(i, object[i]);
	    else while (++i < n) map.set(f(o = object[i], i, object), o);
	  }

	  // Convert object to map.
	  else if (object) for (var key in object) map.set(key, object[key]);

	  return map;
	}

	var nest = function() {
	  var keys = [],
	      sortKeys = [],
	      sortValues,
	      rollup,
	      nest;

	  function apply(array, depth, createResult, setResult) {
	    if (depth >= keys.length) {
	      if (sortValues != null) array.sort(sortValues);
	      return rollup != null ? rollup(array) : array;
	    }

	    var i = -1,
	        n = array.length,
	        key = keys[depth++],
	        keyValue,
	        value,
	        valuesByKey = map(),
	        values,
	        result = createResult();

	    while (++i < n) {
	      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
	        values.push(value);
	      } else {
	        valuesByKey.set(keyValue, [value]);
	      }
	    }

	    valuesByKey.each(function(values, key) {
	      setResult(result, key, apply(values, depth, createResult, setResult));
	    });

	    return result;
	  }

	  function entries(map$$1, depth) {
	    if (++depth > keys.length) return map$$1;
	    var array, sortKey = sortKeys[depth - 1];
	    if (rollup != null && depth >= keys.length) array = map$$1.entries();
	    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
	    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
	  }

	  return nest = {
	    object: function(array) { return apply(array, 0, createObject, setObject); },
	    map: function(array) { return apply(array, 0, createMap, setMap); },
	    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
	    key: function(d) { keys.push(d); return nest; },
	    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
	    sortValues: function(order) { sortValues = order; return nest; },
	    rollup: function(f) { rollup = f; return nest; }
	  };
	};

	function createObject() {
	  return {};
	}

	function setObject(object, key, value) {
	  object[key] = value;
	}

	function createMap() {
	  return map();
	}

	function setMap(map$$1, key, value) {
	  map$$1.set(key, value);
	}

	function Set() {}

	var proto = map.prototype;

	Set.prototype = set.prototype = {
	  constructor: Set,
	  has: proto.has,
	  add: function(value) {
	    value += "";
	    this[prefix + value] = value;
	    return this;
	  },
	  remove: proto.remove,
	  clear: proto.clear,
	  values: proto.keys,
	  size: proto.size,
	  empty: proto.empty,
	  each: proto.each
	};

	function set(object, f) {
	  var set = new Set;

	  // Copy constructor.
	  if (object instanceof Set) object.each(function(value) { set.add(value); });

	  // Otherwise, assume it’s an array.
	  else if (object) {
	    var i = -1, n = object.length;
	    if (f == null) while (++i < n) set.add(object[i]);
	    else while (++i < n) set.add(f(object[i], i, object));
	  }

	  return set;
	}

	var keys = function(map) {
	  var keys = [];
	  for (var key in map) keys.push(key);
	  return keys;
	};

	var values = function(map) {
	  var values = [];
	  for (var key in map) values.push(map[key]);
	  return values;
	};

	var entries = function(map) {
	  var entries = [];
	  for (var key in map) entries.push({key: key, value: map[key]});
	  return entries;
	};

	exports.nest = nest;
	exports.set = set;
	exports.map = map;
	exports.keys = keys;
	exports.values = values;
	exports.entries = entries;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-contour/ Version 1.2.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(412)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Array) { 'use strict';

	var array = Array.prototype;

	var slice = array.slice;

	var ascending = function(a, b) {
	  return a - b;
	};

	var area = function(ring) {
	  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
	  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
	  return area;
	};

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	var contains = function(ring, hole) {
	  var i = -1, n = hole.length, c;
	  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
	  return 0;
	};

	function ringContains(ring, point) {
	  var x = point[0], y = point[1], contains = -1;
	  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
	    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
	    if (segmentContains(pi, pj, point)) return 0;
	    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
	  }
	  return contains;
	}

	function segmentContains(a, b, c) {
	  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
	}

	function collinear(a, b, c) {
	  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
	}

	function within(p, q, r) {
	  return p <= q && q <= r || r <= q && q <= p;
	}

	var noop = function() {};

	var cases = [
	  [],
	  [[[1.0, 1.5], [0.5, 1.0]]],
	  [[[1.5, 1.0], [1.0, 1.5]]],
	  [[[1.5, 1.0], [0.5, 1.0]]],
	  [[[1.0, 0.5], [1.5, 1.0]]],
	  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
	  [[[1.0, 0.5], [1.0, 1.5]]],
	  [[[1.0, 0.5], [0.5, 1.0]]],
	  [[[0.5, 1.0], [1.0, 0.5]]],
	  [[[1.0, 1.5], [1.0, 0.5]]],
	  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
	  [[[1.5, 1.0], [1.0, 0.5]]],
	  [[[0.5, 1.0], [1.5, 1.0]]],
	  [[[1.0, 1.5], [1.5, 1.0]]],
	  [[[0.5, 1.0], [1.0, 1.5]]],
	  []
	];

	var contours = function() {
	  var dx = 1,
	      dy = 1,
	      threshold = d3Array.thresholdSturges,
	      smooth = smoothLinear;

	  function contours(values) {
	    var tz = threshold(values);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
	      tz = d3Array.tickStep(start, stop, tz);
	      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
	    } else {
	      tz = tz.slice().sort(ascending);
	    }

	    return tz.map(function(value) {
	      return contour(values, value);
	    });
	  }

	  // Accumulate, smooth contour rings, assign holes to exterior rings.
	  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
	  function contour(values, value) {
	    var polygons = [],
	        holes = [];

	    isorings(values, value, function(ring) {
	      smooth(ring, values, value);
	      if (area(ring) > 0) polygons.push([ring]);
	      else holes.push(ring);
	    });

	    holes.forEach(function(hole) {
	      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
	        if (contains((polygon = polygons[i])[0], hole) !== -1) {
	          polygon.push(hole);
	          return;
	        }
	      }
	    });

	    return {
	      type: "MultiPolygon",
	      value: value,
	      coordinates: polygons
	    };
	  }

	  // Marching squares with isolines stitched into rings.
	  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
	  function isorings(values, value, callback) {
	    var fragmentByStart = new Array,
	        fragmentByEnd = new Array,
	        x, y, t0, t1, t2, t3;

	    // Special case for the first row (y = -1, t2 = t3 = 0).
	    x = y = -1;
	    t1 = values[0] >= value;
	    cases[t1 << 1].forEach(stitch);
	    while (++x < dx - 1) {
	      t0 = t1, t1 = values[x + 1] >= value;
	      cases[t0 | t1 << 1].forEach(stitch);
	    }
	    cases[t1 << 0].forEach(stitch);

	    // General case for the intermediate rows.
	    while (++y < dy - 1) {
	      x = -1;
	      t1 = values[y * dx + dx] >= value;
	      t2 = values[y * dx] >= value;
	      cases[t1 << 1 | t2 << 2].forEach(stitch);
	      while (++x < dx - 1) {
	        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
	        t3 = t2, t2 = values[y * dx + x + 1] >= value;
	        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
	      }
	      cases[t1 | t2 << 3].forEach(stitch);
	    }

	    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
	    x = -1;
	    t2 = values[y * dx] >= value;
	    cases[t2 << 2].forEach(stitch);
	    while (++x < dx - 1) {
	      t3 = t2, t2 = values[y * dx + x + 1] >= value;
	      cases[t2 << 2 | t3 << 3].forEach(stitch);
	    }
	    cases[t2 << 3].forEach(stitch);

	    function stitch(line) {
	      var start = [line[0][0] + x, line[0][1] + y],
	          end = [line[1][0] + x, line[1][1] + y],
	          startIndex = index(start),
	          endIndex = index(end),
	          f, g;
	      if (f = fragmentByEnd[startIndex]) {
	        if (g = fragmentByStart[endIndex]) {
	          delete fragmentByEnd[f.end];
	          delete fragmentByStart[g.start];
	          if (f === g) {
	            f.ring.push(end);
	            callback(f.ring);
	          } else {
	            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
	          }
	        } else {
	          delete fragmentByEnd[f.end];
	          f.ring.push(end);
	          fragmentByEnd[f.end = endIndex] = f;
	        }
	      } else if (f = fragmentByStart[endIndex]) {
	        if (g = fragmentByEnd[startIndex]) {
	          delete fragmentByStart[f.start];
	          delete fragmentByEnd[g.end];
	          if (f === g) {
	            f.ring.push(end);
	            callback(f.ring);
	          } else {
	            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
	          }
	        } else {
	          delete fragmentByStart[f.start];
	          f.ring.unshift(start);
	          fragmentByStart[f.start = startIndex] = f;
	        }
	      } else {
	        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
	      }
	    }
	  }

	  function index(point) {
	    return point[0] * 2 + point[1] * (dx + 1) * 4;
	  }

	  function smoothLinear(ring, values, value) {
	    ring.forEach(function(point) {
	      var x = point[0],
	          y = point[1],
	          xt = x | 0,
	          yt = y | 0,
	          v0,
	          v1 = values[yt * dx + xt];
	      if (x > 0 && x < dx && xt === x) {
	        v0 = values[yt * dx + xt - 1];
	        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
	      }
	      if (y > 0 && y < dy && yt === y) {
	        v0 = values[(yt - 1) * dx + xt];
	        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
	      }
	    });
	  }

	  contours.contour = contour;

	  contours.size = function(_) {
	    if (!arguments.length) return [dx, dy];
	    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
	    return dx = _0, dy = _1, contours;
	  };

	  contours.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
	  };

	  contours.smooth = function(_) {
	    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
	  };

	  return contours;
	};

	// TODO Optimize edge cases.
	// TODO Optimize index calculation.
	// TODO Optimize arguments.
	function blurX(source, target, r) {
	  var n = source.width,
	      m = source.height,
	      w = (r << 1) + 1;
	  for (var j = 0; j < m; ++j) {
	    for (var i = 0, sr = 0; i < n + r; ++i) {
	      if (i < n) {
	        sr += source.data[i + j * n];
	      }
	      if (i >= r) {
	        if (i >= w) {
	          sr -= source.data[i - w + j * n];
	        }
	        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
	      }
	    }
	  }
	}

	// TODO Optimize edge cases.
	// TODO Optimize index calculation.
	// TODO Optimize arguments.
	function blurY(source, target, r) {
	  var n = source.width,
	      m = source.height,
	      w = (r << 1) + 1;
	  for (var i = 0; i < n; ++i) {
	    for (var j = 0, sr = 0; j < m + r; ++j) {
	      if (j < m) {
	        sr += source.data[i + j * n];
	      }
	      if (j >= r) {
	        if (j >= w) {
	          sr -= source.data[i + (j - w) * n];
	        }
	        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
	      }
	    }
	  }
	}

	function defaultX(d) {
	  return d[0];
	}

	function defaultY(d) {
	  return d[1];
	}

	var density = function() {
	  var x = defaultX,
	      y = defaultY,
	      dx = 960,
	      dy = 500,
	      r = 20, // blur radius
	      k = 2, // log2(grid cell size)
	      o = r * 3, // grid offset, to pad for blur
	      n = (dx + o * 2) >> k, // grid width
	      m = (dy + o * 2) >> k, // grid height
	      threshold = constant(20);

	  function density(data) {
	    var values0 = new Float32Array(n * m),
	        values1 = new Float32Array(n * m);

	    data.forEach(function(d, i, data) {
	      var xi = (x(d, i, data) + o) >> k,
	          yi = (y(d, i, data) + o) >> k;
	      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
	        ++values0[xi + yi * n];
	      }
	    });

	    // TODO Optimize.
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
	    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
	    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

	    var tz = threshold(values0);

	    // Convert number of thresholds into uniform thresholds.
	    if (!Array.isArray(tz)) {
	      var stop = d3Array.max(values0);
	      tz = d3Array.tickStep(0, stop, tz);
	      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
	      tz.shift();
	    }

	    return contours()
	        .thresholds(tz)
	        .size([n, m])
	      (values0)
	        .map(transform);
	  }

	  function transform(geometry) {
	    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
	    geometry.coordinates.forEach(transformPolygon);
	    return geometry;
	  }

	  function transformPolygon(coordinates) {
	    coordinates.forEach(transformRing);
	  }

	  function transformRing(coordinates) {
	    coordinates.forEach(transformPoint);
	  }

	  // TODO Optimize.
	  function transformPoint(coordinates) {
	    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
	    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
	  }

	  function resize() {
	    o = r * 3;
	    n = (dx + o * 2) >> k;
	    m = (dy + o * 2) >> k;
	    return density;
	  }

	  density.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
	  };

	  density.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
	  };

	  density.size = function(_) {
	    if (!arguments.length) return [dx, dy];
	    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
	    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
	    return dx = _0, dy = _1, resize();
	  };

	  density.cellSize = function(_) {
	    if (!arguments.length) return 1 << k;
	    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
	    return k = Math.floor(Math.log(_) / Math.LN2), resize();
	  };

	  density.thresholds = function(_) {
	    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
	  };

	  density.bandwidth = function(_) {
	    if (!arguments.length) return Math.sqrt(r * (r + 1));
	    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
	    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
	  };

	  return density;
	};

	exports.contours = contours;
	exports.contourDensity = density;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-dsv/ Version 1.0.8. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var EOL = {};
	var EOF = {};
	var QUOTE = 34;
	var NEWLINE = 10;
	var RETURN = 13;

	function objectConverter(columns) {
	  return new Function("d", "return {" + columns.map(function(name, i) {
	    return JSON.stringify(name) + ": d[" + i + "]";
	  }).join(",") + "}");
	}

	function customConverter(columns, f) {
	  var object = objectConverter(columns);
	  return function(row, i) {
	    return f(object(row), i, columns);
	  };
	}

	// Compute unique columns in order of discovery.
	function inferColumns(rows) {
	  var columnSet = Object.create(null),
	      columns = [];

	  rows.forEach(function(row) {
	    for (var column in row) {
	      if (!(column in columnSet)) {
	        columns.push(columnSet[column] = column);
	      }
	    }
	  });

	  return columns;
	}

	var dsv = function(delimiter) {
	  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
	      DELIMITER = delimiter.charCodeAt(0);

	  function parse(text, f) {
	    var convert, columns, rows = parseRows(text, function(row, i) {
	      if (convert) return convert(row, i - 1);
	      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
	    });
	    rows.columns = columns || [];
	    return rows;
	  }

	  function parseRows(text, f) {
	    var rows = [], // output rows
	        N = text.length,
	        I = 0, // current character index
	        n = 0, // current line number
	        t, // current token
	        eof = N <= 0, // current token followed by EOF?
	        eol = false; // current token followed by EOL?

	    // Strip the trailing newline.
	    if (text.charCodeAt(N - 1) === NEWLINE) --N;
	    if (text.charCodeAt(N - 1) === RETURN) --N;

	    function token() {
	      if (eof) return EOF;
	      if (eol) return eol = false, EOL;

	      // Unescape quotes.
	      var i, j = I, c;
	      if (text.charCodeAt(j) === QUOTE) {
	        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
	        if ((i = I) >= N) eof = true;
	        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
	      }

	      // Find next delimiter or newline.
	      while (I < N) {
	        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
	        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
	        else if (c !== DELIMITER) continue;
	        return text.slice(j, i);
	      }

	      // Return last token before EOF.
	      return eof = true, text.slice(j, N);
	    }

	    while ((t = token()) !== EOF) {
	      var row = [];
	      while (t !== EOL && t !== EOF) row.push(t), t = token();
	      if (f && (row = f(row, n++)) == null) continue;
	      rows.push(row);
	    }

	    return rows;
	  }

	  function format(rows, columns) {
	    if (columns == null) columns = inferColumns(rows);
	    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
	      return columns.map(function(column) {
	        return formatValue(row[column]);
	      }).join(delimiter);
	    })).join("\n");
	  }

	  function formatRows(rows) {
	    return rows.map(formatRow).join("\n");
	  }

	  function formatRow(row) {
	    return row.map(formatValue).join(delimiter);
	  }

	  function formatValue(text) {
	    return text == null ? ""
	        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
	        : text;
	  }

	  return {
	    parse: parse,
	    parseRows: parseRows,
	    format: format,
	    formatRows: formatRows
	  };
	};

	var csv = dsv(",");

	var csvParse = csv.parse;
	var csvParseRows = csv.parseRows;
	var csvFormat = csv.format;
	var csvFormatRows = csv.formatRows;

	var tsv = dsv("\t");

	var tsvParse = tsv.parse;
	var tsvParseRows = tsv.parseRows;
	var tsvFormat = tsv.format;
	var tsvFormatRows = tsv.formatRows;

	exports.dsvFormat = dsv;
	exports.csvParse = csvParse;
	exports.csvParseRows = csvParseRows;
	exports.csvFormat = csvFormat;
	exports.csvFormatRows = csvFormatRows;
	exports.tsvParse = tsvParse;
	exports.tsvParseRows = tsvParseRows;
	exports.tsvFormat = tsvFormat;
	exports.tsvFormatRows = tsvFormatRows;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-fetch/ Version 1.1.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(427)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-dsv'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Dsv) { 'use strict';

	function responseBlob(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.blob();
	}

	function blob(input, init) {
	  return fetch(input, init).then(responseBlob);
	}

	function responseArrayBuffer(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.arrayBuffer();
	}

	function buffer(input, init) {
	  return fetch(input, init).then(responseArrayBuffer);
	}

	function responseText(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.text();
	}

	function text(input, init) {
	  return fetch(input, init).then(responseText);
	}

	function dsvParse(parse) {
	  return function(input, init, row) {
	    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
	    return text(input, init).then(function(response) {
	      return parse(response, row);
	    });
	  };
	}

	function dsv(delimiter, input, init, row) {
	  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
	  var format = d3Dsv.dsvFormat(delimiter);
	  return text(input, init).then(function(response) {
	    return format.parse(response, row);
	  });
	}

	var csv = dsvParse(d3Dsv.csvParse);
	var tsv = dsvParse(d3Dsv.tsvParse);

	function image(input, init) {
	  return new Promise(function(resolve, reject) {
	    var image = new Image;
	    for (var key in init) image[key] = init[key];
	    image.onerror = reject;
	    image.onload = function() { resolve(image); };
	    image.src = input;
	  });
	}

	function responseJson(response) {
	  if (!response.ok) throw new Error(response.status + " " + response.statusText);
	  return response.json();
	}

	function json(input, init) {
	  return fetch(input, init).then(responseJson);
	}

	function parser(type) {
	  return function(input, init)  {
	    return text(input, init).then(function(text$$1) {
	      return (new DOMParser).parseFromString(text$$1, type);
	    });
	  };
	}

	var xml = parser("application/xml");

	var html = parser("text/html");

	var svg = parser("image/svg+xml");

	exports.blob = blob;
	exports.buffer = buffer;
	exports.dsv = dsv;
	exports.csv = csv;
	exports.tsv = tsv;
	exports.image = image;
	exports.json = json;
	exports.text = text;
	exports.xml = xml;
	exports.html = html;
	exports.svg = svg;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-force/ Version 1.1.0. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(430), __webpack_require__(425), __webpack_require__(415), __webpack_require__(421)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

	var center = function(x, y) {
	  var nodes;

	  if (x == null) x = 0;
	  if (y == null) y = 0;

	  function force() {
	    var i,
	        n = nodes.length,
	        node,
	        sx = 0,
	        sy = 0;

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], sx += node.x, sy += node.y;
	    }

	    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
	      node = nodes[i], node.x -= sx, node.y -= sy;
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  return force;
	};

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	var jiggle = function() {
	  return (Math.random() - 0.5) * 1e-6;
	};

	function x(d) {
	  return d.x + d.vx;
	}

	function y(d) {
	  return d.y + d.vy;
	}

	var collide = function(radius) {
	  var nodes,
	      radii,
	      strength = 1,
	      iterations = 1;

	  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

	  function force() {
	    var i, n = nodes.length,
	        tree,
	        node,
	        xi,
	        yi,
	        ri,
	        ri2;

	    for (var k = 0; k < iterations; ++k) {
	      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        ri = radii[node.index], ri2 = ri * ri;
	        xi = node.x + node.vx;
	        yi = node.y + node.vy;
	        tree.visit(apply);
	      }
	    }

	    function apply(quad, x0, y0, x1, y1) {
	      var data = quad.data, rj = quad.r, r = ri + rj;
	      if (data) {
	        if (data.index > node.index) {
	          var x = xi - data.x - data.vx,
	              y = yi - data.y - data.vy,
	              l = x * x + y * y;
	          if (l < r * r) {
	            if (x === 0) x = jiggle(), l += x * x;
	            if (y === 0) y = jiggle(), l += y * y;
	            l = (r - (l = Math.sqrt(l))) / l * strength;
	            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
	            node.vy += (y *= l) * r;
	            data.vx -= x * (r = 1 - r);
	            data.vy -= y * r;
	          }
	        }
	        return;
	      }
	      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
	    }
	  }

	  function prepare(quad) {
	    if (quad.data) return quad.r = radii[quad.data.index];
	    for (var i = quad.r = 0; i < 4; ++i) {
	      if (quad[i] && quad[i].r > quad.r) {
	        quad.r = quad[i].r;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    radii = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = +_, force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  return force;
	};

	function index(d) {
	  return d.index;
	}

	function find(nodeById, nodeId) {
	  var node = nodeById.get(nodeId);
	  if (!node) throw new Error("missing: " + nodeId);
	  return node;
	}

	var link = function(links) {
	  var id = index,
	      strength = defaultStrength,
	      strengths,
	      distance = constant(30),
	      distances,
	      nodes,
	      count,
	      bias,
	      iterations = 1;

	  if (links == null) links = [];

	  function defaultStrength(link) {
	    return 1 / Math.min(count[link.source.index], count[link.target.index]);
	  }

	  function force(alpha) {
	    for (var k = 0, n = links.length; k < iterations; ++k) {
	      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
	        link = links[i], source = link.source, target = link.target;
	        x = target.x + target.vx - source.x - source.vx || jiggle();
	        y = target.y + target.vy - source.y - source.vy || jiggle();
	        l = Math.sqrt(x * x + y * y);
	        l = (l - distances[i]) / l * alpha * strengths[i];
	        x *= l, y *= l;
	        target.vx -= x * (b = bias[i]);
	        target.vy -= y * b;
	        source.vx += x * (b = 1 - b);
	        source.vy += y * b;
	      }
	    }
	  }

	  function initialize() {
	    if (!nodes) return;

	    var i,
	        n = nodes.length,
	        m = links.length,
	        nodeById = d3Collection.map(nodes, id),
	        link;

	    for (i = 0, count = new Array(n); i < m; ++i) {
	      link = links[i], link.index = i;
	      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
	      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
	      count[link.source.index] = (count[link.source.index] || 0) + 1;
	      count[link.target.index] = (count[link.target.index] || 0) + 1;
	    }

	    for (i = 0, bias = new Array(m); i < m; ++i) {
	      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
	    }

	    strengths = new Array(m), initializeStrength();
	    distances = new Array(m), initializeDistance();
	  }

	  function initializeStrength() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      strengths[i] = +strength(links[i], i, links);
	    }
	  }

	  function initializeDistance() {
	    if (!nodes) return;

	    for (var i = 0, n = links.length; i < n; ++i) {
	      distances[i] = +distance(links[i], i, links);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.links = function(_) {
	    return arguments.length ? (links = _, initialize(), force) : links;
	  };

	  force.id = function(_) {
	    return arguments.length ? (id = _, force) : id;
	  };

	  force.iterations = function(_) {
	    return arguments.length ? (iterations = +_, force) : iterations;
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
	  };

	  force.distance = function(_) {
	    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
	  };

	  return force;
	};

	function x$1(d) {
	  return d.x;
	}

	function y$1(d) {
	  return d.y;
	}

	var initialRadius = 10;
	var initialAngle = Math.PI * (3 - Math.sqrt(5));

	var simulation = function(nodes) {
	  var simulation,
	      alpha = 1,
	      alphaMin = 0.001,
	      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
	      alphaTarget = 0,
	      velocityDecay = 0.6,
	      forces = d3Collection.map(),
	      stepper = d3Timer.timer(step),
	      event = d3Dispatch.dispatch("tick", "end");

	  if (nodes == null) nodes = [];

	  function step() {
	    tick();
	    event.call("tick", simulation);
	    if (alpha < alphaMin) {
	      stepper.stop();
	      event.call("end", simulation);
	    }
	  }

	  function tick() {
	    var i, n = nodes.length, node;

	    alpha += (alphaTarget - alpha) * alphaDecay;

	    forces.each(function(force) {
	      force(alpha);
	    });

	    for (i = 0; i < n; ++i) {
	      node = nodes[i];
	      if (node.fx == null) node.x += node.vx *= velocityDecay;
	      else node.x = node.fx, node.vx = 0;
	      if (node.fy == null) node.y += node.vy *= velocityDecay;
	      else node.y = node.fy, node.vy = 0;
	    }
	  }

	  function initializeNodes() {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.index = i;
	      if (isNaN(node.x) || isNaN(node.y)) {
	        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
	        node.x = radius * Math.cos(angle);
	        node.y = radius * Math.sin(angle);
	      }
	      if (isNaN(node.vx) || isNaN(node.vy)) {
	        node.vx = node.vy = 0;
	      }
	    }
	  }

	  function initializeForce(force) {
	    if (force.initialize) force.initialize(nodes);
	    return force;
	  }

	  initializeNodes();

	  return simulation = {
	    tick: tick,

	    restart: function() {
	      return stepper.restart(step), simulation;
	    },

	    stop: function() {
	      return stepper.stop(), simulation;
	    },

	    nodes: function(_) {
	      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
	    },

	    alpha: function(_) {
	      return arguments.length ? (alpha = +_, simulation) : alpha;
	    },

	    alphaMin: function(_) {
	      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
	    },

	    alphaDecay: function(_) {
	      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
	    },

	    alphaTarget: function(_) {
	      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
	    },

	    velocityDecay: function(_) {
	      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
	    },

	    force: function(name, _) {
	      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
	    },

	    find: function(x, y, radius) {
	      var i = 0,
	          n = nodes.length,
	          dx,
	          dy,
	          d2,
	          node,
	          closest;

	      if (radius == null) radius = Infinity;
	      else radius *= radius;

	      for (i = 0; i < n; ++i) {
	        node = nodes[i];
	        dx = x - node.x;
	        dy = y - node.y;
	        d2 = dx * dx + dy * dy;
	        if (d2 < radius) closest = node, radius = d2;
	      }

	      return closest;
	    },

	    on: function(name, _) {
	      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
	    }
	  };
	};

	var manyBody = function() {
	  var nodes,
	      node,
	      alpha,
	      strength = constant(-30),
	      strengths,
	      distanceMin2 = 1,
	      distanceMax2 = Infinity,
	      theta2 = 0.81;

	  function force(_) {
	    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
	    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length, node;
	    strengths = new Array(n);
	    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
	  }

	  function accumulate(quad) {
	    var strength = 0, q, c, weight = 0, x, y, i;

	    // For internal nodes, accumulate forces from child quadrants.
	    if (quad.length) {
	      for (x = y = i = 0; i < 4; ++i) {
	        if ((q = quad[i]) && (c = Math.abs(q.value))) {
	          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
	        }
	      }
	      quad.x = x / weight;
	      quad.y = y / weight;
	    }

	    // For leaf nodes, accumulate forces from coincident quadrants.
	    else {
	      q = quad;
	      q.x = q.data.x;
	      q.y = q.data.y;
	      do strength += strengths[q.data.index];
	      while (q = q.next);
	    }

	    quad.value = strength;
	  }

	  function apply(quad, x1, _, x2) {
	    if (!quad.value) return true;

	    var x = quad.x - node.x,
	        y = quad.y - node.y,
	        w = x2 - x1,
	        l = x * x + y * y;

	    // Apply the Barnes-Hut approximation if possible.
	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (w * w / theta2 < l) {
	      if (l < distanceMax2) {
	        if (x === 0) x = jiggle(), l += x * x;
	        if (y === 0) y = jiggle(), l += y * y;
	        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	        node.vx += x * quad.value * alpha / l;
	        node.vy += y * quad.value * alpha / l;
	      }
	      return true;
	    }

	    // Otherwise, process points directly.
	    else if (quad.length || l >= distanceMax2) return;

	    // Limit forces for very close nodes; randomize direction if coincident.
	    if (quad.data !== node || quad.next) {
	      if (x === 0) x = jiggle(), l += x * x;
	      if (y === 0) y = jiggle(), l += y * y;
	      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
	    }

	    do if (quad.data !== node) {
	      w = strengths[quad.data.index] * alpha / l;
	      node.vx += x * w;
	      node.vy += y * w;
	    } while (quad = quad.next);
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.distanceMin = function(_) {
	    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
	  };

	  force.distanceMax = function(_) {
	    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
	  };

	  force.theta = function(_) {
	    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
	  };

	  return force;
	};

	var radial = function(radius, x, y) {
	  var nodes,
	      strength = constant(0.1),
	      strengths,
	      radiuses;

	  if (typeof radius !== "function") radius = constant(+radius);
	  if (x == null) x = 0;
	  if (y == null) y = 0;

	  function force(alpha) {
	    for (var i = 0, n = nodes.length; i < n; ++i) {
	      var node = nodes[i],
	          dx = node.x - x || 1e-6,
	          dy = node.y - y || 1e-6,
	          r = Math.sqrt(dx * dx + dy * dy),
	          k = (radiuses[i] - r) * strengths[i] * alpha / r;
	      node.vx += dx * k;
	      node.vy += dy * k;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    radiuses = new Array(n);
	    for (i = 0; i < n; ++i) {
	      radiuses[i] = +radius(nodes[i], i, nodes);
	      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _, initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = +_, force) : x;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = +_, force) : y;
	  };

	  return force;
	};

	var x$2 = function(x) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      xz;

	  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    xz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.x = function(_) {
	    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
	  };

	  return force;
	};

	var y$2 = function(y) {
	  var strength = constant(0.1),
	      nodes,
	      strengths,
	      yz;

	  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

	  function force(alpha) {
	    for (var i = 0, n = nodes.length, node; i < n; ++i) {
	      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
	    }
	  }

	  function initialize() {
	    if (!nodes) return;
	    var i, n = nodes.length;
	    strengths = new Array(n);
	    yz = new Array(n);
	    for (i = 0; i < n; ++i) {
	      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
	    }
	  }

	  force.initialize = function(_) {
	    nodes = _;
	    initialize();
	  };

	  force.strength = function(_) {
	    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
	  };

	  force.y = function(_) {
	    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
	  };

	  return force;
	};

	exports.forceCenter = center;
	exports.forceCollide = collide;
	exports.forceLink = link;
	exports.forceManyBody = manyBody;
	exports.forceRadial = radial;
	exports.forceSimulation = simulation;
	exports.forceX = x$2;
	exports.forceY = y$2;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-quadtree/ Version 1.0.3. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var tree_add = function(d) {
	  var x = +this._x.call(null, d),
	      y = +this._y.call(null, d);
	  return add(this.cover(x, y), x, y, d);
	};

	function add(tree, x, y, d) {
	  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

	  var parent,
	      node = tree._root,
	      leaf = {data: d},
	      x0 = tree._x0,
	      y0 = tree._y0,
	      x1 = tree._x1,
	      y1 = tree._y1,
	      xm,
	      ym,
	      xp,
	      yp,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return tree._root = leaf, tree;

	  // Find the existing leaf for the new point, or add it.
	  while (node.length) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
	  }

	  // Is the new point is exactly coincident with the existing point?
	  xp = +tree._x.call(null, node.data);
	  yp = +tree._y.call(null, node.data);
	  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

	  // Otherwise, split the leaf node until the old and new point are separated.
	  do {
	    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
	  return parent[j] = node, parent[i] = leaf, tree;
	}

	function addAll(data) {
	  var d, i, n = data.length,
	      x,
	      y,
	      xz = new Array(n),
	      yz = new Array(n),
	      x0 = Infinity,
	      y0 = Infinity,
	      x1 = -Infinity,
	      y1 = -Infinity;

	  // Compute the points and their extent.
	  for (i = 0; i < n; ++i) {
	    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
	    xz[i] = x;
	    yz[i] = y;
	    if (x < x0) x0 = x;
	    if (x > x1) x1 = x;
	    if (y < y0) y0 = y;
	    if (y > y1) y1 = y;
	  }

	  // If there were no (valid) points, inherit the existing extent.
	  if (x1 < x0) x0 = this._x0, x1 = this._x1;
	  if (y1 < y0) y0 = this._y0, y1 = this._y1;

	  // Expand the tree to cover the new points.
	  this.cover(x0, y0).cover(x1, y1);

	  // Add the new points.
	  for (i = 0; i < n; ++i) {
	    add(this, xz[i], yz[i], data[i]);
	  }

	  return this;
	}

	var tree_cover = function(x, y) {
	  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

	  var x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1;

	  // If the quadtree has no extent, initialize them.
	  // Integer extent are necessary so that if we later double the extent,
	  // the existing quadrant boundaries don’t change due to floating point error!
	  if (isNaN(x0)) {
	    x1 = (x0 = Math.floor(x)) + 1;
	    y1 = (y0 = Math.floor(y)) + 1;
	  }

	  // Otherwise, double repeatedly to cover.
	  else if (x0 > x || x > x1 || y0 > y || y > y1) {
	    var z = x1 - x0,
	        node = this._root,
	        parent,
	        i;

	    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
	      case 0: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
	        break;
	      }
	      case 1: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
	        break;
	      }
	      case 2: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
	        break;
	      }
	      case 3: {
	        do parent = new Array(4), parent[i] = node, node = parent;
	        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
	        break;
	      }
	    }

	    if (this._root && this._root.length) this._root = node;
	  }

	  // If the quadtree covers the point already, just return.
	  else return this;

	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  return this;
	};

	var tree_data = function() {
	  var data = [];
	  this.visit(function(node) {
	    if (!node.length) do data.push(node.data); while (node = node.next)
	  });
	  return data;
	};

	var tree_extent = function(_) {
	  return arguments.length
	      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
	      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
	};

	var Quad = function(node, x0, y0, x1, y1) {
	  this.node = node;
	  this.x0 = x0;
	  this.y0 = y0;
	  this.x1 = x1;
	  this.y1 = y1;
	};

	var tree_find = function(x, y, radius) {
	  var data,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1,
	      y1,
	      x2,
	      y2,
	      x3 = this._x1,
	      y3 = this._y1,
	      quads = [],
	      node = this._root,
	      q,
	      i;

	  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
	  if (radius == null) radius = Infinity;
	  else {
	    x0 = x - radius, y0 = y - radius;
	    x3 = x + radius, y3 = y + radius;
	    radius *= radius;
	  }

	  while (q = quads.pop()) {

	    // Stop searching if this quadrant can’t contain a closer node.
	    if (!(node = q.node)
	        || (x1 = q.x0) > x3
	        || (y1 = q.y0) > y3
	        || (x2 = q.x1) < x0
	        || (y2 = q.y1) < y0) continue;

	    // Bisect the current quadrant.
	    if (node.length) {
	      var xm = (x1 + x2) / 2,
	          ym = (y1 + y2) / 2;

	      quads.push(
	        new Quad(node[3], xm, ym, x2, y2),
	        new Quad(node[2], x1, ym, xm, y2),
	        new Quad(node[1], xm, y1, x2, ym),
	        new Quad(node[0], x1, y1, xm, ym)
	      );

	      // Visit the closest quadrant first.
	      if (i = (y >= ym) << 1 | (x >= xm)) {
	        q = quads[quads.length - 1];
	        quads[quads.length - 1] = quads[quads.length - 1 - i];
	        quads[quads.length - 1 - i] = q;
	      }
	    }

	    // Visit this point. (Visiting coincident points isn’t necessary!)
	    else {
	      var dx = x - +this._x.call(null, node.data),
	          dy = y - +this._y.call(null, node.data),
	          d2 = dx * dx + dy * dy;
	      if (d2 < radius) {
	        var d = Math.sqrt(radius = d2);
	        x0 = x - d, y0 = y - d;
	        x3 = x + d, y3 = y + d;
	        data = node.data;
	      }
	    }
	  }

	  return data;
	};

	var tree_remove = function(d) {
	  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

	  var parent,
	      node = this._root,
	      retainer,
	      previous,
	      next,
	      x0 = this._x0,
	      y0 = this._y0,
	      x1 = this._x1,
	      y1 = this._y1,
	      x,
	      y,
	      xm,
	      ym,
	      right,
	      bottom,
	      i,
	      j;

	  // If the tree is empty, initialize the root as a leaf.
	  if (!node) return this;

	  // Find the leaf node for the point.
	  // While descending, also retain the deepest parent with a non-removed sibling.
	  if (node.length) while (true) {
	    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
	    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
	    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
	    if (!node.length) break;
	    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
	  }

	  // Find the point to remove.
	  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
	  if (next = node.next) delete node.next;

	  // If there are multiple coincident points, remove just the point.
	  if (previous) return (next ? previous.next = next : delete previous.next), this;

	  // If this is the root point, remove it.
	  if (!parent) return this._root = next, this;

	  // Remove this leaf.
	  next ? parent[i] = next : delete parent[i];

	  // If the parent now contains exactly one leaf, collapse superfluous parents.
	  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
	      && node === (parent[3] || parent[2] || parent[1] || parent[0])
	      && !node.length) {
	    if (retainer) retainer[j] = node;
	    else this._root = node;
	  }

	  return this;
	};

	function removeAll(data) {
	  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
	  return this;
	}

	var tree_root = function() {
	  return this._root;
	};

	var tree_size = function() {
	  var size = 0;
	  this.visit(function(node) {
	    if (!node.length) do ++size; while (node = node.next)
	  });
	  return size;
	};

	var tree_visit = function(callback) {
	  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
	  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
	      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	    }
	  }
	  return this;
	};

	var tree_visitAfter = function(callback) {
	  var quads = [], next = [], q;
	  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
	  while (q = quads.pop()) {
	    var node = q.node;
	    if (node.length) {
	      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
	      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
	      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
	      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
	      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
	    }
	    next.push(q);
	  }
	  while (q = next.pop()) {
	    callback(q.node, q.x0, q.y0, q.x1, q.y1);
	  }
	  return this;
	};

	function defaultX(d) {
	  return d[0];
	}

	var tree_x = function(_) {
	  return arguments.length ? (this._x = _, this) : this._x;
	};

	function defaultY(d) {
	  return d[1];
	}

	var tree_y = function(_) {
	  return arguments.length ? (this._y = _, this) : this._y;
	};

	function quadtree(nodes, x, y) {
	  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
	  return nodes == null ? tree : tree.addAll(nodes);
	}

	function Quadtree(x, y, x0, y0, x1, y1) {
	  this._x = x;
	  this._y = y;
	  this._x0 = x0;
	  this._y0 = y0;
	  this._x1 = x1;
	  this._y1 = y1;
	  this._root = undefined;
	}

	function leaf_copy(leaf) {
	  var copy = {data: leaf.data}, next = copy;
	  while (leaf = leaf.next) next = next.next = {data: leaf.data};
	  return copy;
	}

	var treeProto = quadtree.prototype = Quadtree.prototype;

	treeProto.copy = function() {
	  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
	      node = this._root,
	      nodes,
	      child;

	  if (!node) return copy;

	  if (!node.length) return copy._root = leaf_copy(node), copy;

	  nodes = [{source: node, target: copy._root = new Array(4)}];
	  while (node = nodes.pop()) {
	    for (var i = 0; i < 4; ++i) {
	      if (child = node.source[i]) {
	        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
	        else node.target[i] = leaf_copy(child);
	      }
	    }
	  }

	  return copy;
	};

	treeProto.add = tree_add;
	treeProto.addAll = addAll;
	treeProto.cover = tree_cover;
	treeProto.data = tree_data;
	treeProto.extent = tree_extent;
	treeProto.find = tree_find;
	treeProto.remove = tree_remove;
	treeProto.removeAll = removeAll;
	treeProto.root = tree_root;
	treeProto.size = tree_size;
	treeProto.visit = tree_visit;
	treeProto.visitAfter = tree_visitAfter;
	treeProto.x = tree_x;
	treeProto.y = tree_y;

	exports.quadtree = quadtree;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-format/ Version 1.3.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	// Computes the decimal coefficient and exponent of the specified number x with
	// significant digits p, where x is positive and p is in [1, 21] or undefined.
	// For example, formatDecimal(1.23) returns ["123", 0].
	var formatDecimal = function(x, p) {
	  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
	  var i, coefficient = x.slice(0, i);

	  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
	  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
	  return [
	    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
	    +x.slice(i + 1)
	  ];
	};

	var exponent = function(x) {
	  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
	};

	var formatGroup = function(grouping, thousands) {
	  return function(value, width) {
	    var i = value.length,
	        t = [],
	        j = 0,
	        g = grouping[0],
	        length = 0;

	    while (i > 0 && g > 0) {
	      if (length + g + 1 > width) g = Math.max(1, width - length);
	      t.push(value.substring(i -= g, i + g));
	      if ((length += g + 1) > width) break;
	      g = grouping[j = (j + 1) % grouping.length];
	    }

	    return t.reverse().join(thousands);
	  };
	};

	var formatNumerals = function(numerals) {
	  return function(value) {
	    return value.replace(/[0-9]/g, function(i) {
	      return numerals[+i];
	    });
	  };
	};

	// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
	var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

	function formatSpecifier(specifier) {
	  return new FormatSpecifier(specifier);
	}

	formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

	function FormatSpecifier(specifier) {
	  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
	  var match;
	  this.fill = match[1] || " ";
	  this.align = match[2] || ">";
	  this.sign = match[3] || "-";
	  this.symbol = match[4] || "";
	  this.zero = !!match[5];
	  this.width = match[6] && +match[6];
	  this.comma = !!match[7];
	  this.precision = match[8] && +match[8].slice(1);
	  this.trim = !!match[9];
	  this.type = match[10] || "";
	}

	FormatSpecifier.prototype.toString = function() {
	  return this.fill
	      + this.align
	      + this.sign
	      + this.symbol
	      + (this.zero ? "0" : "")
	      + (this.width == null ? "" : Math.max(1, this.width | 0))
	      + (this.comma ? "," : "")
	      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
	      + (this.trim ? "~" : "")
	      + this.type;
	};

	// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
	var formatTrim = function(s) {
	  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
	    switch (s[i]) {
	      case ".": i0 = i1 = i; break;
	      case "0": if (i0 === 0) i0 = i; i1 = i; break;
	      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
	    }
	  }
	  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
	};

	var prefixExponent;

	var formatPrefixAuto = function(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1],
	      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
	      n = coefficient.length;
	  return i === n ? coefficient
	      : i > n ? coefficient + new Array(i - n + 1).join("0")
	      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
	      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
	};

	var formatRounded = function(x, p) {
	  var d = formatDecimal(x, p);
	  if (!d) return x + "";
	  var coefficient = d[0],
	      exponent = d[1];
	  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
	      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
	      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
	};

	var formatTypes = {
	  "%": function(x, p) { return (x * 100).toFixed(p); },
	  "b": function(x) { return Math.round(x).toString(2); },
	  "c": function(x) { return x + ""; },
	  "d": function(x) { return Math.round(x).toString(10); },
	  "e": function(x, p) { return x.toExponential(p); },
	  "f": function(x, p) { return x.toFixed(p); },
	  "g": function(x, p) { return x.toPrecision(p); },
	  "o": function(x) { return Math.round(x).toString(8); },
	  "p": function(x, p) { return formatRounded(x * 100, p); },
	  "r": formatRounded,
	  "s": formatPrefixAuto,
	  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
	  "x": function(x) { return Math.round(x).toString(16); }
	};

	var identity = function(x) {
	  return x;
	};

	var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

	var formatLocale = function(locale) {
	  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
	      currency = locale.currency,
	      decimal = locale.decimal,
	      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
	      percent = locale.percent || "%";

	  function newFormat(specifier) {
	    specifier = formatSpecifier(specifier);

	    var fill = specifier.fill,
	        align = specifier.align,
	        sign = specifier.sign,
	        symbol = specifier.symbol,
	        zero = specifier.zero,
	        width = specifier.width,
	        comma = specifier.comma,
	        precision = specifier.precision,
	        trim = specifier.trim,
	        type = specifier.type;

	    // The "n" type is an alias for ",g".
	    if (type === "n") comma = true, type = "g";

	    // The "" type, and any invalid type, is an alias for ".12~g".
	    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

	    // If zero fill is specified, padding goes after sign and before digits.
	    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

	    // Compute the prefix and suffix.
	    // For SI-prefix, the suffix is lazily computed.
	    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
	        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

	    // What format function should we use?
	    // Is this an integer type?
	    // Can this type generate exponential notation?
	    var formatType = formatTypes[type],
	        maybeSuffix = /[defgprs%]/.test(type);

	    // Set the default precision if not specified,
	    // or clamp the specified precision to the supported range.
	    // For significant precision, it must be in [1, 21].
	    // For fixed precision, it must be in [0, 20].
	    precision = precision == null ? 6
	        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
	        : Math.max(0, Math.min(20, precision));

	    function format(value) {
	      var valuePrefix = prefix,
	          valueSuffix = suffix,
	          i, n, c;

	      if (type === "c") {
	        valueSuffix = formatType(value) + valueSuffix;
	        value = "";
	      } else {
	        value = +value;

	        // Perform the initial formatting.
	        var valueNegative = value < 0;
	        value = formatType(Math.abs(value), precision);

	        // Trim insignificant zeros.
	        if (trim) value = formatTrim(value);

	        // If a negative value rounds to zero during formatting, treat as positive.
	        if (valueNegative && +value === 0) valueNegative = false;

	        // Compute the prefix and suffix.
	        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
	        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

	        // Break the formatted value into the integer “value” part that can be
	        // grouped, and fractional or exponential “suffix” part that is not.
	        if (maybeSuffix) {
	          i = -1, n = value.length;
	          while (++i < n) {
	            if (c = value.charCodeAt(i), 48 > c || c > 57) {
	              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
	              value = value.slice(0, i);
	              break;
	            }
	          }
	        }
	      }

	      // If the fill character is not "0", grouping is applied before padding.
	      if (comma && !zero) value = group(value, Infinity);

	      // Compute the padding.
	      var length = valuePrefix.length + value.length + valueSuffix.length,
	          padding = length < width ? new Array(width - length + 1).join(fill) : "";

	      // If the fill character is "0", grouping is applied after padding.
	      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

	      // Reconstruct the final output based on the desired alignment.
	      switch (align) {
	        case "<": value = valuePrefix + value + valueSuffix + padding; break;
	        case "=": value = valuePrefix + padding + value + valueSuffix; break;
	        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
	        default: value = padding + valuePrefix + value + valueSuffix; break;
	      }

	      return numerals(value);
	    }

	    format.toString = function() {
	      return specifier + "";
	    };

	    return format;
	  }

	  function formatPrefix(specifier, value) {
	    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
	        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
	        k = Math.pow(10, -e),
	        prefix = prefixes[8 + e / 3];
	    return function(value) {
	      return f(k * value) + prefix;
	    };
	  }

	  return {
	    format: newFormat,
	    formatPrefix: formatPrefix
	  };
	};

	var locale;



	defaultLocale({
	  decimal: ".",
	  thousands: ",",
	  grouping: [3],
	  currency: ["$", ""]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  exports.format = locale.format;
	  exports.formatPrefix = locale.formatPrefix;
	  return locale;
	}

	var precisionFixed = function(step) {
	  return Math.max(0, -exponent(Math.abs(step)));
	};

	var precisionPrefix = function(step, value) {
	  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
	};

	var precisionRound = function(step, max) {
	  step = Math.abs(step), max = Math.abs(max) - step;
	  return Math.max(0, exponent(max) - exponent(step)) + 1;
	};

	exports.formatDefaultLocale = defaultLocale;
	exports.formatLocale = formatLocale;
	exports.formatSpecifier = formatSpecifier;
	exports.precisionFixed = precisionFixed;
	exports.precisionPrefix = precisionPrefix;
	exports.precisionRound = precisionRound;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-geo/ Version 1.10.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(412)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Array) { 'use strict';

	// Adds floating point numbers with twice the normal precision.
	// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
	// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
	// 305–363 (1997).
	// Code adapted from GeographicLib by Charles F. F. Karney,
	// http://geographiclib.sourceforge.net/

	function adder() {
	  return new Adder;
	}

	function Adder() {
	  this.reset();
	}

	Adder.prototype = {
	  constructor: Adder,
	  reset: function() {
	    this.s = // rounded value
	    this.t = 0; // exact error
	  },
	  add: function(y) {
	    add(temp, y, this.t);
	    add(this, temp.s, this.s);
	    if (this.s) this.t += temp.t;
	    else this.s = temp.t;
	  },
	  valueOf: function() {
	    return this.s;
	  }
	};

	var temp = new Adder;

	function add(adder, a, b) {
	  var x = adder.s = a + b,
	      bv = x - a,
	      av = x - bv;
	  adder.t = (a - av) + (b - bv);
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var quarterPi = pi / 4;
	var tau = pi * 2;

	var degrees = 180 / pi;
	var radians = pi / 180;

	var abs = Math.abs;
	var atan = Math.atan;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var ceil = Math.ceil;
	var exp = Math.exp;

	var log = Math.log;
	var pow = Math.pow;
	var sin = Math.sin;
	var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
	var sqrt = Math.sqrt;
	var tan = Math.tan;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
	}

	function haversin(x) {
	  return (x = sin(x / 2)) * x;
	}

	function noop() {}

	function streamGeometry(geometry, stream) {
	  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
	    streamGeometryType[geometry.type](geometry, stream);
	  }
	}

	var streamObjectType = {
	  Feature: function(object, stream) {
	    streamGeometry(object.geometry, stream);
	  },
	  FeatureCollection: function(object, stream) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) streamGeometry(features[i].geometry, stream);
	  }
	};

	var streamGeometryType = {
	  Sphere: function(object, stream) {
	    stream.sphere();
	  },
	  Point: function(object, stream) {
	    object = object.coordinates;
	    stream.point(object[0], object[1], object[2]);
	  },
	  MultiPoint: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
	  },
	  LineString: function(object, stream) {
	    streamLine(object.coordinates, stream, 0);
	  },
	  MultiLineString: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamLine(coordinates[i], stream, 0);
	  },
	  Polygon: function(object, stream) {
	    streamPolygon(object.coordinates, stream);
	  },
	  MultiPolygon: function(object, stream) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) streamPolygon(coordinates[i], stream);
	  },
	  GeometryCollection: function(object, stream) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) streamGeometry(geometries[i], stream);
	  }
	};

	function streamLine(coordinates, stream, closed) {
	  var i = -1, n = coordinates.length - closed, coordinate;
	  stream.lineStart();
	  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
	  stream.lineEnd();
	}

	function streamPolygon(coordinates, stream) {
	  var i = -1, n = coordinates.length;
	  stream.polygonStart();
	  while (++i < n) streamLine(coordinates[i], stream, 1);
	  stream.polygonEnd();
	}

	function geoStream(object, stream) {
	  if (object && streamObjectType.hasOwnProperty(object.type)) {
	    streamObjectType[object.type](object, stream);
	  } else {
	    streamGeometry(object, stream);
	  }
	}

	var areaRingSum = adder();

	var areaSum = adder();
	var lambda00;
	var phi00;
	var lambda0;
	var cosPhi0;
	var sinPhi0;

	var areaStream = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaRingSum.reset();
	    areaStream.lineStart = areaRingStart;
	    areaStream.lineEnd = areaRingEnd;
	  },
	  polygonEnd: function() {
	    var areaRing = +areaRingSum;
	    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
	    this.lineStart = this.lineEnd = this.point = noop;
	  },
	  sphere: function() {
	    areaSum.add(tau);
	  }
	};

	function areaRingStart() {
	  areaStream.point = areaPointFirst;
	}

	function areaRingEnd() {
	  areaPoint(lambda00, phi00);
	}

	function areaPointFirst(lambda, phi) {
	  areaStream.point = areaPoint;
	  lambda00 = lambda, phi00 = phi;
	  lambda *= radians, phi *= radians;
	  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
	}

	function areaPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  phi = phi / 2 + quarterPi; // half the angular distance from south pole

	  // Spherical excess E for a spherical triangle with vertices: south pole,
	  // previous point, current point.  Uses a formula derived from Cagnoli’s
	  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
	  var dLambda = lambda - lambda0,
	      sdLambda = dLambda >= 0 ? 1 : -1,
	      adLambda = sdLambda * dLambda,
	      cosPhi = cos(phi),
	      sinPhi = sin(phi),
	      k = sinPhi0 * sinPhi,
	      u = cosPhi0 * cosPhi + k * cos(adLambda),
	      v = k * sdLambda * sin(adLambda);
	  areaRingSum.add(atan2(v, u));

	  // Advance the previous points.
	  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
	}

	function area(object) {
	  areaSum.reset();
	  geoStream(object, areaStream);
	  return areaSum * 2;
	}

	function spherical(cartesian) {
	  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
	}

	function cartesian(spherical) {
	  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
	  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
	}

	function cartesianDot(a, b) {
	  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
	}

	function cartesianCross(a, b) {
	  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
	}

	// TODO return a
	function cartesianAddInPlace(a, b) {
	  a[0] += b[0], a[1] += b[1], a[2] += b[2];
	}

	function cartesianScale(vector, k) {
	  return [vector[0] * k, vector[1] * k, vector[2] * k];
	}

	// TODO return d
	function cartesianNormalizeInPlace(d) {
	  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
	  d[0] /= l, d[1] /= l, d[2] /= l;
	}

	var lambda0$1;
	var phi0;
	var lambda1;
	var phi1;
	var lambda2;
	var lambda00$1;
	var phi00$1;
	var p0;
	var deltaSum = adder();
	var ranges;
	var range$1;

	var boundsStream = {
	  point: boundsPoint,
	  lineStart: boundsLineStart,
	  lineEnd: boundsLineEnd,
	  polygonStart: function() {
	    boundsStream.point = boundsRingPoint;
	    boundsStream.lineStart = boundsRingStart;
	    boundsStream.lineEnd = boundsRingEnd;
	    deltaSum.reset();
	    areaStream.polygonStart();
	  },
	  polygonEnd: function() {
	    areaStream.polygonEnd();
	    boundsStream.point = boundsPoint;
	    boundsStream.lineStart = boundsLineStart;
	    boundsStream.lineEnd = boundsLineEnd;
	    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
	    else if (deltaSum > epsilon) phi1 = 90;
	    else if (deltaSum < -epsilon) phi0 = -90;
	    range$1[0] = lambda0$1, range$1[1] = lambda1;
	  }
	};

	function boundsPoint(lambda, phi) {
	  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	}

	function linePoint(lambda, phi) {
	  var p = cartesian([lambda * radians, phi * radians]);
	  if (p0) {
	    var normal = cartesianCross(p0, p),
	        equatorial = [normal[1], -normal[0], 0],
	        inflection = cartesianCross(equatorial, normal);
	    cartesianNormalizeInPlace(inflection);
	    inflection = spherical(inflection);
	    var delta = lambda - lambda2,
	        sign$$1 = delta > 0 ? 1 : -1,
	        lambdai = inflection[0] * degrees * sign$$1,
	        phii,
	        antimeridian = abs(delta) > 180;
	    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
	      phii = inflection[1] * degrees;
	      if (phii > phi1) phi1 = phii;
	    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
	      phii = -inflection[1] * degrees;
	      if (phii < phi0) phi0 = phii;
	    } else {
	      if (phi < phi0) phi0 = phi;
	      if (phi > phi1) phi1 = phi;
	    }
	    if (antimeridian) {
	      if (lambda < lambda2) {
	        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	      } else {
	        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	      }
	    } else {
	      if (lambda1 >= lambda0$1) {
	        if (lambda < lambda0$1) lambda0$1 = lambda;
	        if (lambda > lambda1) lambda1 = lambda;
	      } else {
	        if (lambda > lambda2) {
	          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
	        } else {
	          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
	        }
	      }
	    }
	  } else {
	    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
	  }
	  if (phi < phi0) phi0 = phi;
	  if (phi > phi1) phi1 = phi;
	  p0 = p, lambda2 = lambda;
	}

	function boundsLineStart() {
	  boundsStream.point = linePoint;
	}

	function boundsLineEnd() {
	  range$1[0] = lambda0$1, range$1[1] = lambda1;
	  boundsStream.point = boundsPoint;
	  p0 = null;
	}

	function boundsRingPoint(lambda, phi) {
	  if (p0) {
	    var delta = lambda - lambda2;
	    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
	  } else {
	    lambda00$1 = lambda, phi00$1 = phi;
	  }
	  areaStream.point(lambda, phi);
	  linePoint(lambda, phi);
	}

	function boundsRingStart() {
	  areaStream.lineStart();
	}

	function boundsRingEnd() {
	  boundsRingPoint(lambda00$1, phi00$1);
	  areaStream.lineEnd();
	  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
	  range$1[0] = lambda0$1, range$1[1] = lambda1;
	  p0 = null;
	}

	// Finds the left-right distance between two longitudes.
	// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
	// the distance between ±180° to be 360°.
	function angle(lambda0, lambda1) {
	  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
	}

	function rangeCompare(a, b) {
	  return a[0] - b[0];
	}

	function rangeContains(range$$1, x) {
	  return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;
	}

	function bounds(feature) {
	  var i, n, a, b, merged, deltaMax, delta;

	  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
	  ranges = [];
	  geoStream(feature, boundsStream);

	  // First, sort ranges by their minimum longitudes.
	  if (n = ranges.length) {
	    ranges.sort(rangeCompare);

	    // Then, merge any ranges that overlap.
	    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
	      b = ranges[i];
	      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
	        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
	        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
	      } else {
	        merged.push(a = b);
	      }
	    }

	    // Finally, find the largest gap between the merged ranges.
	    // The final bounding box will be the inverse of this gap.
	    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
	      b = merged[i];
	      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
	    }
	  }

	  ranges = range$1 = null;

	  return lambda0$1 === Infinity || phi0 === Infinity
	      ? [[NaN, NaN], [NaN, NaN]]
	      : [[lambda0$1, phi0], [lambda1, phi1]];
	}

	var W0;
	var W1;
	var X0;
	var Y0;
	var Z0;
	var X1;
	var Y1;
	var Z1;
	var X2;
	var Y2;
	var Z2;
	var lambda00$2;
	var phi00$2;
	var x0;
	var y0;
	var z0; // previous point

	var centroidStream = {
	  sphere: noop,
	  point: centroidPoint,
	  lineStart: centroidLineStart,
	  lineEnd: centroidLineEnd,
	  polygonStart: function() {
	    centroidStream.lineStart = centroidRingStart;
	    centroidStream.lineEnd = centroidRingEnd;
	  },
	  polygonEnd: function() {
	    centroidStream.lineStart = centroidLineStart;
	    centroidStream.lineEnd = centroidLineEnd;
	  }
	};

	// Arithmetic mean of Cartesian vectors.
	function centroidPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
	}

	function centroidPointCartesian(x, y, z) {
	  ++W0;
	  X0 += (x - X0) / W0;
	  Y0 += (y - Y0) / W0;
	  Z0 += (z - Z0) / W0;
	}

	function centroidLineStart() {
	  centroidStream.point = centroidLinePointFirst;
	}

	function centroidLinePointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidStream.point = centroidLinePoint;
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLinePoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidLineEnd() {
	  centroidStream.point = centroidPoint;
	}

	// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
	// J. Applied Mechanics 42, 239 (1975).
	function centroidRingStart() {
	  centroidStream.point = centroidRingPointFirst;
	}

	function centroidRingEnd() {
	  centroidRingPoint(lambda00$2, phi00$2);
	  centroidStream.point = centroidPoint;
	}

	function centroidRingPointFirst(lambda, phi) {
	  lambda00$2 = lambda, phi00$2 = phi;
	  lambda *= radians, phi *= radians;
	  centroidStream.point = centroidRingPoint;
	  var cosPhi = cos(phi);
	  x0 = cosPhi * cos(lambda);
	  y0 = cosPhi * sin(lambda);
	  z0 = sin(phi);
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroidRingPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var cosPhi = cos(phi),
	      x = cosPhi * cos(lambda),
	      y = cosPhi * sin(lambda),
	      z = sin(phi),
	      cx = y0 * z - z0 * y,
	      cy = z0 * x - x0 * z,
	      cz = x0 * y - y0 * x,
	      m = sqrt(cx * cx + cy * cy + cz * cz),
	      w = asin(m), // line weight = angle
	      v = m && -w / m; // area weight multiplier
	  X2 += v * cx;
	  Y2 += v * cy;
	  Z2 += v * cz;
	  W1 += w;
	  X1 += w * (x0 + (x0 = x));
	  Y1 += w * (y0 + (y0 = y));
	  Z1 += w * (z0 + (z0 = z));
	  centroidPointCartesian(x0, y0, z0);
	}

	function centroid(object) {
	  W0 = W1 =
	  X0 = Y0 = Z0 =
	  X1 = Y1 = Z1 =
	  X2 = Y2 = Z2 = 0;
	  geoStream(object, centroidStream);

	  var x = X2,
	      y = Y2,
	      z = Z2,
	      m = x * x + y * y + z * z;

	  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
	  if (m < epsilon2) {
	    x = X1, y = Y1, z = Z1;
	    // If the feature has zero length, fall back to arithmetic mean of point vectors.
	    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
	    m = x * x + y * y + z * z;
	    // If the feature still has an undefined ccentroid, then return.
	    if (m < epsilon2) return [NaN, NaN];
	  }

	  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function compose(a, b) {

	  function compose(x, y) {
	    return x = a(x, y), b(x[0], x[1]);
	  }

	  if (a.invert && b.invert) compose.invert = function(x, y) {
	    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
	  };

	  return compose;
	}

	function rotationIdentity(lambda, phi) {
	  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	}

	rotationIdentity.invert = rotationIdentity;

	function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
	  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
	    : rotationLambda(deltaLambda))
	    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
	    : rotationIdentity);
	}

	function forwardRotationLambda(deltaLambda) {
	  return function(lambda, phi) {
	    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
	  };
	}

	function rotationLambda(deltaLambda) {
	  var rotation = forwardRotationLambda(deltaLambda);
	  rotation.invert = forwardRotationLambda(-deltaLambda);
	  return rotation;
	}

	function rotationPhiGamma(deltaPhi, deltaGamma) {
	  var cosDeltaPhi = cos(deltaPhi),
	      sinDeltaPhi = sin(deltaPhi),
	      cosDeltaGamma = cos(deltaGamma),
	      sinDeltaGamma = sin(deltaGamma);

	  function rotation(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaPhi + x * sinDeltaPhi;
	    return [
	      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
	      asin(k * cosDeltaGamma + y * sinDeltaGamma)
	    ];
	  }

	  rotation.invert = function(lambda, phi) {
	    var cosPhi = cos(phi),
	        x = cos(lambda) * cosPhi,
	        y = sin(lambda) * cosPhi,
	        z = sin(phi),
	        k = z * cosDeltaGamma - y * sinDeltaGamma;
	    return [
	      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
	      asin(k * cosDeltaPhi - x * sinDeltaPhi)
	    ];
	  };

	  return rotation;
	}

	function rotation(rotate) {
	  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

	  function forward(coordinates) {
	    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  }

	  forward.invert = function(coordinates) {
	    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
	    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
	  };

	  return forward;
	}

	// Generates a circle centered at [0°, 0°], with a given radius and precision.
	function circleStream(stream, radius, delta, direction, t0, t1) {
	  if (!delta) return;
	  var cosRadius = cos(radius),
	      sinRadius = sin(radius),
	      step = direction * delta;
	  if (t0 == null) {
	    t0 = radius + direction * tau;
	    t1 = radius - step / 2;
	  } else {
	    t0 = circleRadius(cosRadius, t0);
	    t1 = circleRadius(cosRadius, t1);
	    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
	  }
	  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
	    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
	    stream.point(point[0], point[1]);
	  }
	}

	// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
	function circleRadius(cosRadius, point) {
	  point = cartesian(point), point[0] -= cosRadius;
	  cartesianNormalizeInPlace(point);
	  var radius = acos(-point[1]);
	  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
	}

	function circle() {
	  var center = constant([0, 0]),
	      radius = constant(90),
	      precision = constant(6),
	      ring,
	      rotate,
	      stream = {point: point};

	  function point(x, y) {
	    ring.push(x = rotate(x, y));
	    x[0] *= degrees, x[1] *= degrees;
	  }

	  function circle() {
	    var c = center.apply(this, arguments),
	        r = radius.apply(this, arguments) * radians,
	        p = precision.apply(this, arguments) * radians;
	    ring = [];
	    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
	    circleStream(stream, r, p, 1);
	    c = {type: "Polygon", coordinates: [ring]};
	    ring = rotate = null;
	    return c;
	  }

	  circle.center = function(_) {
	    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
	  };

	  circle.radius = function(_) {
	    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
	  };

	  circle.precision = function(_) {
	    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
	  };

	  return circle;
	}

	function clipBuffer() {
	  var lines = [],
	      line;
	  return {
	    point: function(x, y) {
	      line.push([x, y]);
	    },
	    lineStart: function() {
	      lines.push(line = []);
	    },
	    lineEnd: noop,
	    rejoin: function() {
	      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
	    },
	    result: function() {
	      var result = lines;
	      lines = [];
	      line = null;
	      return result;
	    }
	  };
	}

	function pointEqual(a, b) {
	  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
	}

	function Intersection(point, points, other, entry) {
	  this.x = point;
	  this.z = points;
	  this.o = other; // another intersection
	  this.e = entry; // is an entry?
	  this.v = false; // visited
	  this.n = this.p = null; // next & previous
	}

	// A generalized polygon clipping algorithm: given a polygon that has been cut
	// into its visible line segments, and rejoins the segments by interpolating
	// along the clip edge.
	function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
	  var subject = [],
	      clip = [],
	      i,
	      n;

	  segments.forEach(function(segment) {
	    if ((n = segment.length - 1) <= 0) return;
	    var n, p0 = segment[0], p1 = segment[n], x;

	    // If the first and last points of a segment are coincident, then treat as a
	    // closed ring. TODO if all rings are closed, then the winding order of the
	    // exterior ring should be checked.
	    if (pointEqual(p0, p1)) {
	      stream.lineStart();
	      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
	      stream.lineEnd();
	      return;
	    }

	    subject.push(x = new Intersection(p0, segment, null, true));
	    clip.push(x.o = new Intersection(p0, null, x, false));
	    subject.push(x = new Intersection(p1, segment, null, false));
	    clip.push(x.o = new Intersection(p1, null, x, true));
	  });

	  if (!subject.length) return;

	  clip.sort(compareIntersection);
	  link(subject);
	  link(clip);

	  for (i = 0, n = clip.length; i < n; ++i) {
	    clip[i].e = startInside = !startInside;
	  }

	  var start = subject[0],
	      points,
	      point;

	  while (1) {
	    // Find first unvisited intersection.
	    var current = start,
	        isSubject = true;
	    while (current.v) if ((current = current.n) === start) return;
	    points = current.z;
	    stream.lineStart();
	    do {
	      current.v = current.o.v = true;
	      if (current.e) {
	        if (isSubject) {
	          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.n.x, 1, stream);
	        }
	        current = current.n;
	      } else {
	        if (isSubject) {
	          points = current.p.z;
	          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
	        } else {
	          interpolate(current.x, current.p.x, -1, stream);
	        }
	        current = current.p;
	      }
	      current = current.o;
	      points = current.z;
	      isSubject = !isSubject;
	    } while (!current.v);
	    stream.lineEnd();
	  }
	}

	function link(array) {
	  if (!(n = array.length)) return;
	  var n,
	      i = 0,
	      a = array[0],
	      b;
	  while (++i < n) {
	    a.n = b = array[i];
	    b.p = a;
	    a = b;
	  }
	  a.n = b = array[0];
	  b.p = a;
	}

	var sum = adder();

	function polygonContains(polygon, point) {
	  var lambda = point[0],
	      phi = point[1],
	      sinPhi = sin(phi),
	      normal = [sin(lambda), -cos(lambda), 0],
	      angle = 0,
	      winding = 0;

	  sum.reset();

	  if (sinPhi === 1) phi = halfPi + epsilon;
	  else if (sinPhi === -1) phi = -halfPi - epsilon;

	  for (var i = 0, n = polygon.length; i < n; ++i) {
	    if (!(m = (ring = polygon[i]).length)) continue;
	    var ring,
	        m,
	        point0 = ring[m - 1],
	        lambda0 = point0[0],
	        phi0 = point0[1] / 2 + quarterPi,
	        sinPhi0 = sin(phi0),
	        cosPhi0 = cos(phi0);

	    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
	      var point1 = ring[j],
	          lambda1 = point1[0],
	          phi1 = point1[1] / 2 + quarterPi,
	          sinPhi1 = sin(phi1),
	          cosPhi1 = cos(phi1),
	          delta = lambda1 - lambda0,
	          sign$$1 = delta >= 0 ? 1 : -1,
	          absDelta = sign$$1 * delta,
	          antimeridian = absDelta > pi,
	          k = sinPhi0 * sinPhi1;

	      sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
	      angle += antimeridian ? delta + sign$$1 * tau : delta;

	      // Are the longitudes either side of the point’s meridian (lambda),
	      // and are the latitudes smaller than the parallel (phi)?
	      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
	        var arc = cartesianCross(cartesian(point0), cartesian(point1));
	        cartesianNormalizeInPlace(arc);
	        var intersection = cartesianCross(normal, arc);
	        cartesianNormalizeInPlace(intersection);
	        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
	        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
	          winding += antimeridian ^ delta >= 0 ? 1 : -1;
	        }
	      }
	    }
	  }

	  // First, determine whether the South pole is inside or outside:
	  //
	  // It is inside if:
	  // * the polygon winds around it in a clockwise direction.
	  // * the polygon does not (cumulatively) wind around it, but has a negative
	  //   (counter-clockwise) area.
	  //
	  // Second, count the (signed) number of times a segment crosses a lambda
	  // from the point to the South pole.  If it is zero, then the point is the
	  // same side as the South pole.

	  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
	}

	function clip(pointVisible, clipLine, interpolate, start) {
	  return function(sink) {
	    var line = clipLine(sink),
	        ringBuffer = clipBuffer(),
	        ringSink = clipLine(ringBuffer),
	        polygonStarted = false,
	        polygon,
	        segments,
	        ring;

	    var clip = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() {
	        clip.point = pointRing;
	        clip.lineStart = ringStart;
	        clip.lineEnd = ringEnd;
	        segments = [];
	        polygon = [];
	      },
	      polygonEnd: function() {
	        clip.point = point;
	        clip.lineStart = lineStart;
	        clip.lineEnd = lineEnd;
	        segments = d3Array.merge(segments);
	        var startInside = polygonContains(polygon, start);
	        if (segments.length) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
	        } else if (startInside) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          interpolate(null, null, 1, sink);
	          sink.lineEnd();
	        }
	        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
	        segments = polygon = null;
	      },
	      sphere: function() {
	        sink.polygonStart();
	        sink.lineStart();
	        interpolate(null, null, 1, sink);
	        sink.lineEnd();
	        sink.polygonEnd();
	      }
	    };

	    function point(lambda, phi) {
	      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
	    }

	    function pointLine(lambda, phi) {
	      line.point(lambda, phi);
	    }

	    function lineStart() {
	      clip.point = pointLine;
	      line.lineStart();
	    }

	    function lineEnd() {
	      clip.point = point;
	      line.lineEnd();
	    }

	    function pointRing(lambda, phi) {
	      ring.push([lambda, phi]);
	      ringSink.point(lambda, phi);
	    }

	    function ringStart() {
	      ringSink.lineStart();
	      ring = [];
	    }

	    function ringEnd() {
	      pointRing(ring[0][0], ring[0][1]);
	      ringSink.lineEnd();

	      var clean = ringSink.clean(),
	          ringSegments = ringBuffer.result(),
	          i, n = ringSegments.length, m,
	          segment,
	          point;

	      ring.pop();
	      polygon.push(ring);
	      ring = null;

	      if (!n) return;

	      // No intersections.
	      if (clean & 1) {
	        segment = ringSegments[0];
	        if ((m = segment.length - 1) > 0) {
	          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
	          sink.lineStart();
	          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
	          sink.lineEnd();
	        }
	        return;
	      }

	      // Rejoin connected segments.
	      // TODO reuse ringBuffer.rejoin()?
	      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

	      segments.push(ringSegments.filter(validSegment));
	    }

	    return clip;
	  };
	}

	function validSegment(segment) {
	  return segment.length > 1;
	}

	// Intersections are sorted along the clip edge. For both antimeridian cutting
	// and circle clipping, the same comparison is used.
	function compareIntersection(a, b) {
	  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
	       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
	}

	var clipAntimeridian = clip(
	  function() { return true; },
	  clipAntimeridianLine,
	  clipAntimeridianInterpolate,
	  [-pi, -halfPi]
	);

	// Takes a line and cuts into visible segments. Return values: 0 - there were
	// intersections or the line was empty; 1 - no intersections; 2 - there were
	// intersections, and the first and last segments should be rejoined.
	function clipAntimeridianLine(stream) {
	  var lambda0 = NaN,
	      phi0 = NaN,
	      sign0 = NaN,
	      clean; // no intersections

	  return {
	    lineStart: function() {
	      stream.lineStart();
	      clean = 1;
	    },
	    point: function(lambda1, phi1) {
	      var sign1 = lambda1 > 0 ? pi : -pi,
	          delta = abs(lambda1 - lambda0);
	      if (abs(delta - pi) < epsilon) { // line crosses a pole
	        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        stream.point(lambda1, phi0);
	        clean = 0;
	      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
	        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
	        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
	        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
	        stream.point(sign0, phi0);
	        stream.lineEnd();
	        stream.lineStart();
	        stream.point(sign1, phi0);
	        clean = 0;
	      }
	      stream.point(lambda0 = lambda1, phi0 = phi1);
	      sign0 = sign1;
	    },
	    lineEnd: function() {
	      stream.lineEnd();
	      lambda0 = phi0 = NaN;
	    },
	    clean: function() {
	      return 2 - clean; // if intersections, rejoin first and last segments
	    }
	  };
	}

	function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
	  var cosPhi0,
	      cosPhi1,
	      sinLambda0Lambda1 = sin(lambda0 - lambda1);
	  return abs(sinLambda0Lambda1) > epsilon
	      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
	          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
	          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
	      : (phi0 + phi1) / 2;
	}

	function clipAntimeridianInterpolate(from, to, direction, stream) {
	  var phi;
	  if (from == null) {
	    phi = direction * halfPi;
	    stream.point(-pi, phi);
	    stream.point(0, phi);
	    stream.point(pi, phi);
	    stream.point(pi, 0);
	    stream.point(pi, -phi);
	    stream.point(0, -phi);
	    stream.point(-pi, -phi);
	    stream.point(-pi, 0);
	    stream.point(-pi, phi);
	  } else if (abs(from[0] - to[0]) > epsilon) {
	    var lambda = from[0] < to[0] ? pi : -pi;
	    phi = direction * lambda / 2;
	    stream.point(-lambda, phi);
	    stream.point(0, phi);
	    stream.point(lambda, phi);
	  } else {
	    stream.point(to[0], to[1]);
	  }
	}

	function clipCircle(radius) {
	  var cr = cos(radius),
	      delta = 6 * radians,
	      smallRadius = cr > 0,
	      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

	  function interpolate(from, to, direction, stream) {
	    circleStream(stream, radius, delta, direction, from, to);
	  }

	  function visible(lambda, phi) {
	    return cos(lambda) * cos(phi) > cr;
	  }

	  // Takes a line and cuts into visible segments. Return values used for polygon
	  // clipping: 0 - there were intersections or the line was empty; 1 - no
	  // intersections 2 - there were intersections, and the first and last segments
	  // should be rejoined.
	  function clipLine(stream) {
	    var point0, // previous point
	        c0, // code for previous point
	        v0, // visibility of previous point
	        v00, // visibility of first point
	        clean; // no intersections
	    return {
	      lineStart: function() {
	        v00 = v0 = false;
	        clean = 1;
	      },
	      point: function(lambda, phi) {
	        var point1 = [lambda, phi],
	            point2,
	            v = visible(lambda, phi),
	            c = smallRadius
	              ? v ? 0 : code(lambda, phi)
	              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
	        if (!point0 && (v00 = v0 = v)) stream.lineStart();
	        // Handle degeneracies.
	        // TODO ignore if not clipping polygons.
	        if (v !== v0) {
	          point2 = intersect(point0, point1);
	          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
	            point1[0] += epsilon;
	            point1[1] += epsilon;
	            v = visible(point1[0], point1[1]);
	          }
	        }
	        if (v !== v0) {
	          clean = 0;
	          if (v) {
	            // outside going in
	            stream.lineStart();
	            point2 = intersect(point1, point0);
	            stream.point(point2[0], point2[1]);
	          } else {
	            // inside going out
	            point2 = intersect(point0, point1);
	            stream.point(point2[0], point2[1]);
	            stream.lineEnd();
	          }
	          point0 = point2;
	        } else if (notHemisphere && point0 && smallRadius ^ v) {
	          var t;
	          // If the codes for two points are different, or are both zero,
	          // and there this segment intersects with the small circle.
	          if (!(c & c0) && (t = intersect(point1, point0, true))) {
	            clean = 0;
	            if (smallRadius) {
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	            } else {
	              stream.point(t[1][0], t[1][1]);
	              stream.lineEnd();
	              stream.lineStart();
	              stream.point(t[0][0], t[0][1]);
	            }
	          }
	        }
	        if (v && (!point0 || !pointEqual(point0, point1))) {
	          stream.point(point1[0], point1[1]);
	        }
	        point0 = point1, v0 = v, c0 = c;
	      },
	      lineEnd: function() {
	        if (v0) stream.lineEnd();
	        point0 = null;
	      },
	      // Rejoin first and last segments if there were intersections and the first
	      // and last points were visible.
	      clean: function() {
	        return clean | ((v00 && v0) << 1);
	      }
	    };
	  }

	  // Intersects the great circle between a and b with the clip circle.
	  function intersect(a, b, two) {
	    var pa = cartesian(a),
	        pb = cartesian(b);

	    // We have two planes, n1.p = d1 and n2.p = d2.
	    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
	    var n1 = [1, 0, 0], // normal
	        n2 = cartesianCross(pa, pb),
	        n2n2 = cartesianDot(n2, n2),
	        n1n2 = n2[0], // cartesianDot(n1, n2),
	        determinant = n2n2 - n1n2 * n1n2;

	    // Two polar points.
	    if (!determinant) return !two && a;

	    var c1 =  cr * n2n2 / determinant,
	        c2 = -cr * n1n2 / determinant,
	        n1xn2 = cartesianCross(n1, n2),
	        A = cartesianScale(n1, c1),
	        B = cartesianScale(n2, c2);
	    cartesianAddInPlace(A, B);

	    // Solve |p(t)|^2 = 1.
	    var u = n1xn2,
	        w = cartesianDot(A, u),
	        uu = cartesianDot(u, u),
	        t2 = w * w - uu * (cartesianDot(A, A) - 1);

	    if (t2 < 0) return;

	    var t = sqrt(t2),
	        q = cartesianScale(u, (-w - t) / uu);
	    cartesianAddInPlace(q, A);
	    q = spherical(q);

	    if (!two) return q;

	    // Two intersection points.
	    var lambda0 = a[0],
	        lambda1 = b[0],
	        phi0 = a[1],
	        phi1 = b[1],
	        z;

	    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

	    var delta = lambda1 - lambda0,
	        polar = abs(delta - pi) < epsilon,
	        meridian = polar || delta < epsilon;

	    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

	    // Check that the first point is between a and b.
	    if (meridian
	        ? polar
	          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
	          : phi0 <= q[1] && q[1] <= phi1
	        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
	      var q1 = cartesianScale(u, (-w + t) / uu);
	      cartesianAddInPlace(q1, A);
	      return [q, spherical(q1)];
	    }
	  }

	  // Generates a 4-bit vector representing the location of a point relative to
	  // the small circle's bounding box.
	  function code(lambda, phi) {
	    var r = smallRadius ? radius : pi - radius,
	        code = 0;
	    if (lambda < -r) code |= 1; // left
	    else if (lambda > r) code |= 2; // right
	    if (phi < -r) code |= 4; // below
	    else if (phi > r) code |= 8; // above
	    return code;
	  }

	  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
	}

	function clipLine(a, b, x0, y0, x1, y1) {
	  var ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
	  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
	  return true;
	}

	var clipMax = 1e9;
	var clipMin = -clipMax;

	// TODO Use d3-polygon’s polygonContains here for the ring check?
	// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

	function clipRectangle(x0, y0, x1, y1) {

	  function visible(x, y) {
	    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
	  }

	  function interpolate(from, to, direction, stream) {
	    var a = 0, a1 = 0;
	    if (from == null
	        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
	        || comparePoint(from, to) < 0 ^ direction > 0) {
	      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
	      while ((a = (a + direction + 4) % 4) !== a1);
	    } else {
	      stream.point(to[0], to[1]);
	    }
	  }

	  function corner(p, direction) {
	    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
	        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
	        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
	        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
	  }

	  function compareIntersection(a, b) {
	    return comparePoint(a.x, b.x);
	  }

	  function comparePoint(a, b) {
	    var ca = corner(a, 1),
	        cb = corner(b, 1);
	    return ca !== cb ? ca - cb
	        : ca === 0 ? b[1] - a[1]
	        : ca === 1 ? a[0] - b[0]
	        : ca === 2 ? a[1] - b[1]
	        : b[0] - a[0];
	  }

	  return function(stream) {
	    var activeStream = stream,
	        bufferStream = clipBuffer(),
	        segments,
	        polygon,
	        ring,
	        x__, y__, v__, // first point
	        x_, y_, v_, // previous point
	        first,
	        clean;

	    var clipStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: polygonStart,
	      polygonEnd: polygonEnd
	    };

	    function point(x, y) {
	      if (visible(x, y)) activeStream.point(x, y);
	    }

	    function polygonInside() {
	      var winding = 0;

	      for (var i = 0, n = polygon.length; i < n; ++i) {
	        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
	          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
	          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
	          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
	        }
	      }

	      return winding;
	    }

	    // Buffer geometry within a polygon and then clip it en masse.
	    function polygonStart() {
	      activeStream = bufferStream, segments = [], polygon = [], clean = true;
	    }

	    function polygonEnd() {
	      var startInside = polygonInside(),
	          cleanInside = clean && startInside,
	          visible = (segments = d3Array.merge(segments)).length;
	      if (cleanInside || visible) {
	        stream.polygonStart();
	        if (cleanInside) {
	          stream.lineStart();
	          interpolate(null, null, 1, stream);
	          stream.lineEnd();
	        }
	        if (visible) {
	          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
	        }
	        stream.polygonEnd();
	      }
	      activeStream = stream, segments = polygon = ring = null;
	    }

	    function lineStart() {
	      clipStream.point = linePoint;
	      if (polygon) polygon.push(ring = []);
	      first = true;
	      v_ = false;
	      x_ = y_ = NaN;
	    }

	    // TODO rather than special-case polygons, simply handle them separately.
	    // Ideally, coincident intersection points should be jittered to avoid
	    // clipping issues.
	    function lineEnd() {
	      if (segments) {
	        linePoint(x__, y__);
	        if (v__ && v_) bufferStream.rejoin();
	        segments.push(bufferStream.result());
	      }
	      clipStream.point = point;
	      if (v_) activeStream.lineEnd();
	    }

	    function linePoint(x, y) {
	      var v = visible(x, y);
	      if (polygon) ring.push([x, y]);
	      if (first) {
	        x__ = x, y__ = y, v__ = v;
	        first = false;
	        if (v) {
	          activeStream.lineStart();
	          activeStream.point(x, y);
	        }
	      } else {
	        if (v && v_) activeStream.point(x, y);
	        else {
	          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
	              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
	          if (clipLine(a, b, x0, y0, x1, y1)) {
	            if (!v_) {
	              activeStream.lineStart();
	              activeStream.point(a[0], a[1]);
	            }
	            activeStream.point(b[0], b[1]);
	            if (!v) activeStream.lineEnd();
	            clean = false;
	          } else if (v) {
	            activeStream.lineStart();
	            activeStream.point(x, y);
	            clean = false;
	          }
	        }
	      }
	      x_ = x, y_ = y, v_ = v;
	    }

	    return clipStream;
	  };
	}

	function extent() {
	  var x0 = 0,
	      y0 = 0,
	      x1 = 960,
	      y1 = 500,
	      cache,
	      cacheStream,
	      clip;

	  return clip = {
	    stream: function(stream) {
	      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
	    },
	    extent: function(_) {
	      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
	    }
	  };
	}

	var lengthSum = adder();
	var lambda0$2;
	var sinPhi0$1;
	var cosPhi0$1;

	var lengthStream = {
	  sphere: noop,
	  point: noop,
	  lineStart: lengthLineStart,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop
	};

	function lengthLineStart() {
	  lengthStream.point = lengthPointFirst;
	  lengthStream.lineEnd = lengthLineEnd;
	}

	function lengthLineEnd() {
	  lengthStream.point = lengthStream.lineEnd = noop;
	}

	function lengthPointFirst(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
	  lengthStream.point = lengthPoint;
	}

	function lengthPoint(lambda, phi) {
	  lambda *= radians, phi *= radians;
	  var sinPhi = sin(phi),
	      cosPhi = cos(phi),
	      delta = abs(lambda - lambda0$2),
	      cosDelta = cos(delta),
	      sinDelta = sin(delta),
	      x = cosPhi * sinDelta,
	      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
	      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
	  lengthSum.add(atan2(sqrt(x * x + y * y), z));
	  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
	}

	function length(object) {
	  lengthSum.reset();
	  geoStream(object, lengthStream);
	  return +lengthSum;
	}

	var coordinates = [null, null];
	var object = {type: "LineString", coordinates: coordinates};

	function distance(a, b) {
	  coordinates[0] = a;
	  coordinates[1] = b;
	  return length(object);
	}

	var containsObjectType = {
	  Feature: function(object, point) {
	    return containsGeometry(object.geometry, point);
	  },
	  FeatureCollection: function(object, point) {
	    var features = object.features, i = -1, n = features.length;
	    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
	    return false;
	  }
	};

	var containsGeometryType = {
	  Sphere: function() {
	    return true;
	  },
	  Point: function(object, point) {
	    return containsPoint(object.coordinates, point);
	  },
	  MultiPoint: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
	    return false;
	  },
	  LineString: function(object, point) {
	    return containsLine(object.coordinates, point);
	  },
	  MultiLineString: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsLine(coordinates[i], point)) return true;
	    return false;
	  },
	  Polygon: function(object, point) {
	    return containsPolygon(object.coordinates, point);
	  },
	  MultiPolygon: function(object, point) {
	    var coordinates = object.coordinates, i = -1, n = coordinates.length;
	    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
	    return false;
	  },
	  GeometryCollection: function(object, point) {
	    var geometries = object.geometries, i = -1, n = geometries.length;
	    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
	    return false;
	  }
	};

	function containsGeometry(geometry, point) {
	  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
	      ? containsGeometryType[geometry.type](geometry, point)
	      : false;
	}

	function containsPoint(coordinates, point) {
	  return distance(coordinates, point) === 0;
	}

	function containsLine(coordinates, point) {
	  var ab = distance(coordinates[0], coordinates[1]),
	      ao = distance(coordinates[0], point),
	      ob = distance(point, coordinates[1]);
	  return ao + ob <= ab + epsilon;
	}

	function containsPolygon(coordinates, point) {
	  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
	}

	function ringRadians(ring) {
	  return ring = ring.map(pointRadians), ring.pop(), ring;
	}

	function pointRadians(point) {
	  return [point[0] * radians, point[1] * radians];
	}

	function contains(object, point) {
	  return (object && containsObjectType.hasOwnProperty(object.type)
	      ? containsObjectType[object.type]
	      : containsGeometry)(object, point);
	}

	function graticuleX(y0, y1, dy) {
	  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
	  return function(x) { return y.map(function(y) { return [x, y]; }); };
	}

	function graticuleY(x0, x1, dx) {
	  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
	  return function(y) { return x.map(function(x) { return [x, y]; }); };
	}

	function graticule() {
	  var x1, x0, X1, X0,
	      y1, y0, Y1, Y0,
	      dx = 10, dy = dx, DX = 90, DY = 360,
	      x, y, X, Y,
	      precision = 2.5;

	  function graticule() {
	    return {type: "MultiLineString", coordinates: lines()};
	  }

	  function lines() {
	    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
	        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
	        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
	        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
	  }

	  graticule.lines = function() {
	    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
	  };

	  graticule.outline = function() {
	    return {
	      type: "Polygon",
	      coordinates: [
	        X(X0).concat(
	        Y(Y1).slice(1),
	        X(X1).reverse().slice(1),
	        Y(Y0).reverse().slice(1))
	      ]
	    };
	  };

	  graticule.extent = function(_) {
	    if (!arguments.length) return graticule.extentMinor();
	    return graticule.extentMajor(_).extentMinor(_);
	  };

	  graticule.extentMajor = function(_) {
	    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
	    X0 = +_[0][0], X1 = +_[1][0];
	    Y0 = +_[0][1], Y1 = +_[1][1];
	    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
	    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.extentMinor = function(_) {
	    if (!arguments.length) return [[x0, y0], [x1, y1]];
	    x0 = +_[0][0], x1 = +_[1][0];
	    y0 = +_[0][1], y1 = +_[1][1];
	    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
	    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
	    return graticule.precision(precision);
	  };

	  graticule.step = function(_) {
	    if (!arguments.length) return graticule.stepMinor();
	    return graticule.stepMajor(_).stepMinor(_);
	  };

	  graticule.stepMajor = function(_) {
	    if (!arguments.length) return [DX, DY];
	    DX = +_[0], DY = +_[1];
	    return graticule;
	  };

	  graticule.stepMinor = function(_) {
	    if (!arguments.length) return [dx, dy];
	    dx = +_[0], dy = +_[1];
	    return graticule;
	  };

	  graticule.precision = function(_) {
	    if (!arguments.length) return precision;
	    precision = +_;
	    x = graticuleX(y0, y1, 90);
	    y = graticuleY(x0, x1, precision);
	    X = graticuleX(Y0, Y1, 90);
	    Y = graticuleY(X0, X1, precision);
	    return graticule;
	  };

	  return graticule
	      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
	      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
	}

	function graticule10() {
	  return graticule()();
	}

	function interpolate(a, b) {
	  var x0 = a[0] * radians,
	      y0 = a[1] * radians,
	      x1 = b[0] * radians,
	      y1 = b[1] * radians,
	      cy0 = cos(y0),
	      sy0 = sin(y0),
	      cy1 = cos(y1),
	      sy1 = sin(y1),
	      kx0 = cy0 * cos(x0),
	      ky0 = cy0 * sin(x0),
	      kx1 = cy1 * cos(x1),
	      ky1 = cy1 * sin(x1),
	      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
	      k = sin(d);

	  var interpolate = d ? function(t) {
	    var B = sin(t *= d) / k,
	        A = sin(d - t) / k,
	        x = A * kx0 + B * kx1,
	        y = A * ky0 + B * ky1,
	        z = A * sy0 + B * sy1;
	    return [
	      atan2(y, x) * degrees,
	      atan2(z, sqrt(x * x + y * y)) * degrees
	    ];
	  } : function() {
	    return [x0 * degrees, y0 * degrees];
	  };

	  interpolate.distance = d;

	  return interpolate;
	}

	function identity(x) {
	  return x;
	}

	var areaSum$1 = adder();
	var areaRingSum$1 = adder();
	var x00;
	var y00;
	var x0$1;
	var y0$1;

	var areaStream$1 = {
	  point: noop,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: function() {
	    areaStream$1.lineStart = areaRingStart$1;
	    areaStream$1.lineEnd = areaRingEnd$1;
	  },
	  polygonEnd: function() {
	    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
	    areaSum$1.add(abs(areaRingSum$1));
	    areaRingSum$1.reset();
	  },
	  result: function() {
	    var area = areaSum$1 / 2;
	    areaSum$1.reset();
	    return area;
	  }
	};

	function areaRingStart$1() {
	  areaStream$1.point = areaPointFirst$1;
	}

	function areaPointFirst$1(x, y) {
	  areaStream$1.point = areaPoint$1;
	  x00 = x0$1 = x, y00 = y0$1 = y;
	}

	function areaPoint$1(x, y) {
	  areaRingSum$1.add(y0$1 * x - x0$1 * y);
	  x0$1 = x, y0$1 = y;
	}

	function areaRingEnd$1() {
	  areaPoint$1(x00, y00);
	}

	var x0$2 = Infinity;
	var y0$2 = x0$2;
	var x1 = -x0$2;
	var y1 = x1;

	var boundsStream$1 = {
	  point: boundsPoint$1,
	  lineStart: noop,
	  lineEnd: noop,
	  polygonStart: noop,
	  polygonEnd: noop,
	  result: function() {
	    var bounds = [[x0$2, y0$2], [x1, y1]];
	    x1 = y1 = -(y0$2 = x0$2 = Infinity);
	    return bounds;
	  }
	};

	function boundsPoint$1(x, y) {
	  if (x < x0$2) x0$2 = x;
	  if (x > x1) x1 = x;
	  if (y < y0$2) y0$2 = y;
	  if (y > y1) y1 = y;
	}

	// TODO Enforce positive area for exterior, negative area for interior?

	var X0$1 = 0;
	var Y0$1 = 0;
	var Z0$1 = 0;
	var X1$1 = 0;
	var Y1$1 = 0;
	var Z1$1 = 0;
	var X2$1 = 0;
	var Y2$1 = 0;
	var Z2$1 = 0;
	var x00$1;
	var y00$1;
	var x0$3;
	var y0$3;

	var centroidStream$1 = {
	  point: centroidPoint$1,
	  lineStart: centroidLineStart$1,
	  lineEnd: centroidLineEnd$1,
	  polygonStart: function() {
	    centroidStream$1.lineStart = centroidRingStart$1;
	    centroidStream$1.lineEnd = centroidRingEnd$1;
	  },
	  polygonEnd: function() {
	    centroidStream$1.point = centroidPoint$1;
	    centroidStream$1.lineStart = centroidLineStart$1;
	    centroidStream$1.lineEnd = centroidLineEnd$1;
	  },
	  result: function() {
	    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
	        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
	        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
	        : [NaN, NaN];
	    X0$1 = Y0$1 = Z0$1 =
	    X1$1 = Y1$1 = Z1$1 =
	    X2$1 = Y2$1 = Z2$1 = 0;
	    return centroid;
	  }
	};

	function centroidPoint$1(x, y) {
	  X0$1 += x;
	  Y0$1 += y;
	  ++Z0$1;
	}

	function centroidLineStart$1() {
	  centroidStream$1.point = centroidPointFirstLine;
	}

	function centroidPointFirstLine(x, y) {
	  centroidStream$1.point = centroidPointLine;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidPointLine(x, y) {
	  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function centroidLineEnd$1() {
	  centroidStream$1.point = centroidPoint$1;
	}

	function centroidRingStart$1() {
	  centroidStream$1.point = centroidPointFirstRing;
	}

	function centroidRingEnd$1() {
	  centroidPointRing(x00$1, y00$1);
	}

	function centroidPointFirstRing(x, y) {
	  centroidStream$1.point = centroidPointRing;
	  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
	}

	function centroidPointRing(x, y) {
	  var dx = x - x0$3,
	      dy = y - y0$3,
	      z = sqrt(dx * dx + dy * dy);

	  X1$1 += z * (x0$3 + x) / 2;
	  Y1$1 += z * (y0$3 + y) / 2;
	  Z1$1 += z;

	  z = y0$3 * x - x0$3 * y;
	  X2$1 += z * (x0$3 + x);
	  Y2$1 += z * (y0$3 + y);
	  Z2$1 += z * 3;
	  centroidPoint$1(x0$3 = x, y0$3 = y);
	}

	function PathContext(context) {
	  this._context = context;
	}

	PathContext.prototype = {
	  _radius: 4.5,
	  pointRadius: function(_) {
	    return this._radius = _, this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._context.closePath();
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._context.moveTo(x, y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._context.lineTo(x, y);
	        break;
	      }
	      default: {
	        this._context.moveTo(x + this._radius, y);
	        this._context.arc(x, y, this._radius, 0, tau);
	        break;
	      }
	    }
	  },
	  result: noop
	};

	var lengthSum$1 = adder();
	var lengthRing;
	var x00$2;
	var y00$2;
	var x0$4;
	var y0$4;

	var lengthStream$1 = {
	  point: noop,
	  lineStart: function() {
	    lengthStream$1.point = lengthPointFirst$1;
	  },
	  lineEnd: function() {
	    if (lengthRing) lengthPoint$1(x00$2, y00$2);
	    lengthStream$1.point = noop;
	  },
	  polygonStart: function() {
	    lengthRing = true;
	  },
	  polygonEnd: function() {
	    lengthRing = null;
	  },
	  result: function() {
	    var length = +lengthSum$1;
	    lengthSum$1.reset();
	    return length;
	  }
	};

	function lengthPointFirst$1(x, y) {
	  lengthStream$1.point = lengthPoint$1;
	  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
	}

	function lengthPoint$1(x, y) {
	  x0$4 -= x, y0$4 -= y;
	  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
	  x0$4 = x, y0$4 = y;
	}

	function PathString() {
	  this._string = [];
	}

	PathString.prototype = {
	  _radius: 4.5,
	  _circle: circle$1(4.5),
	  pointRadius: function(_) {
	    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
	    return this;
	  },
	  polygonStart: function() {
	    this._line = 0;
	  },
	  polygonEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line === 0) this._string.push("Z");
	    this._point = NaN;
	  },
	  point: function(x, y) {
	    switch (this._point) {
	      case 0: {
	        this._string.push("M", x, ",", y);
	        this._point = 1;
	        break;
	      }
	      case 1: {
	        this._string.push("L", x, ",", y);
	        break;
	      }
	      default: {
	        if (this._circle == null) this._circle = circle$1(this._radius);
	        this._string.push("M", x, ",", y, this._circle);
	        break;
	      }
	    }
	  },
	  result: function() {
	    if (this._string.length) {
	      var result = this._string.join("");
	      this._string = [];
	      return result;
	    } else {
	      return null;
	    }
	  }
	};

	function circle$1(radius) {
	  return "m0," + radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
	      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
	      + "z";
	}

	function index(projection, context) {
	  var pointRadius = 4.5,
	      projectionStream,
	      contextStream;

	  function path(object) {
	    if (object) {
	      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
	      geoStream(object, projectionStream(contextStream));
	    }
	    return contextStream.result();
	  }

	  path.area = function(object) {
	    geoStream(object, projectionStream(areaStream$1));
	    return areaStream$1.result();
	  };

	  path.measure = function(object) {
	    geoStream(object, projectionStream(lengthStream$1));
	    return lengthStream$1.result();
	  };

	  path.bounds = function(object) {
	    geoStream(object, projectionStream(boundsStream$1));
	    return boundsStream$1.result();
	  };

	  path.centroid = function(object) {
	    geoStream(object, projectionStream(centroidStream$1));
	    return centroidStream$1.result();
	  };

	  path.projection = function(_) {
	    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
	  };

	  path.context = function(_) {
	    if (!arguments.length) return context;
	    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
	    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
	    return path;
	  };

	  path.pointRadius = function(_) {
	    if (!arguments.length) return pointRadius;
	    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
	    return path;
	  };

	  return path.projection(projection).context(context);
	}

	function transform(methods) {
	  return {
	    stream: transformer(methods)
	  };
	}

	function transformer(methods) {
	  return function(stream) {
	    var s = new TransformStream;
	    for (var key in methods) s[key] = methods[key];
	    s.stream = stream;
	    return s;
	  };
	}

	function TransformStream() {}

	TransformStream.prototype = {
	  constructor: TransformStream,
	  point: function(x, y) { this.stream.point(x, y); },
	  sphere: function() { this.stream.sphere(); },
	  lineStart: function() { this.stream.lineStart(); },
	  lineEnd: function() { this.stream.lineEnd(); },
	  polygonStart: function() { this.stream.polygonStart(); },
	  polygonEnd: function() { this.stream.polygonEnd(); }
	};

	function fit(projection, fitBounds, object) {
	  var clip = projection.clipExtent && projection.clipExtent();
	  projection.scale(150).translate([0, 0]);
	  if (clip != null) projection.clipExtent(null);
	  geoStream(object, projection.stream(boundsStream$1));
	  fitBounds(boundsStream$1.result());
	  if (clip != null) projection.clipExtent(clip);
	  return projection;
	}

	function fitExtent(projection, extent, object) {
	  return fit(projection, function(b) {
	    var w = extent[1][0] - extent[0][0],
	        h = extent[1][1] - extent[0][1],
	        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
	        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
	        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	function fitSize(projection, size, object) {
	  return fitExtent(projection, [[0, 0], size], object);
	}

	function fitWidth(projection, width, object) {
	  return fit(projection, function(b) {
	    var w = +width,
	        k = w / (b[1][0] - b[0][0]),
	        x = (w - k * (b[1][0] + b[0][0])) / 2,
	        y = -k * b[0][1];
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	function fitHeight(projection, height, object) {
	  return fit(projection, function(b) {
	    var h = +height,
	        k = h / (b[1][1] - b[0][1]),
	        x = -k * b[0][0],
	        y = (h - k * (b[1][1] + b[0][1])) / 2;
	    projection.scale(150 * k).translate([x, y]);
	  }, object);
	}

	var maxDepth = 16;
	var cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

	function resample(project, delta2) {
	  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
	}

	function resampleNone(project) {
	  return transformer({
	    point: function(x, y) {
	      x = project(x, y);
	      this.stream.point(x[0], x[1]);
	    }
	  });
	}

	function resample$1(project, delta2) {

	  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
	    var dx = x1 - x0,
	        dy = y1 - y0,
	        d2 = dx * dx + dy * dy;
	    if (d2 > 4 * delta2 && depth--) {
	      var a = a0 + a1,
	          b = b0 + b1,
	          c = c0 + c1,
	          m = sqrt(a * a + b * b + c * c),
	          phi2 = asin(c /= m),
	          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
	          p = project(lambda2, phi2),
	          x2 = p[0],
	          y2 = p[1],
	          dx2 = x2 - x0,
	          dy2 = y2 - y0,
	          dz = dy * dx2 - dx * dy2;
	      if (dz * dz / d2 > delta2 // perpendicular projected distance
	          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
	          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
	        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
	        stream.point(x2, y2);
	        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
	      }
	    }
	  }
	  return function(stream) {
	    var lambda00, x00, y00, a00, b00, c00, // first point
	        lambda0, x0, y0, a0, b0, c0; // previous point

	    var resampleStream = {
	      point: point,
	      lineStart: lineStart,
	      lineEnd: lineEnd,
	      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
	      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
	    };

	    function point(x, y) {
	      x = project(x, y);
	      stream.point(x[0], x[1]);
	    }

	    function lineStart() {
	      x0 = NaN;
	      resampleStream.point = linePoint;
	      stream.lineStart();
	    }

	    function linePoint(lambda, phi) {
	      var c = cartesian([lambda, phi]), p = project(lambda, phi);
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
	      stream.point(x0, y0);
	    }

	    function lineEnd() {
	      resampleStream.point = point;
	      stream.lineEnd();
	    }

	    function ringStart() {
	      lineStart();
	      resampleStream.point = ringPoint;
	      resampleStream.lineEnd = ringEnd;
	    }

	    function ringPoint(lambda, phi) {
	      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
	      resampleStream.point = linePoint;
	    }

	    function ringEnd() {
	      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
	      resampleStream.lineEnd = lineEnd;
	      lineEnd();
	    }

	    return resampleStream;
	  };
	}

	var transformRadians = transformer({
	  point: function(x, y) {
	    this.stream.point(x * radians, y * radians);
	  }
	});

	function transformRotate(rotate) {
	  return transformer({
	    point: function(x, y) {
	      var r = rotate(x, y);
	      return this.stream.point(r[0], r[1]);
	    }
	  });
	}

	function scaleTranslate(k, dx, dy) {
	  function transform$$1(x, y) {
	    return [dx + k * x, dy - k * y];
	  }
	  transform$$1.invert = function(x, y) {
	    return [(x - dx) / k, (dy - y) / k];
	  };
	  return transform$$1;
	}

	function scaleTranslateRotate(k, dx, dy, alpha) {
	  var cosAlpha = cos(alpha),
	      sinAlpha = sin(alpha),
	      a = cosAlpha * k,
	      b = sinAlpha * k,
	      ai = cosAlpha / k,
	      bi = sinAlpha / k,
	      ci = (sinAlpha * dy - cosAlpha * dx) / k,
	      fi = (sinAlpha * dx + cosAlpha * dy) / k;
	  function transform$$1(x, y) {
	    return [a * x - b * y + dx, dy - b * x - a * y];
	  }
	  transform$$1.invert = function(x, y) {
	    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
	  };
	  return transform$$1;
	}

	function projection(project) {
	  return projectionMutator(function() { return project; })();
	}

	function projectionMutator(projectAt) {
	  var project,
	      k = 150, // scale
	      x = 480, y = 250, // translate
	      lambda = 0, phi = 0, // center
	      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
	      alpha = 0, // post-rotate
	      theta = null, preclip = clipAntimeridian, // pre-clip angle
	      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
	      delta2 = 0.5, // precision
	      projectResample,
	      projectTransform,
	      projectRotateTransform,
	      cache,
	      cacheStream;

	  function projection(point) {
	    return projectRotateTransform(point[0] * radians, point[1] * radians);
	  }

	  function invert(point) {
	    point = projectRotateTransform.invert(point[0], point[1]);
	    return point && [point[0] * degrees, point[1] * degrees];
	  }

	  projection.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
	  };

	  projection.preclip = function(_) {
	    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
	  };

	  projection.postclip = function(_) {
	    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	  };

	  projection.clipAngle = function(_) {
	    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
	  };

	  projection.clipExtent = function(_) {
	    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  projection.scale = function(_) {
	    return arguments.length ? (k = +_, recenter()) : k;
	  };

	  projection.translate = function(_) {
	    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
	  };

	  projection.center = function(_) {
	    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
	  };

	  projection.rotate = function(_) {
	    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
	  };

	  projection.angle = function(_) {
	    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
	  };

	  projection.precision = function(_) {
	    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
	  };

	  projection.fitExtent = function(extent, object) {
	    return fitExtent(projection, extent, object);
	  };

	  projection.fitSize = function(size, object) {
	    return fitSize(projection, size, object);
	  };

	  projection.fitWidth = function(width, object) {
	    return fitWidth(projection, width, object);
	  };

	  projection.fitHeight = function(height, object) {
	    return fitHeight(projection, height, object);
	  };

	  function recenter() {
	    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
	        transform$$1 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
	    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
	    projectTransform = compose(project, transform$$1);
	    projectRotateTransform = compose(rotate, projectTransform);
	    projectResample = resample(projectTransform, delta2);
	    return reset();
	  }

	  function reset() {
	    cache = cacheStream = null;
	    return projection;
	  }

	  return function() {
	    project = projectAt.apply(this, arguments);
	    projection.invert = project.invert && invert;
	    return recenter();
	  };
	}

	function conicProjection(projectAt) {
	  var phi0 = 0,
	      phi1 = pi / 3,
	      m = projectionMutator(projectAt),
	      p = m(phi0, phi1);

	  p.parallels = function(_) {
	    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
	  };

	  return p;
	}

	function cylindricalEqualAreaRaw(phi0) {
	  var cosPhi0 = cos(phi0);

	  function forward(lambda, phi) {
	    return [lambda * cosPhi0, sin(phi) / cosPhi0];
	  }

	  forward.invert = function(x, y) {
	    return [x / cosPhi0, asin(y * cosPhi0)];
	  };

	  return forward;
	}

	function conicEqualAreaRaw(y0, y1) {
	  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

	  // Are the parallels symmetrical around the Equator?
	  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

	  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

	  function project(x, y) {
	    var r = sqrt(c - 2 * n * sin(y)) / n;
	    return [r * sin(x *= n), r0 - r * cos(x)];
	  }

	  project.invert = function(x, y) {
	    var r0y = r0 - y;
	    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
	  };

	  return project;
	}

	function conicEqualArea() {
	  return conicProjection(conicEqualAreaRaw)
	      .scale(155.424)
	      .center([0, 33.6442]);
	}

	function albers() {
	  return conicEqualArea()
	      .parallels([29.5, 45.5])
	      .scale(1070)
	      .translate([480, 250])
	      .rotate([96, 0])
	      .center([-0.6, 38.7]);
	}

	// The projections must have mutually exclusive clip regions on the sphere,
	// as this will avoid emitting interleaving lines and polygons.
	function multiplex(streams) {
	  var n = streams.length;
	  return {
	    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
	    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
	    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
	    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
	    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
	    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
	  };
	}

	// A composite projection for the United States, configured by default for
	// 960×500. The projection also works quite well at 960×600 if you change the
	// scale to 1285 and adjust the translate accordingly. The set of standard
	// parallels for each region comes from USGS, which is published here:
	// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
	function albersUsa() {
	  var cache,
	      cacheStream,
	      lower48 = albers(), lower48Point,
	      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
	      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
	      point, pointStream = {point: function(x, y) { point = [x, y]; }};

	  function albersUsa(coordinates) {
	    var x = coordinates[0], y = coordinates[1];
	    return point = null, (lower48Point.point(x, y), point)
	        || (alaskaPoint.point(x, y), point)
	        || (hawaiiPoint.point(x, y), point);
	  }

	  albersUsa.invert = function(coordinates) {
	    var k = lower48.scale(),
	        t = lower48.translate(),
	        x = (coordinates[0] - t[0]) / k,
	        y = (coordinates[1] - t[1]) / k;
	    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
	        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
	        : lower48).invert(coordinates);
	  };

	  albersUsa.stream = function(stream) {
	    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
	  };

	  albersUsa.precision = function(_) {
	    if (!arguments.length) return lower48.precision();
	    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
	    return reset();
	  };

	  albersUsa.scale = function(_) {
	    if (!arguments.length) return lower48.scale();
	    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
	    return albersUsa.translate(lower48.translate());
	  };

	  albersUsa.translate = function(_) {
	    if (!arguments.length) return lower48.translate();
	    var k = lower48.scale(), x = +_[0], y = +_[1];

	    lower48Point = lower48
	        .translate(_)
	        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
	        .stream(pointStream);

	    alaskaPoint = alaska
	        .translate([x - 0.307 * k, y + 0.201 * k])
	        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    hawaiiPoint = hawaii
	        .translate([x - 0.205 * k, y + 0.212 * k])
	        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
	        .stream(pointStream);

	    return reset();
	  };

	  albersUsa.fitExtent = function(extent, object) {
	    return fitExtent(albersUsa, extent, object);
	  };

	  albersUsa.fitSize = function(size, object) {
	    return fitSize(albersUsa, size, object);
	  };

	  albersUsa.fitWidth = function(width, object) {
	    return fitWidth(albersUsa, width, object);
	  };

	  albersUsa.fitHeight = function(height, object) {
	    return fitHeight(albersUsa, height, object);
	  };

	  function reset() {
	    cache = cacheStream = null;
	    return albersUsa;
	  }

	  return albersUsa.scale(1070);
	}

	function azimuthalRaw(scale) {
	  return function(x, y) {
	    var cx = cos(x),
	        cy = cos(y),
	        k = scale(cx * cy);
	    return [
	      k * cy * sin(x),
	      k * sin(y)
	    ];
	  }
	}

	function azimuthalInvert(angle) {
	  return function(x, y) {
	    var z = sqrt(x * x + y * y),
	        c = angle(z),
	        sc = sin(c),
	        cc = cos(c);
	    return [
	      atan2(x * sc, z * cc),
	      asin(z && y * sc / z)
	    ];
	  }
	}

	var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
	  return sqrt(2 / (1 + cxcy));
	});

	azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
	  return 2 * asin(z / 2);
	});

	function azimuthalEqualArea() {
	  return projection(azimuthalEqualAreaRaw)
	      .scale(124.75)
	      .clipAngle(180 - 1e-3);
	}

	var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
	  return (c = acos(c)) && c / sin(c);
	});

	azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
	  return z;
	});

	function azimuthalEquidistant() {
	  return projection(azimuthalEquidistantRaw)
	      .scale(79.4188)
	      .clipAngle(180 - 1e-3);
	}

	function mercatorRaw(lambda, phi) {
	  return [lambda, log(tan((halfPi + phi) / 2))];
	}

	mercatorRaw.invert = function(x, y) {
	  return [x, 2 * atan(exp(y)) - halfPi];
	};

	function mercator() {
	  return mercatorProjection(mercatorRaw)
	      .scale(961 / tau);
	}

	function mercatorProjection(project) {
	  var m = projection(project),
	      center = m.center,
	      scale = m.scale,
	      translate = m.translate,
	      clipExtent = m.clipExtent,
	      x0 = null, y0, x1, y1; // clip extent

	  m.scale = function(_) {
	    return arguments.length ? (scale(_), reclip()) : scale();
	  };

	  m.translate = function(_) {
	    return arguments.length ? (translate(_), reclip()) : translate();
	  };

	  m.center = function(_) {
	    return arguments.length ? (center(_), reclip()) : center();
	  };

	  m.clipExtent = function(_) {
	    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	  };

	  function reclip() {
	    var k = pi * scale(),
	        t = m(rotation(m.rotate()).invert([0, 0]));
	    return clipExtent(x0 == null
	        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
	        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
	        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
	  }

	  return reclip();
	}

	function tany(y) {
	  return tan((halfPi + y) / 2);
	}

	function conicConformalRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
	      f = cy0 * pow(tany(y0), n) / n;

	  if (!n) return mercatorRaw;

	  function project(x, y) {
	    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
	    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
	    var r = f / pow(tany(y), n);
	    return [r * sin(n * x), f - r * cos(n * x)];
	  }

	  project.invert = function(x, y) {
	    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
	    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
	  };

	  return project;
	}

	function conicConformal() {
	  return conicProjection(conicConformalRaw)
	      .scale(109.5)
	      .parallels([30, 30]);
	}

	function equirectangularRaw(lambda, phi) {
	  return [lambda, phi];
	}

	equirectangularRaw.invert = equirectangularRaw;

	function equirectangular() {
	  return projection(equirectangularRaw)
	      .scale(152.63);
	}

	function conicEquidistantRaw(y0, y1) {
	  var cy0 = cos(y0),
	      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
	      g = cy0 / n + y0;

	  if (abs(n) < epsilon) return equirectangularRaw;

	  function project(x, y) {
	    var gy = g - y, nx = n * x;
	    return [gy * sin(nx), g - gy * cos(nx)];
	  }

	  project.invert = function(x, y) {
	    var gy = g - y;
	    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
	  };

	  return project;
	}

	function conicEquidistant() {
	  return conicProjection(conicEquidistantRaw)
	      .scale(131.154)
	      .center([0, 13.9389]);
	}

	function gnomonicRaw(x, y) {
	  var cy = cos(y), k = cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	gnomonicRaw.invert = azimuthalInvert(atan);

	function gnomonic() {
	  return projection(gnomonicRaw)
	      .scale(144.049)
	      .clipAngle(60);
	}

	function scaleTranslate$1(kx, ky, tx, ty) {
	  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
	    point: function(x, y) {
	      this.stream.point(x * kx + tx, y * ky + ty);
	    }
	  });
	}

	function identity$1() {
	  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity, // scale, translate and reflect
	      x0 = null, y0, x1, y1, // clip extent
	      postclip = identity,
	      cache,
	      cacheStream,
	      projection;

	  function reset() {
	    cache = cacheStream = null;
	    return projection;
	  }

	  return projection = {
	    stream: function(stream) {
	      return cache && cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));
	    },
	    postclip: function(_) {
	      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
	    },
	    clipExtent: function(_) {
	      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
	    },
	    scale: function(_) {
	      return arguments.length ? (transform$$1 = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;
	    },
	    translate: function(_) {
	      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
	    },
	    reflectX: function(_) {
	      return arguments.length ? (transform$$1 = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
	    },
	    reflectY: function(_) {
	      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
	    },
	    fitExtent: function(extent, object) {
	      return fitExtent(projection, extent, object);
	    },
	    fitSize: function(size, object) {
	      return fitSize(projection, size, object);
	    },
	    fitWidth: function(width, object) {
	      return fitWidth(projection, width, object);
	    },
	    fitHeight: function(height, object) {
	      return fitHeight(projection, height, object);
	    }
	  };
	}

	function naturalEarth1Raw(lambda, phi) {
	  var phi2 = phi * phi, phi4 = phi2 * phi2;
	  return [
	    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
	    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
	  ];
	}

	naturalEarth1Raw.invert = function(x, y) {
	  var phi = y, i = 25, delta;
	  do {
	    var phi2 = phi * phi, phi4 = phi2 * phi2;
	    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
	        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
	  } while (abs(delta) > epsilon && --i > 0);
	  return [
	    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
	    phi
	  ];
	};

	function naturalEarth1() {
	  return projection(naturalEarth1Raw)
	      .scale(175.295);
	}

	function orthographicRaw(x, y) {
	  return [cos(y) * sin(x), sin(y)];
	}

	orthographicRaw.invert = azimuthalInvert(asin);

	function orthographic() {
	  return projection(orthographicRaw)
	      .scale(249.5)
	      .clipAngle(90 + epsilon);
	}

	function stereographicRaw(x, y) {
	  var cy = cos(y), k = 1 + cos(x) * cy;
	  return [cy * sin(x) / k, sin(y) / k];
	}

	stereographicRaw.invert = azimuthalInvert(function(z) {
	  return 2 * atan(z);
	});

	function stereographic() {
	  return projection(stereographicRaw)
	      .scale(250)
	      .clipAngle(142);
	}

	function transverseMercatorRaw(lambda, phi) {
	  return [log(tan((halfPi + phi) / 2)), -lambda];
	}

	transverseMercatorRaw.invert = function(x, y) {
	  return [-y, 2 * atan(exp(x)) - halfPi];
	};

	function transverseMercator() {
	  var m = mercatorProjection(transverseMercatorRaw),
	      center = m.center,
	      rotate = m.rotate;

	  m.center = function(_) {
	    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
	  };

	  m.rotate = function(_) {
	    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
	  };

	  return rotate([0, 0, 90])
	      .scale(159.155);
	}

	exports.geoArea = area;
	exports.geoBounds = bounds;
	exports.geoCentroid = centroid;
	exports.geoCircle = circle;
	exports.geoClipAntimeridian = clipAntimeridian;
	exports.geoClipCircle = clipCircle;
	exports.geoClipExtent = extent;
	exports.geoClipRectangle = clipRectangle;
	exports.geoContains = contains;
	exports.geoDistance = distance;
	exports.geoGraticule = graticule;
	exports.geoGraticule10 = graticule10;
	exports.geoInterpolate = interpolate;
	exports.geoLength = length;
	exports.geoPath = index;
	exports.geoAlbers = albers;
	exports.geoAlbersUsa = albersUsa;
	exports.geoAzimuthalEqualArea = azimuthalEqualArea;
	exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
	exports.geoAzimuthalEquidistant = azimuthalEquidistant;
	exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
	exports.geoConicConformal = conicConformal;
	exports.geoConicConformalRaw = conicConformalRaw;
	exports.geoConicEqualArea = conicEqualArea;
	exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
	exports.geoConicEquidistant = conicEquidistant;
	exports.geoConicEquidistantRaw = conicEquidistantRaw;
	exports.geoEquirectangular = equirectangular;
	exports.geoEquirectangularRaw = equirectangularRaw;
	exports.geoGnomonic = gnomonic;
	exports.geoGnomonicRaw = gnomonicRaw;
	exports.geoIdentity = identity$1;
	exports.geoProjection = projection;
	exports.geoProjectionMutator = projectionMutator;
	exports.geoMercator = mercator;
	exports.geoMercatorRaw = mercatorRaw;
	exports.geoNaturalEarth1 = naturalEarth1;
	exports.geoNaturalEarth1Raw = naturalEarth1Raw;
	exports.geoOrthographic = orthographic;
	exports.geoOrthographicRaw = orthographicRaw;
	exports.geoStereographic = stereographic;
	exports.geoStereographicRaw = stereographicRaw;
	exports.geoTransverseMercator = transverseMercator;
	exports.geoTransverseMercatorRaw = transverseMercatorRaw;
	exports.geoRotation = rotation;
	exports.geoStream = geoStream;
	exports.geoTransform = transform;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-hierarchy/ Version 1.1.6. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	function defaultSeparation(a, b) {
	  return a.parent === b.parent ? 1 : 2;
	}

	function meanX(children) {
	  return children.reduce(meanXReduce, 0) / children.length;
	}

	function meanXReduce(x, c) {
	  return x + c.x;
	}

	function maxY(children) {
	  return 1 + children.reduce(maxYReduce, 0);
	}

	function maxYReduce(y, c) {
	  return Math.max(y, c.y);
	}

	function leafLeft(node) {
	  var children;
	  while (children = node.children) node = children[0];
	  return node;
	}

	function leafRight(node) {
	  var children;
	  while (children = node.children) node = children[children.length - 1];
	  return node;
	}

	var cluster = function() {
	  var separation = defaultSeparation,
	      dx = 1,
	      dy = 1,
	      nodeSize = false;

	  function cluster(root) {
	    var previousNode,
	        x = 0;

	    // First walk, computing the initial x & y values.
	    root.eachAfter(function(node) {
	      var children = node.children;
	      if (children) {
	        node.x = meanX(children);
	        node.y = maxY(children);
	      } else {
	        node.x = previousNode ? x += separation(node, previousNode) : 0;
	        node.y = 0;
	        previousNode = node;
	      }
	    });

	    var left = leafLeft(root),
	        right = leafRight(root),
	        x0 = left.x - separation(left, right) / 2,
	        x1 = right.x + separation(right, left) / 2;

	    // Second walk, normalizing x & y to the desired size.
	    return root.eachAfter(nodeSize ? function(node) {
	      node.x = (node.x - root.x) * dx;
	      node.y = (root.y - node.y) * dy;
	    } : function(node) {
	      node.x = (node.x - x0) / (x1 - x0) * dx;
	      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
	    });
	  }

	  cluster.separation = function(x) {
	    return arguments.length ? (separation = x, cluster) : separation;
	  };

	  cluster.size = function(x) {
	    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
	  };

	  cluster.nodeSize = function(x) {
	    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
	  };

	  return cluster;
	};

	function count(node) {
	  var sum = 0,
	      children = node.children,
	      i = children && children.length;
	  if (!i) sum = 1;
	  else while (--i >= 0) sum += children[i].value;
	  node.value = sum;
	}

	var node_count = function() {
	  return this.eachAfter(count);
	};

	var node_each = function(callback) {
	  var node = this, current, next = [node], children, i, n;
	  do {
	    current = next.reverse(), next = [];
	    while (node = current.pop()) {
	      callback(node), children = node.children;
	      if (children) for (i = 0, n = children.length; i < n; ++i) {
	        next.push(children[i]);
	      }
	    }
	  } while (next.length);
	  return this;
	};

	var node_eachBefore = function(callback) {
	  var node = this, nodes = [node], children, i;
	  while (node = nodes.pop()) {
	    callback(node), children = node.children;
	    if (children) for (i = children.length - 1; i >= 0; --i) {
	      nodes.push(children[i]);
	    }
	  }
	  return this;
	};

	var node_eachAfter = function(callback) {
	  var node = this, nodes = [node], next = [], children, i, n;
	  while (node = nodes.pop()) {
	    next.push(node), children = node.children;
	    if (children) for (i = 0, n = children.length; i < n; ++i) {
	      nodes.push(children[i]);
	    }
	  }
	  while (node = next.pop()) {
	    callback(node);
	  }
	  return this;
	};

	var node_sum = function(value) {
	  return this.eachAfter(function(node) {
	    var sum = +value(node.data) || 0,
	        children = node.children,
	        i = children && children.length;
	    while (--i >= 0) sum += children[i].value;
	    node.value = sum;
	  });
	};

	var node_sort = function(compare) {
	  return this.eachBefore(function(node) {
	    if (node.children) {
	      node.children.sort(compare);
	    }
	  });
	};

	var node_path = function(end) {
	  var start = this,
	      ancestor = leastCommonAncestor(start, end),
	      nodes = [start];
	  while (start !== ancestor) {
	    start = start.parent;
	    nodes.push(start);
	  }
	  var k = nodes.length;
	  while (end !== ancestor) {
	    nodes.splice(k, 0, end);
	    end = end.parent;
	  }
	  return nodes;
	};

	function leastCommonAncestor(a, b) {
	  if (a === b) return a;
	  var aNodes = a.ancestors(),
	      bNodes = b.ancestors(),
	      c = null;
	  a = aNodes.pop();
	  b = bNodes.pop();
	  while (a === b) {
	    c = a;
	    a = aNodes.pop();
	    b = bNodes.pop();
	  }
	  return c;
	}

	var node_ancestors = function() {
	  var node = this, nodes = [node];
	  while (node = node.parent) {
	    nodes.push(node);
	  }
	  return nodes;
	};

	var node_descendants = function() {
	  var nodes = [];
	  this.each(function(node) {
	    nodes.push(node);
	  });
	  return nodes;
	};

	var node_leaves = function() {
	  var leaves = [];
	  this.eachBefore(function(node) {
	    if (!node.children) {
	      leaves.push(node);
	    }
	  });
	  return leaves;
	};

	var node_links = function() {
	  var root = this, links = [];
	  root.each(function(node) {
	    if (node !== root) { // Don’t include the root’s parent, if any.
	      links.push({source: node.parent, target: node});
	    }
	  });
	  return links;
	};

	function hierarchy(data, children) {
	  var root = new Node(data),
	      valued = +data.value && (root.value = data.value),
	      node,
	      nodes = [root],
	      child,
	      childs,
	      i,
	      n;

	  if (children == null) children = defaultChildren;

	  while (node = nodes.pop()) {
	    if (valued) node.value = +node.data.value;
	    if ((childs = children(node.data)) && (n = childs.length)) {
	      node.children = new Array(n);
	      for (i = n - 1; i >= 0; --i) {
	        nodes.push(child = node.children[i] = new Node(childs[i]));
	        child.parent = node;
	        child.depth = node.depth + 1;
	      }
	    }
	  }

	  return root.eachBefore(computeHeight);
	}

	function node_copy() {
	  return hierarchy(this).eachBefore(copyData);
	}

	function defaultChildren(d) {
	  return d.children;
	}

	function copyData(node) {
	  node.data = node.data.data;
	}

	function computeHeight(node) {
	  var height = 0;
	  do node.height = height;
	  while ((node = node.parent) && (node.height < ++height));
	}

	function Node(data) {
	  this.data = data;
	  this.depth =
	  this.height = 0;
	  this.parent = null;
	}

	Node.prototype = hierarchy.prototype = {
	  constructor: Node,
	  count: node_count,
	  each: node_each,
	  eachAfter: node_eachAfter,
	  eachBefore: node_eachBefore,
	  sum: node_sum,
	  sort: node_sort,
	  path: node_path,
	  ancestors: node_ancestors,
	  descendants: node_descendants,
	  leaves: node_leaves,
	  links: node_links,
	  copy: node_copy
	};

	var slice = Array.prototype.slice;

	function shuffle(array) {
	  var m = array.length,
	      t,
	      i;

	  while (m) {
	    i = Math.random() * m-- | 0;
	    t = array[m];
	    array[m] = array[i];
	    array[i] = t;
	  }

	  return array;
	}

	var enclose = function(circles) {
	  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

	  while (i < n) {
	    p = circles[i];
	    if (e && enclosesWeak(e, p)) ++i;
	    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
	  }

	  return e;
	};

	function extendBasis(B, p) {
	  var i, j;

	  if (enclosesWeakAll(p, B)) return [p];

	  // If we get here then B must have at least one element.
	  for (i = 0; i < B.length; ++i) {
	    if (enclosesNot(p, B[i])
	        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
	      return [B[i], p];
	    }
	  }

	  // If we get here then B must have at least two elements.
	  for (i = 0; i < B.length - 1; ++i) {
	    for (j = i + 1; j < B.length; ++j) {
	      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
	          && enclosesNot(encloseBasis2(B[i], p), B[j])
	          && enclosesNot(encloseBasis2(B[j], p), B[i])
	          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
	        return [B[i], B[j], p];
	      }
	    }
	  }

	  // If we get here then something is very wrong.
	  throw new Error;
	}

	function enclosesNot(a, b) {
	  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
	  return dr < 0 || dr * dr < dx * dx + dy * dy;
	}

	function enclosesWeak(a, b) {
	  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	  return dr > 0 && dr * dr > dx * dx + dy * dy;
	}

	function enclosesWeakAll(a, B) {
	  for (var i = 0; i < B.length; ++i) {
	    if (!enclosesWeak(a, B[i])) {
	      return false;
	    }
	  }
	  return true;
	}

	function encloseBasis(B) {
	  switch (B.length) {
	    case 1: return encloseBasis1(B[0]);
	    case 2: return encloseBasis2(B[0], B[1]);
	    case 3: return encloseBasis3(B[0], B[1], B[2]);
	  }
	}

	function encloseBasis1(a) {
	  return {
	    x: a.x,
	    y: a.y,
	    r: a.r
	  };
	}

	function encloseBasis2(a, b) {
	  var x1 = a.x, y1 = a.y, r1 = a.r,
	      x2 = b.x, y2 = b.y, r2 = b.r,
	      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
	      l = Math.sqrt(x21 * x21 + y21 * y21);
	  return {
	    x: (x1 + x2 + x21 / l * r21) / 2,
	    y: (y1 + y2 + y21 / l * r21) / 2,
	    r: (l + r1 + r2) / 2
	  };
	}

	function encloseBasis3(a, b, c) {
	  var x1 = a.x, y1 = a.y, r1 = a.r,
	      x2 = b.x, y2 = b.y, r2 = b.r,
	      x3 = c.x, y3 = c.y, r3 = c.r,
	      a2 = x1 - x2,
	      a3 = x1 - x3,
	      b2 = y1 - y2,
	      b3 = y1 - y3,
	      c2 = r2 - r1,
	      c3 = r3 - r1,
	      d1 = x1 * x1 + y1 * y1 - r1 * r1,
	      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
	      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
	      ab = a3 * b2 - a2 * b3,
	      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
	      xb = (b3 * c2 - b2 * c3) / ab,
	      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
	      yb = (a2 * c3 - a3 * c2) / ab,
	      A = xb * xb + yb * yb - 1,
	      B = 2 * (r1 + xa * xb + ya * yb),
	      C = xa * xa + ya * ya - r1 * r1,
	      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
	  return {
	    x: x1 + xa + xb * r,
	    y: y1 + ya + yb * r,
	    r: r
	  };
	}

	function place(b, a, c) {
	  var dx = b.x - a.x, x, a2,
	      dy = b.y - a.y, y, b2,
	      d2 = dx * dx + dy * dy;
	  if (d2) {
	    a2 = a.r + c.r, a2 *= a2;
	    b2 = b.r + c.r, b2 *= b2;
	    if (a2 > b2) {
	      x = (d2 + b2 - a2) / (2 * d2);
	      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
	      c.x = b.x - x * dx - y * dy;
	      c.y = b.y - x * dy + y * dx;
	    } else {
	      x = (d2 + a2 - b2) / (2 * d2);
	      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
	      c.x = a.x + x * dx - y * dy;
	      c.y = a.y + x * dy + y * dx;
	    }
	  } else {
	    c.x = a.x + c.r;
	    c.y = a.y;
	  }
	}

	function intersects(a, b) {
	  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
	  return dr > 0 && dr * dr > dx * dx + dy * dy;
	}

	function score(node) {
	  var a = node._,
	      b = node.next._,
	      ab = a.r + b.r,
	      dx = (a.x * b.r + b.x * a.r) / ab,
	      dy = (a.y * b.r + b.y * a.r) / ab;
	  return dx * dx + dy * dy;
	}

	function Node$1(circle) {
	  this._ = circle;
	  this.next = null;
	  this.previous = null;
	}

	function packEnclose(circles) {
	  if (!(n = circles.length)) return 0;

	  var a, b, c, n, aa, ca, i, j, k, sj, sk;

	  // Place the first circle.
	  a = circles[0], a.x = 0, a.y = 0;
	  if (!(n > 1)) return a.r;

	  // Place the second circle.
	  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
	  if (!(n > 2)) return a.r + b.r;

	  // Place the third circle.
	  place(b, a, c = circles[2]);

	  // Initialize the front-chain using the first three circles a, b and c.
	  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
	  a.next = c.previous = b;
	  b.next = a.previous = c;
	  c.next = b.previous = a;

	  // Attempt to place each remaining circle…
	  pack: for (i = 3; i < n; ++i) {
	    place(a._, b._, c = circles[i]), c = new Node$1(c);

	    // Find the closest intersecting circle on the front-chain, if any.
	    // “Closeness” is determined by linear distance along the front-chain.
	    // “Ahead” or “behind” is likewise determined by linear distance.
	    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
	    do {
	      if (sj <= sk) {
	        if (intersects(j._, c._)) {
	          b = j, a.next = b, b.previous = a, --i;
	          continue pack;
	        }
	        sj += j._.r, j = j.next;
	      } else {
	        if (intersects(k._, c._)) {
	          a = k, a.next = b, b.previous = a, --i;
	          continue pack;
	        }
	        sk += k._.r, k = k.previous;
	      }
	    } while (j !== k.next);

	    // Success! Insert the new circle c between a and b.
	    c.previous = a, c.next = b, a.next = b.previous = b = c;

	    // Compute the new closest circle pair to the centroid.
	    aa = score(a);
	    while ((c = c.next) !== b) {
	      if ((ca = score(c)) < aa) {
	        a = c, aa = ca;
	      }
	    }
	    b = a.next;
	  }

	  // Compute the enclosing circle of the front chain.
	  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

	  // Translate the circles to put the enclosing circle around the origin.
	  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

	  return c.r;
	}

	var siblings = function(circles) {
	  packEnclose(circles);
	  return circles;
	};

	function optional(f) {
	  return f == null ? null : required(f);
	}

	function required(f) {
	  if (typeof f !== "function") throw new Error;
	  return f;
	}

	function constantZero() {
	  return 0;
	}

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	function defaultRadius(d) {
	  return Math.sqrt(d.value);
	}

	var index = function() {
	  var radius = null,
	      dx = 1,
	      dy = 1,
	      padding = constantZero;

	  function pack(root) {
	    root.x = dx / 2, root.y = dy / 2;
	    if (radius) {
	      root.eachBefore(radiusLeaf(radius))
	          .eachAfter(packChildren(padding, 0.5))
	          .eachBefore(translateChild(1));
	    } else {
	      root.eachBefore(radiusLeaf(defaultRadius))
	          .eachAfter(packChildren(constantZero, 1))
	          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
	          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
	    }
	    return root;
	  }

	  pack.radius = function(x) {
	    return arguments.length ? (radius = optional(x), pack) : radius;
	  };

	  pack.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
	  };

	  pack.padding = function(x) {
	    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
	  };

	  return pack;
	};

	function radiusLeaf(radius) {
	  return function(node) {
	    if (!node.children) {
	      node.r = Math.max(0, +radius(node) || 0);
	    }
	  };
	}

	function packChildren(padding, k) {
	  return function(node) {
	    if (children = node.children) {
	      var children,
	          i,
	          n = children.length,
	          r = padding(node) * k || 0,
	          e;

	      if (r) for (i = 0; i < n; ++i) children[i].r += r;
	      e = packEnclose(children);
	      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
	      node.r = e + r;
	    }
	  };
	}

	function translateChild(k) {
	  return function(node) {
	    var parent = node.parent;
	    node.r *= k;
	    if (parent) {
	      node.x = parent.x + k * node.x;
	      node.y = parent.y + k * node.y;
	    }
	  };
	}

	var roundNode = function(node) {
	  node.x0 = Math.round(node.x0);
	  node.y0 = Math.round(node.y0);
	  node.x1 = Math.round(node.x1);
	  node.y1 = Math.round(node.y1);
	};

	var treemapDice = function(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      node,
	      i = -1,
	      n = nodes.length,
	      k = parent.value && (x1 - x0) / parent.value;

	  while (++i < n) {
	    node = nodes[i], node.y0 = y0, node.y1 = y1;
	    node.x0 = x0, node.x1 = x0 += node.value * k;
	  }
	};

	var partition = function() {
	  var dx = 1,
	      dy = 1,
	      padding = 0,
	      round = false;

	  function partition(root) {
	    var n = root.height + 1;
	    root.x0 =
	    root.y0 = padding;
	    root.x1 = dx;
	    root.y1 = dy / n;
	    root.eachBefore(positionNode(dy, n));
	    if (round) root.eachBefore(roundNode);
	    return root;
	  }

	  function positionNode(dy, n) {
	    return function(node) {
	      if (node.children) {
	        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
	      }
	      var x0 = node.x0,
	          y0 = node.y0,
	          x1 = node.x1 - padding,
	          y1 = node.y1 - padding;
	      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	      node.x0 = x0;
	      node.y0 = y0;
	      node.x1 = x1;
	      node.y1 = y1;
	    };
	  }

	  partition.round = function(x) {
	    return arguments.length ? (round = !!x, partition) : round;
	  };

	  partition.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
	  };

	  partition.padding = function(x) {
	    return arguments.length ? (padding = +x, partition) : padding;
	  };

	  return partition;
	};

	var keyPrefix = "$";
	var preroot = {depth: -1};
	var ambiguous = {};

	function defaultId(d) {
	  return d.id;
	}

	function defaultParentId(d) {
	  return d.parentId;
	}

	var stratify = function() {
	  var id = defaultId,
	      parentId = defaultParentId;

	  function stratify(data) {
	    var d,
	        i,
	        n = data.length,
	        root,
	        parent,
	        node,
	        nodes = new Array(n),
	        nodeId,
	        nodeKey,
	        nodeByKey = {};

	    for (i = 0; i < n; ++i) {
	      d = data[i], node = nodes[i] = new Node(d);
	      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
	        nodeKey = keyPrefix + (node.id = nodeId);
	        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
	      }
	    }

	    for (i = 0; i < n; ++i) {
	      node = nodes[i], nodeId = parentId(data[i], i, data);
	      if (nodeId == null || !(nodeId += "")) {
	        if (root) throw new Error("multiple roots");
	        root = node;
	      } else {
	        parent = nodeByKey[keyPrefix + nodeId];
	        if (!parent) throw new Error("missing: " + nodeId);
	        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
	        if (parent.children) parent.children.push(node);
	        else parent.children = [node];
	        node.parent = parent;
	      }
	    }

	    if (!root) throw new Error("no root");
	    root.parent = preroot;
	    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
	    root.parent = null;
	    if (n > 0) throw new Error("cycle");

	    return root;
	  }

	  stratify.id = function(x) {
	    return arguments.length ? (id = required(x), stratify) : id;
	  };

	  stratify.parentId = function(x) {
	    return arguments.length ? (parentId = required(x), stratify) : parentId;
	  };

	  return stratify;
	};

	function defaultSeparation$1(a, b) {
	  return a.parent === b.parent ? 1 : 2;
	}

	// function radialSeparation(a, b) {
	//   return (a.parent === b.parent ? 1 : 2) / a.depth;
	// }

	// This function is used to traverse the left contour of a subtree (or
	// subforest). It returns the successor of v on this contour. This successor is
	// either given by the leftmost child of v or by the thread of v. The function
	// returns null if and only if v is on the highest level of its subtree.
	function nextLeft(v) {
	  var children = v.children;
	  return children ? children[0] : v.t;
	}

	// This function works analogously to nextLeft.
	function nextRight(v) {
	  var children = v.children;
	  return children ? children[children.length - 1] : v.t;
	}

	// Shifts the current subtree rooted at w+. This is done by increasing
	// prelim(w+) and mod(w+) by shift.
	function moveSubtree(wm, wp, shift) {
	  var change = shift / (wp.i - wm.i);
	  wp.c -= change;
	  wp.s += shift;
	  wm.c += change;
	  wp.z += shift;
	  wp.m += shift;
	}

	// All other shifts, applied to the smaller subtrees between w- and w+, are
	// performed by this function. To prepare the shifts, we have to adjust
	// change(w+), shift(w+), and change(w-).
	function executeShifts(v) {
	  var shift = 0,
	      change = 0,
	      children = v.children,
	      i = children.length,
	      w;
	  while (--i >= 0) {
	    w = children[i];
	    w.z += shift;
	    w.m += shift;
	    shift += w.s + (change += w.c);
	  }
	}

	// If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
	// returns the specified (default) ancestor.
	function nextAncestor(vim, v, ancestor) {
	  return vim.a.parent === v.parent ? vim.a : ancestor;
	}

	function TreeNode(node, i) {
	  this._ = node;
	  this.parent = null;
	  this.children = null;
	  this.A = null; // default ancestor
	  this.a = this; // ancestor
	  this.z = 0; // prelim
	  this.m = 0; // mod
	  this.c = 0; // change
	  this.s = 0; // shift
	  this.t = null; // thread
	  this.i = i; // number
	}

	TreeNode.prototype = Object.create(Node.prototype);

	function treeRoot(root) {
	  var tree = new TreeNode(root, 0),
	      node,
	      nodes = [tree],
	      child,
	      children,
	      i,
	      n;

	  while (node = nodes.pop()) {
	    if (children = node._.children) {
	      node.children = new Array(n = children.length);
	      for (i = n - 1; i >= 0; --i) {
	        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
	        child.parent = node;
	      }
	    }
	  }

	  (tree.parent = new TreeNode(null, 0)).children = [tree];
	  return tree;
	}

	// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
	var tree = function() {
	  var separation = defaultSeparation$1,
	      dx = 1,
	      dy = 1,
	      nodeSize = null;

	  function tree(root) {
	    var t = treeRoot(root);

	    // Compute the layout using Buchheim et al.’s algorithm.
	    t.eachAfter(firstWalk), t.parent.m = -t.z;
	    t.eachBefore(secondWalk);

	    // If a fixed node size is specified, scale x and y.
	    if (nodeSize) root.eachBefore(sizeNode);

	    // If a fixed tree size is specified, scale x and y based on the extent.
	    // Compute the left-most, right-most, and depth-most nodes for extents.
	    else {
	      var left = root,
	          right = root,
	          bottom = root;
	      root.eachBefore(function(node) {
	        if (node.x < left.x) left = node;
	        if (node.x > right.x) right = node;
	        if (node.depth > bottom.depth) bottom = node;
	      });
	      var s = left === right ? 1 : separation(left, right) / 2,
	          tx = s - left.x,
	          kx = dx / (right.x + s + tx),
	          ky = dy / (bottom.depth || 1);
	      root.eachBefore(function(node) {
	        node.x = (node.x + tx) * kx;
	        node.y = node.depth * ky;
	      });
	    }

	    return root;
	  }

	  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
	  // applied recursively to the children of v, as well as the function
	  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
	  // node v is placed to the midpoint of its outermost children.
	  function firstWalk(v) {
	    var children = v.children,
	        siblings = v.parent.children,
	        w = v.i ? siblings[v.i - 1] : null;
	    if (children) {
	      executeShifts(v);
	      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
	      if (w) {
	        v.z = w.z + separation(v._, w._);
	        v.m = v.z - midpoint;
	      } else {
	        v.z = midpoint;
	      }
	    } else if (w) {
	      v.z = w.z + separation(v._, w._);
	    }
	    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
	  }

	  // Computes all real x-coordinates by summing up the modifiers recursively.
	  function secondWalk(v) {
	    v._.x = v.z + v.parent.m;
	    v.m += v.parent.m;
	  }

	  // The core of the algorithm. Here, a new subtree is combined with the
	  // previous subtrees. Threads are used to traverse the inside and outside
	  // contours of the left and right subtree up to the highest common level. The
	  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
	  // superscript o means outside and i means inside, the subscript - means left
	  // subtree and + means right subtree. For summing up the modifiers along the
	  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
	  // nodes of the inside contours conflict, we compute the left one of the
	  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
	  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
	  // Finally, we add a new thread (if necessary).
	  function apportion(v, w, ancestor) {
	    if (w) {
	      var vip = v,
	          vop = v,
	          vim = w,
	          vom = vip.parent.children[0],
	          sip = vip.m,
	          sop = vop.m,
	          sim = vim.m,
	          som = vom.m,
	          shift;
	      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
	        vom = nextLeft(vom);
	        vop = nextRight(vop);
	        vop.a = v;
	        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
	        if (shift > 0) {
	          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
	          sip += shift;
	          sop += shift;
	        }
	        sim += vim.m;
	        sip += vip.m;
	        som += vom.m;
	        sop += vop.m;
	      }
	      if (vim && !nextRight(vop)) {
	        vop.t = vim;
	        vop.m += sim - sop;
	      }
	      if (vip && !nextLeft(vom)) {
	        vom.t = vip;
	        vom.m += sip - som;
	        ancestor = v;
	      }
	    }
	    return ancestor;
	  }

	  function sizeNode(node) {
	    node.x *= dx;
	    node.y = node.depth * dy;
	  }

	  tree.separation = function(x) {
	    return arguments.length ? (separation = x, tree) : separation;
	  };

	  tree.size = function(x) {
	    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
	  };

	  tree.nodeSize = function(x) {
	    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
	  };

	  return tree;
	};

	var treemapSlice = function(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      node,
	      i = -1,
	      n = nodes.length,
	      k = parent.value && (y1 - y0) / parent.value;

	  while (++i < n) {
	    node = nodes[i], node.x0 = x0, node.x1 = x1;
	    node.y0 = y0, node.y1 = y0 += node.value * k;
	  }
	};

	var phi = (1 + Math.sqrt(5)) / 2;

	function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
	  var rows = [],
	      nodes = parent.children,
	      row,
	      nodeValue,
	      i0 = 0,
	      i1 = 0,
	      n = nodes.length,
	      dx, dy,
	      value = parent.value,
	      sumValue,
	      minValue,
	      maxValue,
	      newRatio,
	      minRatio,
	      alpha,
	      beta;

	  while (i0 < n) {
	    dx = x1 - x0, dy = y1 - y0;

	    // Find the next non-empty node.
	    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
	    minValue = maxValue = sumValue;
	    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
	    beta = sumValue * sumValue * alpha;
	    minRatio = Math.max(maxValue / beta, beta / minValue);

	    // Keep adding nodes while the aspect ratio maintains or improves.
	    for (; i1 < n; ++i1) {
	      sumValue += nodeValue = nodes[i1].value;
	      if (nodeValue < minValue) minValue = nodeValue;
	      if (nodeValue > maxValue) maxValue = nodeValue;
	      beta = sumValue * sumValue * alpha;
	      newRatio = Math.max(maxValue / beta, beta / minValue);
	      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
	      minRatio = newRatio;
	    }

	    // Position and record the row orientation.
	    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
	    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
	    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
	    value -= sumValue, i0 = i1;
	  }

	  return rows;
	}

	var squarify = ((function custom(ratio) {

	  function squarify(parent, x0, y0, x1, y1) {
	    squarifyRatio(ratio, parent, x0, y0, x1, y1);
	  }

	  squarify.ratio = function(x) {
	    return custom((x = +x) > 1 ? x : 1);
	  };

	  return squarify;
	}))(phi);

	var index$1 = function() {
	  var tile = squarify,
	      round = false,
	      dx = 1,
	      dy = 1,
	      paddingStack = [0],
	      paddingInner = constantZero,
	      paddingTop = constantZero,
	      paddingRight = constantZero,
	      paddingBottom = constantZero,
	      paddingLeft = constantZero;

	  function treemap(root) {
	    root.x0 =
	    root.y0 = 0;
	    root.x1 = dx;
	    root.y1 = dy;
	    root.eachBefore(positionNode);
	    paddingStack = [0];
	    if (round) root.eachBefore(roundNode);
	    return root;
	  }

	  function positionNode(node) {
	    var p = paddingStack[node.depth],
	        x0 = node.x0 + p,
	        y0 = node.y0 + p,
	        x1 = node.x1 - p,
	        y1 = node.y1 - p;
	    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	    node.x0 = x0;
	    node.y0 = y0;
	    node.x1 = x1;
	    node.y1 = y1;
	    if (node.children) {
	      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
	      x0 += paddingLeft(node) - p;
	      y0 += paddingTop(node) - p;
	      x1 -= paddingRight(node) - p;
	      y1 -= paddingBottom(node) - p;
	      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
	      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
	      tile(node, x0, y0, x1, y1);
	    }
	  }

	  treemap.round = function(x) {
	    return arguments.length ? (round = !!x, treemap) : round;
	  };

	  treemap.size = function(x) {
	    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
	  };

	  treemap.tile = function(x) {
	    return arguments.length ? (tile = required(x), treemap) : tile;
	  };

	  treemap.padding = function(x) {
	    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
	  };

	  treemap.paddingInner = function(x) {
	    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
	  };

	  treemap.paddingOuter = function(x) {
	    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
	  };

	  treemap.paddingTop = function(x) {
	    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
	  };

	  treemap.paddingRight = function(x) {
	    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
	  };

	  treemap.paddingBottom = function(x) {
	    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
	  };

	  treemap.paddingLeft = function(x) {
	    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
	  };

	  return treemap;
	};

	var binary = function(parent, x0, y0, x1, y1) {
	  var nodes = parent.children,
	      i, n = nodes.length,
	      sum, sums = new Array(n + 1);

	  for (sums[0] = sum = i = 0; i < n; ++i) {
	    sums[i + 1] = sum += nodes[i].value;
	  }

	  partition(0, n, parent.value, x0, y0, x1, y1);

	  function partition(i, j, value, x0, y0, x1, y1) {
	    if (i >= j - 1) {
	      var node = nodes[i];
	      node.x0 = x0, node.y0 = y0;
	      node.x1 = x1, node.y1 = y1;
	      return;
	    }

	    var valueOffset = sums[i],
	        valueTarget = (value / 2) + valueOffset,
	        k = i + 1,
	        hi = j - 1;

	    while (k < hi) {
	      var mid = k + hi >>> 1;
	      if (sums[mid] < valueTarget) k = mid + 1;
	      else hi = mid;
	    }

	    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

	    var valueLeft = sums[k] - valueOffset,
	        valueRight = value - valueLeft;

	    if ((x1 - x0) > (y1 - y0)) {
	      var xk = (x0 * valueRight + x1 * valueLeft) / value;
	      partition(i, k, valueLeft, x0, y0, xk, y1);
	      partition(k, j, valueRight, xk, y0, x1, y1);
	    } else {
	      var yk = (y0 * valueRight + y1 * valueLeft) / value;
	      partition(i, k, valueLeft, x0, y0, x1, yk);
	      partition(k, j, valueRight, x0, yk, x1, y1);
	    }
	  }
	};

	var sliceDice = function(parent, x0, y0, x1, y1) {
	  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
	};

	var resquarify = ((function custom(ratio) {

	  function resquarify(parent, x0, y0, x1, y1) {
	    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
	      var rows,
	          row,
	          nodes,
	          i,
	          j = -1,
	          n,
	          m = rows.length,
	          value = parent.value;

	      while (++j < m) {
	        row = rows[j], nodes = row.children;
	        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
	        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
	        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
	        value -= row.value;
	      }
	    } else {
	      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
	      rows.ratio = ratio;
	    }
	  }

	  resquarify.ratio = function(x) {
	    return custom((x = +x) > 1 ? x : 1);
	  };

	  return resquarify;
	}))(phi);

	exports.cluster = cluster;
	exports.hierarchy = hierarchy;
	exports.pack = index;
	exports.packSiblings = siblings;
	exports.packEnclose = enclose;
	exports.partition = partition;
	exports.stratify = stratify;
	exports.tree = tree;
	exports.treemap = index$1;
	exports.treemapBinary = binary;
	exports.treemapDice = treemapDice;
	exports.treemapSlice = treemapSlice;
	exports.treemapSliceDice = sliceDice;
	exports.treemapSquarify = squarify;
	exports.treemapResquarify = resquarify;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-polygon/ Version 1.0.3. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var area = function(polygon) {
	  var i = -1,
	      n = polygon.length,
	      a,
	      b = polygon[n - 1],
	      area = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    area += a[1] * b[0] - a[0] * b[1];
	  }

	  return area / 2;
	};

	var centroid = function(polygon) {
	  var i = -1,
	      n = polygon.length,
	      x = 0,
	      y = 0,
	      a,
	      b = polygon[n - 1],
	      c,
	      k = 0;

	  while (++i < n) {
	    a = b;
	    b = polygon[i];
	    k += c = a[0] * b[1] - b[0] * a[1];
	    x += (a[0] + b[0]) * c;
	    y += (a[1] + b[1]) * c;
	  }

	  return k *= 3, [x / k, y / k];
	};

	// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
	// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
	// right, +y is up). Returns a positive value if ABC is counter-clockwise,
	// negative if clockwise, and zero if the points are collinear.
	var cross = function(a, b, c) {
	  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
	};

	function lexicographicOrder(a, b) {
	  return a[0] - b[0] || a[1] - b[1];
	}

	// Computes the upper convex hull per the monotone chain algorithm.
	// Assumes points.length >= 3, is sorted by x, unique in y.
	// Returns an array of indices into points in left-to-right order.
	function computeUpperHullIndexes(points) {
	  var n = points.length,
	      indexes = [0, 1],
	      size = 2;

	  for (var i = 2; i < n; ++i) {
	    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
	    indexes[size++] = i;
	  }

	  return indexes.slice(0, size); // remove popped points
	}

	var hull = function(points) {
	  if ((n = points.length) < 3) return null;

	  var i,
	      n,
	      sortedPoints = new Array(n),
	      flippedPoints = new Array(n);

	  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
	  sortedPoints.sort(lexicographicOrder);
	  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

	  var upperIndexes = computeUpperHullIndexes(sortedPoints),
	      lowerIndexes = computeUpperHullIndexes(flippedPoints);

	  // Construct the hull polygon, removing possible duplicate endpoints.
	  var skipLeft = lowerIndexes[0] === upperIndexes[0],
	      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
	      hull = [];

	  // Add upper hull in right-to-l order.
	  // Then add lower hull in left-to-right order.
	  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
	  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

	  return hull;
	};

	var contains = function(polygon, point) {
	  var n = polygon.length,
	      p = polygon[n - 1],
	      x = point[0], y = point[1],
	      x0 = p[0], y0 = p[1],
	      x1, y1,
	      inside = false;

	  for (var i = 0; i < n; ++i) {
	    p = polygon[i], x1 = p[0], y1 = p[1];
	    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
	    x0 = x1, y0 = y1;
	  }

	  return inside;
	};

	var length = function(polygon) {
	  var i = -1,
	      n = polygon.length,
	      b = polygon[n - 1],
	      xa,
	      ya,
	      xb = b[0],
	      yb = b[1],
	      perimeter = 0;

	  while (++i < n) {
	    xa = xb;
	    ya = yb;
	    b = polygon[i];
	    xb = b[0];
	    yb = b[1];
	    xa -= xb;
	    ya -= yb;
	    perimeter += Math.sqrt(xa * xa + ya * ya);
	  }

	  return perimeter;
	};

	exports.polygonArea = area;
	exports.polygonCentroid = centroid;
	exports.polygonHull = hull;
	exports.polygonContains = contains;
	exports.polygonLength = length;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-random/ Version 1.1.0. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var defaultSource = function() {
	  return Math.random();
	};

	var uniform = ((function sourceRandomUniform(source) {
	  function randomUniform(min, max) {
	    min = min == null ? 0 : +min;
	    max = max == null ? 1 : +max;
	    if (arguments.length === 1) max = min, min = 0;
	    else max -= min;
	    return function() {
	      return source() * max + min;
	    };
	  }

	  randomUniform.source = sourceRandomUniform;

	  return randomUniform;
	}))(defaultSource);

	var normal = ((function sourceRandomNormal(source) {
	  function randomNormal(mu, sigma) {
	    var x, r;
	    mu = mu == null ? 0 : +mu;
	    sigma = sigma == null ? 1 : +sigma;
	    return function() {
	      var y;

	      // If available, use the second previously-generated uniform random.
	      if (x != null) y = x, x = null;

	      // Otherwise, generate a new x and y.
	      else do {
	        x = source() * 2 - 1;
	        y = source() * 2 - 1;
	        r = x * x + y * y;
	      } while (!r || r > 1);

	      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
	    };
	  }

	  randomNormal.source = sourceRandomNormal;

	  return randomNormal;
	}))(defaultSource);

	var logNormal = ((function sourceRandomLogNormal(source) {
	  function randomLogNormal() {
	    var randomNormal = normal.source(source).apply(this, arguments);
	    return function() {
	      return Math.exp(randomNormal());
	    };
	  }

	  randomLogNormal.source = sourceRandomLogNormal;

	  return randomLogNormal;
	}))(defaultSource);

	var irwinHall = ((function sourceRandomIrwinHall(source) {
	  function randomIrwinHall(n) {
	    return function() {
	      for (var sum = 0, i = 0; i < n; ++i) sum += source();
	      return sum;
	    };
	  }

	  randomIrwinHall.source = sourceRandomIrwinHall;

	  return randomIrwinHall;
	}))(defaultSource);

	var bates = ((function sourceRandomBates(source) {
	  function randomBates(n) {
	    var randomIrwinHall = irwinHall.source(source)(n);
	    return function() {
	      return randomIrwinHall() / n;
	    };
	  }

	  randomBates.source = sourceRandomBates;

	  return randomBates;
	}))(defaultSource);

	var exponential = ((function sourceRandomExponential(source) {
	  function randomExponential(lambda) {
	    return function() {
	      return -Math.log(1 - source()) / lambda;
	    };
	  }

	  randomExponential.source = sourceRandomExponential;

	  return randomExponential;
	}))(defaultSource);

	exports.randomUniform = uniform;
	exports.randomNormal = normal;
	exports.randomLogNormal = logNormal;
	exports.randomBates = bates;
	exports.randomIrwinHall = irwinHall;
	exports.randomExponential = exponential;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale/ Version 2.0.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(412), __webpack_require__(425), __webpack_require__(418), __webpack_require__(431), __webpack_require__(437), __webpack_require__(438)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

	var array = Array.prototype;

	var map$1 = array.map;
	var slice = array.slice;

	var implicit = {name: "implicit"};

	function ordinal(range$$1) {
	  var index = d3Collection.map(),
	      domain = [],
	      unknown = implicit;

	  range$$1 = range$$1 == null ? [] : slice.call(range$$1);

	  function scale(d) {
	    var key = d + "", i = index.get(key);
	    if (!i) {
	      if (unknown !== implicit) return unknown;
	      index.set(key, i = domain.push(d));
	    }
	    return range$$1[(i - 1) % range$$1.length];
	  }

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [], index = d3Collection.map();
	    var i = -1, n = _.length, d, key;
	    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
	    return scale;
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range$$1 = slice.call(_), scale) : range$$1.slice();
	  };

	  scale.unknown = function(_) {
	    return arguments.length ? (unknown = _, scale) : unknown;
	  };

	  scale.copy = function() {
	    return ordinal()
	        .domain(domain)
	        .range(range$$1)
	        .unknown(unknown);
	  };

	  return scale;
	}

	function band() {
	  var scale = ordinal().unknown(undefined),
	      domain = scale.domain,
	      ordinalRange = scale.range,
	      range$$1 = [0, 1],
	      step,
	      bandwidth,
	      round = false,
	      paddingInner = 0,
	      paddingOuter = 0,
	      align = 0.5;

	  delete scale.unknown;

	  function rescale() {
	    var n = domain().length,
	        reverse = range$$1[1] < range$$1[0],
	        start = range$$1[reverse - 0],
	        stop = range$$1[1 - reverse];
	    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
	    if (round) step = Math.floor(step);
	    start += (stop - start - step * (n - paddingInner)) * align;
	    bandwidth = step * (1 - paddingInner);
	    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
	    var values = d3Array.range(n).map(function(i) { return start + step * i; });
	    return ordinalRange(reverse ? values.reverse() : values);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range$$1 = [+_[0], +_[1]], round = true, rescale();
	  };

	  scale.bandwidth = function() {
	    return bandwidth;
	  };

	  scale.step = function() {
	    return step;
	  };

	  scale.round = function(_) {
	    return arguments.length ? (round = !!_, rescale()) : round;
	  };

	  scale.padding = function(_) {
	    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
	  };

	  scale.paddingInner = function(_) {
	    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
	  };

	  scale.paddingOuter = function(_) {
	    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
	  };

	  scale.align = function(_) {
	    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
	  };

	  scale.copy = function() {
	    return band()
	        .domain(domain())
	        .range(range$$1)
	        .round(round)
	        .paddingInner(paddingInner)
	        .paddingOuter(paddingOuter)
	        .align(align);
	  };

	  return rescale();
	}

	function pointish(scale) {
	  var copy = scale.copy;

	  scale.padding = scale.paddingOuter;
	  delete scale.paddingInner;
	  delete scale.paddingOuter;

	  scale.copy = function() {
	    return pointish(copy());
	  };

	  return scale;
	}

	function point() {
	  return pointish(band().paddingInner(1));
	}

	function constant(x) {
	  return function() {
	    return x;
	  };
	}

	function number(x) {
	  return +x;
	}

	var unit = [0, 1];

	function deinterpolateLinear(a, b) {
	  return (b -= (a = +a))
	      ? function(x) { return (x - a) / b; }
	      : constant(b);
	}

	function deinterpolateClamp(deinterpolate) {
	  return function(a, b) {
	    var d = deinterpolate(a = +a, b = +b);
	    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
	  };
	}

	function reinterpolateClamp(reinterpolate) {
	  return function(a, b) {
	    var r = reinterpolate(a = +a, b = +b);
	    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
	  };
	}

	function bimap(domain, range$$1, deinterpolate, reinterpolate) {
	  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];
	  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
	  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
	  return function(x) { return r0(d0(x)); };
	}

	function polymap(domain, range$$1, deinterpolate, reinterpolate) {
	  var j = Math.min(domain.length, range$$1.length) - 1,
	      d = new Array(j),
	      r = new Array(j),
	      i = -1;

	  // Reverse descending domains.
	  if (domain[j] < domain[0]) {
	    domain = domain.slice().reverse();
	    range$$1 = range$$1.slice().reverse();
	  }

	  while (++i < j) {
	    d[i] = deinterpolate(domain[i], domain[i + 1]);
	    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
	  }

	  return function(x) {
	    var i = d3Array.bisect(domain, x, 1, j) - 1;
	    return r[i](d[i](x));
	  };
	}

	function copy(source, target) {
	  return target
	      .domain(source.domain())
	      .range(source.range())
	      .interpolate(source.interpolate())
	      .clamp(source.clamp());
	}

	// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
	// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
	function continuous(deinterpolate, reinterpolate) {
	  var domain = unit,
	      range$$1 = unit,
	      interpolate$$1 = d3Interpolate.interpolate,
	      clamp = false,
	      piecewise,
	      output,
	      input;

	  function rescale() {
	    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
	    output = input = null;
	    return scale;
	  }

	  function scale(x) {
	    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
	  }

	  scale.invert = function(y) {
	    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
	  };

	  scale.rangeRound = function(_) {
	    return range$$1 = slice.call(_), interpolate$$1 = d3Interpolate.interpolateRound, rescale();
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, rescale()) : clamp;
	  };

	  scale.interpolate = function(_) {
	    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
	  };

	  return rescale();
	}

	function tickFormat(domain, count, specifier) {
	  var start = domain[0],
	      stop = domain[domain.length - 1],
	      step = d3Array.tickStep(start, stop, count == null ? 10 : count),
	      precision;
	  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
	  switch (specifier.type) {
	    case "s": {
	      var value = Math.max(Math.abs(start), Math.abs(stop));
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
	      return d3Format.formatPrefix(specifier, value);
	    }
	    case "":
	    case "e":
	    case "g":
	    case "p":
	    case "r": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
	      break;
	    }
	    case "f":
	    case "%": {
	      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
	      break;
	    }
	  }
	  return d3Format.format(specifier);
	}

	function linearish(scale) {
	  var domain = scale.domain;

	  scale.ticks = function(count) {
	    var d = domain();
	    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
	  };

	  scale.tickFormat = function(count, specifier) {
	    return tickFormat(domain(), count, specifier);
	  };

	  scale.nice = function(count) {
	    if (count == null) count = 10;

	    var d = domain(),
	        i0 = 0,
	        i1 = d.length - 1,
	        start = d[i0],
	        stop = d[i1],
	        step;

	    if (stop < start) {
	      step = start, start = stop, stop = step;
	      step = i0, i0 = i1, i1 = step;
	    }

	    step = d3Array.tickIncrement(start, stop, count);

	    if (step > 0) {
	      start = Math.floor(start / step) * step;
	      stop = Math.ceil(stop / step) * step;
	      step = d3Array.tickIncrement(start, stop, count);
	    } else if (step < 0) {
	      start = Math.ceil(start * step) / step;
	      stop = Math.floor(stop * step) / step;
	      step = d3Array.tickIncrement(start, stop, count);
	    }

	    if (step > 0) {
	      d[i0] = Math.floor(start / step) * step;
	      d[i1] = Math.ceil(stop / step) * step;
	      domain(d);
	    } else if (step < 0) {
	      d[i0] = Math.ceil(start * step) / step;
	      d[i1] = Math.floor(stop * step) / step;
	      domain(d);
	    }

	    return scale;
	  };

	  return scale;
	}

	function linear() {
	  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber);

	  scale.copy = function() {
	    return copy(scale, linear());
	  };

	  return linearish(scale);
	}

	function identity() {
	  var domain = [0, 1];

	  function scale(x) {
	    return +x;
	  }

	  scale.invert = scale;

	  scale.domain = scale.range = function(_) {
	    return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
	  };

	  scale.copy = function() {
	    return identity().domain(domain);
	  };

	  return linearish(scale);
	}

	function nice(domain, interval) {
	  domain = domain.slice();

	  var i0 = 0,
	      i1 = domain.length - 1,
	      x0 = domain[i0],
	      x1 = domain[i1],
	      t;

	  if (x1 < x0) {
	    t = i0, i0 = i1, i1 = t;
	    t = x0, x0 = x1, x1 = t;
	  }

	  domain[i0] = interval.floor(x0);
	  domain[i1] = interval.ceil(x1);
	  return domain;
	}

	function deinterpolate(a, b) {
	  return (b = Math.log(b / a))
	      ? function(x) { return Math.log(x / a) / b; }
	      : constant(b);
	}

	function reinterpolate(a, b) {
	  return a < 0
	      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
	      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
	}

	function pow10(x) {
	  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
	}

	function powp(base) {
	  return base === 10 ? pow10
	      : base === Math.E ? Math.exp
	      : function(x) { return Math.pow(base, x); };
	}

	function logp(base) {
	  return base === Math.E ? Math.log
	      : base === 10 && Math.log10
	      || base === 2 && Math.log2
	      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
	}

	function reflect(f) {
	  return function(x) {
	    return -f(-x);
	  };
	}

	function log() {
	  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
	      domain = scale.domain,
	      base = 10,
	      logs = logp(10),
	      pows = powp(10);

	  function rescale() {
	    logs = logp(base), pows = powp(base);
	    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
	    return scale;
	  }

	  scale.base = function(_) {
	    return arguments.length ? (base = +_, rescale()) : base;
	  };

	  scale.domain = function(_) {
	    return arguments.length ? (domain(_), rescale()) : domain();
	  };

	  scale.ticks = function(count) {
	    var d = domain(),
	        u = d[0],
	        v = d[d.length - 1],
	        r;

	    if (r = v < u) i = u, u = v, v = i;

	    var i = logs(u),
	        j = logs(v),
	        p,
	        k,
	        t,
	        n = count == null ? 10 : +count,
	        z = [];

	    if (!(base % 1) && j - i < n) {
	      i = Math.round(i) - 1, j = Math.round(j) + 1;
	      if (u > 0) for (; i < j; ++i) {
	        for (k = 1, p = pows(i); k < base; ++k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      } else for (; i < j; ++i) {
	        for (k = base - 1, p = pows(i); k >= 1; --k) {
	          t = p * k;
	          if (t < u) continue;
	          if (t > v) break;
	          z.push(t);
	        }
	      }
	    } else {
	      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
	    }

	    return r ? z.reverse() : z;
	  };

	  scale.tickFormat = function(count, specifier) {
	    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
	    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
	    if (count === Infinity) return specifier;
	    if (count == null) count = 10;
	    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
	    return function(d) {
	      var i = d / pows(Math.round(logs(d)));
	      if (i * base < base - 0.5) i *= base;
	      return i <= k ? specifier(d) : "";
	    };
	  };

	  scale.nice = function() {
	    return domain(nice(domain(), {
	      floor: function(x) { return pows(Math.floor(logs(x))); },
	      ceil: function(x) { return pows(Math.ceil(logs(x))); }
	    }));
	  };

	  scale.copy = function() {
	    return copy(scale, log().base(base));
	  };

	  return scale;
	}

	function raise(x, exponent) {
	  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
	}

	function pow() {
	  var exponent = 1,
	      scale = continuous(deinterpolate, reinterpolate),
	      domain = scale.domain;

	  function deinterpolate(a, b) {
	    return (b = raise(b, exponent) - (a = raise(a, exponent)))
	        ? function(x) { return (raise(x, exponent) - a) / b; }
	        : constant(b);
	  }

	  function reinterpolate(a, b) {
	    b = raise(b, exponent) - (a = raise(a, exponent));
	    return function(t) { return raise(a + b * t, 1 / exponent); };
	  }

	  scale.exponent = function(_) {
	    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
	  };

	  scale.copy = function() {
	    return copy(scale, pow().exponent(exponent));
	  };

	  return linearish(scale);
	}

	function sqrt() {
	  return pow().exponent(0.5);
	}

	function quantile$1() {
	  var domain = [],
	      range$$1 = [],
	      thresholds = [];

	  function rescale() {
	    var i = 0, n = Math.max(1, range$$1.length);
	    thresholds = new Array(n - 1);
	    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
	    return scale;
	  }

	  function scale(x) {
	    if (!isNaN(x = +x)) return range$$1[d3Array.bisect(thresholds, x)];
	  }

	  scale.invertExtent = function(y) {
	    var i = range$$1.indexOf(y);
	    return i < 0 ? [NaN, NaN] : [
	      i > 0 ? thresholds[i - 1] : domain[0],
	      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
	    ];
	  };

	  scale.domain = function(_) {
	    if (!arguments.length) return domain.slice();
	    domain = [];
	    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
	    domain.sort(d3Array.ascending);
	    return rescale();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
	  };

	  scale.quantiles = function() {
	    return thresholds.slice();
	  };

	  scale.copy = function() {
	    return quantile$1()
	        .domain(domain)
	        .range(range$$1);
	  };

	  return scale;
	}

	function quantize() {
	  var x0 = 0,
	      x1 = 1,
	      n = 1,
	      domain = [0.5],
	      range$$1 = [0, 1];

	  function scale(x) {
	    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
	  }

	  function rescale() {
	    var i = -1;
	    domain = new Array(n);
	    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
	    return scale;
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
	  };

	  scale.range = function(_) {
	    return arguments.length ? (n = (range$$1 = slice.call(_)).length - 1, rescale()) : range$$1.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range$$1.indexOf(y);
	    return i < 0 ? [NaN, NaN]
	        : i < 1 ? [x0, domain[0]]
	        : i >= n ? [domain[n - 1], x1]
	        : [domain[i - 1], domain[i]];
	  };

	  scale.copy = function() {
	    return quantize()
	        .domain([x0, x1])
	        .range(range$$1);
	  };

	  return linearish(scale);
	}

	function threshold() {
	  var domain = [0.5],
	      range$$1 = [0, 1],
	      n = 1;

	  function scale(x) {
	    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
	  };

	  scale.range = function(_) {
	    return arguments.length ? (range$$1 = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
	  };

	  scale.invertExtent = function(y) {
	    var i = range$$1.indexOf(y);
	    return [domain[i - 1], domain[i]];
	  };

	  scale.copy = function() {
	    return threshold()
	        .domain(domain)
	        .range(range$$1);
	  };

	  return scale;
	}

	var durationSecond = 1000;
	var durationMinute = durationSecond * 60;
	var durationHour = durationMinute * 60;
	var durationDay = durationHour * 24;
	var durationWeek = durationDay * 7;
	var durationMonth = durationDay * 30;
	var durationYear = durationDay * 365;

	function date(t) {
	  return new Date(t);
	}

	function number$1(t) {
	  return t instanceof Date ? +t : +new Date(+t);
	}

	function calendar(year, month, week, day, hour, minute, second, millisecond, format$$1) {
	  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber),
	      invert = scale.invert,
	      domain = scale.domain;

	  var formatMillisecond = format$$1(".%L"),
	      formatSecond = format$$1(":%S"),
	      formatMinute = format$$1("%I:%M"),
	      formatHour = format$$1("%I %p"),
	      formatDay = format$$1("%a %d"),
	      formatWeek = format$$1("%b %d"),
	      formatMonth = format$$1("%B"),
	      formatYear = format$$1("%Y");

	  var tickIntervals = [
	    [second,  1,      durationSecond],
	    [second,  5,  5 * durationSecond],
	    [second, 15, 15 * durationSecond],
	    [second, 30, 30 * durationSecond],
	    [minute,  1,      durationMinute],
	    [minute,  5,  5 * durationMinute],
	    [minute, 15, 15 * durationMinute],
	    [minute, 30, 30 * durationMinute],
	    [  hour,  1,      durationHour  ],
	    [  hour,  3,  3 * durationHour  ],
	    [  hour,  6,  6 * durationHour  ],
	    [  hour, 12, 12 * durationHour  ],
	    [   day,  1,      durationDay   ],
	    [   day,  2,  2 * durationDay   ],
	    [  week,  1,      durationWeek  ],
	    [ month,  1,      durationMonth ],
	    [ month,  3,  3 * durationMonth ],
	    [  year,  1,      durationYear  ]
	  ];

	  function tickFormat(date) {
	    return (second(date) < date ? formatMillisecond
	        : minute(date) < date ? formatSecond
	        : hour(date) < date ? formatMinute
	        : day(date) < date ? formatHour
	        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
	        : year(date) < date ? formatMonth
	        : formatYear)(date);
	  }

	  function tickInterval(interval, start, stop, step) {
	    if (interval == null) interval = 10;

	    // If a desired tick count is specified, pick a reasonable tick interval
	    // based on the extent of the domain and a rough estimate of tick size.
	    // Otherwise, assume interval is already a time interval and use it.
	    if (typeof interval === "number") {
	      var target = Math.abs(stop - start) / interval,
	          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
	      if (i === tickIntervals.length) {
	        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
	        interval = year;
	      } else if (i) {
	        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
	        step = i[1];
	        interval = i[0];
	      } else {
	        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
	        interval = millisecond;
	      }
	    }

	    return step == null ? interval : interval.every(step);
	  }

	  scale.invert = function(y) {
	    return new Date(invert(y));
	  };

	  scale.domain = function(_) {
	    return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
	  };

	  scale.ticks = function(interval, step) {
	    var d = domain(),
	        t0 = d[0],
	        t1 = d[d.length - 1],
	        r = t1 < t0,
	        t;
	    if (r) t = t0, t0 = t1, t1 = t;
	    t = tickInterval(interval, t0, t1, step);
	    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
	    return r ? t.reverse() : t;
	  };

	  scale.tickFormat = function(count, specifier) {
	    return specifier == null ? tickFormat : format$$1(specifier);
	  };

	  scale.nice = function(interval, step) {
	    var d = domain();
	    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
	        ? domain(nice(d, interval))
	        : scale;
	  };

	  scale.copy = function() {
	    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format$$1));
	  };

	  return scale;
	}

	function time() {
	  return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
	}

	function utcTime() {
	  return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
	}

	function sequential(interpolator) {
	  var x0 = 0,
	      x1 = 1,
	      clamp = false;

	  function scale(x) {
	    var t = (x - x0) / (x1 - x0);
	    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
	  }

	  scale.domain = function(_) {
	    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
	  };

	  scale.clamp = function(_) {
	    return arguments.length ? (clamp = !!_, scale) : clamp;
	  };

	  scale.interpolator = function(_) {
	    return arguments.length ? (interpolator = _, scale) : interpolator;
	  };

	  scale.copy = function() {
	    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
	  };

	  return linearish(scale);
	}

	exports.scaleBand = band;
	exports.scalePoint = point;
	exports.scaleIdentity = identity;
	exports.scaleLinear = linear;
	exports.scaleLog = log;
	exports.scaleOrdinal = ordinal;
	exports.scaleImplicit = implicit;
	exports.scalePow = pow;
	exports.scaleSqrt = sqrt;
	exports.scaleQuantile = quantile$1;
	exports.scaleQuantize = quantize;
	exports.scaleThreshold = threshold;
	exports.scaleTime = time;
	exports.scaleUtc = utcTime;
	exports.scaleSequential = sequential;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time/ Version 1.0.8. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var t0 = new Date;
	var t1 = new Date;

	function newInterval(floori, offseti, count, field) {

	  function interval(date) {
	    return floori(date = new Date(+date)), date;
	  }

	  interval.floor = interval;

	  interval.ceil = function(date) {
	    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
	  };

	  interval.round = function(date) {
	    var d0 = interval(date),
	        d1 = interval.ceil(date);
	    return date - d0 < d1 - date ? d0 : d1;
	  };

	  interval.offset = function(date, step) {
	    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
	  };

	  interval.range = function(start, stop, step) {
	    var range = [], previous;
	    start = interval.ceil(start);
	    step = step == null ? 1 : Math.floor(step);
	    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
	    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
	    while (previous < start && start < stop);
	    return range;
	  };

	  interval.filter = function(test) {
	    return newInterval(function(date) {
	      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
	    }, function(date, step) {
	      if (date >= date) {
	        if (step < 0) while (++step <= 0) {
	          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
	        } else while (--step >= 0) {
	          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
	        }
	      }
	    });
	  };

	  if (count) {
	    interval.count = function(start, end) {
	      t0.setTime(+start), t1.setTime(+end);
	      floori(t0), floori(t1);
	      return Math.floor(count(t0, t1));
	    };

	    interval.every = function(step) {
	      step = Math.floor(step);
	      return !isFinite(step) || !(step > 0) ? null
	          : !(step > 1) ? interval
	          : interval.filter(field
	              ? function(d) { return field(d) % step === 0; }
	              : function(d) { return interval.count(0, d) % step === 0; });
	    };
	  }

	  return interval;
	}

	var millisecond = newInterval(function() {
	  // noop
	}, function(date, step) {
	  date.setTime(+date + step);
	}, function(start, end) {
	  return end - start;
	});

	// An optimized implementation for this simple case.
	millisecond.every = function(k) {
	  k = Math.floor(k);
	  if (!isFinite(k) || !(k > 0)) return null;
	  if (!(k > 1)) return millisecond;
	  return newInterval(function(date) {
	    date.setTime(Math.floor(date / k) * k);
	  }, function(date, step) {
	    date.setTime(+date + step * k);
	  }, function(start, end) {
	    return (end - start) / k;
	  });
	};

	var milliseconds = millisecond.range;

	var durationSecond = 1e3;
	var durationMinute = 6e4;
	var durationHour = 36e5;
	var durationDay = 864e5;
	var durationWeek = 6048e5;

	var second = newInterval(function(date) {
	  date.setTime(Math.floor(date / durationSecond) * durationSecond);
	}, function(date, step) {
	  date.setTime(+date + step * durationSecond);
	}, function(start, end) {
	  return (end - start) / durationSecond;
	}, function(date) {
	  return date.getUTCSeconds();
	});

	var seconds = second.range;

	var minute = newInterval(function(date) {
	  date.setTime(Math.floor(date / durationMinute) * durationMinute);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getMinutes();
	});

	var minutes = minute.range;

	var hour = newInterval(function(date) {
	  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
	  if (offset < 0) offset += durationHour;
	  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getHours();
	});

	var hours = hour.range;

	var day = newInterval(function(date) {
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setDate(date.getDate() + step);
	}, function(start, end) {
	  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
	}, function(date) {
	  return date.getDate() - 1;
	});

	var days = day.range;

	function weekday(i) {
	  return newInterval(function(date) {
	    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setDate(date.getDate() + step * 7);
	  }, function(start, end) {
	    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
	  });
	}

	var sunday = weekday(0);
	var monday = weekday(1);
	var tuesday = weekday(2);
	var wednesday = weekday(3);
	var thursday = weekday(4);
	var friday = weekday(5);
	var saturday = weekday(6);

	var sundays = sunday.range;
	var mondays = monday.range;
	var tuesdays = tuesday.range;
	var wednesdays = wednesday.range;
	var thursdays = thursday.range;
	var fridays = friday.range;
	var saturdays = saturday.range;

	var month = newInterval(function(date) {
	  date.setDate(1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setMonth(date.getMonth() + step);
	}, function(start, end) {
	  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
	}, function(date) {
	  return date.getMonth();
	});

	var months = month.range;

	var year = newInterval(function(date) {
	  date.setMonth(0, 1);
	  date.setHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setFullYear(date.getFullYear() + step);
	}, function(start, end) {
	  return end.getFullYear() - start.getFullYear();
	}, function(date) {
	  return date.getFullYear();
	});

	// An optimized implementation for this simple case.
	year.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
	    date.setMonth(0, 1);
	    date.setHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setFullYear(date.getFullYear() + step * k);
	  });
	};

	var years = year.range;

	var utcMinute = newInterval(function(date) {
	  date.setUTCSeconds(0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationMinute);
	}, function(start, end) {
	  return (end - start) / durationMinute;
	}, function(date) {
	  return date.getUTCMinutes();
	});

	var utcMinutes = utcMinute.range;

	var utcHour = newInterval(function(date) {
	  date.setUTCMinutes(0, 0, 0);
	}, function(date, step) {
	  date.setTime(+date + step * durationHour);
	}, function(start, end) {
	  return (end - start) / durationHour;
	}, function(date) {
	  return date.getUTCHours();
	});

	var utcHours = utcHour.range;

	var utcDay = newInterval(function(date) {
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCDate(date.getUTCDate() + step);
	}, function(start, end) {
	  return (end - start) / durationDay;
	}, function(date) {
	  return date.getUTCDate() - 1;
	});

	var utcDays = utcDay.range;

	function utcWeekday(i) {
	  return newInterval(function(date) {
	    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCDate(date.getUTCDate() + step * 7);
	  }, function(start, end) {
	    return (end - start) / durationWeek;
	  });
	}

	var utcSunday = utcWeekday(0);
	var utcMonday = utcWeekday(1);
	var utcTuesday = utcWeekday(2);
	var utcWednesday = utcWeekday(3);
	var utcThursday = utcWeekday(4);
	var utcFriday = utcWeekday(5);
	var utcSaturday = utcWeekday(6);

	var utcSundays = utcSunday.range;
	var utcMondays = utcMonday.range;
	var utcTuesdays = utcTuesday.range;
	var utcWednesdays = utcWednesday.range;
	var utcThursdays = utcThursday.range;
	var utcFridays = utcFriday.range;
	var utcSaturdays = utcSaturday.range;

	var utcMonth = newInterval(function(date) {
	  date.setUTCDate(1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCMonth(date.getUTCMonth() + step);
	}, function(start, end) {
	  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
	}, function(date) {
	  return date.getUTCMonth();
	});

	var utcMonths = utcMonth.range;

	var utcYear = newInterval(function(date) {
	  date.setUTCMonth(0, 1);
	  date.setUTCHours(0, 0, 0, 0);
	}, function(date, step) {
	  date.setUTCFullYear(date.getUTCFullYear() + step);
	}, function(start, end) {
	  return end.getUTCFullYear() - start.getUTCFullYear();
	}, function(date) {
	  return date.getUTCFullYear();
	});

	// An optimized implementation for this simple case.
	utcYear.every = function(k) {
	  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
	    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
	    date.setUTCMonth(0, 1);
	    date.setUTCHours(0, 0, 0, 0);
	  }, function(date, step) {
	    date.setUTCFullYear(date.getUTCFullYear() + step * k);
	  });
	};

	var utcYears = utcYear.range;

	exports.timeInterval = newInterval;
	exports.timeMillisecond = millisecond;
	exports.timeMilliseconds = milliseconds;
	exports.utcMillisecond = millisecond;
	exports.utcMilliseconds = milliseconds;
	exports.timeSecond = second;
	exports.timeSeconds = seconds;
	exports.utcSecond = second;
	exports.utcSeconds = seconds;
	exports.timeMinute = minute;
	exports.timeMinutes = minutes;
	exports.timeHour = hour;
	exports.timeHours = hours;
	exports.timeDay = day;
	exports.timeDays = days;
	exports.timeWeek = sunday;
	exports.timeWeeks = sundays;
	exports.timeSunday = sunday;
	exports.timeSundays = sundays;
	exports.timeMonday = monday;
	exports.timeMondays = mondays;
	exports.timeTuesday = tuesday;
	exports.timeTuesdays = tuesdays;
	exports.timeWednesday = wednesday;
	exports.timeWednesdays = wednesdays;
	exports.timeThursday = thursday;
	exports.timeThursdays = thursdays;
	exports.timeFriday = friday;
	exports.timeFridays = fridays;
	exports.timeSaturday = saturday;
	exports.timeSaturdays = saturdays;
	exports.timeMonth = month;
	exports.timeMonths = months;
	exports.timeYear = year;
	exports.timeYears = years;
	exports.utcMinute = utcMinute;
	exports.utcMinutes = utcMinutes;
	exports.utcHour = utcHour;
	exports.utcHours = utcHours;
	exports.utcDay = utcDay;
	exports.utcDays = utcDays;
	exports.utcWeek = utcSunday;
	exports.utcWeeks = utcSundays;
	exports.utcSunday = utcSunday;
	exports.utcSundays = utcSundays;
	exports.utcMonday = utcMonday;
	exports.utcMondays = utcMondays;
	exports.utcTuesday = utcTuesday;
	exports.utcTuesdays = utcTuesdays;
	exports.utcWednesday = utcWednesday;
	exports.utcWednesdays = utcWednesdays;
	exports.utcThursday = utcThursday;
	exports.utcThursdays = utcThursdays;
	exports.utcFriday = utcFriday;
	exports.utcFridays = utcFridays;
	exports.utcSaturday = utcSaturday;
	exports.utcSaturdays = utcSaturdays;
	exports.utcMonth = utcMonth;
	exports.utcMonths = utcMonths;
	exports.utcYear = utcYear;
	exports.utcYears = utcYears;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-time-format/ Version 2.1.1. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(437)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Time) { 'use strict';

	function localDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
	    date.setFullYear(d.y);
	    return date;
	  }
	  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
	}

	function utcDate(d) {
	  if (0 <= d.y && d.y < 100) {
	    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
	    date.setUTCFullYear(d.y);
	    return date;
	  }
	  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
	}

	function newYear(y) {
	  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
	}

	function formatLocale(locale) {
	  var locale_dateTime = locale.dateTime,
	      locale_date = locale.date,
	      locale_time = locale.time,
	      locale_periods = locale.periods,
	      locale_weekdays = locale.days,
	      locale_shortWeekdays = locale.shortDays,
	      locale_months = locale.months,
	      locale_shortMonths = locale.shortMonths;

	  var periodRe = formatRe(locale_periods),
	      periodLookup = formatLookup(locale_periods),
	      weekdayRe = formatRe(locale_weekdays),
	      weekdayLookup = formatLookup(locale_weekdays),
	      shortWeekdayRe = formatRe(locale_shortWeekdays),
	      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
	      monthRe = formatRe(locale_months),
	      monthLookup = formatLookup(locale_months),
	      shortMonthRe = formatRe(locale_shortMonths),
	      shortMonthLookup = formatLookup(locale_shortMonths);

	  var formats = {
	    "a": formatShortWeekday,
	    "A": formatWeekday,
	    "b": formatShortMonth,
	    "B": formatMonth,
	    "c": null,
	    "d": formatDayOfMonth,
	    "e": formatDayOfMonth,
	    "f": formatMicroseconds,
	    "H": formatHour24,
	    "I": formatHour12,
	    "j": formatDayOfYear,
	    "L": formatMilliseconds,
	    "m": formatMonthNumber,
	    "M": formatMinutes,
	    "p": formatPeriod,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatSeconds,
	    "u": formatWeekdayNumberMonday,
	    "U": formatWeekNumberSunday,
	    "V": formatWeekNumberISO,
	    "w": formatWeekdayNumberSunday,
	    "W": formatWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatYear,
	    "Y": formatFullYear,
	    "Z": formatZone,
	    "%": formatLiteralPercent
	  };

	  var utcFormats = {
	    "a": formatUTCShortWeekday,
	    "A": formatUTCWeekday,
	    "b": formatUTCShortMonth,
	    "B": formatUTCMonth,
	    "c": null,
	    "d": formatUTCDayOfMonth,
	    "e": formatUTCDayOfMonth,
	    "f": formatUTCMicroseconds,
	    "H": formatUTCHour24,
	    "I": formatUTCHour12,
	    "j": formatUTCDayOfYear,
	    "L": formatUTCMilliseconds,
	    "m": formatUTCMonthNumber,
	    "M": formatUTCMinutes,
	    "p": formatUTCPeriod,
	    "Q": formatUnixTimestamp,
	    "s": formatUnixTimestampSeconds,
	    "S": formatUTCSeconds,
	    "u": formatUTCWeekdayNumberMonday,
	    "U": formatUTCWeekNumberSunday,
	    "V": formatUTCWeekNumberISO,
	    "w": formatUTCWeekdayNumberSunday,
	    "W": formatUTCWeekNumberMonday,
	    "x": null,
	    "X": null,
	    "y": formatUTCYear,
	    "Y": formatUTCFullYear,
	    "Z": formatUTCZone,
	    "%": formatLiteralPercent
	  };

	  var parses = {
	    "a": parseShortWeekday,
	    "A": parseWeekday,
	    "b": parseShortMonth,
	    "B": parseMonth,
	    "c": parseLocaleDateTime,
	    "d": parseDayOfMonth,
	    "e": parseDayOfMonth,
	    "f": parseMicroseconds,
	    "H": parseHour24,
	    "I": parseHour24,
	    "j": parseDayOfYear,
	    "L": parseMilliseconds,
	    "m": parseMonthNumber,
	    "M": parseMinutes,
	    "p": parsePeriod,
	    "Q": parseUnixTimestamp,
	    "s": parseUnixTimestampSeconds,
	    "S": parseSeconds,
	    "u": parseWeekdayNumberMonday,
	    "U": parseWeekNumberSunday,
	    "V": parseWeekNumberISO,
	    "w": parseWeekdayNumberSunday,
	    "W": parseWeekNumberMonday,
	    "x": parseLocaleDate,
	    "X": parseLocaleTime,
	    "y": parseYear,
	    "Y": parseFullYear,
	    "Z": parseZone,
	    "%": parseLiteralPercent
	  };

	  // These recursive directive definitions must be deferred.
	  formats.x = newFormat(locale_date, formats);
	  formats.X = newFormat(locale_time, formats);
	  formats.c = newFormat(locale_dateTime, formats);
	  utcFormats.x = newFormat(locale_date, utcFormats);
	  utcFormats.X = newFormat(locale_time, utcFormats);
	  utcFormats.c = newFormat(locale_dateTime, utcFormats);

	  function newFormat(specifier, formats) {
	    return function(date) {
	      var string = [],
	          i = -1,
	          j = 0,
	          n = specifier.length,
	          c,
	          pad,
	          format;

	      if (!(date instanceof Date)) date = new Date(+date);

	      while (++i < n) {
	        if (specifier.charCodeAt(i) === 37) {
	          string.push(specifier.slice(j, i));
	          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
	          else pad = c === "e" ? " " : "0";
	          if (format = formats[c]) c = format(date, pad);
	          string.push(c);
	          j = i + 1;
	        }
	      }

	      string.push(specifier.slice(j, i));
	      return string.join("");
	    };
	  }

	  function newParse(specifier, newDate) {
	    return function(string) {
	      var d = newYear(1900),
	          i = parseSpecifier(d, specifier, string += "", 0),
	          week, day;
	      if (i != string.length) return null;

	      // If a UNIX timestamp is specified, return it.
	      if ("Q" in d) return new Date(d.Q);

	      // The am-pm flag is 0 for AM, and 1 for PM.
	      if ("p" in d) d.H = d.H % 12 + d.p * 12;

	      // Convert day-of-week and week-of-year to day-of-year.
	      if ("V" in d) {
	        if (d.V < 1 || d.V > 53) return null;
	        if (!("w" in d)) d.w = 1;
	        if ("Z" in d) {
	          week = utcDate(newYear(d.y)), day = week.getUTCDay();
	          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
	          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getUTCFullYear();
	          d.m = week.getUTCMonth();
	          d.d = week.getUTCDate() + (d.w + 6) % 7;
	        } else {
	          week = newDate(newYear(d.y)), day = week.getDay();
	          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
	          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
	          d.y = week.getFullYear();
	          d.m = week.getMonth();
	          d.d = week.getDate() + (d.w + 6) % 7;
	        }
	      } else if ("W" in d || "U" in d) {
	        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
	        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
	        d.m = 0;
	        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
	      }

	      // If a time zone is specified, all fields are interpreted as UTC and then
	      // offset according to the specified time zone.
	      if ("Z" in d) {
	        d.H += d.Z / 100 | 0;
	        d.M += d.Z % 100;
	        return utcDate(d);
	      }

	      // Otherwise, all fields are in local time.
	      return newDate(d);
	    };
	  }

	  function parseSpecifier(d, specifier, string, j) {
	    var i = 0,
	        n = specifier.length,
	        m = string.length,
	        c,
	        parse;

	    while (i < n) {
	      if (j >= m) return -1;
	      c = specifier.charCodeAt(i++);
	      if (c === 37) {
	        c = specifier.charAt(i++);
	        parse = parses[c in pads ? specifier.charAt(i++) : c];
	        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
	      } else if (c != string.charCodeAt(j++)) {
	        return -1;
	      }
	    }

	    return j;
	  }

	  function parsePeriod(d, string, i) {
	    var n = periodRe.exec(string.slice(i));
	    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortWeekday(d, string, i) {
	    var n = shortWeekdayRe.exec(string.slice(i));
	    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseWeekday(d, string, i) {
	    var n = weekdayRe.exec(string.slice(i));
	    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseShortMonth(d, string, i) {
	    var n = shortMonthRe.exec(string.slice(i));
	    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseMonth(d, string, i) {
	    var n = monthRe.exec(string.slice(i));
	    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
	  }

	  function parseLocaleDateTime(d, string, i) {
	    return parseSpecifier(d, locale_dateTime, string, i);
	  }

	  function parseLocaleDate(d, string, i) {
	    return parseSpecifier(d, locale_date, string, i);
	  }

	  function parseLocaleTime(d, string, i) {
	    return parseSpecifier(d, locale_time, string, i);
	  }

	  function formatShortWeekday(d) {
	    return locale_shortWeekdays[d.getDay()];
	  }

	  function formatWeekday(d) {
	    return locale_weekdays[d.getDay()];
	  }

	  function formatShortMonth(d) {
	    return locale_shortMonths[d.getMonth()];
	  }

	  function formatMonth(d) {
	    return locale_months[d.getMonth()];
	  }

	  function formatPeriod(d) {
	    return locale_periods[+(d.getHours() >= 12)];
	  }

	  function formatUTCShortWeekday(d) {
	    return locale_shortWeekdays[d.getUTCDay()];
	  }

	  function formatUTCWeekday(d) {
	    return locale_weekdays[d.getUTCDay()];
	  }

	  function formatUTCShortMonth(d) {
	    return locale_shortMonths[d.getUTCMonth()];
	  }

	  function formatUTCMonth(d) {
	    return locale_months[d.getUTCMonth()];
	  }

	  function formatUTCPeriod(d) {
	    return locale_periods[+(d.getUTCHours() >= 12)];
	  }

	  return {
	    format: function(specifier) {
	      var f = newFormat(specifier += "", formats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    parse: function(specifier) {
	      var p = newParse(specifier += "", localDate);
	      p.toString = function() { return specifier; };
	      return p;
	    },
	    utcFormat: function(specifier) {
	      var f = newFormat(specifier += "", utcFormats);
	      f.toString = function() { return specifier; };
	      return f;
	    },
	    utcParse: function(specifier) {
	      var p = newParse(specifier, utcDate);
	      p.toString = function() { return specifier; };
	      return p;
	    }
	  };
	}

	var pads = {"-": "", "_": " ", "0": "0"};
	var numberRe = /^\s*\d+/;
	var percentRe = /^%/;
	var requoteRe = /[\\^$*+?|[\]().{}]/g;

	function pad(value, fill, width) {
	  var sign = value < 0 ? "-" : "",
	      string = (sign ? -value : value) + "",
	      length = string.length;
	  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
	}

	function requote(s) {
	  return s.replace(requoteRe, "\\$&");
	}

	function formatRe(names) {
	  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
	}

	function formatLookup(names) {
	  var map = {}, i = -1, n = names.length;
	  while (++i < n) map[names[i].toLowerCase()] = i;
	  return map;
	}

	function parseWeekdayNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.w = +n[0], i + n[0].length) : -1;
	}

	function parseWeekdayNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 1));
	  return n ? (d.u = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberSunday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.U = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberISO(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.V = +n[0], i + n[0].length) : -1;
	}

	function parseWeekNumberMonday(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.W = +n[0], i + n[0].length) : -1;
	}

	function parseFullYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 4));
	  return n ? (d.y = +n[0], i + n[0].length) : -1;
	}

	function parseYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
	}

	function parseZone(d, string, i) {
	  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
	  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
	}

	function parseMonthNumber(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
	}

	function parseDayOfMonth(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.d = +n[0], i + n[0].length) : -1;
	}

	function parseDayOfYear(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
	}

	function parseHour24(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.H = +n[0], i + n[0].length) : -1;
	}

	function parseMinutes(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.M = +n[0], i + n[0].length) : -1;
	}

	function parseSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 2));
	  return n ? (d.S = +n[0], i + n[0].length) : -1;
	}

	function parseMilliseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 3));
	  return n ? (d.L = +n[0], i + n[0].length) : -1;
	}

	function parseMicroseconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i, i + 6));
	  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
	}

	function parseLiteralPercent(d, string, i) {
	  var n = percentRe.exec(string.slice(i, i + 1));
	  return n ? i + n[0].length : -1;
	}

	function parseUnixTimestamp(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = +n[0], i + n[0].length) : -1;
	}

	function parseUnixTimestampSeconds(d, string, i) {
	  var n = numberRe.exec(string.slice(i));
	  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
	}

	function formatDayOfMonth(d, p) {
	  return pad(d.getDate(), p, 2);
	}

	function formatHour24(d, p) {
	  return pad(d.getHours(), p, 2);
	}

	function formatHour12(d, p) {
	  return pad(d.getHours() % 12 || 12, p, 2);
	}

	function formatDayOfYear(d, p) {
	  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
	}

	function formatMilliseconds(d, p) {
	  return pad(d.getMilliseconds(), p, 3);
	}

	function formatMicroseconds(d, p) {
	  return formatMilliseconds(d, p) + "000";
	}

	function formatMonthNumber(d, p) {
	  return pad(d.getMonth() + 1, p, 2);
	}

	function formatMinutes(d, p) {
	  return pad(d.getMinutes(), p, 2);
	}

	function formatSeconds(d, p) {
	  return pad(d.getSeconds(), p, 2);
	}

	function formatWeekdayNumberMonday(d) {
	  var day = d.getDay();
	  return day === 0 ? 7 : day;
	}

	function formatWeekNumberSunday(d, p) {
	  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
	}

	function formatWeekNumberISO(d, p) {
	  var day = d.getDay();
	  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
	  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
	}

	function formatWeekdayNumberSunday(d) {
	  return d.getDay();
	}

	function formatWeekNumberMonday(d, p) {
	  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
	}

	function formatYear(d, p) {
	  return pad(d.getFullYear() % 100, p, 2);
	}

	function formatFullYear(d, p) {
	  return pad(d.getFullYear() % 10000, p, 4);
	}

	function formatZone(d) {
	  var z = d.getTimezoneOffset();
	  return (z > 0 ? "-" : (z *= -1, "+"))
	      + pad(z / 60 | 0, "0", 2)
	      + pad(z % 60, "0", 2);
	}

	function formatUTCDayOfMonth(d, p) {
	  return pad(d.getUTCDate(), p, 2);
	}

	function formatUTCHour24(d, p) {
	  return pad(d.getUTCHours(), p, 2);
	}

	function formatUTCHour12(d, p) {
	  return pad(d.getUTCHours() % 12 || 12, p, 2);
	}

	function formatUTCDayOfYear(d, p) {
	  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
	}

	function formatUTCMilliseconds(d, p) {
	  return pad(d.getUTCMilliseconds(), p, 3);
	}

	function formatUTCMicroseconds(d, p) {
	  return formatUTCMilliseconds(d, p) + "000";
	}

	function formatUTCMonthNumber(d, p) {
	  return pad(d.getUTCMonth() + 1, p, 2);
	}

	function formatUTCMinutes(d, p) {
	  return pad(d.getUTCMinutes(), p, 2);
	}

	function formatUTCSeconds(d, p) {
	  return pad(d.getUTCSeconds(), p, 2);
	}

	function formatUTCWeekdayNumberMonday(d) {
	  var dow = d.getUTCDay();
	  return dow === 0 ? 7 : dow;
	}

	function formatUTCWeekNumberSunday(d, p) {
	  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
	}

	function formatUTCWeekNumberISO(d, p) {
	  var day = d.getUTCDay();
	  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
	  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
	}

	function formatUTCWeekdayNumberSunday(d) {
	  return d.getUTCDay();
	}

	function formatUTCWeekNumberMonday(d, p) {
	  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
	}

	function formatUTCYear(d, p) {
	  return pad(d.getUTCFullYear() % 100, p, 2);
	}

	function formatUTCFullYear(d, p) {
	  return pad(d.getUTCFullYear() % 10000, p, 4);
	}

	function formatUTCZone() {
	  return "+0000";
	}

	function formatLiteralPercent() {
	  return "%";
	}

	function formatUnixTimestamp(d) {
	  return +d;
	}

	function formatUnixTimestampSeconds(d) {
	  return Math.floor(+d / 1000);
	}

	var locale;





	defaultLocale({
	  dateTime: "%x, %X",
	  date: "%-m/%-d/%Y",
	  time: "%-I:%M:%S %p",
	  periods: ["AM", "PM"],
	  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
	  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
	  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
	  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
	});

	function defaultLocale(definition) {
	  locale = formatLocale(definition);
	  exports.timeFormat = locale.format;
	  exports.timeParse = locale.parse;
	  exports.utcFormat = locale.utcFormat;
	  exports.utcParse = locale.utcParse;
	  return locale;
	}

	var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

	function formatIsoNative(date) {
	  return date.toISOString();
	}

	var formatIso = Date.prototype.toISOString
	    ? formatIsoNative
	    : exports.utcFormat(isoSpecifier);

	function parseIsoNative(string) {
	  var date = new Date(string);
	  return isNaN(date) ? null : date;
	}

	var parseIso = +new Date("2000-01-01T00:00:00.000Z")
	    ? parseIsoNative
	    : exports.utcParse(isoSpecifier);

	exports.timeFormatDefaultLocale = defaultLocale;
	exports.timeFormatLocale = formatLocale;
	exports.isoFormat = formatIso;
	exports.isoParse = parseIso;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-scale-chromatic/ Version 1.3.0. Copyright 2018 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(418), __webpack_require__(419)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
	}(this, (function (exports,d3Interpolate,d3Color) { 'use strict';

	function colors(specifier) {
	  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
	  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
	  return colors;
	}

	var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

	var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

	var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

	var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

	var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

	var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

	var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

	var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

	var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

	function ramp(scheme) {
	  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
	}

	var scheme = new Array(3).concat(
	  "d8b365f5f5f55ab4ac",
	  "a6611adfc27d80cdc1018571",
	  "a6611adfc27df5f5f580cdc1018571",
	  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
	  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
	  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
	  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
	  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
	  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
	).map(colors);

	var BrBG = ramp(scheme);

	var scheme$1 = new Array(3).concat(
	  "af8dc3f7f7f77fbf7b",
	  "7b3294c2a5cfa6dba0008837",
	  "7b3294c2a5cff7f7f7a6dba0008837",
	  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
	  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
	  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
	  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
	  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
	  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
	).map(colors);

	var PRGn = ramp(scheme$1);

	var scheme$2 = new Array(3).concat(
	  "e9a3c9f7f7f7a1d76a",
	  "d01c8bf1b6dab8e1864dac26",
	  "d01c8bf1b6daf7f7f7b8e1864dac26",
	  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
	  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
	  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
	  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
	  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
	  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
	).map(colors);

	var PiYG = ramp(scheme$2);

	var scheme$3 = new Array(3).concat(
	  "998ec3f7f7f7f1a340",
	  "5e3c99b2abd2fdb863e66101",
	  "5e3c99b2abd2f7f7f7fdb863e66101",
	  "542788998ec3d8daebfee0b6f1a340b35806",
	  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
	  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
	  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
	  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
	  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
	).map(colors);

	var PuOr = ramp(scheme$3);

	var scheme$4 = new Array(3).concat(
	  "ef8a62f7f7f767a9cf",
	  "ca0020f4a58292c5de0571b0",
	  "ca0020f4a582f7f7f792c5de0571b0",
	  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
	  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
	  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
	  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
	  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
	  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
	).map(colors);

	var RdBu = ramp(scheme$4);

	var scheme$5 = new Array(3).concat(
	  "ef8a62ffffff999999",
	  "ca0020f4a582bababa404040",
	  "ca0020f4a582ffffffbababa404040",
	  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
	  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
	  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
	  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
	  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
	  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
	).map(colors);

	var RdGy = ramp(scheme$5);

	var scheme$6 = new Array(3).concat(
	  "fc8d59ffffbf91bfdb",
	  "d7191cfdae61abd9e92c7bb6",
	  "d7191cfdae61ffffbfabd9e92c7bb6",
	  "d73027fc8d59fee090e0f3f891bfdb4575b4",
	  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
	  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
	  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
	  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
	  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
	).map(colors);

	var RdYlBu = ramp(scheme$6);

	var scheme$7 = new Array(3).concat(
	  "fc8d59ffffbf91cf60",
	  "d7191cfdae61a6d96a1a9641",
	  "d7191cfdae61ffffbfa6d96a1a9641",
	  "d73027fc8d59fee08bd9ef8b91cf601a9850",
	  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
	  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
	  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
	  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
	  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
	).map(colors);

	var RdYlGn = ramp(scheme$7);

	var scheme$8 = new Array(3).concat(
	  "fc8d59ffffbf99d594",
	  "d7191cfdae61abdda42b83ba",
	  "d7191cfdae61ffffbfabdda42b83ba",
	  "d53e4ffc8d59fee08be6f59899d5943288bd",
	  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
	  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
	  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
	  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
	  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
	).map(colors);

	var Spectral = ramp(scheme$8);

	var scheme$9 = new Array(3).concat(
	  "e5f5f999d8c92ca25f",
	  "edf8fbb2e2e266c2a4238b45",
	  "edf8fbb2e2e266c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a42ca25f006d2c",
	  "edf8fbccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
	  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
	).map(colors);

	var BuGn = ramp(scheme$9);

	var scheme$10 = new Array(3).concat(
	  "e0ecf49ebcda8856a7",
	  "edf8fbb3cde38c96c688419d",
	  "edf8fbb3cde38c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
	  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
	  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
	).map(colors);

	var BuPu = ramp(scheme$10);

	var scheme$11 = new Array(3).concat(
	  "e0f3dba8ddb543a2ca",
	  "f0f9e8bae4bc7bccc42b8cbe",
	  "f0f9e8bae4bc7bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
	  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
	  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
	).map(colors);

	var GnBu = ramp(scheme$11);

	var scheme$12 = new Array(3).concat(
	  "fee8c8fdbb84e34a33",
	  "fef0d9fdcc8afc8d59d7301f",
	  "fef0d9fdcc8afc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
	  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
	  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
	).map(colors);

	var OrRd = ramp(scheme$12);

	var scheme$13 = new Array(3).concat(
	  "ece2f0a6bddb1c9099",
	  "f6eff7bdc9e167a9cf02818a",
	  "f6eff7bdc9e167a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
	  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
	  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
	).map(colors);

	var PuBuGn = ramp(scheme$13);

	var scheme$14 = new Array(3).concat(
	  "ece7f2a6bddb2b8cbe",
	  "f1eef6bdc9e174a9cf0570b0",
	  "f1eef6bdc9e174a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
	  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
	  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
	).map(colors);

	var PuBu = ramp(scheme$14);

	var scheme$15 = new Array(3).concat(
	  "e7e1efc994c7dd1c77",
	  "f1eef6d7b5d8df65b0ce1256",
	  "f1eef6d7b5d8df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0dd1c77980043",
	  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
	  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
	).map(colors);

	var PuRd = ramp(scheme$15);

	var scheme$16 = new Array(3).concat(
	  "fde0ddfa9fb5c51b8a",
	  "feebe2fbb4b9f768a1ae017e",
	  "feebe2fbb4b9f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
	  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
	  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
	).map(colors);

	var RdPu = ramp(scheme$16);

	var scheme$17 = new Array(3).concat(
	  "edf8b17fcdbb2c7fb8",
	  "ffffcca1dab441b6c4225ea8",
	  "ffffcca1dab441b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
	  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
	  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
	).map(colors);

	var YlGnBu = ramp(scheme$17);

	var scheme$18 = new Array(3).concat(
	  "f7fcb9addd8e31a354",
	  "ffffccc2e69978c679238443",
	  "ffffccc2e69978c67931a354006837",
	  "ffffccd9f0a3addd8e78c67931a354006837",
	  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
	  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
	).map(colors);

	var YlGn = ramp(scheme$18);

	var scheme$19 = new Array(3).concat(
	  "fff7bcfec44fd95f0e",
	  "ffffd4fed98efe9929cc4c02",
	  "ffffd4fed98efe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929d95f0e993404",
	  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
	  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
	).map(colors);

	var YlOrBr = ramp(scheme$19);

	var scheme$20 = new Array(3).concat(
	  "ffeda0feb24cf03b20",
	  "ffffb2fecc5cfd8d3ce31a1c",
	  "ffffb2fecc5cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
	  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
	  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
	).map(colors);

	var YlOrRd = ramp(scheme$20);

	var scheme$21 = new Array(3).concat(
	  "deebf79ecae13182bd",
	  "eff3ffbdd7e76baed62171b5",
	  "eff3ffbdd7e76baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed63182bd08519c",
	  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
	  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
	).map(colors);

	var Blues = ramp(scheme$21);

	var scheme$22 = new Array(3).concat(
	  "e5f5e0a1d99b31a354",
	  "edf8e9bae4b374c476238b45",
	  "edf8e9bae4b374c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
	  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
	  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
	).map(colors);

	var Greens = ramp(scheme$22);

	var scheme$23 = new Array(3).concat(
	  "f0f0f0bdbdbd636363",
	  "f7f7f7cccccc969696525252",
	  "f7f7f7cccccc969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696636363252525",
	  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
	  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
	).map(colors);

	var Greys = ramp(scheme$23);

	var scheme$24 = new Array(3).concat(
	  "efedf5bcbddc756bb1",
	  "f2f0f7cbc9e29e9ac86a51a3",
	  "f2f0f7cbc9e29e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
	  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
	  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
	).map(colors);

	var Purples = ramp(scheme$24);

	var scheme$25 = new Array(3).concat(
	  "fee0d2fc9272de2d26",
	  "fee5d9fcae91fb6a4acb181d",
	  "fee5d9fcae91fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
	  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
	  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
	).map(colors);

	var Reds = ramp(scheme$25);

	var scheme$26 = new Array(3).concat(
	  "fee6cefdae6be6550d",
	  "feeddefdbe85fd8d3cd94701",
	  "feeddefdbe85fd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
	  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
	  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
	).map(colors);

	var Oranges = ramp(scheme$26);

	var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

	var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

	var c = d3Color.cubehelix();

	function rainbow(t) {
	  if (t < 0 || t > 1) t -= Math.floor(t);
	  var ts = Math.abs(t - 0.5);
	  c.h = 360 * t - 100;
	  c.s = 1.5 - 1.5 * ts;
	  c.l = 0.8 - 0.9 * ts;
	  return c + "";
	}

	var c$1 = d3Color.rgb();
	var pi_1_3 = Math.PI / 3;
	var pi_2_3 = Math.PI * 2 / 3;

	function sinebow(t) {
	  var x;
	  t = (0.5 - t) * Math.PI;
	  c$1.r = 255 * (x = Math.sin(t)) * x;
	  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
	  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
	  return c$1 + "";
	}

	function ramp$1(range) {
	  var n = range.length;
	  return function(t) {
	    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
	  };
	}

	var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

	var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

	var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

	var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

	exports.schemeCategory10 = category10;
	exports.schemeAccent = Accent;
	exports.schemeDark2 = Dark2;
	exports.schemePaired = Paired;
	exports.schemePastel1 = Pastel1;
	exports.schemePastel2 = Pastel2;
	exports.schemeSet1 = Set1;
	exports.schemeSet2 = Set2;
	exports.schemeSet3 = Set3;
	exports.interpolateBrBG = BrBG;
	exports.schemeBrBG = scheme;
	exports.interpolatePRGn = PRGn;
	exports.schemePRGn = scheme$1;
	exports.interpolatePiYG = PiYG;
	exports.schemePiYG = scheme$2;
	exports.interpolatePuOr = PuOr;
	exports.schemePuOr = scheme$3;
	exports.interpolateRdBu = RdBu;
	exports.schemeRdBu = scheme$4;
	exports.interpolateRdGy = RdGy;
	exports.schemeRdGy = scheme$5;
	exports.interpolateRdYlBu = RdYlBu;
	exports.schemeRdYlBu = scheme$6;
	exports.interpolateRdYlGn = RdYlGn;
	exports.schemeRdYlGn = scheme$7;
	exports.interpolateSpectral = Spectral;
	exports.schemeSpectral = scheme$8;
	exports.interpolateBuGn = BuGn;
	exports.schemeBuGn = scheme$9;
	exports.interpolateBuPu = BuPu;
	exports.schemeBuPu = scheme$10;
	exports.interpolateGnBu = GnBu;
	exports.schemeGnBu = scheme$11;
	exports.interpolateOrRd = OrRd;
	exports.schemeOrRd = scheme$12;
	exports.interpolatePuBuGn = PuBuGn;
	exports.schemePuBuGn = scheme$13;
	exports.interpolatePuBu = PuBu;
	exports.schemePuBu = scheme$14;
	exports.interpolatePuRd = PuRd;
	exports.schemePuRd = scheme$15;
	exports.interpolateRdPu = RdPu;
	exports.schemeRdPu = scheme$16;
	exports.interpolateYlGnBu = YlGnBu;
	exports.schemeYlGnBu = scheme$17;
	exports.interpolateYlGn = YlGn;
	exports.schemeYlGn = scheme$18;
	exports.interpolateYlOrBr = YlOrBr;
	exports.schemeYlOrBr = scheme$19;
	exports.interpolateYlOrRd = YlOrRd;
	exports.schemeYlOrRd = scheme$20;
	exports.interpolateBlues = Blues;
	exports.schemeBlues = scheme$21;
	exports.interpolateGreens = Greens;
	exports.schemeGreens = scheme$22;
	exports.interpolateGreys = Greys;
	exports.schemeGreys = scheme$23;
	exports.interpolatePurples = Purples;
	exports.schemePurples = scheme$24;
	exports.interpolateReds = Reds;
	exports.schemeReds = scheme$25;
	exports.interpolateOranges = Oranges;
	exports.schemeOranges = scheme$26;
	exports.interpolateCubehelixDefault = cubehelix$1;
	exports.interpolateRainbow = rainbow;
	exports.interpolateWarm = warm;
	exports.interpolateCool = cool;
	exports.interpolateSinebow = sinebow;
	exports.interpolateViridis = viridis;
	exports.interpolateMagma = magma;
	exports.interpolateInferno = inferno;
	exports.interpolatePlasma = plasma;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-shape/ Version 1.2.0. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(424)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3));
	}(this, (function (exports,d3Path) { 'use strict';

	var constant = function(x) {
	  return function constant() {
	    return x;
	  };
	};

	var abs = Math.abs;
	var atan2 = Math.atan2;
	var cos = Math.cos;
	var max = Math.max;
	var min = Math.min;
	var sin = Math.sin;
	var sqrt = Math.sqrt;

	var epsilon = 1e-12;
	var pi = Math.PI;
	var halfPi = pi / 2;
	var tau = 2 * pi;

	function acos(x) {
	  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
	}

	function asin(x) {
	  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
	}

	function arcInnerRadius(d) {
	  return d.innerRadius;
	}

	function arcOuterRadius(d) {
	  return d.outerRadius;
	}

	function arcStartAngle(d) {
	  return d.startAngle;
	}

	function arcEndAngle(d) {
	  return d.endAngle;
	}

	function arcPadAngle(d) {
	  return d && d.padAngle; // Note: optional!
	}

	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	  var x10 = x1 - x0, y10 = y1 - y0,
	      x32 = x3 - x2, y32 = y3 - y2,
	      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
	  return [x0 + t * x10, y0 + t * y10];
	}

	// Compute perpendicular offset line of length rc.
	// http://mathworld.wolfram.com/Circle-LineIntersection.html
	function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
	  var x01 = x0 - x1,
	      y01 = y0 - y1,
	      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
	      ox = lo * y01,
	      oy = -lo * x01,
	      x11 = x0 + ox,
	      y11 = y0 + oy,
	      x10 = x1 + ox,
	      y10 = y1 + oy,
	      x00 = (x11 + x10) / 2,
	      y00 = (y11 + y10) / 2,
	      dx = x10 - x11,
	      dy = y10 - y11,
	      d2 = dx * dx + dy * dy,
	      r = r1 - rc,
	      D = x11 * y10 - x10 * y11,
	      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
	      cx0 = (D * dy - dx * d) / d2,
	      cy0 = (-D * dx - dy * d) / d2,
	      cx1 = (D * dy + dx * d) / d2,
	      cy1 = (-D * dx + dy * d) / d2,
	      dx0 = cx0 - x00,
	      dy0 = cy0 - y00,
	      dx1 = cx1 - x00,
	      dy1 = cy1 - y00;

	  // Pick the closer of the two intersection points.
	  // TODO Is there a faster way to determine which intersection to use?
	  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

	  return {
	    cx: cx0,
	    cy: cy0,
	    x01: -ox,
	    y01: -oy,
	    x11: cx0 * (r1 / r - 1),
	    y11: cy0 * (r1 / r - 1)
	  };
	}

	var arc = function() {
	  var innerRadius = arcInnerRadius,
	      outerRadius = arcOuterRadius,
	      cornerRadius = constant(0),
	      padRadius = null,
	      startAngle = arcStartAngle,
	      endAngle = arcEndAngle,
	      padAngle = arcPadAngle,
	      context = null;

	  function arc() {
	    var buffer,
	        r,
	        r0 = +innerRadius.apply(this, arguments),
	        r1 = +outerRadius.apply(this, arguments),
	        a0 = startAngle.apply(this, arguments) - halfPi,
	        a1 = endAngle.apply(this, arguments) - halfPi,
	        da = abs(a1 - a0),
	        cw = a1 > a0;

	    if (!context) context = buffer = d3Path.path();

	    // Ensure that the outer radius is always larger than the inner radius.
	    if (r1 < r0) r = r1, r1 = r0, r0 = r;

	    // Is it a point?
	    if (!(r1 > epsilon)) context.moveTo(0, 0);

	    // Or is it a circle or annulus?
	    else if (da > tau - epsilon) {
	      context.moveTo(r1 * cos(a0), r1 * sin(a0));
	      context.arc(0, 0, r1, a0, a1, !cw);
	      if (r0 > epsilon) {
	        context.moveTo(r0 * cos(a1), r0 * sin(a1));
	        context.arc(0, 0, r0, a1, a0, cw);
	      }
	    }

	    // Or is it a circular or annular sector?
	    else {
	      var a01 = a0,
	          a11 = a1,
	          a00 = a0,
	          a10 = a1,
	          da0 = da,
	          da1 = da,
	          ap = padAngle.apply(this, arguments) / 2,
	          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
	          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
	          rc0 = rc,
	          rc1 = rc,
	          t0,
	          t1;

	      // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
	      if (rp > epsilon) {
	        var p0 = asin(rp / r0 * sin(ap)),
	            p1 = asin(rp / r1 * sin(ap));
	        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
	        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
	        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
	        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
	      }

	      var x01 = r1 * cos(a01),
	          y01 = r1 * sin(a01),
	          x10 = r0 * cos(a10),
	          y10 = r0 * sin(a10);

	      // Apply rounded corners?
	      if (rc > epsilon) {
	        var x11 = r1 * cos(a11),
	            y11 = r1 * sin(a11),
	            x00 = r0 * cos(a00),
	            y00 = r0 * sin(a00);

	        // Restrict the corner radius according to the sector angle.
	        if (da < pi) {
	          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
	              ax = x01 - oc[0],
	              ay = y01 - oc[1],
	              bx = x11 - oc[0],
	              by = y11 - oc[1],
	              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
	              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
	          rc0 = min(rc, (r0 - lc) / (kc - 1));
	          rc1 = min(rc, (r1 - lc) / (kc + 1));
	        }
	      }

	      // Is the sector collapsed to a line?
	      if (!(da1 > epsilon)) context.moveTo(x01, y01);

	      // Does the sector’s outer ring have rounded corners?
	      else if (rc1 > epsilon) {
	        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
	        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

	        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
	          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the outer ring just a circular arc?
	      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

	      // Is there no inner ring, and it’s a circular sector?
	      // Or perhaps it’s an annular sector collapsed due to padding?
	      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

	      // Does the sector’s inner ring (or point) have rounded corners?
	      else if (rc0 > epsilon) {
	        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
	        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

	        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

	        // Have the corners merged?
	        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

	        // Otherwise, draw the two corners and the ring.
	        else {
	          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
	          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
	          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
	        }
	      }

	      // Or is the inner ring just a circular arc?
	      else context.arc(0, 0, r0, a10, a00, cw);
	    }

	    context.closePath();

	    if (buffer) return context = null, buffer + "" || null;
	  }

	  arc.centroid = function() {
	    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
	        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
	    return [cos(a) * r, sin(a) * r];
	  };

	  arc.innerRadius = function(_) {
	    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
	  };

	  arc.outerRadius = function(_) {
	    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
	  };

	  arc.cornerRadius = function(_) {
	    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
	  };

	  arc.padRadius = function(_) {
	    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
	  };

	  arc.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
	  };

	  arc.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
	  };

	  arc.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
	  };

	  arc.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
	  };

	  return arc;
	};

	function Linear(context) {
	  this._context = context;
	}

	Linear.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: this._context.lineTo(x, y); break;
	    }
	  }
	};

	var curveLinear = function(context) {
	  return new Linear(context);
	};

	function x(p) {
	  return p[0];
	}

	function y(p) {
	  return p[1];
	}

	var line = function() {
	  var x$$1 = x,
	      y$$1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function line(data) {
	    var i,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer;

	    if (context == null) output = curve(buffer = d3Path.path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) output.lineStart();
	        else output.lineEnd();
	      }
	      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  line.x = function(_) {
	    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
	  };

	  line.y = function(_) {
	    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
	  };

	  line.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
	  };

	  line.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
	  };

	  line.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
	  };

	  return line;
	};

	var area = function() {
	  var x0 = x,
	      x1 = null,
	      y0 = constant(0),
	      y1 = y,
	      defined = constant(true),
	      context = null,
	      curve = curveLinear,
	      output = null;

	  function area(data) {
	    var i,
	        j,
	        k,
	        n = data.length,
	        d,
	        defined0 = false,
	        buffer,
	        x0z = new Array(n),
	        y0z = new Array(n);

	    if (context == null) output = curve(buffer = d3Path.path());

	    for (i = 0; i <= n; ++i) {
	      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
	        if (defined0 = !defined0) {
	          j = i;
	          output.areaStart();
	          output.lineStart();
	        } else {
	          output.lineEnd();
	          output.lineStart();
	          for (k = i - 1; k >= j; --k) {
	            output.point(x0z[k], y0z[k]);
	          }
	          output.lineEnd();
	          output.areaEnd();
	        }
	      }
	      if (defined0) {
	        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
	        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
	      }
	    }

	    if (buffer) return output = null, buffer + "" || null;
	  }

	  function arealine() {
	    return line().defined(defined).curve(curve).context(context);
	  }

	  area.x = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
	  };

	  area.x0 = function(_) {
	    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
	  };

	  area.x1 = function(_) {
	    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
	  };

	  area.y = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
	  };

	  area.y0 = function(_) {
	    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
	  };

	  area.y1 = function(_) {
	    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
	  };

	  area.lineX0 =
	  area.lineY0 = function() {
	    return arealine().x(x0).y(y0);
	  };

	  area.lineY1 = function() {
	    return arealine().x(x0).y(y1);
	  };

	  area.lineX1 = function() {
	    return arealine().x(x1).y(y0);
	  };

	  area.defined = function(_) {
	    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
	  };

	  area.curve = function(_) {
	    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
	  };

	  area.context = function(_) {
	    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
	  };

	  return area;
	};

	var descending = function(a, b) {
	  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
	};

	var identity = function(d) {
	  return d;
	};

	var pie = function() {
	  var value = identity,
	      sortValues = descending,
	      sort = null,
	      startAngle = constant(0),
	      endAngle = constant(tau),
	      padAngle = constant(0);

	  function pie(data) {
	    var i,
	        n = data.length,
	        j,
	        k,
	        sum = 0,
	        index = new Array(n),
	        arcs = new Array(n),
	        a0 = +startAngle.apply(this, arguments),
	        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
	        a1,
	        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
	        pa = p * (da < 0 ? -1 : 1),
	        v;

	    for (i = 0; i < n; ++i) {
	      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
	        sum += v;
	      }
	    }

	    // Optionally sort the arcs by previously-computed values or by data.
	    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
	    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

	    // Compute the arcs! They are stored in the original data's order.
	    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
	      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
	        data: data[j],
	        index: i,
	        value: v,
	        startAngle: a0,
	        endAngle: a1,
	        padAngle: p
	      };
	    }

	    return arcs;
	  }

	  pie.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
	  };

	  pie.sortValues = function(_) {
	    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
	  };

	  pie.sort = function(_) {
	    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
	  };

	  pie.startAngle = function(_) {
	    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
	  };

	  pie.endAngle = function(_) {
	    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
	  };

	  pie.padAngle = function(_) {
	    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
	  };

	  return pie;
	};

	var curveRadialLinear = curveRadial(curveLinear);

	function Radial(curve) {
	  this._curve = curve;
	}

	Radial.prototype = {
	  areaStart: function() {
	    this._curve.areaStart();
	  },
	  areaEnd: function() {
	    this._curve.areaEnd();
	  },
	  lineStart: function() {
	    this._curve.lineStart();
	  },
	  lineEnd: function() {
	    this._curve.lineEnd();
	  },
	  point: function(a, r) {
	    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
	  }
	};

	function curveRadial(curve) {

	  function radial(context) {
	    return new Radial(curve(context));
	  }

	  radial._curve = curve;

	  return radial;
	}

	function lineRadial(l) {
	  var c = l.curve;

	  l.angle = l.x, delete l.x;
	  l.radius = l.y, delete l.y;

	  l.curve = function(_) {
	    return arguments.length ? c(curveRadial(_)) : c()._curve;
	  };

	  return l;
	}

	var lineRadial$1 = function() {
	  return lineRadial(line().curve(curveRadialLinear));
	};

	var areaRadial = function() {
	  var a = area().curve(curveRadialLinear),
	      c = a.curve,
	      x0 = a.lineX0,
	      x1 = a.lineX1,
	      y0 = a.lineY0,
	      y1 = a.lineY1;

	  a.angle = a.x, delete a.x;
	  a.startAngle = a.x0, delete a.x0;
	  a.endAngle = a.x1, delete a.x1;
	  a.radius = a.y, delete a.y;
	  a.innerRadius = a.y0, delete a.y0;
	  a.outerRadius = a.y1, delete a.y1;
	  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
	  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
	  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
	  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

	  a.curve = function(_) {
	    return arguments.length ? c(curveRadial(_)) : c()._curve;
	  };

	  return a;
	};

	var pointRadial = function(x, y) {
	  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
	};

	var slice = Array.prototype.slice;

	function linkSource(d) {
	  return d.source;
	}

	function linkTarget(d) {
	  return d.target;
	}

	function link(curve) {
	  var source = linkSource,
	      target = linkTarget,
	      x$$1 = x,
	      y$$1 = y,
	      context = null;

	  function link() {
	    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
	    if (!context) context = buffer = d3Path.path();
	    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
	    if (buffer) return context = null, buffer + "" || null;
	  }

	  link.source = function(_) {
	    return arguments.length ? (source = _, link) : source;
	  };

	  link.target = function(_) {
	    return arguments.length ? (target = _, link) : target;
	  };

	  link.x = function(_) {
	    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), link) : x$$1;
	  };

	  link.y = function(_) {
	    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), link) : y$$1;
	  };

	  link.context = function(_) {
	    return arguments.length ? ((context = _ == null ? null : _), link) : context;
	  };

	  return link;
	}

	function curveHorizontal(context, x0, y0, x1, y1) {
	  context.moveTo(x0, y0);
	  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
	}

	function curveVertical(context, x0, y0, x1, y1) {
	  context.moveTo(x0, y0);
	  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
	}

	function curveRadial$1(context, x0, y0, x1, y1) {
	  var p0 = pointRadial(x0, y0),
	      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
	      p2 = pointRadial(x1, y0),
	      p3 = pointRadial(x1, y1);
	  context.moveTo(p0[0], p0[1]);
	  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
	}

	function linkHorizontal() {
	  return link(curveHorizontal);
	}

	function linkVertical() {
	  return link(curveVertical);
	}

	function linkRadial() {
	  var l = link(curveRadial$1);
	  l.angle = l.x, delete l.x;
	  l.radius = l.y, delete l.y;
	  return l;
	}

	var circle = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / pi);
	    context.moveTo(r, 0);
	    context.arc(0, 0, r, 0, tau);
	  }
	};

	var cross = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / 5) / 2;
	    context.moveTo(-3 * r, -r);
	    context.lineTo(-r, -r);
	    context.lineTo(-r, -3 * r);
	    context.lineTo(r, -3 * r);
	    context.lineTo(r, -r);
	    context.lineTo(3 * r, -r);
	    context.lineTo(3 * r, r);
	    context.lineTo(r, r);
	    context.lineTo(r, 3 * r);
	    context.lineTo(-r, 3 * r);
	    context.lineTo(-r, r);
	    context.lineTo(-3 * r, r);
	    context.closePath();
	  }
	};

	var tan30 = Math.sqrt(1 / 3);
	var tan30_2 = tan30 * 2;

	var diamond = {
	  draw: function(context, size) {
	    var y = Math.sqrt(size / tan30_2),
	        x = y * tan30;
	    context.moveTo(0, -y);
	    context.lineTo(x, 0);
	    context.lineTo(0, y);
	    context.lineTo(-x, 0);
	    context.closePath();
	  }
	};

	var ka = 0.89081309152928522810;
	var kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10);
	var kx = Math.sin(tau / 10) * kr;
	var ky = -Math.cos(tau / 10) * kr;

	var star = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size * ka),
	        x = kx * r,
	        y = ky * r;
	    context.moveTo(0, -r);
	    context.lineTo(x, y);
	    for (var i = 1; i < 5; ++i) {
	      var a = tau * i / 5,
	          c = Math.cos(a),
	          s = Math.sin(a);
	      context.lineTo(s * r, -c * r);
	      context.lineTo(c * x - s * y, s * x + c * y);
	    }
	    context.closePath();
	  }
	};

	var square = {
	  draw: function(context, size) {
	    var w = Math.sqrt(size),
	        x = -w / 2;
	    context.rect(x, x, w, w);
	  }
	};

	var sqrt3 = Math.sqrt(3);

	var triangle = {
	  draw: function(context, size) {
	    var y = -Math.sqrt(size / (sqrt3 * 3));
	    context.moveTo(0, y * 2);
	    context.lineTo(-sqrt3 * y, -y);
	    context.lineTo(sqrt3 * y, -y);
	    context.closePath();
	  }
	};

	var c = -0.5;
	var s = Math.sqrt(3) / 2;
	var k = 1 / Math.sqrt(12);
	var a = (k / 2 + 1) * 3;

	var wye = {
	  draw: function(context, size) {
	    var r = Math.sqrt(size / a),
	        x0 = r / 2,
	        y0 = r * k,
	        x1 = x0,
	        y1 = r * k + r,
	        x2 = -x1,
	        y2 = y1;
	    context.moveTo(x0, y0);
	    context.lineTo(x1, y1);
	    context.lineTo(x2, y2);
	    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
	    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
	    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
	    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
	    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
	    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
	    context.closePath();
	  }
	};

	var symbols = [
	  circle,
	  cross,
	  diamond,
	  square,
	  star,
	  triangle,
	  wye
	];

	var symbol = function() {
	  var type = constant(circle),
	      size = constant(64),
	      context = null;

	  function symbol() {
	    var buffer;
	    if (!context) context = buffer = d3Path.path();
	    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
	    if (buffer) return context = null, buffer + "" || null;
	  }

	  symbol.type = function(_) {
	    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
	  };

	  symbol.size = function(_) {
	    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
	  };

	  symbol.context = function(_) {
	    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
	  };

	  return symbol;
	};

	var noop = function() {};

	function point(that, x, y) {
	  that._context.bezierCurveTo(
	    (2 * that._x0 + that._x1) / 3,
	    (2 * that._y0 + that._y1) / 3,
	    (that._x0 + 2 * that._x1) / 3,
	    (that._y0 + 2 * that._y1) / 3,
	    (that._x0 + 4 * that._x1 + x) / 6,
	    (that._y0 + 4 * that._y1 + y) / 6
	  );
	}

	function Basis(context) {
	  this._context = context;
	}

	Basis.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 3: point(this, this._x1, this._y1); // proceed
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	var basis = function(context) {
	  return new Basis(context);
	};

	function BasisClosed(context) {
	  this._context = context;
	}

	BasisClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x2, this._y2);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
	        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x2, this._y2);
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
	      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
	      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	var basisClosed = function(context) {
	  return new BasisClosed(context);
	};

	function BasisOpen(context) {
	  this._context = context;
	}

	BasisOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
	      case 3: this._point = 4; // proceed
	      default: point(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	  }
	};

	var basisOpen = function(context) {
	  return new BasisOpen(context);
	};

	function Bundle(context, beta) {
	  this._basis = new Basis(context);
	  this._beta = beta;
	}

	Bundle.prototype = {
	  lineStart: function() {
	    this._x = [];
	    this._y = [];
	    this._basis.lineStart();
	  },
	  lineEnd: function() {
	    var x = this._x,
	        y = this._y,
	        j = x.length - 1;

	    if (j > 0) {
	      var x0 = x[0],
	          y0 = y[0],
	          dx = x[j] - x0,
	          dy = y[j] - y0,
	          i = -1,
	          t;

	      while (++i <= j) {
	        t = i / j;
	        this._basis.point(
	          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
	          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
	        );
	      }
	    }

	    this._x = this._y = null;
	    this._basis.lineEnd();
	  },
	  point: function(x, y) {
	    this._x.push(+x);
	    this._y.push(+y);
	  }
	};

	var bundle = ((function custom(beta) {

	  function bundle(context) {
	    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
	  }

	  bundle.beta = function(beta) {
	    return custom(+beta);
	  };

	  return bundle;
	}))(0.85);

	function point$1(that, x, y) {
	  that._context.bezierCurveTo(
	    that._x1 + that._k * (that._x2 - that._x0),
	    that._y1 + that._k * (that._y2 - that._y0),
	    that._x2 + that._k * (that._x1 - x),
	    that._y2 + that._k * (that._y1 - y),
	    that._x2,
	    that._y2
	  );
	}

	function Cardinal(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	Cardinal.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x2, this._y2); break;
	      case 3: point$1(this, this._x1, this._y1); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
	      case 2: this._point = 3; // proceed
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinal = ((function custom(tension) {

	  function cardinal(context) {
	    return new Cardinal(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	}))(0);

	function CardinalClosed(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	CardinalClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.lineTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        this.point(this._x5, this._y5);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinalClosed = ((function custom(tension) {

	  function cardinal(context) {
	    return new CardinalClosed(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	}))(0);

	function CardinalOpen(context, tension) {
	  this._context = context;
	  this._k = (1 - tension) / 6;
	}

	CardinalOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	      case 3: this._point = 4; // proceed
	      default: point$1(this, x, y); break;
	    }
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var cardinalOpen = ((function custom(tension) {

	  function cardinal(context) {
	    return new CardinalOpen(context, tension);
	  }

	  cardinal.tension = function(tension) {
	    return custom(+tension);
	  };

	  return cardinal;
	}))(0);

	function point$2(that, x, y) {
	  var x1 = that._x1,
	      y1 = that._y1,
	      x2 = that._x2,
	      y2 = that._y2;

	  if (that._l01_a > epsilon) {
	    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
	        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
	    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
	    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
	  }

	  if (that._l23_a > epsilon) {
	    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
	        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
	    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
	    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
	  }

	  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
	}

	function CatmullRom(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRom.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x2, this._y2); break;
	      case 3: this.point(this._x2, this._y2); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; // proceed
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRom = ((function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	}))(0.5);

	function CatmullRomClosed(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRomClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
	    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 1: {
	        this._context.moveTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 2: {
	        this._context.lineTo(this._x3, this._y3);
	        this._context.closePath();
	        break;
	      }
	      case 3: {
	        this.point(this._x3, this._y3);
	        this.point(this._x4, this._y4);
	        this.point(this._x5, this._y5);
	        break;
	      }
	    }
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
	      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
	      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRomClosed = ((function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	}))(0.5);

	function CatmullRomOpen(context, alpha) {
	  this._context = context;
	  this._alpha = alpha;
	}

	CatmullRomOpen.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 = this._x2 =
	    this._y0 = this._y1 = this._y2 = NaN;
	    this._l01_a = this._l12_a = this._l23_a =
	    this._l01_2a = this._l12_2a = this._l23_2a =
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;

	    if (this._point) {
	      var x23 = this._x2 - x,
	          y23 = this._y2 - y;
	      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
	    }

	    switch (this._point) {
	      case 0: this._point = 1; break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
	      case 3: this._point = 4; // proceed
	      default: point$2(this, x, y); break;
	    }

	    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
	    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
	    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
	    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
	  }
	};

	var catmullRomOpen = ((function custom(alpha) {

	  function catmullRom(context) {
	    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
	  }

	  catmullRom.alpha = function(alpha) {
	    return custom(+alpha);
	  };

	  return catmullRom;
	}))(0.5);

	function LinearClosed(context) {
	  this._context = context;
	}

	LinearClosed.prototype = {
	  areaStart: noop,
	  areaEnd: noop,
	  lineStart: function() {
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (this._point) this._context.closePath();
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    if (this._point) this._context.lineTo(x, y);
	    else this._point = 1, this._context.moveTo(x, y);
	  }
	};

	var linearClosed = function(context) {
	  return new LinearClosed(context);
	};

	function sign(x) {
	  return x < 0 ? -1 : 1;
	}

	// Calculate the slopes of the tangents (Hermite-type interpolation) based on
	// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
	// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
	// NOV(II), P. 443, 1990.
	function slope3(that, x2, y2) {
	  var h0 = that._x1 - that._x0,
	      h1 = x2 - that._x1,
	      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
	      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
	      p = (s0 * h1 + s1 * h0) / (h0 + h1);
	  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
	}

	// Calculate a one-sided slope.
	function slope2(that, t) {
	  var h = that._x1 - that._x0;
	  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
	}

	// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
	// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
	// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
	function point$3(that, t0, t1) {
	  var x0 = that._x0,
	      y0 = that._y0,
	      x1 = that._x1,
	      y1 = that._y1,
	      dx = (x1 - x0) / 3;
	  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
	}

	function MonotoneX(context) {
	  this._context = context;
	}

	MonotoneX.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x0 = this._x1 =
	    this._y0 = this._y1 =
	    this._t0 = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    switch (this._point) {
	      case 2: this._context.lineTo(this._x1, this._y1); break;
	      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
	    }
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    var t1 = NaN;

	    x = +x, y = +y;
	    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; break;
	      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
	      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
	    }

	    this._x0 = this._x1, this._x1 = x;
	    this._y0 = this._y1, this._y1 = y;
	    this._t0 = t1;
	  }
	};

	function MonotoneY(context) {
	  this._context = new ReflectContext(context);
	}

	(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
	  MonotoneX.prototype.point.call(this, y, x);
	};

	function ReflectContext(context) {
	  this._context = context;
	}

	ReflectContext.prototype = {
	  moveTo: function(x, y) { this._context.moveTo(y, x); },
	  closePath: function() { this._context.closePath(); },
	  lineTo: function(x, y) { this._context.lineTo(y, x); },
	  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
	};

	function monotoneX(context) {
	  return new MonotoneX(context);
	}

	function monotoneY(context) {
	  return new MonotoneY(context);
	}

	function Natural(context) {
	  this._context = context;
	}

	Natural.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = [];
	    this._y = [];
	  },
	  lineEnd: function() {
	    var x = this._x,
	        y = this._y,
	        n = x.length;

	    if (n) {
	      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
	      if (n === 2) {
	        this._context.lineTo(x[1], y[1]);
	      } else {
	        var px = controlPoints(x),
	            py = controlPoints(y);
	        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
	          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
	        }
	      }
	    }

	    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
	    this._line = 1 - this._line;
	    this._x = this._y = null;
	  },
	  point: function(x, y) {
	    this._x.push(+x);
	    this._y.push(+y);
	  }
	};

	// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
	function controlPoints(x) {
	  var i,
	      n = x.length - 1,
	      m,
	      a = new Array(n),
	      b = new Array(n),
	      r = new Array(n);
	  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
	  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
	  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
	  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
	  a[n - 1] = r[n - 1] / b[n - 1];
	  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
	  b[n - 1] = (x[n] + a[n - 1]) / 2;
	  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
	  return [a, b];
	}

	var natural = function(context) {
	  return new Natural(context);
	};

	function Step(context, t) {
	  this._context = context;
	  this._t = t;
	}

	Step.prototype = {
	  areaStart: function() {
	    this._line = 0;
	  },
	  areaEnd: function() {
	    this._line = NaN;
	  },
	  lineStart: function() {
	    this._x = this._y = NaN;
	    this._point = 0;
	  },
	  lineEnd: function() {
	    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
	    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
	    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
	  },
	  point: function(x, y) {
	    x = +x, y = +y;
	    switch (this._point) {
	      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
	      case 1: this._point = 2; // proceed
	      default: {
	        if (this._t <= 0) {
	          this._context.lineTo(this._x, y);
	          this._context.lineTo(x, y);
	        } else {
	          var x1 = this._x * (1 - this._t) + x * this._t;
	          this._context.lineTo(x1, this._y);
	          this._context.lineTo(x1, y);
	        }
	        break;
	      }
	    }
	    this._x = x, this._y = y;
	  }
	};

	var step = function(context) {
	  return new Step(context, 0.5);
	};

	function stepBefore(context) {
	  return new Step(context, 0);
	}

	function stepAfter(context) {
	  return new Step(context, 1);
	}

	var none = function(series, order) {
	  if (!((n = series.length) > 1)) return;
	  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
	    s0 = s1, s1 = series[order[i]];
	    for (j = 0; j < m; ++j) {
	      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
	    }
	  }
	};

	var none$1 = function(series) {
	  var n = series.length, o = new Array(n);
	  while (--n >= 0) o[n] = n;
	  return o;
	};

	function stackValue(d, key) {
	  return d[key];
	}

	var stack = function() {
	  var keys = constant([]),
	      order = none$1,
	      offset = none,
	      value = stackValue;

	  function stack(data) {
	    var kz = keys.apply(this, arguments),
	        i,
	        m = data.length,
	        n = kz.length,
	        sz = new Array(n),
	        oz;

	    for (i = 0; i < n; ++i) {
	      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
	        si[j] = sij = [0, +value(data[j], ki, j, data)];
	        sij.data = data[j];
	      }
	      si.key = ki;
	    }

	    for (i = 0, oz = order(sz); i < n; ++i) {
	      sz[oz[i]].index = i;
	    }

	    offset(sz, oz);
	    return sz;
	  }

	  stack.keys = function(_) {
	    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
	  };

	  stack.value = function(_) {
	    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
	  };

	  stack.order = function(_) {
	    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
	  };

	  stack.offset = function(_) {
	    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
	  };

	  return stack;
	};

	var expand = function(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
	    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
	    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
	  }
	  none(series, order);
	};

	var diverging = function(series, order) {
	  if (!((n = series.length) > 1)) return;
	  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
	    for (yp = yn = 0, i = 0; i < n; ++i) {
	      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
	        d[0] = yp, d[1] = yp += dy;
	      } else if (dy < 0) {
	        d[1] = yn, d[0] = yn += dy;
	      } else {
	        d[0] = yp;
	      }
	    }
	  }
	};

	var silhouette = function(series, order) {
	  if (!((n = series.length) > 0)) return;
	  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
	    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
	    s0[j][1] += s0[j][0] = -y / 2;
	  }
	  none(series, order);
	};

	var wiggle = function(series, order) {
	  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
	  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
	    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
	      var si = series[order[i]],
	          sij0 = si[j][1] || 0,
	          sij1 = si[j - 1][1] || 0,
	          s3 = (sij0 - sij1) / 2;
	      for (var k = 0; k < i; ++k) {
	        var sk = series[order[k]],
	            skj0 = sk[j][1] || 0,
	            skj1 = sk[j - 1][1] || 0;
	        s3 += skj0 - skj1;
	      }
	      s1 += sij0, s2 += s3 * sij0;
	    }
	    s0[j - 1][1] += s0[j - 1][0] = y;
	    if (s1) y -= s2 / s1;
	  }
	  s0[j - 1][1] += s0[j - 1][0] = y;
	  none(series, order);
	};

	var ascending = function(series) {
	  var sums = series.map(sum);
	  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
	};

	function sum(series) {
	  var s = 0, i = -1, n = series.length, v;
	  while (++i < n) if (v = +series[i][1]) s += v;
	  return s;
	}

	var descending$1 = function(series) {
	  return ascending(series).reverse();
	};

	var insideOut = function(series) {
	  var n = series.length,
	      i,
	      j,
	      sums = series.map(sum),
	      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),
	      top = 0,
	      bottom = 0,
	      tops = [],
	      bottoms = [];

	  for (i = 0; i < n; ++i) {
	    j = order[i];
	    if (top < bottom) {
	      top += sums[j];
	      tops.push(j);
	    } else {
	      bottom += sums[j];
	      bottoms.push(j);
	    }
	  }

	  return bottoms.reverse().concat(tops);
	};

	var reverse = function(series) {
	  return none$1(series).reverse();
	};

	exports.arc = arc;
	exports.area = area;
	exports.line = line;
	exports.pie = pie;
	exports.areaRadial = areaRadial;
	exports.radialArea = areaRadial;
	exports.lineRadial = lineRadial$1;
	exports.radialLine = lineRadial$1;
	exports.pointRadial = pointRadial;
	exports.linkHorizontal = linkHorizontal;
	exports.linkVertical = linkVertical;
	exports.linkRadial = linkRadial;
	exports.symbol = symbol;
	exports.symbols = symbols;
	exports.symbolCircle = circle;
	exports.symbolCross = cross;
	exports.symbolDiamond = diamond;
	exports.symbolSquare = square;
	exports.symbolStar = star;
	exports.symbolTriangle = triangle;
	exports.symbolWye = wye;
	exports.curveBasisClosed = basisClosed;
	exports.curveBasisOpen = basisOpen;
	exports.curveBasis = basis;
	exports.curveBundle = bundle;
	exports.curveCardinalClosed = cardinalClosed;
	exports.curveCardinalOpen = cardinalOpen;
	exports.curveCardinal = cardinal;
	exports.curveCatmullRomClosed = catmullRomClosed;
	exports.curveCatmullRomOpen = catmullRomOpen;
	exports.curveCatmullRom = catmullRom;
	exports.curveLinearClosed = linearClosed;
	exports.curveLinear = curveLinear;
	exports.curveMonotoneX = monotoneX;
	exports.curveMonotoneY = monotoneY;
	exports.curveNatural = natural;
	exports.curveStep = step;
	exports.curveStepAfter = stepAfter;
	exports.curveStepBefore = stepBefore;
	exports.stack = stack;
	exports.stackOffsetExpand = expand;
	exports.stackOffsetDiverging = diverging;
	exports.stackOffsetNone = none;
	exports.stackOffsetSilhouette = silhouette;
	exports.stackOffsetWiggle = wiggle;
	exports.stackOrderAscending = ascending;
	exports.stackOrderDescending = descending$1;
	exports.stackOrderInsideOut = insideOut;
	exports.stackOrderNone = none$1;
	exports.stackOrderReverse = reverse;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-voronoi/ Version 1.1.2. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	function x(d) {
	  return d[0];
	}

	function y(d) {
	  return d[1];
	}

	function RedBlackTree() {
	  this._ = null; // root node
	}

	function RedBlackNode(node) {
	  node.U = // parent node
	  node.C = // color - true for red, false for black
	  node.L = // left node
	  node.R = // right node
	  node.P = // previous node
	  node.N = null; // next node
	}

	RedBlackTree.prototype = {
	  constructor: RedBlackTree,

	  insert: function(after, node) {
	    var parent, grandpa, uncle;

	    if (after) {
	      node.P = after;
	      node.N = after.N;
	      if (after.N) after.N.P = node;
	      after.N = node;
	      if (after.R) {
	        after = after.R;
	        while (after.L) after = after.L;
	        after.L = node;
	      } else {
	        after.R = node;
	      }
	      parent = after;
	    } else if (this._) {
	      after = RedBlackFirst(this._);
	      node.P = null;
	      node.N = after;
	      after.P = after.L = node;
	      parent = after;
	    } else {
	      node.P = node.N = null;
	      this._ = node;
	      parent = null;
	    }
	    node.L = node.R = null;
	    node.U = parent;
	    node.C = true;

	    after = node;
	    while (parent && parent.C) {
	      grandpa = parent.U;
	      if (parent === grandpa.L) {
	        uncle = grandpa.R;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.R) {
	            RedBlackRotateLeft(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateRight(this, grandpa);
	        }
	      } else {
	        uncle = grandpa.L;
	        if (uncle && uncle.C) {
	          parent.C = uncle.C = false;
	          grandpa.C = true;
	          after = grandpa;
	        } else {
	          if (after === parent.L) {
	            RedBlackRotateRight(this, parent);
	            after = parent;
	            parent = after.U;
	          }
	          parent.C = false;
	          grandpa.C = true;
	          RedBlackRotateLeft(this, grandpa);
	        }
	      }
	      parent = after.U;
	    }
	    this._.C = false;
	  },

	  remove: function(node) {
	    if (node.N) node.N.P = node.P;
	    if (node.P) node.P.N = node.N;
	    node.N = node.P = null;

	    var parent = node.U,
	        sibling,
	        left = node.L,
	        right = node.R,
	        next,
	        red;

	    if (!left) next = right;
	    else if (!right) next = left;
	    else next = RedBlackFirst(right);

	    if (parent) {
	      if (parent.L === node) parent.L = next;
	      else parent.R = next;
	    } else {
	      this._ = next;
	    }

	    if (left && right) {
	      red = next.C;
	      next.C = node.C;
	      next.L = left;
	      left.U = next;
	      if (next !== right) {
	        parent = next.U;
	        next.U = node.U;
	        node = next.R;
	        parent.L = node;
	        next.R = right;
	        right.U = next;
	      } else {
	        next.U = parent;
	        parent = next;
	        node = next.R;
	      }
	    } else {
	      red = node.C;
	      node = next;
	    }

	    if (node) node.U = parent;
	    if (red) return;
	    if (node && node.C) { node.C = false; return; }

	    do {
	      if (node === this._) break;
	      if (node === parent.L) {
	        sibling = parent.R;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateLeft(this, parent);
	          sibling = parent.R;
	        }
	        if ((sibling.L && sibling.L.C)
	            || (sibling.R && sibling.R.C)) {
	          if (!sibling.R || !sibling.R.C) {
	            sibling.L.C = false;
	            sibling.C = true;
	            RedBlackRotateRight(this, sibling);
	            sibling = parent.R;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.R.C = false;
	          RedBlackRotateLeft(this, parent);
	          node = this._;
	          break;
	        }
	      } else {
	        sibling = parent.L;
	        if (sibling.C) {
	          sibling.C = false;
	          parent.C = true;
	          RedBlackRotateRight(this, parent);
	          sibling = parent.L;
	        }
	        if ((sibling.L && sibling.L.C)
	          || (sibling.R && sibling.R.C)) {
	          if (!sibling.L || !sibling.L.C) {
	            sibling.R.C = false;
	            sibling.C = true;
	            RedBlackRotateLeft(this, sibling);
	            sibling = parent.L;
	          }
	          sibling.C = parent.C;
	          parent.C = sibling.L.C = false;
	          RedBlackRotateRight(this, parent);
	          node = this._;
	          break;
	        }
	      }
	      sibling.C = true;
	      node = parent;
	      parent = parent.U;
	    } while (!node.C);

	    if (node) node.C = false;
	  }
	};

	function RedBlackRotateLeft(tree, node) {
	  var p = node,
	      q = node.R,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.R = q.L;
	  if (p.R) p.R.U = p;
	  q.L = p;
	}

	function RedBlackRotateRight(tree, node) {
	  var p = node,
	      q = node.L,
	      parent = p.U;

	  if (parent) {
	    if (parent.L === p) parent.L = q;
	    else parent.R = q;
	  } else {
	    tree._ = q;
	  }

	  q.U = parent;
	  p.U = q;
	  p.L = q.R;
	  if (p.L) p.L.U = p;
	  q.R = p;
	}

	function RedBlackFirst(node) {
	  while (node.L) node = node.L;
	  return node;
	}

	function createEdge(left, right, v0, v1) {
	  var edge = [null, null],
	      index = edges.push(edge) - 1;
	  edge.left = left;
	  edge.right = right;
	  if (v0) setEdgeEnd(edge, left, right, v0);
	  if (v1) setEdgeEnd(edge, right, left, v1);
	  cells[left.index].halfedges.push(index);
	  cells[right.index].halfedges.push(index);
	  return edge;
	}

	function createBorderEdge(left, v0, v1) {
	  var edge = [v0, v1];
	  edge.left = left;
	  return edge;
	}

	function setEdgeEnd(edge, left, right, vertex) {
	  if (!edge[0] && !edge[1]) {
	    edge[0] = vertex;
	    edge.left = left;
	    edge.right = right;
	  } else if (edge.left === right) {
	    edge[1] = vertex;
	  } else {
	    edge[0] = vertex;
	  }
	}

	// Liang–Barsky line clipping.
	function clipEdge(edge, x0, y0, x1, y1) {
	  var a = edge[0],
	      b = edge[1],
	      ax = a[0],
	      ay = a[1],
	      bx = b[0],
	      by = b[1],
	      t0 = 0,
	      t1 = 1,
	      dx = bx - ax,
	      dy = by - ay,
	      r;

	  r = x0 - ax;
	  if (!dx && r > 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dx > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = x1 - ax;
	  if (!dx && r < 0) return;
	  r /= dx;
	  if (dx < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dx > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  r = y0 - ay;
	  if (!dy && r > 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  } else if (dy > 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  }

	  r = y1 - ay;
	  if (!dy && r < 0) return;
	  r /= dy;
	  if (dy < 0) {
	    if (r > t1) return;
	    if (r > t0) t0 = r;
	  } else if (dy > 0) {
	    if (r < t0) return;
	    if (r < t1) t1 = r;
	  }

	  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

	  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
	  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
	  return true;
	}

	function connectEdge(edge, x0, y0, x1, y1) {
	  var v1 = edge[1];
	  if (v1) return true;

	  var v0 = edge[0],
	      left = edge.left,
	      right = edge.right,
	      lx = left[0],
	      ly = left[1],
	      rx = right[0],
	      ry = right[1],
	      fx = (lx + rx) / 2,
	      fy = (ly + ry) / 2,
	      fm,
	      fb;

	  if (ry === ly) {
	    if (fx < x0 || fx >= x1) return;
	    if (lx > rx) {
	      if (!v0) v0 = [fx, y0];
	      else if (v0[1] >= y1) return;
	      v1 = [fx, y1];
	    } else {
	      if (!v0) v0 = [fx, y1];
	      else if (v0[1] < y0) return;
	      v1 = [fx, y0];
	    }
	  } else {
	    fm = (lx - rx) / (ry - ly);
	    fb = fy - fm * fx;
	    if (fm < -1 || fm > 1) {
	      if (lx > rx) {
	        if (!v0) v0 = [(y0 - fb) / fm, y0];
	        else if (v0[1] >= y1) return;
	        v1 = [(y1 - fb) / fm, y1];
	      } else {
	        if (!v0) v0 = [(y1 - fb) / fm, y1];
	        else if (v0[1] < y0) return;
	        v1 = [(y0 - fb) / fm, y0];
	      }
	    } else {
	      if (ly < ry) {
	        if (!v0) v0 = [x0, fm * x0 + fb];
	        else if (v0[0] >= x1) return;
	        v1 = [x1, fm * x1 + fb];
	      } else {
	        if (!v0) v0 = [x1, fm * x1 + fb];
	        else if (v0[0] < x0) return;
	        v1 = [x0, fm * x0 + fb];
	      }
	    }
	  }

	  edge[0] = v0;
	  edge[1] = v1;
	  return true;
	}

	function clipEdges(x0, y0, x1, y1) {
	  var i = edges.length,
	      edge;

	  while (i--) {
	    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
	        || !clipEdge(edge, x0, y0, x1, y1)
	        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
	            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
	      delete edges[i];
	    }
	  }
	}

	function createCell(site) {
	  return cells[site.index] = {
	    site: site,
	    halfedges: []
	  };
	}

	function cellHalfedgeAngle(cell, edge) {
	  var site = cell.site,
	      va = edge.left,
	      vb = edge.right;
	  if (site === vb) vb = va, va = site;
	  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
	  if (site === va) va = edge[1], vb = edge[0];
	  else va = edge[0], vb = edge[1];
	  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
	}

	function cellHalfedgeStart(cell, edge) {
	  return edge[+(edge.left !== cell.site)];
	}

	function cellHalfedgeEnd(cell, edge) {
	  return edge[+(edge.left === cell.site)];
	}

	function sortCellHalfedges() {
	  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
	    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
	      var index = new Array(m),
	          array = new Array(m);
	      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
	      index.sort(function(i, j) { return array[j] - array[i]; });
	      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
	      for (j = 0; j < m; ++j) halfedges[j] = array[j];
	    }
	  }
	}

	function clipCells(x0, y0, x1, y1) {
	  var nCells = cells.length,
	      iCell,
	      cell,
	      site,
	      iHalfedge,
	      halfedges,
	      nHalfedges,
	      start,
	      startX,
	      startY,
	      end,
	      endX,
	      endY,
	      cover = true;

	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      site = cell.site;
	      halfedges = cell.halfedges;
	      iHalfedge = halfedges.length;

	      // Remove any dangling clipped edges.
	      while (iHalfedge--) {
	        if (!edges[halfedges[iHalfedge]]) {
	          halfedges.splice(iHalfedge, 1);
	        }
	      }

	      // Insert any border edges as necessary.
	      iHalfedge = 0, nHalfedges = halfedges.length;
	      while (iHalfedge < nHalfedges) {
	        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
	        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
	        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
	          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
	              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
	              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
	              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
	              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
	              : null)) - 1);
	          ++nHalfedges;
	        }
	      }

	      if (nHalfedges) cover = false;
	    }
	  }

	  // If there weren’t any edges, have the closest site cover the extent.
	  // It doesn’t matter which corner of the extent we measure!
	  if (cover) {
	    var dx, dy, d2, dc = Infinity;

	    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
	      if (cell = cells[iCell]) {
	        site = cell.site;
	        dx = site[0] - x0;
	        dy = site[1] - y0;
	        d2 = dx * dx + dy * dy;
	        if (d2 < dc) dc = d2, cover = cell;
	      }
	    }

	    if (cover) {
	      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
	      cover.halfedges.push(
	        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
	        edges.push(createBorderEdge(site, v01, v11)) - 1,
	        edges.push(createBorderEdge(site, v11, v10)) - 1,
	        edges.push(createBorderEdge(site, v10, v00)) - 1
	      );
	    }
	  }

	  // Lastly delete any cells with no edges; these were entirely clipped.
	  for (iCell = 0; iCell < nCells; ++iCell) {
	    if (cell = cells[iCell]) {
	      if (!cell.halfedges.length) {
	        delete cells[iCell];
	      }
	    }
	  }
	}

	var circlePool = [];

	var firstCircle;

	function Circle() {
	  RedBlackNode(this);
	  this.x =
	  this.y =
	  this.arc =
	  this.site =
	  this.cy = null;
	}

	function attachCircle(arc) {
	  var lArc = arc.P,
	      rArc = arc.N;

	  if (!lArc || !rArc) return;

	  var lSite = lArc.site,
	      cSite = arc.site,
	      rSite = rArc.site;

	  if (lSite === rSite) return;

	  var bx = cSite[0],
	      by = cSite[1],
	      ax = lSite[0] - bx,
	      ay = lSite[1] - by,
	      cx = rSite[0] - bx,
	      cy = rSite[1] - by;

	  var d = 2 * (ax * cy - ay * cx);
	  if (d >= -epsilon2) return;

	  var ha = ax * ax + ay * ay,
	      hc = cx * cx + cy * cy,
	      x = (cy * ha - ay * hc) / d,
	      y = (ax * hc - cx * ha) / d;

	  var circle = circlePool.pop() || new Circle;
	  circle.arc = arc;
	  circle.site = cSite;
	  circle.x = x + bx;
	  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

	  arc.circle = circle;

	  var before = null,
	      node = circles._;

	  while (node) {
	    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
	      if (node.L) node = node.L;
	      else { before = node.P; break; }
	    } else {
	      if (node.R) node = node.R;
	      else { before = node; break; }
	    }
	  }

	  circles.insert(before, circle);
	  if (!before) firstCircle = circle;
	}

	function detachCircle(arc) {
	  var circle = arc.circle;
	  if (circle) {
	    if (!circle.P) firstCircle = circle.N;
	    circles.remove(circle);
	    circlePool.push(circle);
	    RedBlackNode(circle);
	    arc.circle = null;
	  }
	}

	var beachPool = [];

	function Beach() {
	  RedBlackNode(this);
	  this.edge =
	  this.site =
	  this.circle = null;
	}

	function createBeach(site) {
	  var beach = beachPool.pop() || new Beach;
	  beach.site = site;
	  return beach;
	}

	function detachBeach(beach) {
	  detachCircle(beach);
	  beaches.remove(beach);
	  beachPool.push(beach);
	  RedBlackNode(beach);
	}

	function removeBeach(beach) {
	  var circle = beach.circle,
	      x = circle.x,
	      y = circle.cy,
	      vertex = [x, y],
	      previous = beach.P,
	      next = beach.N,
	      disappearing = [beach];

	  detachBeach(beach);

	  var lArc = previous;
	  while (lArc.circle
	      && Math.abs(x - lArc.circle.x) < epsilon
	      && Math.abs(y - lArc.circle.cy) < epsilon) {
	    previous = lArc.P;
	    disappearing.unshift(lArc);
	    detachBeach(lArc);
	    lArc = previous;
	  }

	  disappearing.unshift(lArc);
	  detachCircle(lArc);

	  var rArc = next;
	  while (rArc.circle
	      && Math.abs(x - rArc.circle.x) < epsilon
	      && Math.abs(y - rArc.circle.cy) < epsilon) {
	    next = rArc.N;
	    disappearing.push(rArc);
	    detachBeach(rArc);
	    rArc = next;
	  }

	  disappearing.push(rArc);
	  detachCircle(rArc);

	  var nArcs = disappearing.length,
	      iArc;
	  for (iArc = 1; iArc < nArcs; ++iArc) {
	    rArc = disappearing[iArc];
	    lArc = disappearing[iArc - 1];
	    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
	  }

	  lArc = disappearing[0];
	  rArc = disappearing[nArcs - 1];
	  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function addBeach(site) {
	  var x = site[0],
	      directrix = site[1],
	      lArc,
	      rArc,
	      dxl,
	      dxr,
	      node = beaches._;

	  while (node) {
	    dxl = leftBreakPoint(node, directrix) - x;
	    if (dxl > epsilon) node = node.L; else {
	      dxr = x - rightBreakPoint(node, directrix);
	      if (dxr > epsilon) {
	        if (!node.R) {
	          lArc = node;
	          break;
	        }
	        node = node.R;
	      } else {
	        if (dxl > -epsilon) {
	          lArc = node.P;
	          rArc = node;
	        } else if (dxr > -epsilon) {
	          lArc = node;
	          rArc = node.N;
	        } else {
	          lArc = rArc = node;
	        }
	        break;
	      }
	    }
	  }

	  createCell(site);
	  var newArc = createBeach(site);
	  beaches.insert(lArc, newArc);

	  if (!lArc && !rArc) return;

	  if (lArc === rArc) {
	    detachCircle(lArc);
	    rArc = createBeach(lArc.site);
	    beaches.insert(newArc, rArc);
	    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
	    attachCircle(lArc);
	    attachCircle(rArc);
	    return;
	  }

	  if (!rArc) { // && lArc
	    newArc.edge = createEdge(lArc.site, newArc.site);
	    return;
	  }

	  // else lArc !== rArc
	  detachCircle(lArc);
	  detachCircle(rArc);

	  var lSite = lArc.site,
	      ax = lSite[0],
	      ay = lSite[1],
	      bx = site[0] - ax,
	      by = site[1] - ay,
	      rSite = rArc.site,
	      cx = rSite[0] - ax,
	      cy = rSite[1] - ay,
	      d = 2 * (bx * cy - by * cx),
	      hb = bx * bx + by * by,
	      hc = cx * cx + cy * cy,
	      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

	  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
	  newArc.edge = createEdge(lSite, site, null, vertex);
	  rArc.edge = createEdge(site, rSite, null, vertex);
	  attachCircle(lArc);
	  attachCircle(rArc);
	}

	function leftBreakPoint(arc, directrix) {
	  var site = arc.site,
	      rfocx = site[0],
	      rfocy = site[1],
	      pby2 = rfocy - directrix;

	  if (!pby2) return rfocx;

	  var lArc = arc.P;
	  if (!lArc) return -Infinity;

	  site = lArc.site;
	  var lfocx = site[0],
	      lfocy = site[1],
	      plby2 = lfocy - directrix;

	  if (!plby2) return lfocx;

	  var hl = lfocx - rfocx,
	      aby2 = 1 / pby2 - 1 / plby2,
	      b = hl / plby2;

	  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

	  return (rfocx + lfocx) / 2;
	}

	function rightBreakPoint(arc, directrix) {
	  var rArc = arc.N;
	  if (rArc) return leftBreakPoint(rArc, directrix);
	  var site = arc.site;
	  return site[1] === directrix ? site[0] : Infinity;
	}

	var epsilon = 1e-6;
	var epsilon2 = 1e-12;
	var beaches;
	var cells;
	var circles;
	var edges;

	function triangleArea(a, b, c) {
	  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
	}

	function lexicographic(a, b) {
	  return b[1] - a[1]
	      || b[0] - a[0];
	}

	function Diagram(sites, extent) {
	  var site = sites.sort(lexicographic).pop(),
	      x,
	      y,
	      circle;

	  edges = [];
	  cells = new Array(sites.length);
	  beaches = new RedBlackTree;
	  circles = new RedBlackTree;

	  while (true) {
	    circle = firstCircle;
	    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
	      if (site[0] !== x || site[1] !== y) {
	        addBeach(site);
	        x = site[0], y = site[1];
	      }
	      site = sites.pop();
	    } else if (circle) {
	      removeBeach(circle.arc);
	    } else {
	      break;
	    }
	  }

	  sortCellHalfedges();

	  if (extent) {
	    var x0 = +extent[0][0],
	        y0 = +extent[0][1],
	        x1 = +extent[1][0],
	        y1 = +extent[1][1];
	    clipEdges(x0, y0, x1, y1);
	    clipCells(x0, y0, x1, y1);
	  }

	  this.edges = edges;
	  this.cells = cells;

	  beaches =
	  circles =
	  edges =
	  cells = null;
	}

	Diagram.prototype = {
	  constructor: Diagram,

	  polygons: function() {
	    var edges = this.edges;

	    return this.cells.map(function(cell) {
	      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
	      polygon.data = cell.site.data;
	      return polygon;
	    });
	  },

	  triangles: function() {
	    var triangles = [],
	        edges = this.edges;

	    this.cells.forEach(function(cell, i) {
	      if (!(m = (halfedges = cell.halfedges).length)) return;
	      var site = cell.site,
	          halfedges,
	          j = -1,
	          m,
	          s0,
	          e1 = edges[halfedges[m - 1]],
	          s1 = e1.left === site ? e1.right : e1.left;

	      while (++j < m) {
	        s0 = s1;
	        e1 = edges[halfedges[j]];
	        s1 = e1.left === site ? e1.right : e1.left;
	        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
	          triangles.push([site.data, s0.data, s1.data]);
	        }
	      }
	    });

	    return triangles;
	  },

	  links: function() {
	    return this.edges.filter(function(edge) {
	      return edge.right;
	    }).map(function(edge) {
	      return {
	        source: edge.left.data,
	        target: edge.right.data
	      };
	    });
	  },

	  find: function(x, y, radius) {
	    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

	    // Use the previously-found cell, or start with an arbitrary one.
	    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
	    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

	    // Traverse the half-edges to find a closer cell, if any.
	    do {
	      cell = that.cells[i0 = i1], i1 = null;
	      cell.halfedges.forEach(function(e) {
	        var edge = that.edges[e], v = edge.left;
	        if ((v === cell.site || !v) && !(v = edge.right)) return;
	        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
	        if (v2 < d2) d2 = v2, i1 = v.index;
	      });
	    } while (i1 !== null);

	    that._found = i0;

	    return radius == null || d2 <= radius * radius ? cell.site : null;
	  }
	};

	var voronoi = function() {
	  var x$$1 = x,
	      y$$1 = y,
	      extent = null;

	  function voronoi(data) {
	    return new Diagram(data.map(function(d, i) {
	      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
	      s.index = i;
	      s.data = d;
	      return s;
	    }), extent);
	  }

	  voronoi.polygons = function(data) {
	    return voronoi(data).polygons();
	  };

	  voronoi.links = function(data) {
	    return voronoi(data).links();
	  };

	  voronoi.triangles = function(data) {
	    return voronoi(data).triangles();
	  };

	  voronoi.x = function(_) {
	    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
	  };

	  voronoi.y = function(_) {
	    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
	  };

	  voronoi.extent = function(_) {
	    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
	  };

	  voronoi.size = function(_) {
	    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
	  };

	  return voronoi;
	};

	exports.voronoi = voronoi;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

	// https://d3js.org/d3-zoom/ Version 1.7.1. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports, __webpack_require__(415), __webpack_require__(416), __webpack_require__(418), __webpack_require__(417), __webpack_require__(420)) :
		typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
		(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
	}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';

	var constant = function(x) {
	  return function() {
	    return x;
	  };
	};

	function ZoomEvent(target, type, transform) {
	  this.target = target;
	  this.type = type;
	  this.transform = transform;
	}

	function Transform(k, x, y) {
	  this.k = k;
	  this.x = x;
	  this.y = y;
	}

	Transform.prototype = {
	  constructor: Transform,
	  scale: function(k) {
	    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
	  },
	  translate: function(x, y) {
	    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
	  },
	  apply: function(point) {
	    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
	  },
	  applyX: function(x) {
	    return x * this.k + this.x;
	  },
	  applyY: function(y) {
	    return y * this.k + this.y;
	  },
	  invert: function(location) {
	    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
	  },
	  invertX: function(x) {
	    return (x - this.x) / this.k;
	  },
	  invertY: function(y) {
	    return (y - this.y) / this.k;
	  },
	  rescaleX: function(x) {
	    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
	  },
	  rescaleY: function(y) {
	    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
	  },
	  toString: function() {
	    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
	  }
	};

	var identity = new Transform(1, 0, 0);

	transform.prototype = Transform.prototype;

	function transform(node) {
	  return node.__zoom || identity;
	}

	function nopropagation() {
	  d3Selection.event.stopImmediatePropagation();
	}

	var noevent = function() {
	  d3Selection.event.preventDefault();
	  d3Selection.event.stopImmediatePropagation();
	};

	// Ignore right-click, since that should open the context menu.
	function defaultFilter() {
	  return !d3Selection.event.button;
	}

	function defaultExtent() {
	  var e = this, w, h;
	  if (e instanceof SVGElement) {
	    e = e.ownerSVGElement || e;
	    w = e.width.baseVal.value;
	    h = e.height.baseVal.value;
	  } else {
	    w = e.clientWidth;
	    h = e.clientHeight;
	  }
	  return [[0, 0], [w, h]];
	}

	function defaultTransform() {
	  return this.__zoom || identity;
	}

	function defaultWheelDelta() {
	  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode ? 120 : 1) / 500;
	}

	function defaultTouchable() {
	  return "ontouchstart" in this;
	}

	function defaultConstrain(transform$$1, extent, translateExtent) {
	  var dx0 = transform$$1.invertX(extent[0][0]) - translateExtent[0][0],
	      dx1 = transform$$1.invertX(extent[1][0]) - translateExtent[1][0],
	      dy0 = transform$$1.invertY(extent[0][1]) - translateExtent[0][1],
	      dy1 = transform$$1.invertY(extent[1][1]) - translateExtent[1][1];
	  return transform$$1.translate(
	    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
	    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
	  );
	}

	var zoom = function() {
	  var filter = defaultFilter,
	      extent = defaultExtent,
	      constrain = defaultConstrain,
	      wheelDelta = defaultWheelDelta,
	      touchable = defaultTouchable,
	      scaleExtent = [0, Infinity],
	      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
	      duration = 250,
	      interpolate = d3Interpolate.interpolateZoom,
	      gestures = [],
	      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
	      touchstarting,
	      touchending,
	      touchDelay = 500,
	      wheelDelay = 150,
	      clickDistance2 = 0;

	  function zoom(selection) {
	    selection
	        .property("__zoom", defaultTransform)
	        .on("wheel.zoom", wheeled)
	        .on("mousedown.zoom", mousedowned)
	        .on("dblclick.zoom", dblclicked)
	      .filter(touchable)
	        .on("touchstart.zoom", touchstarted)
	        .on("touchmove.zoom", touchmoved)
	        .on("touchend.zoom touchcancel.zoom", touchended)
	        .style("touch-action", "none")
	        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
	  }

	  zoom.transform = function(collection, transform$$1) {
	    var selection = collection.selection ? collection.selection() : collection;
	    selection.property("__zoom", defaultTransform);
	    if (collection !== selection) {
	      schedule(collection, transform$$1);
	    } else {
	      selection.interrupt().each(function() {
	        gesture(this, arguments)
	            .start()
	            .zoom(null, typeof transform$$1 === "function" ? transform$$1.apply(this, arguments) : transform$$1)
	            .end();
	      });
	    }
	  };

	  zoom.scaleBy = function(selection, k) {
	    zoom.scaleTo(selection, function() {
	      var k0 = this.__zoom.k,
	          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	      return k0 * k1;
	    });
	  };

	  zoom.scaleTo = function(selection, k) {
	    zoom.transform(selection, function() {
	      var e = extent.apply(this, arguments),
	          t0 = this.__zoom,
	          p0 = centroid(e),
	          p1 = t0.invert(p0),
	          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
	      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
	    });
	  };

	  zoom.translateBy = function(selection, x, y) {
	    zoom.transform(selection, function() {
	      return constrain(this.__zoom.translate(
	        typeof x === "function" ? x.apply(this, arguments) : x,
	        typeof y === "function" ? y.apply(this, arguments) : y
	      ), extent.apply(this, arguments), translateExtent);
	    });
	  };

	  zoom.translateTo = function(selection, x, y) {
	    zoom.transform(selection, function() {
	      var e = extent.apply(this, arguments),
	          t = this.__zoom,
	          p = centroid(e);
	      return constrain(identity.translate(p[0], p[1]).scale(t.k).translate(
	        typeof x === "function" ? -x.apply(this, arguments) : -x,
	        typeof y === "function" ? -y.apply(this, arguments) : -y
	      ), e, translateExtent);
	    });
	  };

	  function scale(transform$$1, k) {
	    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
	    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);
	  }

	  function translate(transform$$1, p0, p1) {
	    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;
	    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);
	  }

	  function centroid(extent) {
	    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
	  }

	  function schedule(transition, transform$$1, center) {
	    transition
	        .on("start.zoom", function() { gesture(this, arguments).start(); })
	        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
	        .tween("zoom", function() {
	          var that = this,
	              args = arguments,
	              g = gesture(that, args),
	              e = extent.apply(that, args),
	              p = center || centroid(e),
	              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
	              a = that.__zoom,
	              b = typeof transform$$1 === "function" ? transform$$1.apply(that, args) : transform$$1,
	              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
	          return function(t) {
	            if (t === 1) t = b; // Avoid rounding error on end.
	            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
	            g.zoom(null, t);
	          };
	        });
	  }

	  function gesture(that, args) {
	    for (var i = 0, n = gestures.length, g; i < n; ++i) {
	      if ((g = gestures[i]).that === that) {
	        return g;
	      }
	    }
	    return new Gesture(that, args);
	  }

	  function Gesture(that, args) {
	    this.that = that;
	    this.args = args;
	    this.index = -1;
	    this.active = 0;
	    this.extent = extent.apply(that, args);
	  }

	  Gesture.prototype = {
	    start: function() {
	      if (++this.active === 1) {
	        this.index = gestures.push(this) - 1;
	        this.emit("start");
	      }
	      return this;
	    },
	    zoom: function(key, transform$$1) {
	      if (this.mouse && key !== "mouse") this.mouse[1] = transform$$1.invert(this.mouse[0]);
	      if (this.touch0 && key !== "touch") this.touch0[1] = transform$$1.invert(this.touch0[0]);
	      if (this.touch1 && key !== "touch") this.touch1[1] = transform$$1.invert(this.touch1[0]);
	      this.that.__zoom = transform$$1;
	      this.emit("zoom");
	      return this;
	    },
	    end: function() {
	      if (--this.active === 0) {
	        gestures.splice(this.index, 1);
	        this.index = -1;
	        this.emit("end");
	      }
	      return this;
	    },
	    emit: function(type) {
	      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
	    }
	  };

	  function wheeled() {
	    if (!filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments),
	        t = this.__zoom,
	        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
	        p = d3Selection.mouse(this);

	    // If the mouse is in the same location as before, reuse it.
	    // If there were recent wheel events, reset the wheel idle timeout.
	    if (g.wheel) {
	      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
	        g.mouse[1] = t.invert(g.mouse[0] = p);
	      }
	      clearTimeout(g.wheel);
	    }

	    // If this wheel event won’t trigger a transform change, ignore it.
	    else if (t.k === k) return;

	    // Otherwise, capture the mouse point and location at the start.
	    else {
	      g.mouse = [p, t.invert(p)];
	      d3Transition.interrupt(this);
	      g.start();
	    }

	    noevent();
	    g.wheel = setTimeout(wheelidled, wheelDelay);
	    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

	    function wheelidled() {
	      g.wheel = null;
	      g.end();
	    }
	  }

	  function mousedowned() {
	    if (touchending || !filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments),
	        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
	        p = d3Selection.mouse(this),
	        x0 = d3Selection.event.clientX,
	        y0 = d3Selection.event.clientY;

	    d3Drag.dragDisable(d3Selection.event.view);
	    nopropagation();
	    g.mouse = [p, this.__zoom.invert(p)];
	    d3Transition.interrupt(this);
	    g.start();

	    function mousemoved() {
	      noevent();
	      if (!g.moved) {
	        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
	        g.moved = dx * dx + dy * dy > clickDistance2;
	      }
	      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
	    }

	    function mouseupped() {
	      v.on("mousemove.zoom mouseup.zoom", null);
	      d3Drag.dragEnable(d3Selection.event.view, g.moved);
	      noevent();
	      g.end();
	    }
	  }

	  function dblclicked() {
	    if (!filter.apply(this, arguments)) return;
	    var t0 = this.__zoom,
	        p0 = d3Selection.mouse(this),
	        p1 = t0.invert(p0),
	        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
	        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

	    noevent();
	    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
	    else d3Selection.select(this).call(zoom.transform, t1);
	  }

	  function touchstarted() {
	    if (!filter.apply(this, arguments)) return;
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        started,
	        n = touches.length, i, t, p;

	    nopropagation();
	    for (i = 0; i < n; ++i) {
	      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
	      p = [p, this.__zoom.invert(p), t.identifier];
	      if (!g.touch0) g.touch0 = p, started = true;
	      else if (!g.touch1) g.touch1 = p;
	    }

	    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
	    if (touchstarting) {
	      touchstarting = clearTimeout(touchstarting);
	      if (!g.touch1) {
	        g.end();
	        p = d3Selection.select(this).on("dblclick.zoom");
	        if (p) p.apply(this, arguments);
	        return;
	      }
	    }

	    if (started) {
	      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
	      d3Transition.interrupt(this);
	      g.start();
	    }
	  }

	  function touchmoved() {
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        n = touches.length, i, t, p, l;

	    noevent();
	    if (touchstarting) touchstarting = clearTimeout(touchstarting);
	    for (i = 0; i < n; ++i) {
	      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
	      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
	      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
	    }
	    t = g.that.__zoom;
	    if (g.touch1) {
	      var p0 = g.touch0[0], l0 = g.touch0[1],
	          p1 = g.touch1[0], l1 = g.touch1[1],
	          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
	          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
	      t = scale(t, Math.sqrt(dp / dl));
	      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
	      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
	    }
	    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
	    else return;
	    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
	  }

	  function touchended() {
	    var g = gesture(this, arguments),
	        touches = d3Selection.event.changedTouches,
	        n = touches.length, i, t;

	    nopropagation();
	    if (touchending) clearTimeout(touchending);
	    touchending = setTimeout(function() { touchending = null; }, touchDelay);
	    for (i = 0; i < n; ++i) {
	      t = touches[i];
	      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
	      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
	    }
	    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
	    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
	    else g.end();
	  }

	  zoom.wheelDelta = function(_) {
	    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
	  };

	  zoom.filter = function(_) {
	    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
	  };

	  zoom.touchable = function(_) {
	    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
	  };

	  zoom.extent = function(_) {
	    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
	  };

	  zoom.scaleExtent = function(_) {
	    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
	  };

	  zoom.translateExtent = function(_) {
	    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
	  };

	  zoom.constrain = function(_) {
	    return arguments.length ? (constrain = _, zoom) : constrain;
	  };

	  zoom.duration = function(_) {
	    return arguments.length ? (duration = +_, zoom) : duration;
	  };

	  zoom.interpolate = function(_) {
	    return arguments.length ? (interpolate = _, zoom) : interpolate;
	  };

	  zoom.on = function() {
	    var value = listeners.on.apply(listeners, arguments);
	    return value === listeners ? zoom : value;
	  };

	  zoom.clickDistance = function(_) {
	    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
	  };

	  return zoom;
	};

	exports.zoom = zoom;
	exports.zoomTransform = transform;
	exports.zoomIdentity = identity;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

	// https://github.com/d3/d3-hexbin Version 0.2.2. Copyright 2017 Mike Bostock.
	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.d3 = global.d3 || {})));
	}(this, (function (exports) { 'use strict';

	var thirdPi = Math.PI / 3;
	var angles = [0, thirdPi, 2 * thirdPi, 3 * thirdPi, 4 * thirdPi, 5 * thirdPi];

	function pointX(d) {
	  return d[0];
	}

	function pointY(d) {
	  return d[1];
	}

	var hexbin = function() {
	  var x0 = 0,
	      y0 = 0,
	      x1 = 1,
	      y1 = 1,
	      x = pointX,
	      y = pointY,
	      r,
	      dx,
	      dy;

	  function hexbin(points) {
	    var binsById = {}, bins = [], i, n = points.length;

	    for (i = 0; i < n; ++i) {
	      if (isNaN(px = +x.call(null, point = points[i], i, points))
	          || isNaN(py = +y.call(null, point, i, points))) continue;

	      var point,
	          px,
	          py,
	          pj = Math.round(py = py / dy),
	          pi = Math.round(px = px / dx - (pj & 1) / 2),
	          py1 = py - pj;

	      if (Math.abs(py1) * 3 > 1) {
	        var px1 = px - pi,
	            pi2 = pi + (px < pi ? -1 : 1) / 2,
	            pj2 = pj + (py < pj ? -1 : 1),
	            px2 = px - pi2,
	            py2 = py - pj2;
	        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi = pi2 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
	      }

	      var id = pi + "-" + pj, bin = binsById[id];
	      if (bin) bin.push(point);
	      else {
	        bins.push(bin = binsById[id] = [point]);
	        bin.x = (pi + (pj & 1) / 2) * dx;
	        bin.y = pj * dy;
	      }
	    }

	    return bins;
	  }

	  function hexagon(radius) {
	    var x0 = 0, y0 = 0;
	    return angles.map(function(angle) {
	      var x1 = Math.sin(angle) * radius,
	          y1 = -Math.cos(angle) * radius,
	          dx = x1 - x0,
	          dy = y1 - y0;
	      x0 = x1, y0 = y1;
	      return [dx, dy];
	    });
	  }

	  hexbin.hexagon = function(radius) {
	    return "m" + hexagon(radius == null ? r : +radius).join("l") + "z";
	  };

	  hexbin.centers = function() {
	    var centers = [],
	        j = Math.round(y0 / dy),
	        i = Math.round(x0 / dx);
	    for (var y = j * dy; y < y1 + r; y += dy, ++j) {
	      for (var x = i * dx + (j & 1) * dx / 2; x < x1 + dx / 2; x += dx) {
	        centers.push([x, y]);
	      }
	    }
	    return centers;
	  };

	  hexbin.mesh = function() {
	    var fragment = hexagon(r).slice(0, 4).join("l");
	    return hexbin.centers().map(function(p) { return "M" + p + "m" + fragment; }).join("");
	  };

	  hexbin.x = function(_) {
	    return arguments.length ? (x = _, hexbin) : x;
	  };

	  hexbin.y = function(_) {
	    return arguments.length ? (y = _, hexbin) : y;
	  };

	  hexbin.radius = function(_) {
	    return arguments.length ? (r = +_, dx = r * 2 * Math.sin(thirdPi), dy = r * 1.5, hexbin) : r;
	  };

	  hexbin.size = function(_) {
	    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], hexbin) : [x1 - x0, y1 - y0];
	  };

	  hexbin.extent = function(_) {
	    return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], hexbin) : [[x0, y0], [x1, y1]];
	  };

	  return hexbin.radius(1);
	};

	exports.hexbin = hexbin;

	Object.defineProperty(exports, '__esModule', { value: true });

	})));


/***/ })
]);